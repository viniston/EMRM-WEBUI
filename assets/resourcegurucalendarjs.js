// **Github:** https://github.com/teambition/gulp-ejs-template
//
// **License:** MIT
/* global module, define, setImmediate, window */

; (function (root, factory) {
    'use strict';

    if (typeof module === 'object' && module.exports) module.exports = factory();
    else if (typeof define === 'function' && define.amd) define([], factory);
    else root.templates = factory();
}(typeof window === 'object' ? window : this, function () {
    'use strict';
    var templates = {};

    templates['availability/add_timeblock'] = templates['availability/add_timeblock.ejs'] = function (it) {
        var locals = it, __output = "";
        ; __output += "<div class=\"js-time-range\"></div>\n<p class=\"text--small time-block-popover-text\">Any overlaps will be merged.</p>\n<footer>\n  <button class=\"btn btn-guru btn--small js-add-button\">Add</button>\n  <button class=\"btn btn--small js-cancel-button\">Cancel</button>\n</footer>\n";
        return __output.trim();
    };

    templates['availability/copy_availability'] = templates['availability/copy_availability.ejs'] = function (it) {
        var locals = it, __output = "";
        ; __output += "<h3>Copy to these days</h3>\n<div class=\"js-day-selection\"></div>\n<footer>\n  <button class=\"btn btn-guru js-copy\">Copy</button>\n  <button class=\"btn js-cancel\">Cancel</button>\n</footer>\n";
        return __output.trim();
    };

    templates['availability/date_range'] = templates['availability/date_range.ejs'] = function (it) {
        var locals = it, __output = "";
        ; __output += "<span class=\"js-multiple-days-every\">Every </span><strong class=\"js-day-name\"></strong> <span class=\"js-multiple-days-from\">from </span><span class=\"js-date-range\"></span>\n";
        return __output.trim();
    };

    templates['availability/day'] = templates['availability/day.ejs'] = function (it) {
        var locals = it, __output = "";
        ; __output += "<div class='js-custom-availability-day-tab' data-id='";; __output += escape(this.cid); __output += "'>\n  <h3>";; __output += escape(this.day.getName()); __output += "</h3>\n  <p>";; __output += escape(this.hours); __output += "</p>\n</div>\n\n<div class='js-custom-availability-day-body'>\n  <div class='js-custom-availability-helper-text'>\n    <p>Every ";; __output += escape(this.day.getName()); __output += " from ";; __output += escape(this.day.getFormattedDate()); __output += "\n      <p class='js-availability-varies-text'>\n        Availability varies within this date range.\n        To change that, you can specify times below to apply to every ";; __output += escape(this.day.getName()); __output += " within the date range.\n        If you make no changes, it will remain varied on ";; __output += escape(this.day.getName()); __output += "\n      </p>\n    </p>\n  </div>\n\n  <div class='js-day-details' />\n\n  <div class='js-availability-overview custom-availability-overview'>\n    <span class='custom-availability-overview-heading'>\n      Availability -\n    </span>\n    <b>\n      ";; __output += escape(this.hours); __output += "\n    </b>\n    <span class='custom-availability-overtime-overview'>\n      (including\n      <b>\n        ";; __output += escape(this.overtime); __output += "\n        overtime\n      </b>\n      )\n    </span>\n  </div>\n</div>\n";
        return __output.trim();
    };

    templates['availability/day_detail'] = templates['availability/day_detail.ejs'] = function (it) {
        var locals = it, __output = "";
        ; __output += "<p class=\"js-date-range-component\"></p>\n<p class=\"js-variance-text\"></p>\n<span class=\"js-time-blocks\"></span>\n<div class=\"js-availability-text\"></div>\n";
        return __output.trim();
    };

    templates['availability/onboard'] = templates['availability/onboard.ejs'] = function (it) {
        var locals = it, __output = "";
        ; __output += "<div class=\"onboard-overlay\">\n  <h4 class=\"h1 bold\">Exceptions to normal availability</h4>\n  <p>Use this form to specify exceptions to a resource's normal availability.</p>\n  <p>\n    You should specify a resource's &quot;regular&quot; availability in the\n    resources section instead - under &quot;Normal Availability&quot;.\n  </p>\n  <footer>\n    <button class=\"btn btn-guru js-close\">Got it</button>\n  </footer>\n</div>\n";
        return __output.trim();
    };

    templates['availability/popover_menu'] = templates['availability/popover_menu.ejs'] = function (it) {
        var locals = it, __output = "";
        ; __output += "<div class=\"availability-tabs__menu dropdown\">\n  <a class=\"dropdown-toggle\">\n    <i class=\"rg-ion-chevron-down\"></i>\n  </a>\n  <ul class=\"dropdown-menu\">\n    <li class=\"js-reset-availability\">\n      <a>Reset To Normal Availability</a>\n    </li>\n    <li class=\"js-copy-availability\">\n      <a>Copy To Other Days &hellip;</a>\n    </li>\n  </ul>\n</div>\n";
        return __output.trim();
    };

    templates['calendar/color_control'] = templates['calendar/color_control.ejs'] = function (it) {
        var locals = it, __output = "";
        ; __output += "<a id=\"color-by-trigger\" class=\"dropdown-toggle\" data-toggle=\"dropdown\" href=\"#\">\n  <span id=\"active-coloring\">Color by Something</span>\n</a>\n<ul class=\"dropdown-menu no-ellipsis is-left-aligned\" id=\"color-by-options\">\n  <li><a href=\"#\" id=\"color-by-project\">Color by Project</a></li>\n  <li><a href=\"#\" id=\"color-by-client\">Color by Client</a></li>\n  <li><a href=\"#\" id=\"color-by-booker\">Color by Booker</a></li>\n</ul>\n";
        return __output.trim();
    };

    templates['calendar/controls'] = templates['calendar/controls.ejs'] = function (it) {
        var locals = it, __output = "";
        ; __output += "<nav class=\"calendar\">\n  <ul class='right-menu is-padded'>\n    <li>\n      <div data-toggle=\"tooltip\" data-placement=\"bottom\" class='header-btn zoom-toggle js-zoom-toggle'>\n        <div class=\"zoom-control\">\n        </div>\n      </div>\n    </li>\n    <li>\n      <div data-toggle=\"tooltip\" data-placement=\"bottom\" class=\"js-toggle-availability header-btn has-icon btn-availability\"></div>\n    </li>\n    <li id=\"color-control\">\n    </li>\n    <li>\n      <div id=\"quick-search\" class=\"header-btn\">\n      </div>\n    </li>\n    <li class=\"dropdown is-header-dropdown has-chevron filters\">\n      <a class=\"dropdown-toggle\" data-toggle=\"dropdown\" href=\"#\">Filters</a>\n      <div class=\"dropdown-menu\" id=\"filter-bar\"></div>\n    </li>\n  </ul>\n</nav>\n\n";
        return __output.trim();
    };

    templates['calendar/date_control'] = templates['calendar/date_control.ejs'] = function (it) {
        var locals = it, __output = "";
        ; __output += "<li>\n  <a href=\"#\" class=\"current js-current\">Today</a>\n</li>\n<li class=\"load-more previous\">\n  <a href=\"#\" class=\"previous js-previous\"></a>\n</li>\n<li class=\"load-more next\">\n  <a href=\"#\" class=\"next js-next\"></a>\n</li>\n\n<li class='months-dropdown dropdown is-header-dropdown'>\n  <a class=\"dropdown-toggle header-btn has-icon btn-calendar\" data-toggle=\"dropdown\" href=\"#\">\n  </a>\n  <div class=\"dropdown-menu is-centered\">\n    <div class='year-scroller'>\n      <a class='js-scroll-year previous'></a>\n      <span class='js-scroll-year current'>";; __output += escape(this.activeYear); __output += "</span>\n      <a class='js-scroll-year next'></a>\n\n    </div>\n    <ul class=\"months\">\n      <li data-month=\"1\"><a href=\"#\">Jan</a></li>\n      <li data-month=\"2\"><a href=\"#\">Feb</a></li>\n      <li data-month=\"3\"><a href=\"#\">Mar</a></li>\n      <li data-month=\"4\"><a href=\"#\">Apr</a></li>\n      <li data-month=\"5\"><a href=\"#\">May</a></li>\n      <li data-month=\"6\"><a href=\"#\">Jun</a></li>\n      <li data-month=\"7\"><a href=\"#\">Jul</a></li>\n      <li data-month=\"8\"><a href=\"#\">Aug</a></li>\n      <li data-month=\"9\"><a href=\"#\">Sep</a></li>\n      <li data-month=\"10\"><a href=\"#\">Oct</a></li>\n      <li data-month=\"11\"><a href=\"#\">Nov</a></li>\n      <li data-month=\"12\"><a href=\"#\">Dec</a></li>\n    </ul>\n  </div>\n</li>\n\n<li class='years-dropdown dropdown has-chevron is-header-dropdown'>\n  <a id=\"jump-to-year-trigger\" class=\"dropdown-toggle\" data-toggle=\"dropdown\" href=\"#\">\n    <span id=\"active-year\"></span>\n  </a>\n  <ul class=\"dropdown-menu is-centered\" id=\"jump-to-year-options\">\n    ";; this.years.forEach(function (year) { ; __output += "\n    <li data-year=\"";; __output += escape(year); __output += "\"><a href=\"#\">";; __output += escape(year); __output += "</a></li>\n    ";; });; __output += "\n  </ul>\n</li>\n\n<li class='months-listing'>\n  <ul class=\"months\">\n    <li data-month=\"1\"><a href=\"#\">Jan</a></li>\n    <li data-month=\"2\"><a href=\"#\">Feb</a></li>\n    <li data-month=\"3\"><a href=\"#\">Mar</a></li>\n    <li data-month=\"4\"><a href=\"#\">Apr</a></li>\n    <li data-month=\"5\"><a href=\"#\">May</a></li>\n    <li data-month=\"6\"><a href=\"#\">Jun</a></li>\n    <li data-month=\"7\"><a href=\"#\">Jul</a></li>\n    <li data-month=\"8\"><a href=\"#\">Aug</a></li>\n    <li data-month=\"9\"><a href=\"#\">Sep</a></li>\n    <li data-month=\"10\"><a href=\"#\">Oct</a></li>\n    <li data-month=\"11\"><a href=\"#\">Nov</a></li>\n    <li data-month=\"12\"><a href=\"#\">Dec</a></li>\n  </ul>\n</li>\n\n<div class=\"large-controls\">\n  <div class=\"previous-timeperiods\" style=\"display: none;\">&nbsp;</div>\n  <div class=\"next-timeperiods\" style=\"display: none;\">&nbsp;</div>\n  <div class=\"previous-resources\" style=\"display: none;\">&nbsp;</div>\n  <div class=\"next-resources\" style=\"display: none;\">&nbsp;</div>\n</div>\n";
        return __output.trim();
    };

    templates['calendar/filter_panel'] = templates['calendar/filter_panel.ejs'] = function (it) {
        var locals = it, __output = "";
        ; __output += "<div class=\"filter-container\">\n  <div class=\"filter__save\">\n    <span class=\"filter__save-link\">Save filters</span>\n    <span data-toggle=\"tooltip\" data-placement=\"left\" class=\"filter__info-tooltip\" data-original-title=\"Save your favourite filter sets for quick access later.\"></span>\n    <div class=\"filter__save-dialog\">\n      <input type=\"text\" name=\"name\" class=\"filter__save-name\" />\n      <button type=\"button\" class=\"btn btn-guru btn-small\">Save</button>\n      <button type=\"button\" class=\"btn btn-small\">Cancel</button>\n    </div>\n  </div>\n  <div class=\"filter-categories\"></div>\n</div>\n";
        return __output.trim();
    };

    templates['calendar/header'] = templates['calendar/header.ejs'] = function (it) {
        var locals = it, __output = "";
        ; __output += "<div class=\"blank-space\"></div>\n<div id=\"time-periods\"></nav>\n";
        return __output.trim();
    };

    templates['calendar/layout'] = templates['calendar/layout.ejs'] = function (it) {
        var locals = it, __output = "";
        ; __output += "<header></header>\n<aside></aside>\n<section class=\"red\"></section>\n";
        return __output.trim();
    };

    templates['calendar/light_spinner'] = templates['calendar/light_spinner.ejs'] = function (it) {
        var locals = it, __output = "";
        ; __output += "<div class=\"spinner-wrap\">\n  <div class=\"sprite-spinner\">\n    <img src=\"/assets/calendar/spinner_light.png\" alt=\"\"/>\n  </div>\n</div>\n";
        return __output.trim();
    };

    templates['calendar/unit'] = templates['calendar/unit.ejs'] = function (it) {
        var locals = it, __output = "";
        ; __output += "<span class=\"name\"></span>\n<span class=\"date\"></span>\n";
        return __output.trim();
    };

    templates['calendar/unit_grouping'] = templates['calendar/unit_grouping.ejs'] = function (it) {
        var locals = it, __output = "";
        ; __output += "<h2 class=\"date-period\"></h2>\n<h2 class=\"week-period\"> </h2>\n\n<div class=\"units\"></div>\n";
        return __output.trim();
    };

    templates['dialogs/allowance_breakdown'] = templates['dialogs/allowance_breakdown.ejs'] = function (it) {
        var locals = it, __output = "";
        ; __output += "<p>\n  <span class='automated-calculation-heading'>Automated calculation</span>\n</p>\n";
        return __output.trim();
    };

    templates['dialogs/booking_clash_management'] = templates['dialogs/booking_clash_management.ejs'] = function (it) {
        var locals = it, __output = "";
        ; __output += "<div class=\"booking-clash\">\n  <main>\n    <img src=\"/assets/smallicon/icon--alert.svg\">\n    <h1 class=\"text--warning\">Booking Clash</h1>\n    <p class='js-booking-clash-text'>\n      <span class=\"js-booking-count\"></span> within the date range no longer <span class=\"js-fit-text\"></span> the new schedule. What do you want to do with the bookings?\n    </p>\n  </main>\n  <footer>\n    <button class=\"btn btn-guru js-add-waiting\">Move To Waiting List</button>\n    <button class=\"btn btn-guru js-delete-bookings\">Delete</button>\n    <button class=\"btn cancel js-cancel\">Cancel</button>\n  </footer>\n</div>\n";
        return __output.trim();
    };

    templates['dialogs/booking_details_body'] = templates['dialogs/booking_details_body.ejs'] = function (it) {
        var locals = it, __output = "";
        ; __output += "<div class=\"availability-changed alert alert-block\" style=\"display: none;\">\n  <h4 class=\"text--warning\">Availability Changed</h4>\n  <p>This resource's availability has changed since this booking was made. Editing it may change the amount of time booked.</p>\n</div>\n<dl>\n  <dt id=\"booking-resources-field\">Resource</dt>\n  <dd id=\"booking-resources\" class=\"booking-resources\"></dd>\n  <div class=\"js-actions-container\"/>\n  <dt id=\"project-label\">Project</dt>\n  <dd id=\"project-name\">project name</dd>\n  <dt id=\"client-label\">Client</dt>\n  <dd id=\"client-name\">client name</dd>\n  <dt>Total</dt>\n  <dd class=\"hours\"><span id=\"confirmed-hours\">2h confirmed</span> <span id=\"waiting-list-hours\" class=\"red-marker\">+ 10m on waiting list</span></dd>\n  <dt id=\"details-field\">Details</dt>\n  <dd id=\"details\" class=\"booking-details\">details</dd>\n  <dt>Billable</dt>\n  <dd id=\"billable\"></dd>\n  <dt>Booker</dt>\n  <dd id='booker-avatar'>\n    <img class=\"js-booker-img\"/>\n    <div class=\"js-booker-name booker-name\"></div>\n  </dd>\n</dl>\n";
        return __output.trim();
    };

    templates['dialogs/booking_details_header'] = templates['dialogs/booking_details_header.ejs'] = function (it) {
        var locals = it, __output = "";
        ; __output += "<div class=\"popover__header\">\n  <i class=\"rg-ion-android-time\"></i>\n  Booking\n</div>\n<div>\n  <time id=\"booking-duration\">11.30am - 12.30pm <span>every day</span></time>\n</div>\n\n<time id=\"booking-date\">1 - 2 Apr 2013 <span>(GMT +0) UTC</span></time>\n";
        return __output.trim();
    };

    templates['dialogs/booking_details_single_actions'] = templates['dialogs/booking_details_single_actions.ejs'] = function (it) {
        var locals = it, __output = "";
        ; __output += "<ul>\n  <li class=\"downtime-btn-group\">\n    <a title=\"Edit\" class=\"btn--blank\" id=\"edit-booking\"><i class=\"rg-ion-edit\"></i></a>\n  </li>\n  <li class=\"downtime-btn-group\">\n    <a title=\"Delete\" class=\"btn--blank\" id=\"delete-booking\"><i class=\"rg-ion-ios-trash\"></i></a>\n  </li>\n</ul>\n";
        return __output.trim();
    };

    templates['dialogs/booking_series_details_actions'] = templates['dialogs/booking_series_details_actions.ejs'] = function (it) {
        var locals = it, __output = "";
        ; __output += "<li class=\"downtime-btn-group\">\n  <a title=\"Edit\" class=\"btn--blank dropdown-toggle edit-dropdown\" data-toggle=\"dropdown\" href=\"#\"><i class=\"rg-ion-edit\"></i><span class=\"rg-ion-chevron-down\"></span></a>\n  <ul class=\"dropdown-menu\">\n    <li><a id=\"edit-single-booking\">Edit (date) only</a></li>\n    <li class=\"divider\"></li>\n    <li><a id=\"edit-series\">Edit entire booking</a></li>\n  </ul>\n</li>\n\n<li class=\"downtime-btn-group\"><a title=\"Split\" id=\"split-series\" class=\"btn--blank\" href=\"#\"><i class=\"rg-ion-scissors\"></i></a></li>\n\n<li class=\"downtime-btn-group\">\n  <a title=\"Delete\" class=\"btn--blank dropdown-toggle delete-dropdown\" data-toggle=\"dropdown\" href=\"#\"><i class=\"rg-ion-ios-trash\"></i><span class=\"rg-ion-chevron-down\"></span></a>\n  <ul class=\"dropdown-menu\">\n    <li><a id=\"delete-single-booking\">Delete (date) only</a></li>\n    <li class=\"divider\"></li>\n    <li><a id=\"delete-series\">Delete entire booking</a></li>\n  </ul>\n</li>\n";
        return __output.trim();
    };

    templates['dialogs/custom_availability'] = templates['dialogs/custom_availability.ejs'] = function (it) {
        var locals = it, __output = "";
        ; __output += "<div class=\"availability-title\">\n  <h1 class=\"availability-title__heading\">\n    Availability\n  </h1>\n  <div class=\"js-avatar availability-title__resource\">\n    <span class=\"js-resource-avatar\"></span>\n    <div class=\"availability-title__resource-name\">";; __output += escape(this.resource.getName()); __output += "</div>\n  </div>\n  <h2 class=\"availability-title__date\">\n    ";; __output += escape(this.dateRange.toString()); __output += "\n    <span class=\"js-timezone availability-title__timezone\">";; __output += escape(this.resource.getTimeZone().toString()); __output += "</span>\n  </h2>\n</div>\n<div class=\"availability-tabs\">\n</div>\n";
        return __output.trim();
    };

    templates['dialogs/custom_availability_form'] = templates['dialogs/custom_availability_form.ejs'] = function (it) {
        var locals = it, __output = "";
        ; __output += "<div class=\"availability-title\">\n  <div class=\"availability-title__daterange availability-input-dates js-daterange\">\n    <span class=\"dash\">From</span>\n  </div>\n  <span data-toggle=\"tooltip\" data-html=\"true\" data-placement=\"left\" class=\"filter__availability-form\" data-original-title=\"Use this form to specify exceptions to a resource's normal availability. If you want to change when a resource normally works, it's much better to change 'normal availability' in the resources section instead.<br><br>Only availability that falls within the selected date range is editable. Please note that availability can be affected by any time off/downtime bookings added to the schedule.\"></span>\n</div>\n";
        return __output.trim();
    };

    templates['dialogs/dialog'] = templates['dialogs/dialog.ejs'] = function (it) {
        var locals = it, __output = "";
        ; __output += "<header></header>\n<main></main>\n<footer></footer>\n";
        return __output.trim();
    };

    templates['dialogs/downtime_details_actions'] = templates['dialogs/downtime_details_actions.ejs'] = function (it) {
        var locals = it, __output = "";
        ; __output += "<li class=\"downtime-btn-group\">\n  <a title=\"Edit\" class=\"btn--blank\" id='edit-downtime'><i class=\"rg-ion-edit\"></i></a>\n</li>\n<li class=\"downtime-btn-group js-split-button\"><a title=\"Split\" id=\"split-downtime\" class=\"btn--blank\"><i class=\"rg-ion-scissors\"></i></a></li>\n<li class=\"downtime-btn-group js-delete-button\"></li>\n";
        return __output.trim();
    };

    templates['dialogs/downtime_details_actions_delete_series'] = templates['dialogs/downtime_details_actions_delete_series.ejs'] = function (it) {
        var locals = it, __output = "";
        ; __output += "<a title=\"Delete\" class=\"btn--blank dropdown-toggle delete-dropdown\" data-toggle=\"dropdown\" href=\"#\"><i class=\"rg-ion-ios-trash\"></i><span class=\"rg-ion-chevron-down js-delete-menu\"></span></a>\n<ul class=\"dropdown-menu js-delete-menu\">\n  <li><a id=\"delete-duration\">Delete (date) only</a></li>\n  <li class=\"divider\"></li>\n  <li><a id=\"delete-downtime\">Delete entire event</a></li>\n</ul>\n";
        return __output.trim();
    };

    templates['dialogs/downtime_details_actions_delete_single'] = templates['dialogs/downtime_details_actions_delete_single.ejs'] = function (it) {
        var locals = it, __output = "";
        ; __output += "<a title=\"Delete\" class=\"btn--blank delete-dropdown\" id=\"delete-downtime\" href='#'><i class=\"rg-ion-ios-trash\"></i></a>\n";
        return __output.trim();
    };

    templates['dialogs/downtime_details_body'] = templates['dialogs/downtime_details_body.ejs'] = function (it) {
        var locals = it, __output = "";
        ; __output += "<main>\n  <dl>\n    <dt id=\"booking-resources-field\">Resources</dt>\n    <dd id=\"booking-resources\" class=\"booking-resources\"></dd>\n    <div class=\"js-actions-container\"/>\n    <dt id=\"booking-target-field\">Type</dt>\n    <dd id=\"booking-target\">type name</dd>\n    <dt>Time</dt>\n    <dd class=\"hours\"><span id=\"confirmed-hours\">2h confirmed</span></dd>\n    <dt id=\"details-field\">Details</dt>\n    <dd id=\"details\" class=\"booking-details\">details</dd>\n    <dt>Booker</dt>\n    <dd id='booker-avatar'>\n      <img class=\"js-booker-img\"/>\n      <div class=\"js-booker-name booker-name\"></div>\n    </dd>\n  </dl>\n</main>\n";
        return __output.trim();
    };

    templates['dialogs/downtime_details_header'] = templates['dialogs/downtime_details_header.ejs'] = function (it) {
        var locals = it, __output = "";
        ; __output += "<div class=\"popover__header\" id=\"popover-header\">\n  Time Off\n</div>\n<div>\n  <time id=\"downtime-duration\">11.30am - 12.30pm</time>\n</div>\n<time class=\"downtime-details-date\">1 Jan 2015</time>\n";
        return __output.trim();
    };

    templates['dialogs/edit_booking_header'] = templates['dialogs/edit_booking_header.ejs'] = function (it) {
        var locals = it, __output = "";
        ; __output += "<header>\n  <div class=\"popover__header\" id \"popover-header\">\n    <i class=\"rg-ion-android-time\"></i>\n    Edit Booking\n  </div>\n</header>\n";
        return __output.trim();
    };

    templates['dialogs/error_list'] = templates['dialogs/error_list.ejs'] = function (it) {
        var locals = it, __output = "";
        ; __output += "<div class=\"booking-clash\">\n  <main>\n    <img src=\"/assets/smallicon/icon--alert.svg\">\n    <h1 class=\"text--warning\">The following issues prevented us from completing your request:</h1>\n    <div class=\"alert alert-error js-alert-error\">\n    </div>\n  </main>\n  <footer>\n    <button class=\"btn btn-guru add-waiting js-ok\">OK</button>\n  </footer>\n</div>\n";
        return __output.trim();
    };

    templates['dialogs/new_booking'] = templates['dialogs/new_booking.ejs'] = function (it) {
        var locals = it, __output = "";
        ; __output += "<div>\n  <main>\n\n    <form class=\"booking-form\">\n      <div class=\"booking-save-error\">Oops, something went wrong. Engineers have been notified. Please try again and <a href=\"https://resourceguruapp.com/help\" target=\"blank\">contact us</a> if it persists.</div>\n      <dl>\n        <dt class=\"resource-instance-name required\">Resource</dt>\n        <dd class=\"resource-instance-value\"></dd>\n        <dt class=\"required\">From</dt>\n        <dd class=\"booking-date required js-booking-date\"></dd>\n        <dt class=\"booking-time-field required\">Hours</dt>\n        <dd class=\"booking-time\">\n        </dd>\n        <dt>Project/Client</dt>\n        <dd>\n          <div class=\"project-client\"></div>\n          <span class=\"booking-project-id-error\"></span>\n          <span class=\"booking-client-id-error\"></span>\n        </dd>\n        <dt></dt>\n        <dd>\n          <div class=\"booking-billable-control\"></div>\n        </dd>\n        <dt>Details</dt>\n        <dd>\n          <textarea id=\"booking-details\"></textarea>\n          <span class=\"booking-details-error\"></span>\n        </dd>\n        <dt class=\"required\">Booker</dt>\n        <dd class=\"booker\">\n        </dd>\n      </dl>\n    </form>\n  </main>\n  <footer>\n    <button class=\"btn btn-guru\" id=\"add-booking\">Add Booking</button>\n    <button class=\"btn\" id=\"cancel\">Cancel</button>\n  </footer>\n</div>\n";
        return __output.trim();
    };

    templates['dialogs/new_booking_downtime_popover'] = templates['dialogs/new_booking_downtime_popover.ejs'] = function (it) {
        var locals = it, __output = "";
        ; __output += "<div class=\"f-dropdown copy-availability-dropdown\" data-dropdown-content aria-hidden=\"true\" aria-autoclose=\"false\" tabindex=\"-1\">\n  <span class=\"shadow-arrow\" style=\"margin-top: 20px\"></span>\n  <div class=\"dropdown-content\">\n    <div class=\"downtime__tabs with-time-off\">\n      <ul class=\"tabs\" data-tab>\n        <li class=\"tab-title booking-tab\">\n          <span id='new-booking'><i class=\"rg-ion-android-time\"></i>New Booking</span>\n        </li>\n        <li class=\"tab-title downtime-tab\">\n          <span id='new-downtime'><i class=\"rg-icon--vacation\"></i><span class=\"js-time-off-text\">New Time Off</span></span>\n        </li>\n      </ul>\n\n      <div class=\"tabs-content downtime__content\">\n        <div class=\"content active\" id=\"panel2\">\n          <div class=\"new-booking-time-off\">\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n";
        return __output.trim();
    };

    templates['dialogs/new_client'] = templates['dialogs/new_client.ejs'] = function (it) {
        var locals = it, __output = "";
        ; __output += "<header>\n    <div>\n        <h3>New Client</h3>\n    </div>\n</header>\n<main>\n    <form>\n        <dl>\n            <dt class=\"required\">Name</dt>\n            <dd>\n                <input class=\"client-name\" type=\"text\" placeholder=\"Enter a name for the new client\"><span class=\"help-inline hide\"></span>\n            </dd>\n            <dt>Color</dt>\n        </dl>\n    </form>\n</main>\n<footer>\n    <button class=\"btn btn-guru add-client js-add-client\">Add Client</button>\n    <button class=\"btn cancel\">Cancel</button>\n</footer>\n";
        return __output.trim();
    };

    templates['dialogs/new_downtime'] = templates['dialogs/new_downtime.ejs'] = function (it) {
        var locals = it, __output = "";
        ; __output += "<main>\n  <form class=\"time-off__form\">\n    <div class=\"downtime-save-error\">Oops, something went wrong. Engineers have been notified. Please try again and <a href=\"https://resourceguruapp.com/help\" target=\"blank\">contact us</a> if it persists.</div>\n    <dl>\n      <dt class=\"resource-field required\">Resource</dt>\n      <dd class=\"js-resource-selector downtime-resource\"></dd>\n      <div class=\"downtime-date\"></div>\n      <dt>Type</dt>\n      <dd class=\"downtime-type required\" id=\"downtime-type-options\"></dd>\n      <dt class='js-timezone-heading required'></dt>\n      <dd class=\"js-timezone-selector\"></dd>\n      <dt>Details</dt>\n      <dd class=\"downtime-details optional\">\n        <textarea id=\"downtime-details-value\"></textarea>\n      </dd>\n      <dt class=\"required\">Booker</dt>\n      <dd class=\"booker js-booker\"></dd>\n    </dl>\n  </form>\n</main>\n<footer>\n  <button class=\"btn btn-guru\" id=\"add-downtime\">Add Time Off</button>\n  <button class=\"btn\" id=\"cancel\">Cancel</button>\n</footer>\n";
        return __output.trim();
    };

    templates['dialogs/new_downtime_header'] = templates['dialogs/new_downtime_header.ejs'] = function (it) {
        var locals = it, __output = "";
        ; __output += "<header>\n  <div class='popover__header'>\n    <h4>\n      <i class=\"js-downtime-icon rg-icon--vacation\"></i><span class='js-time-off-header-text'> New Time Off </span>\n    </h4>\n  </div>\n</header>\n";
        return __output.trim();
    };

    templates['dialogs/new_project'] = templates['dialogs/new_project.ejs'] = function (it) {
        var locals = it, __output = "";
        ; __output += "<header>\n  <div>\n    <h3>New Project</h3>\n  </div>\n</header>\n<main>\n  <form>\n    <dl>\n      <dt class=\"required\">Project</dt>\n      <dd><input type=\"text\" class=\"project-name\" placeholder=\"Enter a name for the new project\"><span class=\"name-error\"></span></dd>\n\n      <dt>Project code</dt>\n      <dd><div class=\"project-code-control\"></div><span class=\"project-code-error\"></span></dd>\n\n      <dt>Client</dt>\n      <dd class=\"client-select-field\">\n      </dd>\n      <dt />\n      <dd>\n        <div class=\"booking-billable-control\"></div>\n      </dd>\n      <dt>\n        Color\n      </dt>\n    </dl>\n  </form>\n</main>\n<footer>\n  <button class=\"btn btn-guru add-project js-add-project\">Add Project</button>\n  <button class=\"btn cancel\">Cancel</button>\n</footer>\n";
        return __output.trim();
    };

    templates['dialogs/popover'] = templates['dialogs/popover.ejs'] = function (it) {
        var locals = it, __output = "";
        ; __output += "<div class=\"f-dropdown copy-availability-dropdown ";; __output += escape(this.cssClass); __output += "\" data-dropdown-content aria-hidden=\"true\" aria-autoclose=\"false\" tabindex=\"-1\">\n  <span class=\"shadow-arrow\"></span>\n  <div class=\"dropdown-content\">\n  </div>\n</div>\n";
        return __output.trim();
    };

    templates['dialogs/removed_availability_dates'] = templates['dialogs/removed_availability_dates.ejs'] = function (it) {
        var locals = it, __output = "";
        ; __output += "<div class=\"booking-clash\">\n  <main>\n    <h1 class=\"text--warning js-warning-title\"></h1>\n\n    <div class=\"js-booking-non-working-dates-details\"></div>\n  </main>\n  <footer>\n    <button class=\"btn btn-guru js-ok\">OK</button>\n  </footer>\n</div>\n";
        return __output.trim();
    };

    templates['dialogs/split_booking'] = templates['dialogs/split_booking.ejs'] = function (it) {
        var locals = it, __output = "";
        ; __output += "<header>\n  <div>\n    <h3>Split this booking series into two blocks?</h3>\n  </div>\n</header>\n<main><div></div><div class=\"split block1\">Mon 15 Apr - Tue 16 Apr</div>\n  <div class=\"split indicator\">&nbsp;</div>\n  <div class=\"split block2\">Wed 17 Apr - Fri 19 Apr</div>\n</main>\n<footer>\n  <button id=\"split-booking\" class=\"btn btn-guru\" type=\"button\">Split Booking</button>\n  <button id=\"cancel\" class=\"btn\">Cancel</button>\n</footer>\n";
        return __output.trim();
    };

    templates['dialogs/split_downtime'] = templates['dialogs/split_downtime.ejs'] = function (it) {
        var locals = it, __output = "";
        ; __output += "<header>\n  <div>\n    <h3 class=\"js-title-downtime-type\">Split this series of events into two blocks?</h3>\n  </div>\n</header>\n<main><div></div><div class=\"split block1\">Mon 15 Apr - Tue 16 Apr</div>\n  <div class=\"split indicator\">&nbsp;</div>\n  <div class=\"split block2\">Wed 17 Apr - Fri 19 Apr</div>\n</main>\n<footer>\n  <button id=\"split-downtime\" class=\"btn btn-guru\" type=\"button\">Split <span class=\"js-button-downtime-type\">Time Off</span></button>\n  <button id=\"cancel\" class=\"btn\">Cancel</button>\n</footer>\n";
        return __output.trim();
    };

    templates['dialogs/waiting_list_confirmation'] = templates['dialogs/waiting_list_confirmation.ejs'] = function (it) {
        var locals = it, __output = "";
        ; __output += "<div class=\"booking-clash\">\n  <main>\n    <img src=\"/assets/smallicon/icon--alert.svg\">\n    <h1 class=\"text--warning\">Booking Clash</h1>\n    <div class=\"js-booking-clash-details\"></div>\n  </main>\n  <footer>\n    <button class=\"btn btn-guru add-waiting\">Add To Waiting List</button>\n    <button class=\"btn cancel\">Cancel</button>\n  </footer>\n</div>\n";
        return __output.trim();
    };

    templates['downtimes/resource_selector'] = templates['downtimes/resource_selector.ejs'] = function (it) {
        var locals = it, __output = "";
        ; __output += "<div class=\"filter__options-control\">\n  <select class=\"chzn-select filter-option\" multiple></select>\n</div>\n<span class=\"help-inline error\" visibility=\"hidden\">Please select at least one resource.</span>\n";
        return __output.trim();
    };

    templates['downtimes/vacation_allowance'] = templates['downtimes/vacation_allowance.ejs'] = function (it) {
        var locals = it, __output = "";
        ; __output += "<dt>Vacation allowance</dt>\n";
        return __output.trim();
    };

    templates['downtimes/vacation_allowance_year'] = templates['downtimes/vacation_allowance_year.ejs'] = function (it) {
        var locals = it, __output = "";
        ; __output += "<dd>\n  <p class=\"is-bold\">Jan to Dec ";; __output += escape(this.model.get('year')); __output += " allowance</p>\n  <p>Deduct\n    <span><input type=\"text\" data-attribute-year=\"";; __output += escape(this.model.get('year')); __output += "\" class=\"input--small\" value=\"";; __output += escape(this.model.get('numberOfUsedDays')); __output += "\"></input></span>\n    days from remaining allowance of\n    <span>";; __output += escape(this.model.get('remainingAllowance')); __output += "</span> days\n  </p>\n  <span class=\"js-tooltip filter__info-tooltip\"></span>\n</dd>\n";
        return __output.trim();
    };

    templates['filters/category'] = templates['filters/category.ejs'] = function (it) {
        var locals = it, __output = "";
        ; __output += "<h3 class=\"filter__category--name\"></h3>\n<div class=\"filter__category--selected-options\">\n  <span><strong>Perm/Freelance (any):</strong> Permanent</span>\n  <span><strong>Skills (all):</strong> HTML5 &nbsp;|&nbsp; Ruby on Rails</span>\n</div>\n<div class=\"filter__category__filters\"></div>\n<a href=\"#\" class=\"filter__clear\">Clear</a>\n";
        return __output.trim();
    };

    templates['filters/category_options'] = templates['filters/category_options.ejs'] = function (it) {
        var locals = it, __output = "";
        ; __output += "<span class=\"shadow-arrow\"></span>\n<div>\n  <span class=\"match-label\">Match:</span>\n  <h3>Projects</h3>\n  <span class=\"select-all-filters\">\n    <a class=\"filter__options--all\">All</a>\n  </span>\n  <span class=\"reset-select-all-filters\" style=\"display: none\">\n    <a class=\"filter__options--all\">Clear</a> (all selected)\n  </span>\n  <div class=\"filter__options\"></div>\n  ";; if (this.tooltip) { ; __output += "\n    <span data-toggle=\"tooltip\" data-placement=\"left\" class=\"filter__info-tooltip\" data-original-title=\"Filters are automatically generated from any custom fields you have in Settings &gt; Resources &gt; Custom Fields.\"></span>\n  ";; }; __output += "\n</div>\n";
        return __output.trim();
    };

    templates['filters/option_group'] = templates['filters/option_group.ejs'] = function (it) {
        var locals = it, __output = "";
        ; __output += "<div class=\"filter__options-control\">\n  <select class=\"chzn-select filter-option\" multiple></select>\n</div>\n<div class=\"filter__match-type-control\">\n  <div class=\"match-type\"></div>\n</div>\n";
        return __output.trim();
    };

    templates['filters/quick_search_menu'] = templates['filters/quick_search_menu.ejs'] = function (it) {
        var locals = it, __output = "";
        ; __output += "<div class=\"js-menu-cog time-off-resource__menu\">\n  <a class=\"dropdown-toggle\">\n    <i class=\"rg-ion-gear-a\"> </i>\n  </a>\n  <ul class=\"dropdown-menu js-menu-options\" style=\"position: relative;\">\n    <li>\n      <a class=\"js-currently-filtered\">Currently filtered</a>\n    </li>\n    <li>\n      <a class=\"js-all-people\">All people</a>\n    </li>\n    <li>\n      <a class=\"js-all-resources\">All resources</a>\n    </li>\n    <li>\n      <a class=\"js-clear-resources\">Clear</a>\n    </li>\n  </ul>\n</div>\n";
        return __output.trim();
    };

    templates['filters/save_filter_form'] = templates['filters/save_filter_form.ejs'] = function (it) {
        var locals = it, __output = "";
        ; __output += "  <input type=\"text\" name=\"name\" class=\"filter__save-name\" />\n  <div class=\"filter__save-form--actions\">\n    <button type=\"button\" class=\"btn btn-guru btn--small save\">Save</button>\n    <button type=\"button\" class=\"btn btn--small cancel\">Cancel</button>\n  </div>\n";
        return __output.trim();
    };

    templates['filters/saved_filter'] = templates['filters/saved_filter.ejs'] = function (it) {
        var locals = it, __output = "";
        ; __output += "<div class=\"filter__saved-filter-name\"></div>\n<input type=\"text\" class=\"filter__saved-filter-input\" style=\"display: none\" placeholder=\"Type the new name\">\n<span class=\"filter__saved-filter-actions\">\n  <span class=\"save-rename-filter\" style=\"display: none\">Save</span>\n  <span class=\"rename-filter\">Rename</span>\n  <span class=\"delete-filter\">Delete</span>\n</span>\n";
        return __output.trim();
    };

    templates['filters/saved_filter_panel'] = templates['filters/saved_filter_panel.ejs'] = function (it) {
        var locals = it, __output = "";
        ; __output += "<div class=\"filter__save-header\">\n  <span data-toggle=\"tooltip\" data-placement=\"left\" data-original-title=\"Please select some filters first.\" class=\"filter__save-link\">Save filters</span>\n  <span data-toggle=\"tooltip\" data-placement=\"left\" class=\"filter__info-tooltip\" data-original-title=\"Save your favourite filter sets for quick access later.\"></span>\n</div>\n<div class=\"filter__save-form\">\n</div>\n<h3>Saved filters</h3>\n<div class=\"filter__saved-filter-list\">\n</div>\n";
        return __output.trim();
    };

    templates['filters/selected_options_summary'] = templates['filters/selected_options_summary.ejs'] = function (it) {
        var locals = it, __output = "";
        ; this.collection.forEach(function (group) { ; __output += "\n  <span>\n    <strong>";; __output += escape(group.name); __output += " (";; __output += escape(group.matchType); __output += "):</strong>\n    ";; __output = [__output, group.selectedOptions].join(""); __output += "\n  </span>\n";; });; __output += "\n";
        return __output.trim();
    };

    templates['filters/selected_options_summary_all'] = templates['filters/selected_options_summary_all.ejs'] = function (it) {
        var locals = it, __output = "";
        ; __output += "<span><strong>All</strong></span>\n";
        return __output.trim();
    };

    templates['resource/card'] = templates['resource/card.ejs'] = function (it) {
        var locals = it, __output = "";
        ; __output += "<img src=\"\" />\n<h3>Resource Name</h3>\n<h4>Resource Tag line</h4>\n<p class=\"timezone\"></p>\n";
        return __output.trim();
    };

    templates['selectors/color_picker'] = templates['selectors/color_picker.ejs'] = function (it) {
        var locals = it, __output = "";
        ; __output += "<dd class=\"controls\">\n    <select class=\"color optional color-picker-select js-select\" id=\"client_color\" name=\"client[color]\">\n        <option value=\"\"></option>\n    </select>\n    <div class=\"btn-group color-picker\">\n        <a href=\"#\" class=\"btn dropdown-toggle\" data-toggle=\"dropdown\">\n            <span class=\"selected-color\"></span>\n            <span class=\"caret\"></span>\n        </a>\n        <ul class=\"dropdown-menu color-palette js-displayed-colors\"></ul>\n    </div>\n</dd>\n";
        return __output.trim();
    };

    templates['selectors/date_range'] = templates['selectors/date_range.ejs'] = function (it) {
        var locals = it, __output = "";
        ; __output += "<span>\n  <input type=\"text\" id=\"booking-start-date\" class=\"js-date-range-input\" autocomplete=\"off\">\n</span>\n<span class=\"dash\">to</span>\n<span>\n  <input type=\"text\" id=\"booking-end-date\" class=\"js-date-range-input\" autocomplete=\"off\">\n</span>\n<div class=\"help-inline error\">Please select a start and end date.</div>\n";
        return __output.trim();
    };

    templates['selectors/date_time_range'] = templates['selectors/date_time_range.ejs'] = function (it) {
        var locals = it, __output = "";
        ; __output += "<dt class=\"required\">From</dt>\n<dd>\n  <span>\n    <input type=\"text\" id=\"booking-start-date\" class=\"js-date-range-input\" autocomplete=\"off\">\n    <input type=\"text\" id=\"booking-start-time\" class=\"js-time-range-input\" autocomplete=\"off\">\n  </span>\n</dd>\n<dt class=\"required\">To</dt>\n<dd>\n  <span>\n    <input type=\"text\" id=\"booking-end-date\" class=\"js-date-range-input\" autocomplete=\"off\">\n    <input type=\"text\" id=\"booking-end-time\" class=\"js-time-range-input\" autocomplete=\"off\">\n  </span>\n  <div class=\"help-inline error\">Validation message</div>\n</dd>\n";
        return __output.trim();
    };

    templates['selectors/duration'] = templates['selectors/duration.ejs'] = function (it) {
        var locals = it, __output = "";
        ; __output += "<span class=\"input-append\"><input id=\"booking-hour-time\" type=\"text\" autocomplete=\"off\"><span class=\"add-on\">h</span></span><span class=\"input-append\"><input id=\"booking-minute-time\" type=\"text\" autocomplete=\"off\"><span class=\"add-on\">m</span></span><span class=\"alt-toggle\">or <a href=\"#\" class=\"book-duration-type-toggle\">Book specific time</a></span>\n<span class=\"help-inline error\"></span>\n";
        return __output.trim();
    };

    templates['selectors/resource'] = templates['selectors/resource.ejs'] = function (it) {
        var locals = it, __output = "";
        ; __output += "<div class=\"current\">\n  <span class=\"resource-name\">Resource Name</span>\n  <span class=\"alt-toggle\"><a href=\"#\">change...</a></span>\n</div>\n<div class=\"selector\" style=\"display: none;\">\n  <select class=\"chzn-select\"></select>\n</div>\n";
        return __output.trim();
    };

    templates['selectors/time_range'] = templates['selectors/time_range.ejs'] = function (it) {
        var locals = it, __output = "";
        ; __output += "<span>\n  <input type=\"text\" id=\"booking-start-time\" class=\"js-time-range-input\" autocomplete=\"off\">\n</span>\n<span class=\"dash\">to</span>\n<span>\n  <input type=\"text\" id=\"booking-end-time\" class=\"js-time-range-input\" autocomplete=\"off\">\n</span>\n<span class=\"alt-toggle\">or <a href=\"#\" class=\"book-duration-type-toggle\">Book hours per day</a></span>\n<div>\n  <span class=\"help-inline error\">Please select a valid start and end time.</span>\n</div>\n";
        return __output.trim();
    };

    var ejs = {
        locals: {},
        get: getTpl,
        render: render
    };
    return ejs;

    function render(tplName, data) {
        var it = copy({}, ejs.locals);
        return getTpl(tplName)(copy(it, data));
    }

    function getTpl(tplName) {
        return templates[tplName];
    }

    function escape(markup) {
        if (!markup) return '';
        return String(markup)
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/'/g, '&#39;')
            .replace(/"/g, '&quot;');
    }

    function copy(to, from) {
        from = from || {};
        for (var key in from) to[key] = from[key];
        return to;
    }
}));
;
templates.find = function (name) {
    return function (data) {
        return templates.get(name).call(data);
    };
};
;
// vim:ts=4:sts=4:sw=4:
/*!
 *
 * Copyright 2009-2012 Kris Kowal under the terms of the MIT
 * license found at http://github.com/kriskowal/q/raw/master/LICENSE
 *
 * With parts by Tyler Close
 * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found
 * at http://www.opensource.org/licenses/mit-license.html
 * Forked at ref_send.js version: 2009-05-11
 *
 * With parts by Mark Miller
 * Copyright (C) 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

(function (definition) {
    "use strict";

    // This file will function properly as a <script> tag, or a module
    // using CommonJS and NodeJS or RequireJS module formats.  In
    // Common/Node/RequireJS, the module exports the Q API and when
    // executed as a simple <script>, it creates a Q global instead.

    // Montage Require
    if (typeof bootstrap === "function") {
        bootstrap("promise", definition);

        // CommonJS
    } else if (typeof exports === "object" && typeof module === "object") {
        module.exports = definition();

        // RequireJS
    } else if (typeof define === "function" && define.amd) {
        define(definition);

        // SES (Secure EcmaScript)
    } else if (typeof ses !== "undefined") {
        if (!ses.ok()) {
            return;
        } else {
            ses.makeQ = definition;
        }

        // <script>
    } else if (typeof self !== "undefined") {
        self.Q = definition();

    } else {
        throw new Error("This environment was not anticiapted by Q. Please file a bug.");
    }

})(function () {
    "use strict";

    var hasStacks = false;
    try {
        throw new Error();
    } catch (e) {
        hasStacks = !!e.stack;
    }

    // All code after this point will be filtered from stack traces reported
    // by Q.
    var qStartingLine = captureLine();
    var qFileName;

    // shims

    // used for fallback in "allResolved"
    var noop = function () { };

    // Use the fastest possible means to execute a task in a future turn
    // of the event loop.
    var nextTick = (function () {
        // linked list of tasks (single, with head node)
        var head = { task: void 0, next: null };
        var tail = head;
        var flushing = false;
        var requestTick = void 0;
        var isNodeJS = false;

        function flush() {
            /* jshint loopfunc: true */

            while (head.next) {
                head = head.next;
                var task = head.task;
                head.task = void 0;
                var domain = head.domain;

                if (domain) {
                    head.domain = void 0;
                    domain.enter();
                }

                try {
                    task();

                } catch (e) {
                    if (isNodeJS) {
                        // In node, uncaught exceptions are considered fatal errors.
                        // Re-throw them synchronously to interrupt flushing!

                        // Ensure continuation if the uncaught exception is suppressed
                        // listening "uncaughtException" events (as domains does).
                        // Continue in next event to avoid tick recursion.
                        if (domain) {
                            domain.exit();
                        }
                        setTimeout(flush, 0);
                        if (domain) {
                            domain.enter();
                        }

                        throw e;

                    } else {
                        // In browsers, uncaught exceptions are not fatal.
                        // Re-throw them asynchronously to avoid slow-downs.
                        setTimeout(function () {
                            throw e;
                        }, 0);
                    }
                }

                if (domain) {
                    domain.exit();
                }
            }

            flushing = false;
        }

        nextTick = function (task) {
            tail = tail.next = {
                task: task,
                domain: isNodeJS && process.domain,
                next: null
            };

            if (!flushing) {
                flushing = true;
                requestTick();
            }
        };

        if (typeof process !== "undefined" && process.nextTick) {
            // Node.js before 0.9. Note that some fake-Node environments, like the
            // Mocha test runner, introduce a `process` global without a `nextTick`.
            isNodeJS = true;

            requestTick = function () {
                process.nextTick(flush);
            };

        } else if (typeof setImmediate === "function") {
            // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate
            if (typeof window !== "undefined") {
                requestTick = setImmediate.bind(window, flush);
            } else {
                requestTick = function () {
                    setImmediate(flush);
                };
            }

        } else if (typeof MessageChannel !== "undefined") {
            // modern browsers
            // http://www.nonblocking.io/2011/06/windownexttick.html
            var channel = new MessageChannel();
            // At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create
            // working message ports the first time a page loads.
            channel.port1.onmessage = function () {
                requestTick = requestPortTick;
                channel.port1.onmessage = flush;
                flush();
            };
            var requestPortTick = function () {
                // Opera requires us to provide a message payload, regardless of
                // whether we use it.
                channel.port2.postMessage(0);
            };
            requestTick = function () {
                setTimeout(flush, 0);
                requestPortTick();
            };

        } else {
            // old browsers
            requestTick = function () {
                setTimeout(flush, 0);
            };
        }

        return nextTick;
    })();

    // Attempt to make generics safe in the face of downstream
    // modifications.
    // There is no situation where this is necessary.
    // If you need a security guarantee, these primordials need to be
    // deeply frozen anyway, and if you donâ€™t need a security guarantee,
    // this is just plain paranoid.
    // However, this **might** have the nice side-effect of reducing the size of
    // the minified code by reducing x.call() to merely x()
    // See Mark Millerâ€™s explanation of what this does.
    // http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming
    var call = Function.call;
    function uncurryThis(f) {
        return function () {
            return call.apply(f, arguments);
        };
    }
    // This is equivalent, but slower:
    // uncurryThis = Function_bind.bind(Function_bind.call);
    // http://jsperf.com/uncurrythis

    var array_slice = uncurryThis(Array.prototype.slice);

    var array_reduce = uncurryThis(
        Array.prototype.reduce || function (callback, basis) {
            var index = 0,
                length = this.length;
            // concerning the initial value, if one is not provided
            if (arguments.length === 1) {
                // seek to the first value in the array, accounting
                // for the possibility that is is a sparse array
                do {
                    if (index in this) {
                        basis = this[index++];
                        break;
                    }
                    if (++index >= length) {
                        throw new TypeError();
                    }
                } while (1);
            }
            // reduce
            for (; index < length; index++) {
                // account for the possibility that the array is sparse
                if (index in this) {
                    basis = callback(basis, this[index], index);
                }
            }
            return basis;
        }
    );

    var array_indexOf = uncurryThis(
        Array.prototype.indexOf || function (value) {
            // not a very good shim, but good enough for our one use of it
            for (var i = 0; i < this.length; i++) {
                if (this[i] === value) {
                    return i;
                }
            }
            return -1;
        }
    );

    var array_map = uncurryThis(
        Array.prototype.map || function (callback, thisp) {
            var self = this;
            var collect = [];
            array_reduce(self, function (undefined, value, index) {
                collect.push(callback.call(thisp, value, index, self));
            }, void 0);
            return collect;
        }
    );

    var object_create = Object.create || function (prototype) {
        function Type() { }
        Type.prototype = prototype;
        return new Type();
    };

    var object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);

    var object_keys = Object.keys || function (object) {
        var keys = [];
        for (var key in object) {
            if (object_hasOwnProperty(object, key)) {
                keys.push(key);
            }
        }
        return keys;
    };

    var object_toString = uncurryThis(Object.prototype.toString);

    function isObject(value) {
        return value === Object(value);
    }

    // generator related shims

    // FIXME: Remove this function once ES6 generators are in SpiderMonkey.
    function isStopIteration(exception) {
        return (
            object_toString(exception) === "[object StopIteration]" ||
            exception instanceof QReturnValue
        );
    }

    // FIXME: Remove this helper and Q.return once ES6 generators are in
    // SpiderMonkey.
    var QReturnValue;
    if (typeof ReturnValue !== "undefined") {
        QReturnValue = ReturnValue;
    } else {
        QReturnValue = function (value) {
            this.value = value;
        };
    }

    // long stack traces

    var STACK_JUMP_SEPARATOR = "From previous event:";

    function makeStackTraceLong(error, promise) {
        // If possible, transform the error stack trace by removing Node and Q
        // cruft, then concatenating with the stack trace of `promise`. See #57.
        if (hasStacks &&
            promise.stack &&
            typeof error === "object" &&
            error !== null &&
            error.stack &&
            error.stack.indexOf(STACK_JUMP_SEPARATOR) === -1
        ) {
            var stacks = [];
            for (var p = promise; !!p; p = p.source) {
                if (p.stack) {
                    stacks.unshift(p.stack);
                }
            }
            stacks.unshift(error.stack);

            var concatedStacks = stacks.join("\n" + STACK_JUMP_SEPARATOR + "\n");
            error.stack = filterStackString(concatedStacks);
        }
    }

    function filterStackString(stackString) {
        var lines = stackString.split("\n");
        var desiredLines = [];
        for (var i = 0; i < lines.length; ++i) {
            var line = lines[i];

            if (!isInternalFrame(line) && !isNodeFrame(line) && line) {
                desiredLines.push(line);
            }
        }
        return desiredLines.join("\n");
    }

    function isNodeFrame(stackLine) {
        return stackLine.indexOf("(module.js:") !== -1 ||
            stackLine.indexOf("(node.js:") !== -1;
    }

    function getFileNameAndLineNumber(stackLine) {
        // Named functions: "at functionName (filename:lineNumber:columnNumber)"
        // In IE10 function name can have spaces ("Anonymous function") O_o
        var attempt1 = /at .+ \((.+):(\d+):(?:\d+)\)$/.exec(stackLine);
        if (attempt1) {
            return [attempt1[1], Number(attempt1[2])];
        }

        // Anonymous functions: "at filename:lineNumber:columnNumber"
        var attempt2 = /at ([^ ]+):(\d+):(?:\d+)$/.exec(stackLine);
        if (attempt2) {
            return [attempt2[1], Number(attempt2[2])];
        }

        // Firefox style: "function@filename:lineNumber or @filename:lineNumber"
        var attempt3 = /.*@(.+):(\d+)$/.exec(stackLine);
        if (attempt3) {
            return [attempt3[1], Number(attempt3[2])];
        }
    }

    function isInternalFrame(stackLine) {
        var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);

        if (!fileNameAndLineNumber) {
            return false;
        }

        var fileName = fileNameAndLineNumber[0];
        var lineNumber = fileNameAndLineNumber[1];

        return fileName === qFileName &&
            lineNumber >= qStartingLine &&
            lineNumber <= qEndingLine;
    }

    // discover own file name and line number range for filtering stack
    // traces
    function captureLine() {
        if (!hasStacks) {
            return;
        }

        try {
            throw new Error();
        } catch (e) {
            var lines = e.stack.split("\n");
            var firstLine = lines[0].indexOf("@") > 0 ? lines[1] : lines[2];
            var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);
            if (!fileNameAndLineNumber) {
                return;
            }

            qFileName = fileNameAndLineNumber[0];
            return fileNameAndLineNumber[1];
        }
    }

    function deprecate(callback, name, alternative) {
        return function () {
            if (typeof console !== "undefined" &&
                typeof console.warn === "function") {
                console.warn(name + " is deprecated, use " + alternative +
                    " instead.", new Error("").stack);
            }
            return callback.apply(callback, arguments);
        };
    }

    // end of shims
    // beginning of real work

    /**
     * Constructs a promise for an immediate reference, passes promises through, or
     * coerces promises from different systems.
     * @param value immediate reference or promise
     */
    function Q(value) {
        // If the object is already a Promise, return it directly.  This enables
        // the resolve function to both be used to created references from objects,
        // but to tolerably coerce non-promises to promises.
        if (value instanceof Promise) {
            return value;
        }

        // assimilate thenables
        if (isPromiseAlike(value)) {
            return coerce(value);
        } else {
            return fulfill(value);
        }
    }
    Q.resolve = Q;

    /**
     * Performs a task in a future turn of the event loop.
     * @param {Function} task
     */
    Q.nextTick = nextTick;

    /**
     * Controls whether or not long stack traces will be on
     */
    Q.longStackSupport = false;

    // enable long stacks if Q_DEBUG is set
    if (typeof process === "object" && process && process.env && process.env.Q_DEBUG) {
        Q.longStackSupport = true;
    }

    /**
     * Constructs a {promise, resolve, reject} object.
     *
     * `resolve` is a callback to invoke with a more resolved value for the
     * promise. To fulfill the promise, invoke `resolve` with any value that is
     * not a thenable. To reject the promise, invoke `resolve` with a rejected
     * thenable, or invoke `reject` with the reason directly. To resolve the
     * promise to another thenable, thus putting it in the same state, invoke
     * `resolve` with that other thenable.
     */
    Q.defer = defer;
    function defer() {
        // if "messages" is an "Array", that indicates that the promise has not yet
        // been resolved.  If it is "undefined", it has been resolved.  Each
        // element of the messages array is itself an array of complete arguments to
        // forward to the resolved promise.  We coerce the resolution value to a
        // promise using the `resolve` function because it handles both fully
        // non-thenable values and other thenables gracefully.
        var messages = [], progressListeners = [], resolvedPromise;

        var deferred = object_create(defer.prototype);
        var promise = object_create(Promise.prototype);

        promise.promiseDispatch = function (resolve, op, operands) {
            var args = array_slice(arguments);
            if (messages) {
                messages.push(args);
                if (op === "when" && operands[1]) { // progress operand
                    progressListeners.push(operands[1]);
                }
            } else {
                Q.nextTick(function () {
                    resolvedPromise.promiseDispatch.apply(resolvedPromise, args);
                });
            }
        };

        // XXX deprecated
        promise.valueOf = function () {
            if (messages) {
                return promise;
            }
            var nearerValue = nearer(resolvedPromise);
            if (isPromise(nearerValue)) {
                resolvedPromise = nearerValue; // shorten chain
            }
            return nearerValue;
        };

        promise.inspect = function () {
            if (!resolvedPromise) {
                return { state: "pending" };
            }
            return resolvedPromise.inspect();
        };

        if (Q.longStackSupport && hasStacks) {
            try {
                throw new Error();
            } catch (e) {
                // NOTE: don't try to use `Error.captureStackTrace` or transfer the
                // accessor around; that causes memory leaks as per GH-111. Just
                // reify the stack trace as a string ASAP.
                //
                // At the same time, cut off the first line; it's always just
                // "[object Promise]\n", as per the `toString`.
                promise.stack = e.stack.substring(e.stack.indexOf("\n") + 1);
            }
        }

        // NOTE: we do the checks for `resolvedPromise` in each method, instead of
        // consolidating them into `become`, since otherwise we'd create new
        // promises with the lines `become(whatever(value))`. See e.g. GH-252.

        function become(newPromise) {
            resolvedPromise = newPromise;
            promise.source = newPromise;

            array_reduce(messages, function (undefined, message) {
                Q.nextTick(function () {
                    newPromise.promiseDispatch.apply(newPromise, message);
                });
            }, void 0);

            messages = void 0;
            progressListeners = void 0;
        }

        deferred.promise = promise;
        deferred.resolve = function (value) {
            if (resolvedPromise) {
                return;
            }

            become(Q(value));
        };

        deferred.fulfill = function (value) {
            if (resolvedPromise) {
                return;
            }

            become(fulfill(value));
        };
        deferred.reject = function (reason) {
            if (resolvedPromise) {
                return;
            }

            become(reject(reason));
        };
        deferred.notify = function (progress) {
            if (resolvedPromise) {
                return;
            }

            array_reduce(progressListeners, function (undefined, progressListener) {
                Q.nextTick(function () {
                    progressListener(progress);
                });
            }, void 0);
        };

        return deferred;
    }

    /**
     * Creates a Node-style callback that will resolve or reject the deferred
     * promise.
     * @returns a nodeback
     */
    defer.prototype.makeNodeResolver = function () {
        var self = this;
        return function (error, value) {
            if (error) {
                self.reject(error);
            } else if (arguments.length > 2) {
                self.resolve(array_slice(arguments, 1));
            } else {
                self.resolve(value);
            }
        };
    };

    /**
     * @param resolver {Function} a function that returns nothing and accepts
     * the resolve, reject, and notify functions for a deferred.
     * @returns a promise that may be resolved with the given resolve and reject
     * functions, or rejected by a thrown exception in resolver
     */
    Q.Promise = promise; // ES6
    Q.promise = promise;
    function promise(resolver) {
        if (typeof resolver !== "function") {
            throw new TypeError("resolver must be a function.");
        }
        var deferred = defer();
        try {
            resolver(deferred.resolve, deferred.reject, deferred.notify);
        } catch (reason) {
            deferred.reject(reason);
        }
        return deferred.promise;
    }

    promise.race = race; // ES6
    promise.all = all; // ES6
    promise.reject = reject; // ES6
    promise.resolve = Q; // ES6

    // XXX experimental.  This method is a way to denote that a local value is
    // serializable and should be immediately dispatched to a remote upon request,
    // instead of passing a reference.
    Q.passByCopy = function (object) {
        //freeze(object);
        //passByCopies.set(object, true);
        return object;
    };

    Promise.prototype.passByCopy = function () {
        //freeze(object);
        //passByCopies.set(object, true);
        return this;
    };

    /**
     * If two promises eventually fulfill to the same value, promises that value,
     * but otherwise rejects.
     * @param x {Any*}
     * @param y {Any*}
     * @returns {Any*} a promise for x and y if they are the same, but a rejection
     * otherwise.
     *
     */
    Q.join = function (x, y) {
        return Q(x).join(y);
    };

    Promise.prototype.join = function (that) {
        return Q([this, that]).spread(function (x, y) {
            if (x === y) {
                // TODO: "===" should be Object.is or equiv
                return x;
            } else {
                throw new Error("Can't join: not the same: " + x + " " + y);
            }
        });
    };

    /**
     * Returns a promise for the first of an array of promises to become settled.
     * @param answers {Array[Any*]} promises to race
     * @returns {Any*} the first promise to be settled
     */
    Q.race = race;
    function race(answerPs) {
        return promise(function (resolve, reject) {
            // Switch to this once we can assume at least ES5
            // answerPs.forEach(function(answerP) {
            //     Q(answerP).then(resolve, reject);
            // });
            // Use this in the meantime
            for (var i = 0, len = answerPs.length; i < len; i++) {
                Q(answerPs[i]).then(resolve, reject);
            }
        });
    }

    Promise.prototype.race = function () {
        return this.then(Q.race);
    };

    /**
     * Constructs a Promise with a promise descriptor object and optional fallback
     * function.  The descriptor contains methods like when(rejected), get(name),
     * set(name, value), post(name, args), and delete(name), which all
     * return either a value, a promise for a value, or a rejection.  The fallback
     * accepts the operation name, a resolver, and any further arguments that would
     * have been forwarded to the appropriate method above had a method been
     * provided with the proper name.  The API makes no guarantees about the nature
     * of the returned object, apart from that it is usable whereever promises are
     * bought and sold.
     */
    Q.makePromise = Promise;
    function Promise(descriptor, fallback, inspect) {
        if (fallback === void 0) {
            fallback = function (op) {
                return reject(new Error(
                    "Promise does not support operation: " + op
                ));
            };
        }
        if (inspect === void 0) {
            inspect = function () {
                return { state: "unknown" };
            };
        }

        var promise = object_create(Promise.prototype);

        promise.promiseDispatch = function (resolve, op, args) {
            var result;
            try {
                if (descriptor[op]) {
                    result = descriptor[op].apply(promise, args);
                } else {
                    result = fallback.call(promise, op, args);
                }
            } catch (exception) {
                result = reject(exception);
            }
            if (resolve) {
                resolve(result);
            }
        };

        promise.inspect = inspect;

        // XXX deprecated `valueOf` and `exception` support
        if (inspect) {
            var inspected = inspect();
            if (inspected.state === "rejected") {
                promise.exception = inspected.reason;
            }

            promise.valueOf = function () {
                var inspected = inspect();
                if (inspected.state === "pending" ||
                    inspected.state === "rejected") {
                    return promise;
                }
                return inspected.value;
            };
        }

        return promise;
    }

    Promise.prototype.toString = function () {
        return "[object Promise]";
    };

    Promise.prototype.then = function (fulfilled, rejected, progressed) {
        var self = this;
        var deferred = defer();
        var done = false;   // ensure the untrusted promise makes at most a
        // single call to one of the callbacks

        function _fulfilled(value) {
            try {
                return typeof fulfilled === "function" ? fulfilled(value) : value;
            } catch (exception) {
                return reject(exception);
            }
        }

        function _rejected(exception) {
            if (typeof rejected === "function") {
                makeStackTraceLong(exception, self);
                try {
                    return rejected(exception);
                } catch (newException) {
                    return reject(newException);
                }
            }
            return reject(exception);
        }

        function _progressed(value) {
            return typeof progressed === "function" ? progressed(value) : value;
        }

        Q.nextTick(function () {
            self.promiseDispatch(function (value) {
                if (done) {
                    return;
                }
                done = true;

                deferred.resolve(_fulfilled(value));
            }, "when", [function (exception) {
                if (done) {
                    return;
                }
                done = true;

                deferred.resolve(_rejected(exception));
            }]);
        });

        // Progress propagator need to be attached in the current tick.
        self.promiseDispatch(void 0, "when", [void 0, function (value) {
            var newValue;
            var threw = false;
            try {
                newValue = _progressed(value);
            } catch (e) {
                threw = true;
                if (Q.onerror) {
                    Q.onerror(e);
                } else {
                    throw e;
                }
            }

            if (!threw) {
                deferred.notify(newValue);
            }
        }]);

        return deferred.promise;
    };

    Q.tap = function (promise, callback) {
        return Q(promise).tap(callback);
    };

    /**
     * Works almost like "finally", but not called for rejections.
     * Original resolution value is passed through callback unaffected.
     * Callback may return a promise that will be awaited for.
     * @param {Function} callback
     * @returns {Q.Promise}
     * @example
     * doSomething()
     *   .then(...)
     *   .tap(console.log)
     *   .then(...);
     */
    Promise.prototype.tap = function (callback) {
        callback = Q(callback);

        return this.then(function (value) {
            return callback.fcall(value).thenResolve(value);
        });
    };

    /**
     * Registers an observer on a promise.
     *
     * Guarantees:
     *
     * 1. that fulfilled and rejected will be called only once.
     * 2. that either the fulfilled callback or the rejected callback will be
     *    called, but not both.
     * 3. that fulfilled and rejected will not be called in this turn.
     *
     * @param value      promise or immediate reference to observe
     * @param fulfilled  function to be called with the fulfilled value
     * @param rejected   function to be called with the rejection exception
     * @param progressed function to be called on any progress notifications
     * @return promise for the return value from the invoked callback
     */
    Q.when = when;
    function when(value, fulfilled, rejected, progressed) {
        return Q(value).then(fulfilled, rejected, progressed);
    }

    Promise.prototype.thenResolve = function (value) {
        return this.then(function () { return value; });
    };

    Q.thenResolve = function (promise, value) {
        return Q(promise).thenResolve(value);
    };

    Promise.prototype.thenReject = function (reason) {
        return this.then(function () { throw reason; });
    };

    Q.thenReject = function (promise, reason) {
        return Q(promise).thenReject(reason);
    };

    /**
     * If an object is not a promise, it is as "near" as possible.
     * If a promise is rejected, it is as "near" as possible too.
     * If itâ€™s a fulfilled promise, the fulfillment value is nearer.
     * If itâ€™s a deferred promise and the deferred has been resolved, the
     * resolution is "nearer".
     * @param object
     * @returns most resolved (nearest) form of the object
     */

    // XXX should we re-do this?
    Q.nearer = nearer;
    function nearer(value) {
        if (isPromise(value)) {
            var inspected = value.inspect();
            if (inspected.state === "fulfilled") {
                return inspected.value;
            }
        }
        return value;
    }

    /**
     * @returns whether the given object is a promise.
     * Otherwise it is a fulfilled value.
     */
    Q.isPromise = isPromise;
    function isPromise(object) {
        return object instanceof Promise;
    }

    Q.isPromiseAlike = isPromiseAlike;
    function isPromiseAlike(object) {
        return isObject(object) && typeof object.then === "function";
    }

    /**
     * @returns whether the given object is a pending promise, meaning not
     * fulfilled or rejected.
     */
    Q.isPending = isPending;
    function isPending(object) {
        return isPromise(object) && object.inspect().state === "pending";
    }

    Promise.prototype.isPending = function () {
        return this.inspect().state === "pending";
    };

    /**
     * @returns whether the given object is a value or fulfilled
     * promise.
     */
    Q.isFulfilled = isFulfilled;
    function isFulfilled(object) {
        return !isPromise(object) || object.inspect().state === "fulfilled";
    }

    Promise.prototype.isFulfilled = function () {
        return this.inspect().state === "fulfilled";
    };

    /**
     * @returns whether the given object is a rejected promise.
     */
    Q.isRejected = isRejected;
    function isRejected(object) {
        return isPromise(object) && object.inspect().state === "rejected";
    }

    Promise.prototype.isRejected = function () {
        return this.inspect().state === "rejected";
    };

    //// BEGIN UNHANDLED REJECTION TRACKING

    // This promise library consumes exceptions thrown in handlers so they can be
    // handled by a subsequent promise.  The exceptions get added to this array when
    // they are created, and removed when they are handled.  Note that in ES6 or
    // shimmed environments, this would naturally be a `Set`.
    var unhandledReasons = [];
    var unhandledRejections = [];
    var trackUnhandledRejections = true;

    function resetUnhandledRejections() {
        unhandledReasons.length = 0;
        unhandledRejections.length = 0;

        if (!trackUnhandledRejections) {
            trackUnhandledRejections = true;
        }
    }

    function trackRejection(promise, reason) {
        if (!trackUnhandledRejections) {
            return;
        }

        unhandledRejections.push(promise);
        if (reason && typeof reason.stack !== "undefined") {
            unhandledReasons.push(reason.stack);
        } else {
            unhandledReasons.push("(no stack) " + reason);
        }
    }

    function untrackRejection(promise) {
        if (!trackUnhandledRejections) {
            return;
        }

        var at = array_indexOf(unhandledRejections, promise);
        if (at !== -1) {
            unhandledRejections.splice(at, 1);
            unhandledReasons.splice(at, 1);
        }
    }

    Q.resetUnhandledRejections = resetUnhandledRejections;

    Q.getUnhandledReasons = function () {
        // Make a copy so that consumers can't interfere with our internal state.
        return unhandledReasons.slice();
    };

    Q.stopUnhandledRejectionTracking = function () {
        resetUnhandledRejections();
        trackUnhandledRejections = false;
    };

    resetUnhandledRejections();

    //// END UNHANDLED REJECTION TRACKING

    /**
     * Constructs a rejected promise.
     * @param reason value describing the failure
     */
    Q.reject = reject;
    function reject(reason) {
        var rejection = Promise({
            "when": function (rejected) {
                // note that the error has been handled
                if (rejected) {
                    untrackRejection(this);
                }
                return rejected ? rejected(reason) : this;
            }
        }, function fallback() {
            return this;
        }, function inspect() {
            return { state: "rejected", reason: reason };
        });

        // Note that the reason has not been handled.
        trackRejection(rejection, reason);

        return rejection;
    }

    /**
     * Constructs a fulfilled promise for an immediate reference.
     * @param value immediate reference
     */
    Q.fulfill = fulfill;
    function fulfill(value) {
        return Promise({
            "when": function () {
                return value;
            },
            "get": function (name) {
                return value[name];
            },
            "set": function (name, rhs) {
                value[name] = rhs;
            },
            "delete": function (name) {
                delete value[name];
            },
            "post": function (name, args) {
                // Mark Miller proposes that post with no name should apply a
                // promised function.
                if (name === null || name === void 0) {
                    return value.apply(void 0, args);
                } else {
                    return value[name].apply(value, args);
                }
            },
            "apply": function (thisp, args) {
                return value.apply(thisp, args);
            },
            "keys": function () {
                return object_keys(value);
            }
        }, void 0, function inspect() {
            return { state: "fulfilled", value: value };
        });
    }

    /**
     * Converts thenables to Q promises.
     * @param promise thenable promise
     * @returns a Q promise
     */
    function coerce(promise) {
        var deferred = defer();
        Q.nextTick(function () {
            try {
                promise.then(deferred.resolve, deferred.reject, deferred.notify);
            } catch (exception) {
                deferred.reject(exception);
            }
        });
        return deferred.promise;
    }

    /**
     * Annotates an object such that it will never be
     * transferred away from this process over any promise
     * communication channel.
     * @param object
     * @returns promise a wrapping of that object that
     * additionally responds to the "isDef" message
     * without a rejection.
     */
    Q.master = master;
    function master(object) {
        return Promise({
            "isDef": function () { }
        }, function fallback(op, args) {
            return dispatch(object, op, args);
        }, function () {
            return Q(object).inspect();
        });
    }

    /**
     * Spreads the values of a promised array of arguments into the
     * fulfillment callback.
     * @param fulfilled callback that receives variadic arguments from the
     * promised array
     * @param rejected callback that receives the exception if the promise
     * is rejected.
     * @returns a promise for the return value or thrown exception of
     * either callback.
     */
    Q.spread = spread;
    function spread(value, fulfilled, rejected) {
        return Q(value).spread(fulfilled, rejected);
    }

    Promise.prototype.spread = function (fulfilled, rejected) {
        return this.all().then(function (array) {
            return fulfilled.apply(void 0, array);
        }, rejected);
    };

    /**
     * The async function is a decorator for generator functions, turning
     * them into asynchronous generators.  Although generators are only part
     * of the newest ECMAScript 6 drafts, this code does not cause syntax
     * errors in older engines.  This code should continue to work and will
     * in fact improve over time as the language improves.
     *
     * ES6 generators are currently part of V8 version 3.19 with the
     * --harmony-generators runtime flag enabled.  SpiderMonkey has had them
     * for longer, but under an older Python-inspired form.  This function
     * works on both kinds of generators.
     *
     * Decorates a generator function such that:
     *  - it may yield promises
     *  - execution will continue when that promise is fulfilled
     *  - the value of the yield expression will be the fulfilled value
     *  - it returns a promise for the return value (when the generator
     *    stops iterating)
     *  - the decorated function returns a promise for the return value
     *    of the generator or the first rejected promise among those
     *    yielded.
     *  - if an error is thrown in the generator, it propagates through
     *    every following yield until it is caught, or until it escapes
     *    the generator function altogether, and is translated into a
     *    rejection for the promise returned by the decorated generator.
     */
    Q.async = async;
    function async(makeGenerator) {
        return function () {
            // when verb is "send", arg is a value
            // when verb is "throw", arg is an exception
            function continuer(verb, arg) {
                var result;

                // Until V8 3.19 / Chromium 29 is released, SpiderMonkey is the only
                // engine that has a deployed base of browsers that support generators.
                // However, SM's generators use the Python-inspired semantics of
                // outdated ES6 drafts.  We would like to support ES6, but we'd also
                // like to make it possible to use generators in deployed browsers, so
                // we also support Python-style generators.  At some point we can remove
                // this block.

                if (typeof StopIteration === "undefined") {
                    // ES6 Generators
                    try {
                        result = generator[verb](arg);
                    } catch (exception) {
                        return reject(exception);
                    }
                    if (result.done) {
                        return Q(result.value);
                    } else {
                        return when(result.value, callback, errback);
                    }
                } else {
                    // SpiderMonkey Generators
                    // FIXME: Remove this case when SM does ES6 generators.
                    try {
                        result = generator[verb](arg);
                    } catch (exception) {
                        if (isStopIteration(exception)) {
                            return Q(exception.value);
                        } else {
                            return reject(exception);
                        }
                    }
                    return when(result, callback, errback);
                }
            }
            var generator = makeGenerator.apply(this, arguments);
            var callback = continuer.bind(continuer, "next");
            var errback = continuer.bind(continuer, "throw");
            return callback();
        };
    }

    /**
     * The spawn function is a small wrapper around async that immediately
     * calls the generator and also ends the promise chain, so that any
     * unhandled errors are thrown instead of forwarded to the error
     * handler. This is useful because it's extremely common to run
     * generators at the top-level to work with libraries.
     */
    Q.spawn = spawn;
    function spawn(makeGenerator) {
        Q.done(Q.async(makeGenerator)());
    }

    // FIXME: Remove this interface once ES6 generators are in SpiderMonkey.
    /**
     * Throws a ReturnValue exception to stop an asynchronous generator.
     *
     * This interface is a stop-gap measure to support generator return
     * values in older Firefox/SpiderMonkey.  In browsers that support ES6
     * generators like Chromium 29, just use "return" in your generator
     * functions.
     *
     * @param value the return value for the surrounding generator
     * @throws ReturnValue exception with the value.
     * @example
     * // ES6 style
     * Q.async(function* () {
     *      var foo = yield getFooPromise();
     *      var bar = yield getBarPromise();
     *      return foo + bar;
     * })
     * // Older SpiderMonkey style
     * Q.async(function () {
     *      var foo = yield getFooPromise();
     *      var bar = yield getBarPromise();
     *      Q.return(foo + bar);
     * })
     */
    Q["return"] = _return;
    function _return(value) {
        throw new QReturnValue(value);
    }

    /**
     * The promised function decorator ensures that any promise arguments
     * are settled and passed as values (`this` is also settled and passed
     * as a value).  It will also ensure that the result of a function is
     * always a promise.
     *
     * @example
     * var add = Q.promised(function (a, b) {
     *     return a + b;
     * });
     * add(Q(a), Q(B));
     *
     * @param {function} callback The function to decorate
     * @returns {function} a function that has been decorated.
     */
    Q.promised = promised;
    function promised(callback) {
        return function () {
            return spread([this, all(arguments)], function (self, args) {
                return callback.apply(self, args);
            });
        };
    }

    /**
     * sends a message to a value in a future turn
     * @param object* the recipient
     * @param op the name of the message operation, e.g., "when",
     * @param args further arguments to be forwarded to the operation
     * @returns result {Promise} a promise for the result of the operation
     */
    Q.dispatch = dispatch;
    function dispatch(object, op, args) {
        return Q(object).dispatch(op, args);
    }

    Promise.prototype.dispatch = function (op, args) {
        var self = this;
        var deferred = defer();
        Q.nextTick(function () {
            self.promiseDispatch(deferred.resolve, op, args);
        });
        return deferred.promise;
    };

    /**
     * Gets the value of a property in a future turn.
     * @param object    promise or immediate reference for target object
     * @param name      name of property to get
     * @return promise for the property value
     */
    Q.get = function (object, key) {
        return Q(object).dispatch("get", [key]);
    };

    Promise.prototype.get = function (key) {
        return this.dispatch("get", [key]);
    };

    /**
     * Sets the value of a property in a future turn.
     * @param object    promise or immediate reference for object object
     * @param name      name of property to set
     * @param value     new value of property
     * @return promise for the return value
     */
    Q.set = function (object, key, value) {
        return Q(object).dispatch("set", [key, value]);
    };

    Promise.prototype.set = function (key, value) {
        return this.dispatch("set", [key, value]);
    };

    /**
     * Deletes a property in a future turn.
     * @param object    promise or immediate reference for target object
     * @param name      name of property to delete
     * @return promise for the return value
     */
    Q.del = // XXX legacy
        Q["delete"] = function (object, key) {
            return Q(object).dispatch("delete", [key]);
        };

    Promise.prototype.del = // XXX legacy
        Promise.prototype["delete"] = function (key) {
            return this.dispatch("delete", [key]);
        };

    /**
     * Invokes a method in a future turn.
     * @param object    promise or immediate reference for target object
     * @param name      name of method to invoke
     * @param value     a value to post, typically an array of
     *                  invocation arguments for promises that
     *                  are ultimately backed with `resolve` values,
     *                  as opposed to those backed with URLs
     *                  wherein the posted value can be any
     *                  JSON serializable object.
     * @return promise for the return value
     */
    // bound locally because it is used by other methods
    Q.mapply = // XXX As proposed by "Redsandro"
        Q.post = function (object, name, args) {
            return Q(object).dispatch("post", [name, args]);
        };

    Promise.prototype.mapply = // XXX As proposed by "Redsandro"
        Promise.prototype.post = function (name, args) {
            return this.dispatch("post", [name, args]);
        };

    /**
     * Invokes a method in a future turn.
     * @param object    promise or immediate reference for target object
     * @param name      name of method to invoke
     * @param ...args   array of invocation arguments
     * @return promise for the return value
     */
    Q.send = // XXX Mark Miller's proposed parlance
        Q.mcall = // XXX As proposed by "Redsandro"
        Q.invoke = function (object, name /*...args*/) {
            return Q(object).dispatch("post", [name, array_slice(arguments, 2)]);
        };

    Promise.prototype.send = // XXX Mark Miller's proposed parlance
        Promise.prototype.mcall = // XXX As proposed by "Redsandro"
        Promise.prototype.invoke = function (name /*...args*/) {
            return this.dispatch("post", [name, array_slice(arguments, 1)]);
        };

    /**
     * Applies the promised function in a future turn.
     * @param object    promise or immediate reference for target function
     * @param args      array of application arguments
     */
    Q.fapply = function (object, args) {
        return Q(object).dispatch("apply", [void 0, args]);
    };

    Promise.prototype.fapply = function (args) {
        return this.dispatch("apply", [void 0, args]);
    };

    /**
     * Calls the promised function in a future turn.
     * @param object    promise or immediate reference for target function
     * @param ...args   array of application arguments
     */
    Q["try"] =
        Q.fcall = function (object /* ...args*/) {
            return Q(object).dispatch("apply", [void 0, array_slice(arguments, 1)]);
        };

    Promise.prototype.fcall = function (/*...args*/) {
        return this.dispatch("apply", [void 0, array_slice(arguments)]);
    };

    /**
     * Binds the promised function, transforming return values into a fulfilled
     * promise and thrown errors into a rejected one.
     * @param object    promise or immediate reference for target function
     * @param ...args   array of application arguments
     */
    Q.fbind = function (object /*...args*/) {
        var promise = Q(object);
        var args = array_slice(arguments, 1);
        return function fbound() {
            return promise.dispatch("apply", [
                this,
                args.concat(array_slice(arguments))
            ]);
        };
    };
    Promise.prototype.fbind = function (/*...args*/) {
        var promise = this;
        var args = array_slice(arguments);
        return function fbound() {
            return promise.dispatch("apply", [
                this,
                args.concat(array_slice(arguments))
            ]);
        };
    };

    /**
     * Requests the names of the owned properties of a promised
     * object in a future turn.
     * @param object    promise or immediate reference for target object
     * @return promise for the keys of the eventually settled object
     */
    Q.keys = function (object) {
        return Q(object).dispatch("keys", []);
    };

    Promise.prototype.keys = function () {
        return this.dispatch("keys", []);
    };

    /**
     * Turns an array of promises into a promise for an array.  If any of
     * the promises gets rejected, the whole array is rejected immediately.
     * @param {Array*} an array (or promise for an array) of values (or
     * promises for values)
     * @returns a promise for an array of the corresponding values
     */
    // By Mark Miller
    // http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled
    Q.all = all;
    function all(promises) {
        return when(promises, function (promises) {
            var countDown = 0;
            var deferred = defer();
            array_reduce(promises, function (undefined, promise, index) {
                var snapshot;
                if (
                    isPromise(promise) &&
                    (snapshot = promise.inspect()).state === "fulfilled"
                ) {
                    promises[index] = snapshot.value;
                } else {
                    ++countDown;
                    when(
                        promise,
                        function (value) {
                            promises[index] = value;
                            if (--countDown === 0) {
                                deferred.resolve(promises);
                            }
                        },
                        deferred.reject,
                        function (progress) {
                            deferred.notify({ index: index, value: progress });
                        }
                    );
                }
            }, void 0);
            if (countDown === 0) {
                deferred.resolve(promises);
            }
            return deferred.promise;
        });
    }

    Promise.prototype.all = function () {
        return all(this);
    };

    /**
     * Waits for all promises to be settled, either fulfilled or
     * rejected.  This is distinct from `all` since that would stop
     * waiting at the first rejection.  The promise returned by
     * `allResolved` will never be rejected.
     * @param promises a promise for an array (or an array) of promises
     * (or values)
     * @return a promise for an array of promises
     */
    Q.allResolved = deprecate(allResolved, "allResolved", "allSettled");
    function allResolved(promises) {
        return when(promises, function (promises) {
            promises = array_map(promises, Q);
            return when(all(array_map(promises, function (promise) {
                return when(promise, noop, noop);
            })), function () {
                return promises;
            });
        });
    }

    Promise.prototype.allResolved = function () {
        return allResolved(this);
    };

    /**
     * @see Promise#allSettled
     */
    Q.allSettled = allSettled;
    function allSettled(promises) {
        return Q(promises).allSettled();
    }

    /**
     * Turns an array of promises into a promise for an array of their states (as
     * returned by `inspect`) when they have all settled.
     * @param {Array[Any*]} values an array (or promise for an array) of values (or
     * promises for values)
     * @returns {Array[State]} an array of states for the respective values.
     */
    Promise.prototype.allSettled = function () {
        return this.then(function (promises) {
            return all(array_map(promises, function (promise) {
                promise = Q(promise);
                function regardless() {
                    return promise.inspect();
                }
                return promise.then(regardless, regardless);
            }));
        });
    };

    /**
     * Captures the failure of a promise, giving an oportunity to recover
     * with a callback.  If the given promise is fulfilled, the returned
     * promise is fulfilled.
     * @param {Any*} promise for something
     * @param {Function} callback to fulfill the returned promise if the
     * given promise is rejected
     * @returns a promise for the return value of the callback
     */
    Q.fail = // XXX legacy
        Q["catch"] = function (object, rejected) {
            return Q(object).then(void 0, rejected);
        };

    Promise.prototype.fail = // XXX legacy
        Promise.prototype["catch"] = function (rejected) {
            return this.then(void 0, rejected);
        };

    /**
     * Attaches a listener that can respond to progress notifications from a
     * promise's originating deferred. This listener receives the exact arguments
     * passed to ``deferred.notify``.
     * @param {Any*} promise for something
     * @param {Function} callback to receive any progress notifications
     * @returns the given promise, unchanged
     */
    Q.progress = progress;
    function progress(object, progressed) {
        return Q(object).then(void 0, void 0, progressed);
    }

    Promise.prototype.progress = function (progressed) {
        return this.then(void 0, void 0, progressed);
    };

    /**
     * Provides an opportunity to observe the settling of a promise,
     * regardless of whether the promise is fulfilled or rejected.  Forwards
     * the resolution to the returned promise when the callback is done.
     * The callback can return a promise to defer completion.
     * @param {Any*} promise
     * @param {Function} callback to observe the resolution of the given
     * promise, takes no arguments.
     * @returns a promise for the resolution of the given promise when
     * ``fin`` is done.
     */
    Q.fin = // XXX legacy
        Q["finally"] = function (object, callback) {
            return Q(object)["finally"](callback);
        };

    Promise.prototype.fin = // XXX legacy
        Promise.prototype["finally"] = function (callback) {
            callback = Q(callback);
            return this.then(function (value) {
                return callback.fcall().then(function () {
                    return value;
                });
            }, function (reason) {
                // TODO attempt to recycle the rejection with "this".
                return callback.fcall().then(function () {
                    throw reason;
                });
            });
        };

    /**
     * Terminates a chain of promises, forcing rejections to be
     * thrown as exceptions.
     * @param {Any*} promise at the end of a chain of promises
     * @returns nothing
     */
    Q.done = function (object, fulfilled, rejected, progress) {
        return Q(object).done(fulfilled, rejected, progress);
    };

    Promise.prototype.done = function (fulfilled, rejected, progress) {
        var onUnhandledError = function (error) {
            // forward to a future turn so that ``when``
            // does not catch it and turn it into a rejection.
            Q.nextTick(function () {
                makeStackTraceLong(error, promise);
                if (Q.onerror) {
                    Q.onerror(error);
                } else {
                    throw error;
                }
            });
        };

        // Avoid unnecessary `nextTick`ing via an unnecessary `when`.
        var promise = fulfilled || rejected || progress ?
            this.then(fulfilled, rejected, progress) :
            this;

        if (typeof process === "object" && process && process.domain) {
            onUnhandledError = process.domain.bind(onUnhandledError);
        }

        promise.then(void 0, onUnhandledError);
    };

    /**
     * Causes a promise to be rejected if it does not get fulfilled before
     * some milliseconds time out.
     * @param {Any*} promise
     * @param {Number} milliseconds timeout
     * @param {Any*} custom error message or Error object (optional)
     * @returns a promise for the resolution of the given promise if it is
     * fulfilled before the timeout, otherwise rejected.
     */
    Q.timeout = function (object, ms, error) {
        return Q(object).timeout(ms, error);
    };

    Promise.prototype.timeout = function (ms, error) {
        var deferred = defer();
        var timeoutId = setTimeout(function () {
            if (!error || "string" === typeof error) {
                error = new Error(error || "Timed out after " + ms + " ms");
                error.code = "ETIMEDOUT";
            }
            deferred.reject(error);
        }, ms);

        this.then(function (value) {
            clearTimeout(timeoutId);
            deferred.resolve(value);
        }, function (exception) {
            clearTimeout(timeoutId);
            deferred.reject(exception);
        }, deferred.notify);

        return deferred.promise;
    };

    /**
     * Returns a promise for the given value (or promised value), some
     * milliseconds after it resolved. Passes rejections immediately.
     * @param {Any*} promise
     * @param {Number} milliseconds
     * @returns a promise for the resolution of the given promise after milliseconds
     * time has elapsed since the resolution of the given promise.
     * If the given promise rejects, that is passed immediately.
     */
    Q.delay = function (object, timeout) {
        if (timeout === void 0) {
            timeout = object;
            object = void 0;
        }
        return Q(object).delay(timeout);
    };

    Promise.prototype.delay = function (timeout) {
        return this.then(function (value) {
            var deferred = defer();
            setTimeout(function () {
                deferred.resolve(value);
            }, timeout);
            return deferred.promise;
        });
    };

    /**
     * Passes a continuation to a Node function, which is called with the given
     * arguments provided as an array, and returns a promise.
     *
     *      Q.nfapply(FS.readFile, [__filename])
     *      .then(function (content) {
     *      })
     *
     */
    Q.nfapply = function (callback, args) {
        return Q(callback).nfapply(args);
    };

    Promise.prototype.nfapply = function (args) {
        var deferred = defer();
        var nodeArgs = array_slice(args);
        nodeArgs.push(deferred.makeNodeResolver());
        this.fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
    };

    /**
     * Passes a continuation to a Node function, which is called with the given
     * arguments provided individually, and returns a promise.
     * @example
     * Q.nfcall(FS.readFile, __filename)
     * .then(function (content) {
     * })
     *
     */
    Q.nfcall = function (callback /*...args*/) {
        var args = array_slice(arguments, 1);
        return Q(callback).nfapply(args);
    };

    Promise.prototype.nfcall = function (/*...args*/) {
        var nodeArgs = array_slice(arguments);
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        this.fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
    };

    /**
     * Wraps a NodeJS continuation passing function and returns an equivalent
     * version that returns a promise.
     * @example
     * Q.nfbind(FS.readFile, __filename)("utf-8")
     * .then(console.log)
     * .done()
     */
    Q.nfbind =
        Q.denodeify = function (callback /*...args*/) {
            var baseArgs = array_slice(arguments, 1);
            return function () {
                var nodeArgs = baseArgs.concat(array_slice(arguments));
                var deferred = defer();
                nodeArgs.push(deferred.makeNodeResolver());
                Q(callback).fapply(nodeArgs).fail(deferred.reject);
                return deferred.promise;
            };
        };

    Promise.prototype.nfbind =
        Promise.prototype.denodeify = function (/*...args*/) {
            var args = array_slice(arguments);
            args.unshift(this);
            return Q.denodeify.apply(void 0, args);
        };

    Q.nbind = function (callback, thisp /*...args*/) {
        var baseArgs = array_slice(arguments, 2);
        return function () {
            var nodeArgs = baseArgs.concat(array_slice(arguments));
            var deferred = defer();
            nodeArgs.push(deferred.makeNodeResolver());
            function bound() {
                return callback.apply(thisp, arguments);
            }
            Q(bound).fapply(nodeArgs).fail(deferred.reject);
            return deferred.promise;
        };
    };

    Promise.prototype.nbind = function (/*thisp, ...args*/) {
        var args = array_slice(arguments, 0);
        args.unshift(this);
        return Q.nbind.apply(void 0, args);
    };

    /**
     * Calls a method of a Node-style object that accepts a Node-style
     * callback with a given array of arguments, plus a provided callback.
     * @param object an object that has the named method
     * @param {String} name name of the method of object
     * @param {Array} args arguments to pass to the method; the callback
     * will be provided by Q and appended to these arguments.
     * @returns a promise for the value or error
     */
    Q.nmapply = // XXX As proposed by "Redsandro"
        Q.npost = function (object, name, args) {
            return Q(object).npost(name, args);
        };

    Promise.prototype.nmapply = // XXX As proposed by "Redsandro"
        Promise.prototype.npost = function (name, args) {
            var nodeArgs = array_slice(args || []);
            var deferred = defer();
            nodeArgs.push(deferred.makeNodeResolver());
            this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
            return deferred.promise;
        };

    /**
     * Calls a method of a Node-style object that accepts a Node-style
     * callback, forwarding the given variadic arguments, plus a provided
     * callback argument.
     * @param object an object that has the named method
     * @param {String} name name of the method of object
     * @param ...args arguments to pass to the method; the callback will
     * be provided by Q and appended to these arguments.
     * @returns a promise for the value or error
     */
    Q.nsend = // XXX Based on Mark Miller's proposed "send"
        Q.nmcall = // XXX Based on "Redsandro's" proposal
        Q.ninvoke = function (object, name /*...args*/) {
            var nodeArgs = array_slice(arguments, 2);
            var deferred = defer();
            nodeArgs.push(deferred.makeNodeResolver());
            Q(object).dispatch("post", [name, nodeArgs]).fail(deferred.reject);
            return deferred.promise;
        };

    Promise.prototype.nsend = // XXX Based on Mark Miller's proposed "send"
        Promise.prototype.nmcall = // XXX Based on "Redsandro's" proposal
        Promise.prototype.ninvoke = function (name /*...args*/) {
            var nodeArgs = array_slice(arguments, 1);
            var deferred = defer();
            nodeArgs.push(deferred.makeNodeResolver());
            this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
            return deferred.promise;
        };

    /**
     * If a function would like to support both Node continuation-passing-style and
     * promise-returning-style, it can end its internal promise chain with
     * `nodeify(nodeback)`, forwarding the optional nodeback argument.  If the user
     * elects to use a nodeback, the result will be sent there.  If they do not
     * pass a nodeback, they will receive the result promise.
     * @param object a result (or a promise for a result)
     * @param {Function} nodeback a Node.js-style callback
     * @returns either the promise or nothing
     */
    Q.nodeify = nodeify;
    function nodeify(object, nodeback) {
        return Q(object).nodeify(nodeback);
    }

    Promise.prototype.nodeify = function (nodeback) {
        if (nodeback) {
            this.then(function (value) {
                Q.nextTick(function () {
                    nodeback(null, value);
                });
            }, function (error) {
                Q.nextTick(function () {
                    nodeback(error);
                });
            });
        } else {
            return this;
        }
    };

    // All code before this point will be filtered from stack traces.
    var qEndingLine = captureLine();

    return Q;

});
;
/*! jQuery v1.9.1 | (c) 2005, 2012 jQuery Foundation, Inc. | jquery.org/license
//@ sourceMappingURL=jquery.min.map
*/(function (e, t) {
    var n, r, i = typeof t, o = e.document, a = e.location, s = e.jQuery, u = e.$, l = {}, c = [], p = "1.9.1", f = c.concat, d = c.push, h = c.slice, g = c.indexOf, m = l.toString, y = l.hasOwnProperty, v = p.trim, b = function (e, t) { return new b.fn.init(e, t, r) }, x = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source, w = /\S+/g, T = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, N = /^(?:(<[\w\W]+>)[^>]*|#([\w-]*))$/, C = /^<(\w+)\s*\/?>(?:<\/\1>|)$/, k = /^[\],:{}\s]*$/, E = /(?:^|:|,)(?:\s*\[)+/g, S = /\\(?:["\\\/bfnrt]|u[\da-fA-F]{4})/g, A = /"[^"\\\r\n]*"|true|false|null|-?(?:\d+\.|)\d+(?:[eE][+-]?\d+|)/g, j = /^-ms-/, D = /-([\da-z])/gi, L = function (e, t) { return t.toUpperCase() }, H = function (e) { (o.addEventListener || "load" === e.type || "complete" === o.readyState) && (q(), b.ready()) }, q = function () { o.addEventListener ? (o.removeEventListener("DOMContentLoaded", H, !1), e.removeEventListener("load", H, !1)) : (o.detachEvent("onreadystatechange", H), e.detachEvent("onload", H)) }; b.fn = b.prototype = { jquery: p, constructor: b, init: function (e, n, r) { var i, a; if (!e) return this; if ("string" == typeof e) { if (i = "<" === e.charAt(0) && ">" === e.charAt(e.length - 1) && e.length >= 3 ? [null, e, null] : N.exec(e), !i || !i[1] && n) return !n || n.jquery ? (n || r).find(e) : this.constructor(n).find(e); if (i[1]) { if (n = n instanceof b ? n[0] : n, b.merge(this, b.parseHTML(i[1], n && n.nodeType ? n.ownerDocument || n : o, !0)), C.test(i[1]) && b.isPlainObject(n)) for (i in n) b.isFunction(this[i]) ? this[i](n[i]) : this.attr(i, n[i]); return this } if (a = o.getElementById(i[2]), a && a.parentNode) { if (a.id !== i[2]) return r.find(e); this.length = 1, this[0] = a } return this.context = o, this.selector = e, this } return e.nodeType ? (this.context = this[0] = e, this.length = 1, this) : b.isFunction(e) ? r.ready(e) : (e.selector !== t && (this.selector = e.selector, this.context = e.context), b.makeArray(e, this)) }, selector: "", length: 0, size: function () { return this.length }, toArray: function () { return h.call(this) }, get: function (e) { return null == e ? this.toArray() : 0 > e ? this[this.length + e] : this[e] }, pushStack: function (e) { var t = b.merge(this.constructor(), e); return t.prevObject = this, t.context = this.context, t }, each: function (e, t) { return b.each(this, e, t) }, ready: function (e) { return b.ready.promise().done(e), this }, slice: function () { return this.pushStack(h.apply(this, arguments)) }, first: function () { return this.eq(0) }, last: function () { return this.eq(-1) }, eq: function (e) { var t = this.length, n = +e + (0 > e ? t : 0); return this.pushStack(n >= 0 && t > n ? [this[n]] : []) }, map: function (e) { return this.pushStack(b.map(this, function (t, n) { return e.call(t, n, t) })) }, end: function () { return this.prevObject || this.constructor(null) }, push: d, sort: [].sort, splice: [].splice }, b.fn.init.prototype = b.fn, b.extend = b.fn.extend = function () { var e, n, r, i, o, a, s = arguments[0] || {}, u = 1, l = arguments.length, c = !1; for ("boolean" == typeof s && (c = s, s = arguments[1] || {}, u = 2), "object" == typeof s || b.isFunction(s) || (s = {}), l === u && (s = this, --u); l > u; u++)if (null != (o = arguments[u])) for (i in o) e = s[i], r = o[i], s !== r && (c && r && (b.isPlainObject(r) || (n = b.isArray(r))) ? (n ? (n = !1, a = e && b.isArray(e) ? e : []) : a = e && b.isPlainObject(e) ? e : {}, s[i] = b.extend(c, a, r)) : r !== t && (s[i] = r)); return s }, b.extend({ noConflict: function (t) { return e.$ === b && (e.$ = u), t && e.jQuery === b && (e.jQuery = s), b }, isReady: !1, readyWait: 1, holdReady: function (e) { e ? b.readyWait++ : b.ready(!0) }, ready: function (e) { if (e === !0 ? !--b.readyWait : !b.isReady) { if (!o.body) return setTimeout(b.ready); b.isReady = !0, e !== !0 && --b.readyWait > 0 || (n.resolveWith(o, [b]), b.fn.trigger && b(o).trigger("ready").off("ready")) } }, isFunction: function (e) { return "function" === b.type(e) }, isArray: Array.isArray || function (e) { return "array" === b.type(e) }, isWindow: function (e) { return null != e && e == e.window }, isNumeric: function (e) { return !isNaN(parseFloat(e)) && isFinite(e) }, type: function (e) { return null == e ? e + "" : "object" == typeof e || "function" == typeof e ? l[m.call(e)] || "object" : typeof e }, isPlainObject: function (e) { if (!e || "object" !== b.type(e) || e.nodeType || b.isWindow(e)) return !1; try { if (e.constructor && !y.call(e, "constructor") && !y.call(e.constructor.prototype, "isPrototypeOf")) return !1 } catch (n) { return !1 } var r; for (r in e); return r === t || y.call(e, r) }, isEmptyObject: function (e) { var t; for (t in e) return !1; return !0 }, error: function (e) { throw Error(e) }, parseHTML: function (e, t, n) { if (!e || "string" != typeof e) return null; "boolean" == typeof t && (n = t, t = !1), t = t || o; var r = C.exec(e), i = !n && []; return r ? [t.createElement(r[1])] : (r = b.buildFragment([e], t, i), i && b(i).remove(), b.merge([], r.childNodes)) }, parseJSON: function (n) { return e.JSON && e.JSON.parse ? e.JSON.parse(n) : null === n ? n : "string" == typeof n && (n = b.trim(n), n && k.test(n.replace(S, "@").replace(A, "]").replace(E, ""))) ? Function("return " + n)() : (b.error("Invalid JSON: " + n), t) }, parseXML: function (n) { var r, i; if (!n || "string" != typeof n) return null; try { e.DOMParser ? (i = new DOMParser, r = i.parseFromString(n, "text/xml")) : (r = new ActiveXObject("Microsoft.XMLDOM"), r.async = "false", r.loadXML(n)) } catch (o) { r = t } return r && r.documentElement && !r.getElementsByTagName("parsererror").length || b.error("Invalid XML: " + n), r }, noop: function () { }, globalEval: function (t) { t && b.trim(t) && (e.execScript || function (t) { e.eval.call(e, t) })(t) }, camelCase: function (e) { return e.replace(j, "ms-").replace(D, L) }, nodeName: function (e, t) { return e.nodeName && e.nodeName.toLowerCase() === t.toLowerCase() }, each: function (e, t, n) { var r, i = 0, o = e.length, a = M(e); if (n) { if (a) { for (; o > i; i++)if (r = t.apply(e[i], n), r === !1) break } else for (i in e) if (r = t.apply(e[i], n), r === !1) break } else if (a) { for (; o > i; i++)if (r = t.call(e[i], i, e[i]), r === !1) break } else for (i in e) if (r = t.call(e[i], i, e[i]), r === !1) break; return e }, trim: v && !v.call("\ufeff\u00a0") ? function (e) { return null == e ? "" : v.call(e) } : function (e) { return null == e ? "" : (e + "").replace(T, "") }, makeArray: function (e, t) { var n = t || []; return null != e && (M(Object(e)) ? b.merge(n, "string" == typeof e ? [e] : e) : d.call(n, e)), n }, inArray: function (e, t, n) { var r; if (t) { if (g) return g.call(t, e, n); for (r = t.length, n = n ? 0 > n ? Math.max(0, r + n) : n : 0; r > n; n++)if (n in t && t[n] === e) return n } return -1 }, merge: function (e, n) { var r = n.length, i = e.length, o = 0; if ("number" == typeof r) for (; r > o; o++)e[i++] = n[o]; else while (n[o] !== t) e[i++] = n[o++]; return e.length = i, e }, grep: function (e, t, n) { var r, i = [], o = 0, a = e.length; for (n = !!n; a > o; o++)r = !!t(e[o], o), n !== r && i.push(e[o]); return i }, map: function (e, t, n) { var r, i = 0, o = e.length, a = M(e), s = []; if (a) for (; o > i; i++)r = t(e[i], i, n), null != r && (s[s.length] = r); else for (i in e) r = t(e[i], i, n), null != r && (s[s.length] = r); return f.apply([], s) }, guid: 1, proxy: function (e, n) { var r, i, o; return "string" == typeof n && (o = e[n], n = e, e = o), b.isFunction(e) ? (r = h.call(arguments, 2), i = function () { return e.apply(n || this, r.concat(h.call(arguments))) }, i.guid = e.guid = e.guid || b.guid++ , i) : t }, access: function (e, n, r, i, o, a, s) { var u = 0, l = e.length, c = null == r; if ("object" === b.type(r)) { o = !0; for (u in r) b.access(e, n, u, r[u], !0, a, s) } else if (i !== t && (o = !0, b.isFunction(i) || (s = !0), c && (s ? (n.call(e, i), n = null) : (c = n, n = function (e, t, n) { return c.call(b(e), n) })), n)) for (; l > u; u++)n(e[u], r, s ? i : i.call(e[u], u, n(e[u], r))); return o ? e : c ? n.call(e) : l ? n(e[0], r) : a }, now: function () { return (new Date).getTime() } }), b.ready.promise = function (t) { if (!n) if (n = b.Deferred(), "complete" === o.readyState) setTimeout(b.ready); else if (o.addEventListener) o.addEventListener("DOMContentLoaded", H, !1), e.addEventListener("load", H, !1); else { o.attachEvent("onreadystatechange", H), e.attachEvent("onload", H); var r = !1; try { r = null == e.frameElement && o.documentElement } catch (i) { } r && r.doScroll && function a() { if (!b.isReady) { try { r.doScroll("left") } catch (e) { return setTimeout(a, 50) } q(), b.ready() } }() } return n.promise(t) }, b.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function (e, t) { l["[object " + t + "]"] = t.toLowerCase() }); function M(e) { var t = e.length, n = b.type(e); return b.isWindow(e) ? !1 : 1 === e.nodeType && t ? !0 : "array" === n || "function" !== n && (0 === t || "number" == typeof t && t > 0 && t - 1 in e) } r = b(o); var _ = {}; function F(e) { var t = _[e] = {}; return b.each(e.match(w) || [], function (e, n) { t[n] = !0 }), t } b.Callbacks = function (e) { e = "string" == typeof e ? _[e] || F(e) : b.extend({}, e); var n, r, i, o, a, s, u = [], l = !e.once && [], c = function (t) { for (r = e.memory && t, i = !0, a = s || 0, s = 0, o = u.length, n = !0; u && o > a; a++)if (u[a].apply(t[0], t[1]) === !1 && e.stopOnFalse) { r = !1; break } n = !1, u && (l ? l.length && c(l.shift()) : r ? u = [] : p.disable()) }, p = { add: function () { if (u) { var t = u.length; (function i(t) { b.each(t, function (t, n) { var r = b.type(n); "function" === r ? e.unique && p.has(n) || u.push(n) : n && n.length && "string" !== r && i(n) }) })(arguments), n ? o = u.length : r && (s = t, c(r)) } return this }, remove: function () { return u && b.each(arguments, function (e, t) { var r; while ((r = b.inArray(t, u, r)) > -1) u.splice(r, 1), n && (o >= r && o-- , a >= r && a--) }), this }, has: function (e) { return e ? b.inArray(e, u) > -1 : !(!u || !u.length) }, empty: function () { return u = [], this }, disable: function () { return u = l = r = t, this }, disabled: function () { return !u }, lock: function () { return l = t, r || p.disable(), this }, locked: function () { return !l }, fireWith: function (e, t) { return t = t || [], t = [e, t.slice ? t.slice() : t], !u || i && !l || (n ? l.push(t) : c(t)), this }, fire: function () { return p.fireWith(this, arguments), this }, fired: function () { return !!i } }; return p }, b.extend({ Deferred: function (e) { var t = [["resolve", "done", b.Callbacks("once memory"), "resolved"], ["reject", "fail", b.Callbacks("once memory"), "rejected"], ["notify", "progress", b.Callbacks("memory")]], n = "pending", r = { state: function () { return n }, always: function () { return i.done(arguments).fail(arguments), this }, then: function () { var e = arguments; return b.Deferred(function (n) { b.each(t, function (t, o) { var a = o[0], s = b.isFunction(e[t]) && e[t]; i[o[1]](function () { var e = s && s.apply(this, arguments); e && b.isFunction(e.promise) ? e.promise().done(n.resolve).fail(n.reject).progress(n.notify) : n[a + "With"](this === r ? n.promise() : this, s ? [e] : arguments) }) }), e = null }).promise() }, promise: function (e) { return null != e ? b.extend(e, r) : r } }, i = {}; return r.pipe = r.then, b.each(t, function (e, o) { var a = o[2], s = o[3]; r[o[1]] = a.add, s && a.add(function () { n = s }, t[1 ^ e][2].disable, t[2][2].lock), i[o[0]] = function () { return i[o[0] + "With"](this === i ? r : this, arguments), this }, i[o[0] + "With"] = a.fireWith }), r.promise(i), e && e.call(i, i), i }, when: function (e) { var t = 0, n = h.call(arguments), r = n.length, i = 1 !== r || e && b.isFunction(e.promise) ? r : 0, o = 1 === i ? e : b.Deferred(), a = function (e, t, n) { return function (r) { t[e] = this, n[e] = arguments.length > 1 ? h.call(arguments) : r, n === s ? o.notifyWith(t, n) : --i || o.resolveWith(t, n) } }, s, u, l; if (r > 1) for (s = Array(r), u = Array(r), l = Array(r); r > t; t++)n[t] && b.isFunction(n[t].promise) ? n[t].promise().done(a(t, l, n)).fail(o.reject).progress(a(t, u, s)) : --i; return i || o.resolveWith(l, n), o.promise() } }), b.support = function () { var t, n, r, a, s, u, l, c, p, f, d = o.createElement("div"); if (d.setAttribute("className", "t"), d.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>", n = d.getElementsByTagName("*"), r = d.getElementsByTagName("a")[0], !n || !r || !n.length) return {}; s = o.createElement("select"), l = s.appendChild(o.createElement("option")), a = d.getElementsByTagName("input")[0], r.style.cssText = "top:1px;float:left;opacity:.5", t = { getSetAttribute: "t" !== d.className, leadingWhitespace: 3 === d.firstChild.nodeType, tbody: !d.getElementsByTagName("tbody").length, htmlSerialize: !!d.getElementsByTagName("link").length, style: /top/.test(r.getAttribute("style")), hrefNormalized: "/a" === r.getAttribute("href"), opacity: /^0.5/.test(r.style.opacity), cssFloat: !!r.style.cssFloat, checkOn: !!a.value, optSelected: l.selected, enctype: !!o.createElement("form").enctype, html5Clone: "<:nav></:nav>" !== o.createElement("nav").cloneNode(!0).outerHTML, boxModel: "CSS1Compat" === o.compatMode, deleteExpando: !0, noCloneEvent: !0, inlineBlockNeedsLayout: !1, shrinkWrapBlocks: !1, reliableMarginRight: !0, boxSizingReliable: !0, pixelPosition: !1 }, a.checked = !0, t.noCloneChecked = a.cloneNode(!0).checked, s.disabled = !0, t.optDisabled = !l.disabled; try { delete d.test } catch (h) { t.deleteExpando = !1 } a = o.createElement("input"), a.setAttribute("value", ""), t.input = "" === a.getAttribute("value"), a.value = "t", a.setAttribute("type", "radio"), t.radioValue = "t" === a.value, a.setAttribute("checked", "t"), a.setAttribute("name", "t"), u = o.createDocumentFragment(), u.appendChild(a), t.appendChecked = a.checked, t.checkClone = u.cloneNode(!0).cloneNode(!0).lastChild.checked, d.attachEvent && (d.attachEvent("onclick", function () { t.noCloneEvent = !1 }), d.cloneNode(!0).click()); for (f in { submit: !0, change: !0, focusin: !0 }) d.setAttribute(c = "on" + f, "t"), t[f + "Bubbles"] = c in e || d.attributes[c].expando === !1; return d.style.backgroundClip = "content-box", d.cloneNode(!0).style.backgroundClip = "", t.clearCloneStyle = "content-box" === d.style.backgroundClip, b(function () { var n, r, a, s = "padding:0;margin:0;border:0;display:block;box-sizing:content-box;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;", u = o.getElementsByTagName("body")[0]; u && (n = o.createElement("div"), n.style.cssText = "border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px", u.appendChild(n).appendChild(d), d.innerHTML = "<table><tr><td></td><td>t</td></tr></table>", a = d.getElementsByTagName("td"), a[0].style.cssText = "padding:0;margin:0;border:0;display:none", p = 0 === a[0].offsetHeight, a[0].style.display = "", a[1].style.display = "none", t.reliableHiddenOffsets = p && 0 === a[0].offsetHeight, d.innerHTML = "", d.style.cssText = "box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%;", t.boxSizing = 4 === d.offsetWidth, t.doesNotIncludeMarginInBodyOffset = 1 !== u.offsetTop, e.getComputedStyle && (t.pixelPosition = "1%" !== (e.getComputedStyle(d, null) || {}).top, t.boxSizingReliable = "4px" === (e.getComputedStyle(d, null) || { width: "4px" }).width, r = d.appendChild(o.createElement("div")), r.style.cssText = d.style.cssText = s, r.style.marginRight = r.style.width = "0", d.style.width = "1px", t.reliableMarginRight = !parseFloat((e.getComputedStyle(r, null) || {}).marginRight)), typeof d.style.zoom !== i && (d.innerHTML = "", d.style.cssText = s + "width:1px;padding:1px;display:inline;zoom:1", t.inlineBlockNeedsLayout = 3 === d.offsetWidth, d.style.display = "block", d.innerHTML = "<div></div>", d.firstChild.style.width = "5px", t.shrinkWrapBlocks = 3 !== d.offsetWidth, t.inlineBlockNeedsLayout && (u.style.zoom = 1)), u.removeChild(n), n = d = a = r = null) }), n = s = u = l = r = a = null, t }(); var O = /(?:\{[\s\S]*\}|\[[\s\S]*\])$/, B = /([A-Z])/g; function P(e, n, r, i) { if (b.acceptData(e)) { var o, a, s = b.expando, u = "string" == typeof n, l = e.nodeType, p = l ? b.cache : e, f = l ? e[s] : e[s] && s; if (f && p[f] && (i || p[f].data) || !u || r !== t) return f || (l ? e[s] = f = c.pop() || b.guid++ : f = s), p[f] || (p[f] = {}, l || (p[f].toJSON = b.noop)), ("object" == typeof n || "function" == typeof n) && (i ? p[f] = b.extend(p[f], n) : p[f].data = b.extend(p[f].data, n)), o = p[f], i || (o.data || (o.data = {}), o = o.data), r !== t && (o[b.camelCase(n)] = r), u ? (a = o[n], null == a && (a = o[b.camelCase(n)])) : a = o, a } } function R(e, t, n) { if (b.acceptData(e)) { var r, i, o, a = e.nodeType, s = a ? b.cache : e, u = a ? e[b.expando] : b.expando; if (s[u]) { if (t && (o = n ? s[u] : s[u].data)) { b.isArray(t) ? t = t.concat(b.map(t, b.camelCase)) : t in o ? t = [t] : (t = b.camelCase(t), t = t in o ? [t] : t.split(" ")); for (r = 0, i = t.length; i > r; r++)delete o[t[r]]; if (!(n ? $ : b.isEmptyObject)(o)) return } (n || (delete s[u].data, $(s[u]))) && (a ? b.cleanData([e], !0) : b.support.deleteExpando || s != s.window ? delete s[u] : s[u] = null) } } } b.extend({ cache: {}, expando: "jQuery" + (p + Math.random()).replace(/\D/g, ""), noData: { embed: !0, object: "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000", applet: !0 }, hasData: function (e) { return e = e.nodeType ? b.cache[e[b.expando]] : e[b.expando], !!e && !$(e) }, data: function (e, t, n) { return P(e, t, n) }, removeData: function (e, t) { return R(e, t) }, _data: function (e, t, n) { return P(e, t, n, !0) }, _removeData: function (e, t) { return R(e, t, !0) }, acceptData: function (e) { if (e.nodeType && 1 !== e.nodeType && 9 !== e.nodeType) return !1; var t = e.nodeName && b.noData[e.nodeName.toLowerCase()]; return !t || t !== !0 && e.getAttribute("classid") === t } }), b.fn.extend({ data: function (e, n) { var r, i, o = this[0], a = 0, s = null; if (e === t) { if (this.length && (s = b.data(o), 1 === o.nodeType && !b._data(o, "parsedAttrs"))) { for (r = o.attributes; r.length > a; a++)i = r[a].name, i.indexOf("data-") || (i = b.camelCase(i.slice(5)), W(o, i, s[i])); b._data(o, "parsedAttrs", !0) } return s } return "object" == typeof e ? this.each(function () { b.data(this, e) }) : b.access(this, function (n) { return n === t ? o ? W(o, e, b.data(o, e)) : null : (this.each(function () { b.data(this, e, n) }), t) }, null, n, arguments.length > 1, null, !0) }, removeData: function (e) { return this.each(function () { b.removeData(this, e) }) } }); function W(e, n, r) { if (r === t && 1 === e.nodeType) { var i = "data-" + n.replace(B, "-$1").toLowerCase(); if (r = e.getAttribute(i), "string" == typeof r) { try { r = "true" === r ? !0 : "false" === r ? !1 : "null" === r ? null : +r + "" === r ? +r : O.test(r) ? b.parseJSON(r) : r } catch (o) { } b.data(e, n, r) } else r = t } return r } function $(e) { var t; for (t in e) if (("data" !== t || !b.isEmptyObject(e[t])) && "toJSON" !== t) return !1; return !0 } b.extend({ queue: function (e, n, r) { var i; return e ? (n = (n || "fx") + "queue", i = b._data(e, n), r && (!i || b.isArray(r) ? i = b._data(e, n, b.makeArray(r)) : i.push(r)), i || []) : t }, dequeue: function (e, t) { t = t || "fx"; var n = b.queue(e, t), r = n.length, i = n.shift(), o = b._queueHooks(e, t), a = function () { b.dequeue(e, t) }; "inprogress" === i && (i = n.shift(), r--), o.cur = i, i && ("fx" === t && n.unshift("inprogress"), delete o.stop, i.call(e, a, o)), !r && o && o.empty.fire() }, _queueHooks: function (e, t) { var n = t + "queueHooks"; return b._data(e, n) || b._data(e, n, { empty: b.Callbacks("once memory").add(function () { b._removeData(e, t + "queue"), b._removeData(e, n) }) }) } }), b.fn.extend({ queue: function (e, n) { var r = 2; return "string" != typeof e && (n = e, e = "fx", r--), r > arguments.length ? b.queue(this[0], e) : n === t ? this : this.each(function () { var t = b.queue(this, e, n); b._queueHooks(this, e), "fx" === e && "inprogress" !== t[0] && b.dequeue(this, e) }) }, dequeue: function (e) { return this.each(function () { b.dequeue(this, e) }) }, delay: function (e, t) { return e = b.fx ? b.fx.speeds[e] || e : e, t = t || "fx", this.queue(t, function (t, n) { var r = setTimeout(t, e); n.stop = function () { clearTimeout(r) } }) }, clearQueue: function (e) { return this.queue(e || "fx", []) }, promise: function (e, n) { var r, i = 1, o = b.Deferred(), a = this, s = this.length, u = function () { --i || o.resolveWith(a, [a]) }; "string" != typeof e && (n = e, e = t), e = e || "fx"; while (s--) r = b._data(a[s], e + "queueHooks"), r && r.empty && (i++ , r.empty.add(u)); return u(), o.promise(n) } }); var I, z, X = /[\t\r\n]/g, U = /\r/g, V = /^(?:input|select|textarea|button|object)$/i, Y = /^(?:a|area)$/i, J = /^(?:checked|selected|autofocus|autoplay|async|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped)$/i, G = /^(?:checked|selected)$/i, Q = b.support.getSetAttribute, K = b.support.input; b.fn.extend({ attr: function (e, t) { return b.access(this, b.attr, e, t, arguments.length > 1) }, removeAttr: function (e) { return this.each(function () { b.removeAttr(this, e) }) }, prop: function (e, t) { return b.access(this, b.prop, e, t, arguments.length > 1) }, removeProp: function (e) { return e = b.propFix[e] || e, this.each(function () { try { this[e] = t, delete this[e] } catch (n) { } }) }, addClass: function (e) { var t, n, r, i, o, a = 0, s = this.length, u = "string" == typeof e && e; if (b.isFunction(e)) return this.each(function (t) { b(this).addClass(e.call(this, t, this.className)) }); if (u) for (t = (e || "").match(w) || []; s > a; a++)if (n = this[a], r = 1 === n.nodeType && (n.className ? (" " + n.className + " ").replace(X, " ") : " ")) { o = 0; while (i = t[o++]) 0 > r.indexOf(" " + i + " ") && (r += i + " "); n.className = b.trim(r) } return this }, removeClass: function (e) { var t, n, r, i, o, a = 0, s = this.length, u = 0 === arguments.length || "string" == typeof e && e; if (b.isFunction(e)) return this.each(function (t) { b(this).removeClass(e.call(this, t, this.className)) }); if (u) for (t = (e || "").match(w) || []; s > a; a++)if (n = this[a], r = 1 === n.nodeType && (n.className ? (" " + n.className + " ").replace(X, " ") : "")) { o = 0; while (i = t[o++]) while (r.indexOf(" " + i + " ") >= 0) r = r.replace(" " + i + " ", " "); n.className = e ? b.trim(r) : "" } return this }, toggleClass: function (e, t) { var n = typeof e, r = "boolean" == typeof t; return b.isFunction(e) ? this.each(function (n) { b(this).toggleClass(e.call(this, n, this.className, t), t) }) : this.each(function () { if ("string" === n) { var o, a = 0, s = b(this), u = t, l = e.match(w) || []; while (o = l[a++]) u = r ? u : !s.hasClass(o), s[u ? "addClass" : "removeClass"](o) } else (n === i || "boolean" === n) && (this.className && b._data(this, "__className__", this.className), this.className = this.className || e === !1 ? "" : b._data(this, "__className__") || "") }) }, hasClass: function (e) { var t = " " + e + " ", n = 0, r = this.length; for (; r > n; n++)if (1 === this[n].nodeType && (" " + this[n].className + " ").replace(X, " ").indexOf(t) >= 0) return !0; return !1 }, val: function (e) { var n, r, i, o = this[0]; { if (arguments.length) return i = b.isFunction(e), this.each(function (n) { var o, a = b(this); 1 === this.nodeType && (o = i ? e.call(this, n, a.val()) : e, null == o ? o = "" : "number" == typeof o ? o += "" : b.isArray(o) && (o = b.map(o, function (e) { return null == e ? "" : e + "" })), r = b.valHooks[this.type] || b.valHooks[this.nodeName.toLowerCase()], r && "set" in r && r.set(this, o, "value") !== t || (this.value = o)) }); if (o) return r = b.valHooks[o.type] || b.valHooks[o.nodeName.toLowerCase()], r && "get" in r && (n = r.get(o, "value")) !== t ? n : (n = o.value, "string" == typeof n ? n.replace(U, "") : null == n ? "" : n) } } }), b.extend({ valHooks: { option: { get: function (e) { var t = e.attributes.value; return !t || t.specified ? e.value : e.text } }, select: { get: function (e) { var t, n, r = e.options, i = e.selectedIndex, o = "select-one" === e.type || 0 > i, a = o ? null : [], s = o ? i + 1 : r.length, u = 0 > i ? s : o ? i : 0; for (; s > u; u++)if (n = r[u], !(!n.selected && u !== i || (b.support.optDisabled ? n.disabled : null !== n.getAttribute("disabled")) || n.parentNode.disabled && b.nodeName(n.parentNode, "optgroup"))) { if (t = b(n).val(), o) return t; a.push(t) } return a }, set: function (e, t) { var n = b.makeArray(t); return b(e).find("option").each(function () { this.selected = b.inArray(b(this).val(), n) >= 0 }), n.length || (e.selectedIndex = -1), n } } }, attr: function (e, n, r) { var o, a, s, u = e.nodeType; if (e && 3 !== u && 8 !== u && 2 !== u) return typeof e.getAttribute === i ? b.prop(e, n, r) : (a = 1 !== u || !b.isXMLDoc(e), a && (n = n.toLowerCase(), o = b.attrHooks[n] || (J.test(n) ? z : I)), r === t ? o && a && "get" in o && null !== (s = o.get(e, n)) ? s : (typeof e.getAttribute !== i && (s = e.getAttribute(n)), null == s ? t : s) : null !== r ? o && a && "set" in o && (s = o.set(e, r, n)) !== t ? s : (e.setAttribute(n, r + ""), r) : (b.removeAttr(e, n), t)) }, removeAttr: function (e, t) { var n, r, i = 0, o = t && t.match(w); if (o && 1 === e.nodeType) while (n = o[i++]) r = b.propFix[n] || n, J.test(n) ? !Q && G.test(n) ? e[b.camelCase("default-" + n)] = e[r] = !1 : e[r] = !1 : b.attr(e, n, ""), e.removeAttribute(Q ? n : r) }, attrHooks: { type: { set: function (e, t) { if (!b.support.radioValue && "radio" === t && b.nodeName(e, "input")) { var n = e.value; return e.setAttribute("type", t), n && (e.value = n), t } } } }, propFix: { tabindex: "tabIndex", readonly: "readOnly", "for": "htmlFor", "class": "className", maxlength: "maxLength", cellspacing: "cellSpacing", cellpadding: "cellPadding", rowspan: "rowSpan", colspan: "colSpan", usemap: "useMap", frameborder: "frameBorder", contenteditable: "contentEditable" }, prop: function (e, n, r) { var i, o, a, s = e.nodeType; if (e && 3 !== s && 8 !== s && 2 !== s) return a = 1 !== s || !b.isXMLDoc(e), a && (n = b.propFix[n] || n, o = b.propHooks[n]), r !== t ? o && "set" in o && (i = o.set(e, r, n)) !== t ? i : e[n] = r : o && "get" in o && null !== (i = o.get(e, n)) ? i : e[n] }, propHooks: { tabIndex: { get: function (e) { var n = e.getAttributeNode("tabindex"); return n && n.specified ? parseInt(n.value, 10) : V.test(e.nodeName) || Y.test(e.nodeName) && e.href ? 0 : t } } } }), z = { get: function (e, n) { var r = b.prop(e, n), i = "boolean" == typeof r && e.getAttribute(n), o = "boolean" == typeof r ? K && Q ? null != i : G.test(n) ? e[b.camelCase("default-" + n)] : !!i : e.getAttributeNode(n); return o && o.value !== !1 ? n.toLowerCase() : t }, set: function (e, t, n) { return t === !1 ? b.removeAttr(e, n) : K && Q || !G.test(n) ? e.setAttribute(!Q && b.propFix[n] || n, n) : e[b.camelCase("default-" + n)] = e[n] = !0, n } }, K && Q || (b.attrHooks.value = { get: function (e, n) { var r = e.getAttributeNode(n); return b.nodeName(e, "input") ? e.defaultValue : r && r.specified ? r.value : t }, set: function (e, n, r) { return b.nodeName(e, "input") ? (e.defaultValue = n, t) : I && I.set(e, n, r) } }), Q || (I = b.valHooks.button = { get: function (e, n) { var r = e.getAttributeNode(n); return r && ("id" === n || "name" === n || "coords" === n ? "" !== r.value : r.specified) ? r.value : t }, set: function (e, n, r) { var i = e.getAttributeNode(r); return i || e.setAttributeNode(i = e.ownerDocument.createAttribute(r)), i.value = n += "", "value" === r || n === e.getAttribute(r) ? n : t } }, b.attrHooks.contenteditable = { get: I.get, set: function (e, t, n) { I.set(e, "" === t ? !1 : t, n) } }, b.each(["width", "height"], function (e, n) { b.attrHooks[n] = b.extend(b.attrHooks[n], { set: function (e, r) { return "" === r ? (e.setAttribute(n, "auto"), r) : t } }) })), b.support.hrefNormalized || (b.each(["href", "src", "width", "height"], function (e, n) { b.attrHooks[n] = b.extend(b.attrHooks[n], { get: function (e) { var r = e.getAttribute(n, 2); return null == r ? t : r } }) }), b.each(["href", "src"], function (e, t) { b.propHooks[t] = { get: function (e) { return e.getAttribute(t, 4) } } })), b.support.style || (b.attrHooks.style = { get: function (e) { return e.style.cssText || t }, set: function (e, t) { return e.style.cssText = t + "" } }), b.support.optSelected || (b.propHooks.selected = b.extend(b.propHooks.selected, { get: function (e) { var t = e.parentNode; return t && (t.selectedIndex, t.parentNode && t.parentNode.selectedIndex), null } })), b.support.enctype || (b.propFix.enctype = "encoding"), b.support.checkOn || b.each(["radio", "checkbox"], function () { b.valHooks[this] = { get: function (e) { return null === e.getAttribute("value") ? "on" : e.value } } }), b.each(["radio", "checkbox"], function () { b.valHooks[this] = b.extend(b.valHooks[this], { set: function (e, n) { return b.isArray(n) ? e.checked = b.inArray(b(e).val(), n) >= 0 : t } }) }); var Z = /^(?:input|select|textarea)$/i, et = /^key/, tt = /^(?:mouse|contextmenu)|click/, nt = /^(?:focusinfocus|focusoutblur)$/, rt = /^([^.]*)(?:\.(.+)|)$/; function it() { return !0 } function ot() { return !1 } b.event = { global: {}, add: function (e, n, r, o, a) { var s, u, l, c, p, f, d, h, g, m, y, v = b._data(e); if (v) { r.handler && (c = r, r = c.handler, a = c.selector), r.guid || (r.guid = b.guid++), (u = v.events) || (u = v.events = {}), (f = v.handle) || (f = v.handle = function (e) { return typeof b === i || e && b.event.triggered === e.type ? t : b.event.dispatch.apply(f.elem, arguments) }, f.elem = e), n = (n || "").match(w) || [""], l = n.length; while (l--) s = rt.exec(n[l]) || [], g = y = s[1], m = (s[2] || "").split(".").sort(), p = b.event.special[g] || {}, g = (a ? p.delegateType : p.bindType) || g, p = b.event.special[g] || {}, d = b.extend({ type: g, origType: y, data: o, handler: r, guid: r.guid, selector: a, needsContext: a && b.expr.match.needsContext.test(a), namespace: m.join(".") }, c), (h = u[g]) || (h = u[g] = [], h.delegateCount = 0, p.setup && p.setup.call(e, o, m, f) !== !1 || (e.addEventListener ? e.addEventListener(g, f, !1) : e.attachEvent && e.attachEvent("on" + g, f))), p.add && (p.add.call(e, d), d.handler.guid || (d.handler.guid = r.guid)), a ? h.splice(h.delegateCount++, 0, d) : h.push(d), b.event.global[g] = !0; e = null } }, remove: function (e, t, n, r, i) { var o, a, s, u, l, c, p, f, d, h, g, m = b.hasData(e) && b._data(e); if (m && (c = m.events)) { t = (t || "").match(w) || [""], l = t.length; while (l--) if (s = rt.exec(t[l]) || [], d = g = s[1], h = (s[2] || "").split(".").sort(), d) { p = b.event.special[d] || {}, d = (r ? p.delegateType : p.bindType) || d, f = c[d] || [], s = s[2] && RegExp("(^|\\.)" + h.join("\\.(?:.*\\.|)") + "(\\.|$)"), u = o = f.length; while (o--) a = f[o], !i && g !== a.origType || n && n.guid !== a.guid || s && !s.test(a.namespace) || r && r !== a.selector && ("**" !== r || !a.selector) || (f.splice(o, 1), a.selector && f.delegateCount-- , p.remove && p.remove.call(e, a)); u && !f.length && (p.teardown && p.teardown.call(e, h, m.handle) !== !1 || b.removeEvent(e, d, m.handle), delete c[d]) } else for (d in c) b.event.remove(e, d + t[l], n, r, !0); b.isEmptyObject(c) && (delete m.handle, b._removeData(e, "events")) } }, trigger: function (n, r, i, a) { var s, u, l, c, p, f, d, h = [i || o], g = y.call(n, "type") ? n.type : n, m = y.call(n, "namespace") ? n.namespace.split(".") : []; if (l = f = i = i || o, 3 !== i.nodeType && 8 !== i.nodeType && !nt.test(g + b.event.triggered) && (g.indexOf(".") >= 0 && (m = g.split("."), g = m.shift(), m.sort()), u = 0 > g.indexOf(":") && "on" + g, n = n[b.expando] ? n : new b.Event(g, "object" == typeof n && n), n.isTrigger = !0, n.namespace = m.join("."), n.namespace_re = n.namespace ? RegExp("(^|\\.)" + m.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, n.result = t, n.target || (n.target = i), r = null == r ? [n] : b.makeArray(r, [n]), p = b.event.special[g] || {}, a || !p.trigger || p.trigger.apply(i, r) !== !1)) { if (!a && !p.noBubble && !b.isWindow(i)) { for (c = p.delegateType || g, nt.test(c + g) || (l = l.parentNode); l; l = l.parentNode)h.push(l), f = l; f === (i.ownerDocument || o) && h.push(f.defaultView || f.parentWindow || e) } d = 0; while ((l = h[d++]) && !n.isPropagationStopped()) n.type = d > 1 ? c : p.bindType || g, s = (b._data(l, "events") || {})[n.type] && b._data(l, "handle"), s && s.apply(l, r), s = u && l[u], s && b.acceptData(l) && s.apply && s.apply(l, r) === !1 && n.preventDefault(); if (n.type = g, !(a || n.isDefaultPrevented() || p._default && p._default.apply(i.ownerDocument, r) !== !1 || "click" === g && b.nodeName(i, "a") || !b.acceptData(i) || !u || !i[g] || b.isWindow(i))) { f = i[u], f && (i[u] = null), b.event.triggered = g; try { i[g]() } catch (v) { } b.event.triggered = t, f && (i[u] = f) } return n.result } }, dispatch: function (e) { e = b.event.fix(e); var n, r, i, o, a, s = [], u = h.call(arguments), l = (b._data(this, "events") || {})[e.type] || [], c = b.event.special[e.type] || {}; if (u[0] = e, e.delegateTarget = this, !c.preDispatch || c.preDispatch.call(this, e) !== !1) { s = b.event.handlers.call(this, e, l), n = 0; while ((o = s[n++]) && !e.isPropagationStopped()) { e.currentTarget = o.elem, a = 0; while ((i = o.handlers[a++]) && !e.isImmediatePropagationStopped()) (!e.namespace_re || e.namespace_re.test(i.namespace)) && (e.handleObj = i, e.data = i.data, r = ((b.event.special[i.origType] || {}).handle || i.handler).apply(o.elem, u), r !== t && (e.result = r) === !1 && (e.preventDefault(), e.stopPropagation())) } return c.postDispatch && c.postDispatch.call(this, e), e.result } }, handlers: function (e, n) { var r, i, o, a, s = [], u = n.delegateCount, l = e.target; if (u && l.nodeType && (!e.button || "click" !== e.type)) for (; l != this; l = l.parentNode || this)if (1 === l.nodeType && (l.disabled !== !0 || "click" !== e.type)) { for (o = [], a = 0; u > a; a++)i = n[a], r = i.selector + " ", o[r] === t && (o[r] = i.needsContext ? b(r, this).index(l) >= 0 : b.find(r, this, null, [l]).length), o[r] && o.push(i); o.length && s.push({ elem: l, handlers: o }) } return n.length > u && s.push({ elem: this, handlers: n.slice(u) }), s }, fix: function (e) { if (e[b.expando]) return e; var t, n, r, i = e.type, a = e, s = this.fixHooks[i]; s || (this.fixHooks[i] = s = tt.test(i) ? this.mouseHooks : et.test(i) ? this.keyHooks : {}), r = s.props ? this.props.concat(s.props) : this.props, e = new b.Event(a), t = r.length; while (t--) n = r[t], e[n] = a[n]; return e.target || (e.target = a.srcElement || o), 3 === e.target.nodeType && (e.target = e.target.parentNode), e.metaKey = !!e.metaKey, s.filter ? s.filter(e, a) : e }, props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "), fixHooks: {}, keyHooks: { props: "char charCode key keyCode".split(" "), filter: function (e, t) { return null == e.which && (e.which = null != t.charCode ? t.charCode : t.keyCode), e } }, mouseHooks: { props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "), filter: function (e, n) { var r, i, a, s = n.button, u = n.fromElement; return null == e.pageX && null != n.clientX && (i = e.target.ownerDocument || o, a = i.documentElement, r = i.body, e.pageX = n.clientX + (a && a.scrollLeft || r && r.scrollLeft || 0) - (a && a.clientLeft || r && r.clientLeft || 0), e.pageY = n.clientY + (a && a.scrollTop || r && r.scrollTop || 0) - (a && a.clientTop || r && r.clientTop || 0)), !e.relatedTarget && u && (e.relatedTarget = u === e.target ? n.toElement : u), e.which || s === t || (e.which = 1 & s ? 1 : 2 & s ? 3 : 4 & s ? 2 : 0), e } }, special: { load: { noBubble: !0 }, click: { trigger: function () { return b.nodeName(this, "input") && "checkbox" === this.type && this.click ? (this.click(), !1) : t } }, focus: { trigger: function () { if (this !== o.activeElement && this.focus) try { return this.focus(), !1 } catch (e) { } }, delegateType: "focusin" }, blur: { trigger: function () { return this === o.activeElement && this.blur ? (this.blur(), !1) : t }, delegateType: "focusout" }, beforeunload: { postDispatch: function (e) { e.result !== t && (e.originalEvent.returnValue = e.result) } } }, simulate: function (e, t, n, r) { var i = b.extend(new b.Event, n, { type: e, isSimulated: !0, originalEvent: {} }); r ? b.event.trigger(i, null, t) : b.event.dispatch.call(t, i), i.isDefaultPrevented() && n.preventDefault() } }, b.removeEvent = o.removeEventListener ? function (e, t, n) { e.removeEventListener && e.removeEventListener(t, n, !1) } : function (e, t, n) { var r = "on" + t; e.detachEvent && (typeof e[r] === i && (e[r] = null), e.detachEvent(r, n)) }, b.Event = function (e, n) { return this instanceof b.Event ? (e && e.type ? (this.originalEvent = e, this.type = e.type, this.isDefaultPrevented = e.defaultPrevented || e.returnValue === !1 || e.getPreventDefault && e.getPreventDefault() ? it : ot) : this.type = e, n && b.extend(this, n), this.timeStamp = e && e.timeStamp || b.now(), this[b.expando] = !0, t) : new b.Event(e, n) }, b.Event.prototype = { isDefaultPrevented: ot, isPropagationStopped: ot, isImmediatePropagationStopped: ot, preventDefault: function () { var e = this.originalEvent; this.isDefaultPrevented = it, e && (e.preventDefault ? e.preventDefault() : e.returnValue = !1) }, stopPropagation: function () { var e = this.originalEvent; this.isPropagationStopped = it, e && (e.stopPropagation && e.stopPropagation(), e.cancelBubble = !0) }, stopImmediatePropagation: function () { this.isImmediatePropagationStopped = it, this.stopPropagation() } }, b.each({ mouseenter: "mouseover", mouseleave: "mouseout" }, function (e, t) {
        b.event.special[e] = {
            delegateType: t, bindType: t, handle: function (e) {
                var n, r = this, i = e.relatedTarget, o = e.handleObj;
                return (!i || i !== r && !b.contains(r, i)) && (e.type = o.origType, n = o.handler.apply(this, arguments), e.type = t), n
            }
        }
    }), b.support.submitBubbles || (b.event.special.submit = { setup: function () { return b.nodeName(this, "form") ? !1 : (b.event.add(this, "click._submit keypress._submit", function (e) { var n = e.target, r = b.nodeName(n, "input") || b.nodeName(n, "button") ? n.form : t; r && !b._data(r, "submitBubbles") && (b.event.add(r, "submit._submit", function (e) { e._submit_bubble = !0 }), b._data(r, "submitBubbles", !0)) }), t) }, postDispatch: function (e) { e._submit_bubble && (delete e._submit_bubble, this.parentNode && !e.isTrigger && b.event.simulate("submit", this.parentNode, e, !0)) }, teardown: function () { return b.nodeName(this, "form") ? !1 : (b.event.remove(this, "._submit"), t) } }), b.support.changeBubbles || (b.event.special.change = { setup: function () { return Z.test(this.nodeName) ? (("checkbox" === this.type || "radio" === this.type) && (b.event.add(this, "propertychange._change", function (e) { "checked" === e.originalEvent.propertyName && (this._just_changed = !0) }), b.event.add(this, "click._change", function (e) { this._just_changed && !e.isTrigger && (this._just_changed = !1), b.event.simulate("change", this, e, !0) })), !1) : (b.event.add(this, "beforeactivate._change", function (e) { var t = e.target; Z.test(t.nodeName) && !b._data(t, "changeBubbles") && (b.event.add(t, "change._change", function (e) { !this.parentNode || e.isSimulated || e.isTrigger || b.event.simulate("change", this.parentNode, e, !0) }), b._data(t, "changeBubbles", !0)) }), t) }, handle: function (e) { var n = e.target; return this !== n || e.isSimulated || e.isTrigger || "radio" !== n.type && "checkbox" !== n.type ? e.handleObj.handler.apply(this, arguments) : t }, teardown: function () { return b.event.remove(this, "._change"), !Z.test(this.nodeName) } }), b.support.focusinBubbles || b.each({ focus: "focusin", blur: "focusout" }, function (e, t) { var n = 0, r = function (e) { b.event.simulate(t, e.target, b.event.fix(e), !0) }; b.event.special[t] = { setup: function () { 0 === n++ && o.addEventListener(e, r, !0) }, teardown: function () { 0 === --n && o.removeEventListener(e, r, !0) } } }), b.fn.extend({ on: function (e, n, r, i, o) { var a, s; if ("object" == typeof e) { "string" != typeof n && (r = r || n, n = t); for (a in e) this.on(a, n, r, e[a], o); return this } if (null == r && null == i ? (i = n, r = n = t) : null == i && ("string" == typeof n ? (i = r, r = t) : (i = r, r = n, n = t)), i === !1) i = ot; else if (!i) return this; return 1 === o && (s = i, i = function (e) { return b().off(e), s.apply(this, arguments) }, i.guid = s.guid || (s.guid = b.guid++)), this.each(function () { b.event.add(this, e, i, r, n) }) }, one: function (e, t, n, r) { return this.on(e, t, n, r, 1) }, off: function (e, n, r) { var i, o; if (e && e.preventDefault && e.handleObj) return i = e.handleObj, b(e.delegateTarget).off(i.namespace ? i.origType + "." + i.namespace : i.origType, i.selector, i.handler), this; if ("object" == typeof e) { for (o in e) this.off(o, n, e[o]); return this } return (n === !1 || "function" == typeof n) && (r = n, n = t), r === !1 && (r = ot), this.each(function () { b.event.remove(this, e, r, n) }) }, bind: function (e, t, n) { return this.on(e, null, t, n) }, unbind: function (e, t) { return this.off(e, null, t) }, delegate: function (e, t, n, r) { return this.on(t, e, n, r) }, undelegate: function (e, t, n) { return 1 === arguments.length ? this.off(e, "**") : this.off(t, e || "**", n) }, trigger: function (e, t) { return this.each(function () { b.event.trigger(e, t, this) }) }, triggerHandler: function (e, n) { var r = this[0]; return r ? b.event.trigger(e, n, r, !0) : t } }), function (e, t) { var n, r, i, o, a, s, u, l, c, p, f, d, h, g, m, y, v, x = "sizzle" + -new Date, w = e.document, T = {}, N = 0, C = 0, k = it(), E = it(), S = it(), A = typeof t, j = 1 << 31, D = [], L = D.pop, H = D.push, q = D.slice, M = D.indexOf || function (e) { var t = 0, n = this.length; for (; n > t; t++)if (this[t] === e) return t; return -1 }, _ = "[\\x20\\t\\r\\n\\f]", F = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+", O = F.replace("w", "w#"), B = "([*^$|!~]?=)", P = "\\[" + _ + "*(" + F + ")" + _ + "*(?:" + B + _ + "*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|(" + O + ")|)|)" + _ + "*\\]", R = ":(" + F + ")(?:\\(((['\"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|" + P.replace(3, 8) + ")*)|.*)\\)|)", W = RegExp("^" + _ + "+|((?:^|[^\\\\])(?:\\\\.)*)" + _ + "+$", "g"), $ = RegExp("^" + _ + "*," + _ + "*"), I = RegExp("^" + _ + "*([\\x20\\t\\r\\n\\f>+~])" + _ + "*"), z = RegExp(R), X = RegExp("^" + O + "$"), U = { ID: RegExp("^#(" + F + ")"), CLASS: RegExp("^\\.(" + F + ")"), NAME: RegExp("^\\[name=['\"]?(" + F + ")['\"]?\\]"), TAG: RegExp("^(" + F.replace("w", "w*") + ")"), ATTR: RegExp("^" + P), PSEUDO: RegExp("^" + R), CHILD: RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + _ + "*(even|odd|(([+-]|)(\\d*)n|)" + _ + "*(?:([+-]|)" + _ + "*(\\d+)|))" + _ + "*\\)|)", "i"), needsContext: RegExp("^" + _ + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + _ + "*((?:-\\d)?\\d*)" + _ + "*\\)|)(?=[^-]|$)", "i") }, V = /[\x20\t\r\n\f]*[+~]/, Y = /^[^{]+\{\s*\[native code/, J = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, G = /^(?:input|select|textarea|button)$/i, Q = /^h\d$/i, K = /'|\\/g, Z = /\=[\x20\t\r\n\f]*([^'"\]]*)[\x20\t\r\n\f]*\]/g, et = /\\([\da-fA-F]{1,6}[\x20\t\r\n\f]?|.)/g, tt = function (e, t) { var n = "0x" + t - 65536; return n !== n ? t : 0 > n ? String.fromCharCode(n + 65536) : String.fromCharCode(55296 | n >> 10, 56320 | 1023 & n) }; try { q.call(w.documentElement.childNodes, 0)[0].nodeType } catch (nt) { q = function (e) { var t, n = []; while (t = this[e++]) n.push(t); return n } } function rt(e) { return Y.test(e + "") } function it() { var e, t = []; return e = function (n, r) { return t.push(n += " ") > i.cacheLength && delete e[t.shift()], e[n] = r } } function ot(e) { return e[x] = !0, e } function at(e) { var t = p.createElement("div"); try { return e(t) } catch (n) { return !1 } finally { t = null } } function st(e, t, n, r) { var i, o, a, s, u, l, f, g, m, v; if ((t ? t.ownerDocument || t : w) !== p && c(t), t = t || p, n = n || [], !e || "string" != typeof e) return n; if (1 !== (s = t.nodeType) && 9 !== s) return []; if (!d && !r) { if (i = J.exec(e)) if (a = i[1]) { if (9 === s) { if (o = t.getElementById(a), !o || !o.parentNode) return n; if (o.id === a) return n.push(o), n } else if (t.ownerDocument && (o = t.ownerDocument.getElementById(a)) && y(t, o) && o.id === a) return n.push(o), n } else { if (i[2]) return H.apply(n, q.call(t.getElementsByTagName(e), 0)), n; if ((a = i[3]) && T.getByClassName && t.getElementsByClassName) return H.apply(n, q.call(t.getElementsByClassName(a), 0)), n } if (T.qsa && !h.test(e)) { if (f = !0, g = x, m = t, v = 9 === s && e, 1 === s && "object" !== t.nodeName.toLowerCase()) { l = ft(e), (f = t.getAttribute("id")) ? g = f.replace(K, "\\$&") : t.setAttribute("id", g), g = "[id='" + g + "'] ", u = l.length; while (u--) l[u] = g + dt(l[u]); m = V.test(e) && t.parentNode || t, v = l.join(",") } if (v) try { return H.apply(n, q.call(m.querySelectorAll(v), 0)), n } catch (b) { } finally { f || t.removeAttribute("id") } } } return wt(e.replace(W, "$1"), t, n, r) } a = st.isXML = function (e) { var t = e && (e.ownerDocument || e).documentElement; return t ? "HTML" !== t.nodeName : !1 }, c = st.setDocument = function (e) { var n = e ? e.ownerDocument || e : w; return n !== p && 9 === n.nodeType && n.documentElement ? (p = n, f = n.documentElement, d = a(n), T.tagNameNoComments = at(function (e) { return e.appendChild(n.createComment("")), !e.getElementsByTagName("*").length }), T.attributes = at(function (e) { e.innerHTML = "<select></select>"; var t = typeof e.lastChild.getAttribute("multiple"); return "boolean" !== t && "string" !== t }), T.getByClassName = at(function (e) { return e.innerHTML = "<div class='hidden e'></div><div class='hidden'></div>", e.getElementsByClassName && e.getElementsByClassName("e").length ? (e.lastChild.className = "e", 2 === e.getElementsByClassName("e").length) : !1 }), T.getByName = at(function (e) { e.id = x + 0, e.innerHTML = "<a name='" + x + "'></a><div name='" + x + "'></div>", f.insertBefore(e, f.firstChild); var t = n.getElementsByName && n.getElementsByName(x).length === 2 + n.getElementsByName(x + 0).length; return T.getIdNotName = !n.getElementById(x), f.removeChild(e), t }), i.attrHandle = at(function (e) { return e.innerHTML = "<a href='#'></a>", e.firstChild && typeof e.firstChild.getAttribute !== A && "#" === e.firstChild.getAttribute("href") }) ? {} : { href: function (e) { return e.getAttribute("href", 2) }, type: function (e) { return e.getAttribute("type") } }, T.getIdNotName ? (i.find.ID = function (e, t) { if (typeof t.getElementById !== A && !d) { var n = t.getElementById(e); return n && n.parentNode ? [n] : [] } }, i.filter.ID = function (e) { var t = e.replace(et, tt); return function (e) { return e.getAttribute("id") === t } }) : (i.find.ID = function (e, n) { if (typeof n.getElementById !== A && !d) { var r = n.getElementById(e); return r ? r.id === e || typeof r.getAttributeNode !== A && r.getAttributeNode("id").value === e ? [r] : t : [] } }, i.filter.ID = function (e) { var t = e.replace(et, tt); return function (e) { var n = typeof e.getAttributeNode !== A && e.getAttributeNode("id"); return n && n.value === t } }), i.find.TAG = T.tagNameNoComments ? function (e, n) { return typeof n.getElementsByTagName !== A ? n.getElementsByTagName(e) : t } : function (e, t) { var n, r = [], i = 0, o = t.getElementsByTagName(e); if ("*" === e) { while (n = o[i++]) 1 === n.nodeType && r.push(n); return r } return o }, i.find.NAME = T.getByName && function (e, n) { return typeof n.getElementsByName !== A ? n.getElementsByName(name) : t }, i.find.CLASS = T.getByClassName && function (e, n) { return typeof n.getElementsByClassName === A || d ? t : n.getElementsByClassName(e) }, g = [], h = [":focus"], (T.qsa = rt(n.querySelectorAll)) && (at(function (e) { e.innerHTML = "<select><option selected=''></option></select>", e.querySelectorAll("[selected]").length || h.push("\\[" + _ + "*(?:checked|disabled|ismap|multiple|readonly|selected|value)"), e.querySelectorAll(":checked").length || h.push(":checked") }), at(function (e) { e.innerHTML = "<input type='hidden' i=''/>", e.querySelectorAll("[i^='']").length && h.push("[*^$]=" + _ + "*(?:\"\"|'')"), e.querySelectorAll(":enabled").length || h.push(":enabled", ":disabled"), e.querySelectorAll("*,:x"), h.push(",.*:") })), (T.matchesSelector = rt(m = f.matchesSelector || f.mozMatchesSelector || f.webkitMatchesSelector || f.oMatchesSelector || f.msMatchesSelector)) && at(function (e) { T.disconnectedMatch = m.call(e, "div"), m.call(e, "[s!='']:x"), g.push("!=", R) }), h = RegExp(h.join("|")), g = RegExp(g.join("|")), y = rt(f.contains) || f.compareDocumentPosition ? function (e, t) { var n = 9 === e.nodeType ? e.documentElement : e, r = t && t.parentNode; return e === r || !(!r || 1 !== r.nodeType || !(n.contains ? n.contains(r) : e.compareDocumentPosition && 16 & e.compareDocumentPosition(r))) } : function (e, t) { if (t) while (t = t.parentNode) if (t === e) return !0; return !1 }, v = f.compareDocumentPosition ? function (e, t) { var r; return e === t ? (u = !0, 0) : (r = t.compareDocumentPosition && e.compareDocumentPosition && e.compareDocumentPosition(t)) ? 1 & r || e.parentNode && 11 === e.parentNode.nodeType ? e === n || y(w, e) ? -1 : t === n || y(w, t) ? 1 : 0 : 4 & r ? -1 : 1 : e.compareDocumentPosition ? -1 : 1 } : function (e, t) { var r, i = 0, o = e.parentNode, a = t.parentNode, s = [e], l = [t]; if (e === t) return u = !0, 0; if (!o || !a) return e === n ? -1 : t === n ? 1 : o ? -1 : a ? 1 : 0; if (o === a) return ut(e, t); r = e; while (r = r.parentNode) s.unshift(r); r = t; while (r = r.parentNode) l.unshift(r); while (s[i] === l[i]) i++; return i ? ut(s[i], l[i]) : s[i] === w ? -1 : l[i] === w ? 1 : 0 }, u = !1, [0, 0].sort(v), T.detectDuplicates = u, p) : p }, st.matches = function (e, t) { return st(e, null, null, t) }, st.matchesSelector = function (e, t) { if ((e.ownerDocument || e) !== p && c(e), t = t.replace(Z, "='$1']"), !(!T.matchesSelector || d || g && g.test(t) || h.test(t))) try { var n = m.call(e, t); if (n || T.disconnectedMatch || e.document && 11 !== e.document.nodeType) return n } catch (r) { } return st(t, p, null, [e]).length > 0 }, st.contains = function (e, t) { return (e.ownerDocument || e) !== p && c(e), y(e, t) }, st.attr = function (e, t) { var n; return (e.ownerDocument || e) !== p && c(e), d || (t = t.toLowerCase()), (n = i.attrHandle[t]) ? n(e) : d || T.attributes ? e.getAttribute(t) : ((n = e.getAttributeNode(t)) || e.getAttribute(t)) && e[t] === !0 ? t : n && n.specified ? n.value : null }, st.error = function (e) { throw Error("Syntax error, unrecognized expression: " + e) }, st.uniqueSort = function (e) { var t, n = [], r = 1, i = 0; if (u = !T.detectDuplicates, e.sort(v), u) { for (; t = e[r]; r++)t === e[r - 1] && (i = n.push(r)); while (i--) e.splice(n[i], 1) } return e }; function ut(e, t) { var n = t && e, r = n && (~t.sourceIndex || j) - (~e.sourceIndex || j); if (r) return r; if (n) while (n = n.nextSibling) if (n === t) return -1; return e ? 1 : -1 } function lt(e) { return function (t) { var n = t.nodeName.toLowerCase(); return "input" === n && t.type === e } } function ct(e) { return function (t) { var n = t.nodeName.toLowerCase(); return ("input" === n || "button" === n) && t.type === e } } function pt(e) { return ot(function (t) { return t = +t, ot(function (n, r) { var i, o = e([], n.length, t), a = o.length; while (a--) n[i = o[a]] && (n[i] = !(r[i] = n[i])) }) }) } o = st.getText = function (e) { var t, n = "", r = 0, i = e.nodeType; if (i) { if (1 === i || 9 === i || 11 === i) { if ("string" == typeof e.textContent) return e.textContent; for (e = e.firstChild; e; e = e.nextSibling)n += o(e) } else if (3 === i || 4 === i) return e.nodeValue } else for (; t = e[r]; r++)n += o(t); return n }, i = st.selectors = { cacheLength: 50, createPseudo: ot, match: U, find: {}, relative: { ">": { dir: "parentNode", first: !0 }, " ": { dir: "parentNode" }, "+": { dir: "previousSibling", first: !0 }, "~": { dir: "previousSibling" } }, preFilter: { ATTR: function (e) { return e[1] = e[1].replace(et, tt), e[3] = (e[4] || e[5] || "").replace(et, tt), "~=" === e[2] && (e[3] = " " + e[3] + " "), e.slice(0, 4) }, CHILD: function (e) { return e[1] = e[1].toLowerCase(), "nth" === e[1].slice(0, 3) ? (e[3] || st.error(e[0]), e[4] = +(e[4] ? e[5] + (e[6] || 1) : 2 * ("even" === e[3] || "odd" === e[3])), e[5] = +(e[7] + e[8] || "odd" === e[3])) : e[3] && st.error(e[0]), e }, PSEUDO: function (e) { var t, n = !e[5] && e[2]; return U.CHILD.test(e[0]) ? null : (e[4] ? e[2] = e[4] : n && z.test(n) && (t = ft(n, !0)) && (t = n.indexOf(")", n.length - t) - n.length) && (e[0] = e[0].slice(0, t), e[2] = n.slice(0, t)), e.slice(0, 3)) } }, filter: { TAG: function (e) { return "*" === e ? function () { return !0 } : (e = e.replace(et, tt).toLowerCase(), function (t) { return t.nodeName && t.nodeName.toLowerCase() === e }) }, CLASS: function (e) { var t = k[e + " "]; return t || (t = RegExp("(^|" + _ + ")" + e + "(" + _ + "|$)")) && k(e, function (e) { return t.test(e.className || typeof e.getAttribute !== A && e.getAttribute("class") || "") }) }, ATTR: function (e, t, n) { return function (r) { var i = st.attr(r, e); return null == i ? "!=" === t : t ? (i += "", "=" === t ? i === n : "!=" === t ? i !== n : "^=" === t ? n && 0 === i.indexOf(n) : "*=" === t ? n && i.indexOf(n) > -1 : "$=" === t ? n && i.slice(-n.length) === n : "~=" === t ? (" " + i + " ").indexOf(n) > -1 : "|=" === t ? i === n || i.slice(0, n.length + 1) === n + "-" : !1) : !0 } }, CHILD: function (e, t, n, r, i) { var o = "nth" !== e.slice(0, 3), a = "last" !== e.slice(-4), s = "of-type" === t; return 1 === r && 0 === i ? function (e) { return !!e.parentNode } : function (t, n, u) { var l, c, p, f, d, h, g = o !== a ? "nextSibling" : "previousSibling", m = t.parentNode, y = s && t.nodeName.toLowerCase(), v = !u && !s; if (m) { if (o) { while (g) { p = t; while (p = p[g]) if (s ? p.nodeName.toLowerCase() === y : 1 === p.nodeType) return !1; h = g = "only" === e && !h && "nextSibling" } return !0 } if (h = [a ? m.firstChild : m.lastChild], a && v) { c = m[x] || (m[x] = {}), l = c[e] || [], d = l[0] === N && l[1], f = l[0] === N && l[2], p = d && m.childNodes[d]; while (p = ++d && p && p[g] || (f = d = 0) || h.pop()) if (1 === p.nodeType && ++f && p === t) { c[e] = [N, d, f]; break } } else if (v && (l = (t[x] || (t[x] = {}))[e]) && l[0] === N) f = l[1]; else while (p = ++d && p && p[g] || (f = d = 0) || h.pop()) if ((s ? p.nodeName.toLowerCase() === y : 1 === p.nodeType) && ++f && (v && ((p[x] || (p[x] = {}))[e] = [N, f]), p === t)) break; return f -= i, f === r || 0 === f % r && f / r >= 0 } } }, PSEUDO: function (e, t) { var n, r = i.pseudos[e] || i.setFilters[e.toLowerCase()] || st.error("unsupported pseudo: " + e); return r[x] ? r(t) : r.length > 1 ? (n = [e, e, "", t], i.setFilters.hasOwnProperty(e.toLowerCase()) ? ot(function (e, n) { var i, o = r(e, t), a = o.length; while (a--) i = M.call(e, o[a]), e[i] = !(n[i] = o[a]) }) : function (e) { return r(e, 0, n) }) : r } }, pseudos: { not: ot(function (e) { var t = [], n = [], r = s(e.replace(W, "$1")); return r[x] ? ot(function (e, t, n, i) { var o, a = r(e, null, i, []), s = e.length; while (s--) (o = a[s]) && (e[s] = !(t[s] = o)) }) : function (e, i, o) { return t[0] = e, r(t, null, o, n), !n.pop() } }), has: ot(function (e) { return function (t) { return st(e, t).length > 0 } }), contains: ot(function (e) { return function (t) { return (t.textContent || t.innerText || o(t)).indexOf(e) > -1 } }), lang: ot(function (e) { return X.test(e || "") || st.error("unsupported lang: " + e), e = e.replace(et, tt).toLowerCase(), function (t) { var n; do if (n = d ? t.getAttribute("xml:lang") || t.getAttribute("lang") : t.lang) return n = n.toLowerCase(), n === e || 0 === n.indexOf(e + "-"); while ((t = t.parentNode) && 1 === t.nodeType); return !1 } }), target: function (t) { var n = e.location && e.location.hash; return n && n.slice(1) === t.id }, root: function (e) { return e === f }, focus: function (e) { return e === p.activeElement && (!p.hasFocus || p.hasFocus()) && !!(e.type || e.href || ~e.tabIndex) }, enabled: function (e) { return e.disabled === !1 }, disabled: function (e) { return e.disabled === !0 }, checked: function (e) { var t = e.nodeName.toLowerCase(); return "input" === t && !!e.checked || "option" === t && !!e.selected }, selected: function (e) { return e.parentNode && e.parentNode.selectedIndex, e.selected === !0 }, empty: function (e) { for (e = e.firstChild; e; e = e.nextSibling)if (e.nodeName > "@" || 3 === e.nodeType || 4 === e.nodeType) return !1; return !0 }, parent: function (e) { return !i.pseudos.empty(e) }, header: function (e) { return Q.test(e.nodeName) }, input: function (e) { return G.test(e.nodeName) }, button: function (e) { var t = e.nodeName.toLowerCase(); return "input" === t && "button" === e.type || "button" === t }, text: function (e) { var t; return "input" === e.nodeName.toLowerCase() && "text" === e.type && (null == (t = e.getAttribute("type")) || t.toLowerCase() === e.type) }, first: pt(function () { return [0] }), last: pt(function (e, t) { return [t - 1] }), eq: pt(function (e, t, n) { return [0 > n ? n + t : n] }), even: pt(function (e, t) { var n = 0; for (; t > n; n += 2)e.push(n); return e }), odd: pt(function (e, t) { var n = 1; for (; t > n; n += 2)e.push(n); return e }), lt: pt(function (e, t, n) { var r = 0 > n ? n + t : n; for (; --r >= 0;)e.push(r); return e }), gt: pt(function (e, t, n) { var r = 0 > n ? n + t : n; for (; t > ++r;)e.push(r); return e }) } }; for (n in { radio: !0, checkbox: !0, file: !0, password: !0, image: !0 }) i.pseudos[n] = lt(n); for (n in { submit: !0, reset: !0 }) i.pseudos[n] = ct(n); function ft(e, t) { var n, r, o, a, s, u, l, c = E[e + " "]; if (c) return t ? 0 : c.slice(0); s = e, u = [], l = i.preFilter; while (s) { (!n || (r = $.exec(s))) && (r && (s = s.slice(r[0].length) || s), u.push(o = [])), n = !1, (r = I.exec(s)) && (n = r.shift(), o.push({ value: n, type: r[0].replace(W, " ") }), s = s.slice(n.length)); for (a in i.filter) !(r = U[a].exec(s)) || l[a] && !(r = l[a](r)) || (n = r.shift(), o.push({ value: n, type: a, matches: r }), s = s.slice(n.length)); if (!n) break } return t ? s.length : s ? st.error(e) : E(e, u).slice(0) } function dt(e) { var t = 0, n = e.length, r = ""; for (; n > t; t++)r += e[t].value; return r } function ht(e, t, n) { var i = t.dir, o = n && "parentNode" === i, a = C++; return t.first ? function (t, n, r) { while (t = t[i]) if (1 === t.nodeType || o) return e(t, n, r) } : function (t, n, s) { var u, l, c, p = N + " " + a; if (s) { while (t = t[i]) if ((1 === t.nodeType || o) && e(t, n, s)) return !0 } else while (t = t[i]) if (1 === t.nodeType || o) if (c = t[x] || (t[x] = {}), (l = c[i]) && l[0] === p) { if ((u = l[1]) === !0 || u === r) return u === !0 } else if (l = c[i] = [p], l[1] = e(t, n, s) || r, l[1] === !0) return !0 } } function gt(e) { return e.length > 1 ? function (t, n, r) { var i = e.length; while (i--) if (!e[i](t, n, r)) return !1; return !0 } : e[0] } function mt(e, t, n, r, i) { var o, a = [], s = 0, u = e.length, l = null != t; for (; u > s; s++)(o = e[s]) && (!n || n(o, r, i)) && (a.push(o), l && t.push(s)); return a } function yt(e, t, n, r, i, o) { return r && !r[x] && (r = yt(r)), i && !i[x] && (i = yt(i, o)), ot(function (o, a, s, u) { var l, c, p, f = [], d = [], h = a.length, g = o || xt(t || "*", s.nodeType ? [s] : s, []), m = !e || !o && t ? g : mt(g, f, e, s, u), y = n ? i || (o ? e : h || r) ? [] : a : m; if (n && n(m, y, s, u), r) { l = mt(y, d), r(l, [], s, u), c = l.length; while (c--) (p = l[c]) && (y[d[c]] = !(m[d[c]] = p)) } if (o) { if (i || e) { if (i) { l = [], c = y.length; while (c--) (p = y[c]) && l.push(m[c] = p); i(null, y = [], l, u) } c = y.length; while (c--) (p = y[c]) && (l = i ? M.call(o, p) : f[c]) > -1 && (o[l] = !(a[l] = p)) } } else y = mt(y === a ? y.splice(h, y.length) : y), i ? i(null, a, y, u) : H.apply(a, y) }) } function vt(e) { var t, n, r, o = e.length, a = i.relative[e[0].type], s = a || i.relative[" "], u = a ? 1 : 0, c = ht(function (e) { return e === t }, s, !0), p = ht(function (e) { return M.call(t, e) > -1 }, s, !0), f = [function (e, n, r) { return !a && (r || n !== l) || ((t = n).nodeType ? c(e, n, r) : p(e, n, r)) }]; for (; o > u; u++)if (n = i.relative[e[u].type]) f = [ht(gt(f), n)]; else { if (n = i.filter[e[u].type].apply(null, e[u].matches), n[x]) { for (r = ++u; o > r; r++)if (i.relative[e[r].type]) break; return yt(u > 1 && gt(f), u > 1 && dt(e.slice(0, u - 1)).replace(W, "$1"), n, r > u && vt(e.slice(u, r)), o > r && vt(e = e.slice(r)), o > r && dt(e)) } f.push(n) } return gt(f) } function bt(e, t) { var n = 0, o = t.length > 0, a = e.length > 0, s = function (s, u, c, f, d) { var h, g, m, y = [], v = 0, b = "0", x = s && [], w = null != d, T = l, C = s || a && i.find.TAG("*", d && u.parentNode || u), k = N += null == T ? 1 : Math.random() || .1; for (w && (l = u !== p && u, r = n); null != (h = C[b]); b++) { if (a && h) { g = 0; while (m = e[g++]) if (m(h, u, c)) { f.push(h); break } w && (N = k, r = ++n) } o && ((h = !m && h) && v-- , s && x.push(h)) } if (v += b, o && b !== v) { g = 0; while (m = t[g++]) m(x, y, u, c); if (s) { if (v > 0) while (b--) x[b] || y[b] || (y[b] = L.call(f)); y = mt(y) } H.apply(f, y), w && !s && y.length > 0 && v + t.length > 1 && st.uniqueSort(f) } return w && (N = k, l = T), x }; return o ? ot(s) : s } s = st.compile = function (e, t) { var n, r = [], i = [], o = S[e + " "]; if (!o) { t || (t = ft(e)), n = t.length; while (n--) o = vt(t[n]), o[x] ? r.push(o) : i.push(o); o = S(e, bt(i, r)) } return o }; function xt(e, t, n) { var r = 0, i = t.length; for (; i > r; r++)st(e, t[r], n); return n } function wt(e, t, n, r) { var o, a, u, l, c, p = ft(e); if (!r && 1 === p.length) { if (a = p[0] = p[0].slice(0), a.length > 2 && "ID" === (u = a[0]).type && 9 === t.nodeType && !d && i.relative[a[1].type]) { if (t = i.find.ID(u.matches[0].replace(et, tt), t)[0], !t) return n; e = e.slice(a.shift().value.length) } o = U.needsContext.test(e) ? 0 : a.length; while (o--) { if (u = a[o], i.relative[l = u.type]) break; if ((c = i.find[l]) && (r = c(u.matches[0].replace(et, tt), V.test(a[0].type) && t.parentNode || t))) { if (a.splice(o, 1), e = r.length && dt(a), !e) return H.apply(n, q.call(r, 0)), n; break } } } return s(e, p)(r, t, d, n, V.test(e)), n } i.pseudos.nth = i.pseudos.eq; function Tt() { } i.filters = Tt.prototype = i.pseudos, i.setFilters = new Tt, c(), st.attr = b.attr, b.find = st, b.expr = st.selectors, b.expr[":"] = b.expr.pseudos, b.unique = st.uniqueSort, b.text = st.getText, b.isXMLDoc = st.isXML, b.contains = st.contains }(e); var at = /Until$/, st = /^(?:parents|prev(?:Until|All))/, ut = /^.[^:#\[\.,]*$/, lt = b.expr.match.needsContext, ct = { children: !0, contents: !0, next: !0, prev: !0 }; b.fn.extend({ find: function (e) { var t, n, r, i = this.length; if ("string" != typeof e) return r = this, this.pushStack(b(e).filter(function () { for (t = 0; i > t; t++)if (b.contains(r[t], this)) return !0 })); for (n = [], t = 0; i > t; t++)b.find(e, this[t], n); return n = this.pushStack(i > 1 ? b.unique(n) : n), n.selector = (this.selector ? this.selector + " " : "") + e, n }, has: function (e) { var t, n = b(e, this), r = n.length; return this.filter(function () { for (t = 0; r > t; t++)if (b.contains(this, n[t])) return !0 }) }, not: function (e) { return this.pushStack(ft(this, e, !1)) }, filter: function (e) { return this.pushStack(ft(this, e, !0)) }, is: function (e) { return !!e && ("string" == typeof e ? lt.test(e) ? b(e, this.context).index(this[0]) >= 0 : b.filter(e, this).length > 0 : this.filter(e).length > 0) }, closest: function (e, t) { var n, r = 0, i = this.length, o = [], a = lt.test(e) || "string" != typeof e ? b(e, t || this.context) : 0; for (; i > r; r++) { n = this[r]; while (n && n.ownerDocument && n !== t && 11 !== n.nodeType) { if (a ? a.index(n) > -1 : b.find.matchesSelector(n, e)) { o.push(n); break } n = n.parentNode } } return this.pushStack(o.length > 1 ? b.unique(o) : o) }, index: function (e) { return e ? "string" == typeof e ? b.inArray(this[0], b(e)) : b.inArray(e.jquery ? e[0] : e, this) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1 }, add: function (e, t) { var n = "string" == typeof e ? b(e, t) : b.makeArray(e && e.nodeType ? [e] : e), r = b.merge(this.get(), n); return this.pushStack(b.unique(r)) }, addBack: function (e) { return this.add(null == e ? this.prevObject : this.prevObject.filter(e)) } }), b.fn.andSelf = b.fn.addBack; function pt(e, t) { do e = e[t]; while (e && 1 !== e.nodeType); return e } b.each({ parent: function (e) { var t = e.parentNode; return t && 11 !== t.nodeType ? t : null }, parents: function (e) { return b.dir(e, "parentNode") }, parentsUntil: function (e, t, n) { return b.dir(e, "parentNode", n) }, next: function (e) { return pt(e, "nextSibling") }, prev: function (e) { return pt(e, "previousSibling") }, nextAll: function (e) { return b.dir(e, "nextSibling") }, prevAll: function (e) { return b.dir(e, "previousSibling") }, nextUntil: function (e, t, n) { return b.dir(e, "nextSibling", n) }, prevUntil: function (e, t, n) { return b.dir(e, "previousSibling", n) }, siblings: function (e) { return b.sibling((e.parentNode || {}).firstChild, e) }, children: function (e) { return b.sibling(e.firstChild) }, contents: function (e) { return b.nodeName(e, "iframe") ? e.contentDocument || e.contentWindow.document : b.merge([], e.childNodes) } }, function (e, t) { b.fn[e] = function (n, r) { var i = b.map(this, t, n); return at.test(e) || (r = n), r && "string" == typeof r && (i = b.filter(r, i)), i = this.length > 1 && !ct[e] ? b.unique(i) : i, this.length > 1 && st.test(e) && (i = i.reverse()), this.pushStack(i) } }), b.extend({ filter: function (e, t, n) { return n && (e = ":not(" + e + ")"), 1 === t.length ? b.find.matchesSelector(t[0], e) ? [t[0]] : [] : b.find.matches(e, t) }, dir: function (e, n, r) { var i = [], o = e[n]; while (o && 9 !== o.nodeType && (r === t || 1 !== o.nodeType || !b(o).is(r))) 1 === o.nodeType && i.push(o), o = o[n]; return i }, sibling: function (e, t) { var n = []; for (; e; e = e.nextSibling)1 === e.nodeType && e !== t && n.push(e); return n } }); function ft(e, t, n) { if (t = t || 0, b.isFunction(t)) return b.grep(e, function (e, r) { var i = !!t.call(e, r, e); return i === n }); if (t.nodeType) return b.grep(e, function (e) { return e === t === n }); if ("string" == typeof t) { var r = b.grep(e, function (e) { return 1 === e.nodeType }); if (ut.test(t)) return b.filter(t, r, !n); t = b.filter(t, r) } return b.grep(e, function (e) { return b.inArray(e, t) >= 0 === n }) } function dt(e) { var t = ht.split("|"), n = e.createDocumentFragment(); if (n.createElement) while (t.length) n.createElement(t.pop()); return n } var ht = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video", gt = / jQuery\d+="(?:null|\d+)"/g, mt = RegExp("<(?:" + ht + ")[\\s/>]", "i"), yt = /^\s+/, vt = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi, bt = /<([\w:]+)/, xt = /<tbody/i, wt = /<|&#?\w+;/, Tt = /<(?:script|style|link)/i, Nt = /^(?:checkbox|radio)$/i, Ct = /checked\s*(?:[^=]|=\s*.checked.)/i, kt = /^$|\/(?:java|ecma)script/i, Et = /^true\/(.*)/, St = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g, At = { option: [1, "<select multiple='multiple'>", "</select>"], legend: [1, "<fieldset>", "</fieldset>"], area: [1, "<map>", "</map>"], param: [1, "<object>", "</object>"], thead: [1, "<table>", "</table>"], tr: [2, "<table><tbody>", "</tbody></table>"], col: [2, "<table><tbody></tbody><colgroup>", "</colgroup></table>"], td: [3, "<table><tbody><tr>", "</tr></tbody></table>"], _default: b.support.htmlSerialize ? [0, "", ""] : [1, "X<div>", "</div>"] }, jt = dt(o), Dt = jt.appendChild(o.createElement("div")); At.optgroup = At.option, At.tbody = At.tfoot = At.colgroup = At.caption = At.thead, At.th = At.td, b.fn.extend({ text: function (e) { return b.access(this, function (e) { return e === t ? b.text(this) : this.empty().append((this[0] && this[0].ownerDocument || o).createTextNode(e)) }, null, e, arguments.length) }, wrapAll: function (e) { if (b.isFunction(e)) return this.each(function (t) { b(this).wrapAll(e.call(this, t)) }); if (this[0]) { var t = b(e, this[0].ownerDocument).eq(0).clone(!0); this[0].parentNode && t.insertBefore(this[0]), t.map(function () { var e = this; while (e.firstChild && 1 === e.firstChild.nodeType) e = e.firstChild; return e }).append(this) } return this }, wrapInner: function (e) { return b.isFunction(e) ? this.each(function (t) { b(this).wrapInner(e.call(this, t)) }) : this.each(function () { var t = b(this), n = t.contents(); n.length ? n.wrapAll(e) : t.append(e) }) }, wrap: function (e) { var t = b.isFunction(e); return this.each(function (n) { b(this).wrapAll(t ? e.call(this, n) : e) }) }, unwrap: function () { return this.parent().each(function () { b.nodeName(this, "body") || b(this).replaceWith(this.childNodes) }).end() }, append: function () { return this.domManip(arguments, !0, function (e) { (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) && this.appendChild(e) }) }, prepend: function () { return this.domManip(arguments, !0, function (e) { (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) && this.insertBefore(e, this.firstChild) }) }, before: function () { return this.domManip(arguments, !1, function (e) { this.parentNode && this.parentNode.insertBefore(e, this) }) }, after: function () { return this.domManip(arguments, !1, function (e) { this.parentNode && this.parentNode.insertBefore(e, this.nextSibling) }) }, remove: function (e, t) { var n, r = 0; for (; null != (n = this[r]); r++)(!e || b.filter(e, [n]).length > 0) && (t || 1 !== n.nodeType || b.cleanData(Ot(n)), n.parentNode && (t && b.contains(n.ownerDocument, n) && Mt(Ot(n, "script")), n.parentNode.removeChild(n))); return this }, empty: function () { var e, t = 0; for (; null != (e = this[t]); t++) { 1 === e.nodeType && b.cleanData(Ot(e, !1)); while (e.firstChild) e.removeChild(e.firstChild); e.options && b.nodeName(e, "select") && (e.options.length = 0) } return this }, clone: function (e, t) { return e = null == e ? !1 : e, t = null == t ? e : t, this.map(function () { return b.clone(this, e, t) }) }, html: function (e) { return b.access(this, function (e) { var n = this[0] || {}, r = 0, i = this.length; if (e === t) return 1 === n.nodeType ? n.innerHTML.replace(gt, "") : t; if (!("string" != typeof e || Tt.test(e) || !b.support.htmlSerialize && mt.test(e) || !b.support.leadingWhitespace && yt.test(e) || At[(bt.exec(e) || ["", ""])[1].toLowerCase()])) { e = e.replace(vt, "<$1></$2>"); try { for (; i > r; r++)n = this[r] || {}, 1 === n.nodeType && (b.cleanData(Ot(n, !1)), n.innerHTML = e); n = 0 } catch (o) { } } n && this.empty().append(e) }, null, e, arguments.length) }, replaceWith: function (e) { var t = b.isFunction(e); return t || "string" == typeof e || (e = b(e).not(this).detach()), this.domManip([e], !0, function (e) { var t = this.nextSibling, n = this.parentNode; n && (b(this).remove(), n.insertBefore(e, t)) }) }, detach: function (e) { return this.remove(e, !0) }, domManip: function (e, n, r) { e = f.apply([], e); var i, o, a, s, u, l, c = 0, p = this.length, d = this, h = p - 1, g = e[0], m = b.isFunction(g); if (m || !(1 >= p || "string" != typeof g || b.support.checkClone) && Ct.test(g)) return this.each(function (i) { var o = d.eq(i); m && (e[0] = g.call(this, i, n ? o.html() : t)), o.domManip(e, n, r) }); if (p && (l = b.buildFragment(e, this[0].ownerDocument, !1, this), i = l.firstChild, 1 === l.childNodes.length && (l = i), i)) { for (n = n && b.nodeName(i, "tr"), s = b.map(Ot(l, "script"), Ht), a = s.length; p > c; c++)o = l, c !== h && (o = b.clone(o, !0, !0), a && b.merge(s, Ot(o, "script"))), r.call(n && b.nodeName(this[c], "table") ? Lt(this[c], "tbody") : this[c], o, c); if (a) for (u = s[s.length - 1].ownerDocument, b.map(s, qt), c = 0; a > c; c++)o = s[c], kt.test(o.type || "") && !b._data(o, "globalEval") && b.contains(u, o) && (o.src ? b.ajax({ url: o.src, type: "GET", dataType: "script", async: !1, global: !1, "throws": !0 }) : b.globalEval((o.text || o.textContent || o.innerHTML || "").replace(St, ""))); l = i = null } return this } }); function Lt(e, t) { return e.getElementsByTagName(t)[0] || e.appendChild(e.ownerDocument.createElement(t)) } function Ht(e) { var t = e.getAttributeNode("type"); return e.type = (t && t.specified) + "/" + e.type, e } function qt(e) { var t = Et.exec(e.type); return t ? e.type = t[1] : e.removeAttribute("type"), e } function Mt(e, t) { var n, r = 0; for (; null != (n = e[r]); r++)b._data(n, "globalEval", !t || b._data(t[r], "globalEval")) } function _t(e, t) { if (1 === t.nodeType && b.hasData(e)) { var n, r, i, o = b._data(e), a = b._data(t, o), s = o.events; if (s) { delete a.handle, a.events = {}; for (n in s) for (r = 0, i = s[n].length; i > r; r++)b.event.add(t, n, s[n][r]) } a.data && (a.data = b.extend({}, a.data)) } } function Ft(e, t) { var n, r, i; if (1 === t.nodeType) { if (n = t.nodeName.toLowerCase(), !b.support.noCloneEvent && t[b.expando]) { i = b._data(t); for (r in i.events) b.removeEvent(t, r, i.handle); t.removeAttribute(b.expando) } "script" === n && t.text !== e.text ? (Ht(t).text = e.text, qt(t)) : "object" === n ? (t.parentNode && (t.outerHTML = e.outerHTML), b.support.html5Clone && e.innerHTML && !b.trim(t.innerHTML) && (t.innerHTML = e.innerHTML)) : "input" === n && Nt.test(e.type) ? (t.defaultChecked = t.checked = e.checked, t.value !== e.value && (t.value = e.value)) : "option" === n ? t.defaultSelected = t.selected = e.defaultSelected : ("input" === n || "textarea" === n) && (t.defaultValue = e.defaultValue) } } b.each({ appendTo: "append", prependTo: "prepend", insertBefore: "before", insertAfter: "after", replaceAll: "replaceWith" }, function (e, t) { b.fn[e] = function (e) { var n, r = 0, i = [], o = b(e), a = o.length - 1; for (; a >= r; r++)n = r === a ? this : this.clone(!0), b(o[r])[t](n), d.apply(i, n.get()); return this.pushStack(i) } }); function Ot(e, n) { var r, o, a = 0, s = typeof e.getElementsByTagName !== i ? e.getElementsByTagName(n || "*") : typeof e.querySelectorAll !== i ? e.querySelectorAll(n || "*") : t; if (!s) for (s = [], r = e.childNodes || e; null != (o = r[a]); a++)!n || b.nodeName(o, n) ? s.push(o) : b.merge(s, Ot(o, n)); return n === t || n && b.nodeName(e, n) ? b.merge([e], s) : s } function Bt(e) { Nt.test(e.type) && (e.defaultChecked = e.checked) } b.extend({
        clone: function (e, t, n) { var r, i, o, a, s, u = b.contains(e.ownerDocument, e); if (b.support.html5Clone || b.isXMLDoc(e) || !mt.test("<" + e.nodeName + ">") ? o = e.cloneNode(!0) : (Dt.innerHTML = e.outerHTML, Dt.removeChild(o = Dt.firstChild)), !(b.support.noCloneEvent && b.support.noCloneChecked || 1 !== e.nodeType && 11 !== e.nodeType || b.isXMLDoc(e))) for (r = Ot(o), s = Ot(e), a = 0; null != (i = s[a]); ++a)r[a] && Ft(i, r[a]); if (t) if (n) for (s = s || Ot(e), r = r || Ot(o), a = 0; null != (i = s[a]); a++)_t(i, r[a]); else _t(e, o); return r = Ot(o, "script"), r.length > 0 && Mt(r, !u && Ot(e, "script")), r = s = i = null, o }, buildFragment: function (e, t, n, r) {
            var i, o, a, s, u, l, c, p = e.length, f = dt(t), d = [], h = 0; for (; p > h; h++)if (o = e[h], o || 0 === o) if ("object" === b.type(o)) b.merge(d, o.nodeType ? [o] : o); else if (wt.test(o)) {
            s = s || f.appendChild(t.createElement("div")), u = (bt.exec(o) || ["", ""])[1].toLowerCase(), c = At[u] || At._default, s.innerHTML = c[1] + o.replace(vt, "<$1></$2>") + c[2], i = c[0]; while (i--) s = s.lastChild; if (!b.support.leadingWhitespace && yt.test(o) && d.push(t.createTextNode(yt.exec(o)[0])), !b.support.tbody) {
            o = "table" !== u || xt.test(o) ? "<table>" !== c[1] || xt.test(o) ? 0 : s : s.firstChild, i = o && o.childNodes.length; while (i--) b.nodeName(l = o.childNodes[i], "tbody") && !l.childNodes.length && o.removeChild(l)
            } b.merge(d, s.childNodes), s.textContent = ""; while (s.firstChild) s.removeChild(s.firstChild); s = f.lastChild
            } else d.push(t.createTextNode(o)); s && f.removeChild(s), b.support.appendChecked || b.grep(Ot(d, "input"), Bt), h = 0; while (o = d[h++]) if ((!r || -1 === b.inArray(o, r)) && (a = b.contains(o.ownerDocument, o), s = Ot(f.appendChild(o), "script"), a && Mt(s), n)) { i = 0; while (o = s[i++]) kt.test(o.type || "") && n.push(o) } return s = null, f
        }, cleanData: function (e, t) { var n, r, o, a, s = 0, u = b.expando, l = b.cache, p = b.support.deleteExpando, f = b.event.special; for (; null != (n = e[s]); s++)if ((t || b.acceptData(n)) && (o = n[u], a = o && l[o])) { if (a.events) for (r in a.events) f[r] ? b.event.remove(n, r) : b.removeEvent(n, r, a.handle); l[o] && (delete l[o], p ? delete n[u] : typeof n.removeAttribute !== i ? n.removeAttribute(u) : n[u] = null, c.push(o)) } }
    }); var Pt, Rt, Wt, $t = /alpha\([^)]*\)/i, It = /opacity\s*=\s*([^)]*)/, zt = /^(top|right|bottom|left)$/, Xt = /^(none|table(?!-c[ea]).+)/, Ut = /^margin/, Vt = RegExp("^(" + x + ")(.*)$", "i"), Yt = RegExp("^(" + x + ")(?!px)[a-z%]+$", "i"), Jt = RegExp("^([+-])=(" + x + ")", "i"), Gt = { BODY: "block" }, Qt = { position: "absolute", visibility: "hidden", display: "block" }, Kt = { letterSpacing: 0, fontWeight: 400 }, Zt = ["Top", "Right", "Bottom", "Left"], en = ["Webkit", "O", "Moz", "ms"]; function tn(e, t) { if (t in e) return t; var n = t.charAt(0).toUpperCase() + t.slice(1), r = t, i = en.length; while (i--) if (t = en[i] + n, t in e) return t; return r } function nn(e, t) { return e = t || e, "none" === b.css(e, "display") || !b.contains(e.ownerDocument, e) } function rn(e, t) { var n, r, i, o = [], a = 0, s = e.length; for (; s > a; a++)r = e[a], r.style && (o[a] = b._data(r, "olddisplay"), n = r.style.display, t ? (o[a] || "none" !== n || (r.style.display = ""), "" === r.style.display && nn(r) && (o[a] = b._data(r, "olddisplay", un(r.nodeName)))) : o[a] || (i = nn(r), (n && "none" !== n || !i) && b._data(r, "olddisplay", i ? n : b.css(r, "display")))); for (a = 0; s > a; a++)r = e[a], r.style && (t && "none" !== r.style.display && "" !== r.style.display || (r.style.display = t ? o[a] || "" : "none")); return e } b.fn.extend({ css: function (e, n) { return b.access(this, function (e, n, r) { var i, o, a = {}, s = 0; if (b.isArray(n)) { for (o = Rt(e), i = n.length; i > s; s++)a[n[s]] = b.css(e, n[s], !1, o); return a } return r !== t ? b.style(e, n, r) : b.css(e, n) }, e, n, arguments.length > 1) }, show: function () { return rn(this, !0) }, hide: function () { return rn(this) }, toggle: function (e) { var t = "boolean" == typeof e; return this.each(function () { (t ? e : nn(this)) ? b(this).show() : b(this).hide() }) } }), b.extend({ cssHooks: { opacity: { get: function (e, t) { if (t) { var n = Wt(e, "opacity"); return "" === n ? "1" : n } } } }, cssNumber: { columnCount: !0, fillOpacity: !0, fontWeight: !0, lineHeight: !0, opacity: !0, orphans: !0, widows: !0, zIndex: !0, zoom: !0 }, cssProps: { "float": b.support.cssFloat ? "cssFloat" : "styleFloat" }, style: function (e, n, r, i) { if (e && 3 !== e.nodeType && 8 !== e.nodeType && e.style) { var o, a, s, u = b.camelCase(n), l = e.style; if (n = b.cssProps[u] || (b.cssProps[u] = tn(l, u)), s = b.cssHooks[n] || b.cssHooks[u], r === t) return s && "get" in s && (o = s.get(e, !1, i)) !== t ? o : l[n]; if (a = typeof r, "string" === a && (o = Jt.exec(r)) && (r = (o[1] + 1) * o[2] + parseFloat(b.css(e, n)), a = "number"), !(null == r || "number" === a && isNaN(r) || ("number" !== a || b.cssNumber[u] || (r += "px"), b.support.clearCloneStyle || "" !== r || 0 !== n.indexOf("background") || (l[n] = "inherit"), s && "set" in s && (r = s.set(e, r, i)) === t))) try { l[n] = r } catch (c) { } } }, css: function (e, n, r, i) { var o, a, s, u = b.camelCase(n); return n = b.cssProps[u] || (b.cssProps[u] = tn(e.style, u)), s = b.cssHooks[n] || b.cssHooks[u], s && "get" in s && (a = s.get(e, !0, r)), a === t && (a = Wt(e, n, i)), "normal" === a && n in Kt && (a = Kt[n]), "" === r || r ? (o = parseFloat(a), r === !0 || b.isNumeric(o) ? o || 0 : a) : a }, swap: function (e, t, n, r) { var i, o, a = {}; for (o in t) a[o] = e.style[o], e.style[o] = t[o]; i = n.apply(e, r || []); for (o in t) e.style[o] = a[o]; return i } }), e.getComputedStyle ? (Rt = function (t) { return e.getComputedStyle(t, null) }, Wt = function (e, n, r) { var i, o, a, s = r || Rt(e), u = s ? s.getPropertyValue(n) || s[n] : t, l = e.style; return s && ("" !== u || b.contains(e.ownerDocument, e) || (u = b.style(e, n)), Yt.test(u) && Ut.test(n) && (i = l.width, o = l.minWidth, a = l.maxWidth, l.minWidth = l.maxWidth = l.width = u, u = s.width, l.width = i, l.minWidth = o, l.maxWidth = a)), u }) : o.documentElement.currentStyle && (Rt = function (e) { return e.currentStyle }, Wt = function (e, n, r) { var i, o, a, s = r || Rt(e), u = s ? s[n] : t, l = e.style; return null == u && l && l[n] && (u = l[n]), Yt.test(u) && !zt.test(n) && (i = l.left, o = e.runtimeStyle, a = o && o.left, a && (o.left = e.currentStyle.left), l.left = "fontSize" === n ? "1em" : u, u = l.pixelLeft + "px", l.left = i, a && (o.left = a)), "" === u ? "auto" : u }); function on(e, t, n) { var r = Vt.exec(t); return r ? Math.max(0, r[1] - (n || 0)) + (r[2] || "px") : t } function an(e, t, n, r, i) { var o = n === (r ? "border" : "content") ? 4 : "width" === t ? 1 : 0, a = 0; for (; 4 > o; o += 2)"margin" === n && (a += b.css(e, n + Zt[o], !0, i)), r ? ("content" === n && (a -= b.css(e, "padding" + Zt[o], !0, i)), "margin" !== n && (a -= b.css(e, "border" + Zt[o] + "Width", !0, i))) : (a += b.css(e, "padding" + Zt[o], !0, i), "padding" !== n && (a += b.css(e, "border" + Zt[o] + "Width", !0, i))); return a } function sn(e, t, n) { var r = !0, i = "width" === t ? e.offsetWidth : e.offsetHeight, o = Rt(e), a = b.support.boxSizing && "border-box" === b.css(e, "boxSizing", !1, o); if (0 >= i || null == i) { if (i = Wt(e, t, o), (0 > i || null == i) && (i = e.style[t]), Yt.test(i)) return i; r = a && (b.support.boxSizingReliable || i === e.style[t]), i = parseFloat(i) || 0 } return i + an(e, t, n || (a ? "border" : "content"), r, o) + "px" } function un(e) { var t = o, n = Gt[e]; return n || (n = ln(e, t), "none" !== n && n || (Pt = (Pt || b("<iframe frameborder='0' width='0' height='0'/>").css("cssText", "display:block !important")).appendTo(t.documentElement), t = (Pt[0].contentWindow || Pt[0].contentDocument).document, t.write("<!doctype html><html><body>"), t.close(), n = ln(e, t), Pt.detach()), Gt[e] = n), n } function ln(e, t) { var n = b(t.createElement(e)).appendTo(t.body), r = b.css(n[0], "display"); return n.remove(), r } b.each(["height", "width"], function (e, n) { b.cssHooks[n] = { get: function (e, r, i) { return r ? 0 === e.offsetWidth && Xt.test(b.css(e, "display")) ? b.swap(e, Qt, function () { return sn(e, n, i) }) : sn(e, n, i) : t }, set: function (e, t, r) { var i = r && Rt(e); return on(e, t, r ? an(e, n, r, b.support.boxSizing && "border-box" === b.css(e, "boxSizing", !1, i), i) : 0) } } }), b.support.opacity || (b.cssHooks.opacity = { get: function (e, t) { return It.test((t && e.currentStyle ? e.currentStyle.filter : e.style.filter) || "") ? .01 * parseFloat(RegExp.$1) + "" : t ? "1" : "" }, set: function (e, t) { var n = e.style, r = e.currentStyle, i = b.isNumeric(t) ? "alpha(opacity=" + 100 * t + ")" : "", o = r && r.filter || n.filter || ""; n.zoom = 1, (t >= 1 || "" === t) && "" === b.trim(o.replace($t, "")) && n.removeAttribute && (n.removeAttribute("filter"), "" === t || r && !r.filter) || (n.filter = $t.test(o) ? o.replace($t, i) : o + " " + i) } }), b(function () { b.support.reliableMarginRight || (b.cssHooks.marginRight = { get: function (e, n) { return n ? b.swap(e, { display: "inline-block" }, Wt, [e, "marginRight"]) : t } }), !b.support.pixelPosition && b.fn.position && b.each(["top", "left"], function (e, n) { b.cssHooks[n] = { get: function (e, r) { return r ? (r = Wt(e, n), Yt.test(r) ? b(e).position()[n] + "px" : r) : t } } }) }), b.expr && b.expr.filters && (b.expr.filters.hidden = function (e) { return 0 >= e.offsetWidth && 0 >= e.offsetHeight || !b.support.reliableHiddenOffsets && "none" === (e.style && e.style.display || b.css(e, "display")) }, b.expr.filters.visible = function (e) { return !b.expr.filters.hidden(e) }), b.each({ margin: "", padding: "", border: "Width" }, function (e, t) { b.cssHooks[e + t] = { expand: function (n) { var r = 0, i = {}, o = "string" == typeof n ? n.split(" ") : [n]; for (; 4 > r; r++)i[e + Zt[r] + t] = o[r] || o[r - 2] || o[0]; return i } }, Ut.test(e) || (b.cssHooks[e + t].set = on) }); var cn = /%20/g, pn = /\[\]$/, fn = /\r?\n/g, dn = /^(?:submit|button|image|reset|file)$/i, hn = /^(?:input|select|textarea|keygen)/i; b.fn.extend({ serialize: function () { return b.param(this.serializeArray()) }, serializeArray: function () { return this.map(function () { var e = b.prop(this, "elements"); return e ? b.makeArray(e) : this }).filter(function () { var e = this.type; return this.name && !b(this).is(":disabled") && hn.test(this.nodeName) && !dn.test(e) && (this.checked || !Nt.test(e)) }).map(function (e, t) { var n = b(this).val(); return null == n ? null : b.isArray(n) ? b.map(n, function (e) { return { name: t.name, value: e.replace(fn, "\r\n") } }) : { name: t.name, value: n.replace(fn, "\r\n") } }).get() } }), b.param = function (e, n) { var r, i = [], o = function (e, t) { t = b.isFunction(t) ? t() : null == t ? "" : t, i[i.length] = encodeURIComponent(e) + "=" + encodeURIComponent(t) }; if (n === t && (n = b.ajaxSettings && b.ajaxSettings.traditional), b.isArray(e) || e.jquery && !b.isPlainObject(e)) b.each(e, function () { o(this.name, this.value) }); else for (r in e) gn(r, e[r], n, o); return i.join("&").replace(cn, "+") }; function gn(e, t, n, r) { var i; if (b.isArray(t)) b.each(t, function (t, i) { n || pn.test(e) ? r(e, i) : gn(e + "[" + ("object" == typeof i ? t : "") + "]", i, n, r) }); else if (n || "object" !== b.type(t)) r(e, t); else for (i in t) gn(e + "[" + i + "]", t[i], n, r) } b.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "), function (e, t) { b.fn[t] = function (e, n) { return arguments.length > 0 ? this.on(t, null, e, n) : this.trigger(t) } }), b.fn.hover = function (e, t) { return this.mouseenter(e).mouseleave(t || e) }; var mn, yn, vn = b.now(), bn = /\?/, xn = /#.*$/, wn = /([?&])_=[^&]*/, Tn = /^(.*?):[ \t]*([^\r\n]*)\r?$/gm, Nn = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, Cn = /^(?:GET|HEAD)$/, kn = /^\/\//, En = /^([\w.+-]+:)(?:\/\/([^\/?#:]*)(?::(\d+)|)|)/, Sn = b.fn.load, An = {}, jn = {}, Dn = "*/".concat("*"); try { yn = a.href } catch (Ln) { yn = o.createElement("a"), yn.href = "", yn = yn.href } mn = En.exec(yn.toLowerCase()) || []; function Hn(e) { return function (t, n) { "string" != typeof t && (n = t, t = "*"); var r, i = 0, o = t.toLowerCase().match(w) || []; if (b.isFunction(n)) while (r = o[i++]) "+" === r[0] ? (r = r.slice(1) || "*", (e[r] = e[r] || []).unshift(n)) : (e[r] = e[r] || []).push(n) } } function qn(e, n, r, i) { var o = {}, a = e === jn; function s(u) { var l; return o[u] = !0, b.each(e[u] || [], function (e, u) { var c = u(n, r, i); return "string" != typeof c || a || o[c] ? a ? !(l = c) : t : (n.dataTypes.unshift(c), s(c), !1) }), l } return s(n.dataTypes[0]) || !o["*"] && s("*") } function Mn(e, n) { var r, i, o = b.ajaxSettings.flatOptions || {}; for (i in n) n[i] !== t && ((o[i] ? e : r || (r = {}))[i] = n[i]); return r && b.extend(!0, e, r), e } b.fn.load = function (e, n, r) { if ("string" != typeof e && Sn) return Sn.apply(this, arguments); var i, o, a, s = this, u = e.indexOf(" "); return u >= 0 && (i = e.slice(u, e.length), e = e.slice(0, u)), b.isFunction(n) ? (r = n, n = t) : n && "object" == typeof n && (a = "POST"), s.length > 0 && b.ajax({ url: e, type: a, dataType: "html", data: n }).done(function (e) { o = arguments, s.html(i ? b("<div>").append(b.parseHTML(e)).find(i) : e) }).complete(r && function (e, t) { s.each(r, o || [e.responseText, t, e]) }), this }, b.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function (e, t) { b.fn[t] = function (e) { return this.on(t, e) } }), b.each(["get", "post"], function (e, n) { b[n] = function (e, r, i, o) { return b.isFunction(r) && (o = o || i, i = r, r = t), b.ajax({ url: e, type: n, dataType: o, data: r, success: i }) } }), b.extend({ active: 0, lastModified: {}, etag: {}, ajaxSettings: { url: yn, type: "GET", isLocal: Nn.test(mn[1]), global: !0, processData: !0, async: !0, contentType: "application/x-www-form-urlencoded; charset=UTF-8", accepts: { "*": Dn, text: "text/plain", html: "text/html", xml: "application/xml, text/xml", json: "application/json, text/javascript" }, contents: { xml: /xml/, html: /html/, json: /json/ }, responseFields: { xml: "responseXML", text: "responseText" }, converters: { "* text": e.String, "text html": !0, "text json": b.parseJSON, "text xml": b.parseXML }, flatOptions: { url: !0, context: !0 } }, ajaxSetup: function (e, t) { return t ? Mn(Mn(e, b.ajaxSettings), t) : Mn(b.ajaxSettings, e) }, ajaxPrefilter: Hn(An), ajaxTransport: Hn(jn), ajax: function (e, n) { "object" == typeof e && (n = e, e = t), n = n || {}; var r, i, o, a, s, u, l, c, p = b.ajaxSetup({}, n), f = p.context || p, d = p.context && (f.nodeType || f.jquery) ? b(f) : b.event, h = b.Deferred(), g = b.Callbacks("once memory"), m = p.statusCode || {}, y = {}, v = {}, x = 0, T = "canceled", N = { readyState: 0, getResponseHeader: function (e) { var t; if (2 === x) { if (!c) { c = {}; while (t = Tn.exec(a)) c[t[1].toLowerCase()] = t[2] } t = c[e.toLowerCase()] } return null == t ? null : t }, getAllResponseHeaders: function () { return 2 === x ? a : null }, setRequestHeader: function (e, t) { var n = e.toLowerCase(); return x || (e = v[n] = v[n] || e, y[e] = t), this }, overrideMimeType: function (e) { return x || (p.mimeType = e), this }, statusCode: function (e) { var t; if (e) if (2 > x) for (t in e) m[t] = [m[t], e[t]]; else N.always(e[N.status]); return this }, abort: function (e) { var t = e || T; return l && l.abort(t), k(0, t), this } }; if (h.promise(N).complete = g.add, N.success = N.done, N.error = N.fail, p.url = ((e || p.url || yn) + "").replace(xn, "").replace(kn, mn[1] + "//"), p.type = n.method || n.type || p.method || p.type, p.dataTypes = b.trim(p.dataType || "*").toLowerCase().match(w) || [""], null == p.crossDomain && (r = En.exec(p.url.toLowerCase()), p.crossDomain = !(!r || r[1] === mn[1] && r[2] === mn[2] && (r[3] || ("http:" === r[1] ? 80 : 443)) == (mn[3] || ("http:" === mn[1] ? 80 : 443)))), p.data && p.processData && "string" != typeof p.data && (p.data = b.param(p.data, p.traditional)), qn(An, p, n, N), 2 === x) return N; u = p.global, u && 0 === b.active++ && b.event.trigger("ajaxStart"), p.type = p.type.toUpperCase(), p.hasContent = !Cn.test(p.type), o = p.url, p.hasContent || (p.data && (o = p.url += (bn.test(o) ? "&" : "?") + p.data, delete p.data), p.cache === !1 && (p.url = wn.test(o) ? o.replace(wn, "$1_=" + vn++) : o + (bn.test(o) ? "&" : "?") + "_=" + vn++)), p.ifModified && (b.lastModified[o] && N.setRequestHeader("If-Modified-Since", b.lastModified[o]), b.etag[o] && N.setRequestHeader("If-None-Match", b.etag[o])), (p.data && p.hasContent && p.contentType !== !1 || n.contentType) && N.setRequestHeader("Content-Type", p.contentType), N.setRequestHeader("Accept", p.dataTypes[0] && p.accepts[p.dataTypes[0]] ? p.accepts[p.dataTypes[0]] + ("*" !== p.dataTypes[0] ? ", " + Dn + "; q=0.01" : "") : p.accepts["*"]); for (i in p.headers) N.setRequestHeader(i, p.headers[i]); if (p.beforeSend && (p.beforeSend.call(f, N, p) === !1 || 2 === x)) return N.abort(); T = "abort"; for (i in { success: 1, error: 1, complete: 1 }) N[i](p[i]); if (l = qn(jn, p, n, N)) { N.readyState = 1, u && d.trigger("ajaxSend", [N, p]), p.async && p.timeout > 0 && (s = setTimeout(function () { N.abort("timeout") }, p.timeout)); try { x = 1, l.send(y, k) } catch (C) { if (!(2 > x)) throw C; k(-1, C) } } else k(-1, "No Transport"); function k(e, n, r, i) { var c, y, v, w, T, C = n; 2 !== x && (x = 2, s && clearTimeout(s), l = t, a = i || "", N.readyState = e > 0 ? 4 : 0, r && (w = _n(p, N, r)), e >= 200 && 300 > e || 304 === e ? (p.ifModified && (T = N.getResponseHeader("Last-Modified"), T && (b.lastModified[o] = T), T = N.getResponseHeader("etag"), T && (b.etag[o] = T)), 204 === e ? (c = !0, C = "nocontent") : 304 === e ? (c = !0, C = "notmodified") : (c = Fn(p, w), C = c.state, y = c.data, v = c.error, c = !v)) : (v = C, (e || !C) && (C = "error", 0 > e && (e = 0))), N.status = e, N.statusText = (n || C) + "", c ? h.resolveWith(f, [y, C, N]) : h.rejectWith(f, [N, C, v]), N.statusCode(m), m = t, u && d.trigger(c ? "ajaxSuccess" : "ajaxError", [N, p, c ? y : v]), g.fireWith(f, [N, C]), u && (d.trigger("ajaxComplete", [N, p]), --b.active || b.event.trigger("ajaxStop"))) } return N }, getScript: function (e, n) { return b.get(e, t, n, "script") }, getJSON: function (e, t, n) { return b.get(e, t, n, "json") } }); function _n(e, n, r) { var i, o, a, s, u = e.contents, l = e.dataTypes, c = e.responseFields; for (s in c) s in r && (n[c[s]] = r[s]); while ("*" === l[0]) l.shift(), o === t && (o = e.mimeType || n.getResponseHeader("Content-Type")); if (o) for (s in u) if (u[s] && u[s].test(o)) { l.unshift(s); break } if (l[0] in r) a = l[0]; else { for (s in r) { if (!l[0] || e.converters[s + " " + l[0]]) { a = s; break } i || (i = s) } a = a || i } return a ? (a !== l[0] && l.unshift(a), r[a]) : t } function Fn(e, t) { var n, r, i, o, a = {}, s = 0, u = e.dataTypes.slice(), l = u[0]; if (e.dataFilter && (t = e.dataFilter(t, e.dataType)), u[1]) for (i in e.converters) a[i.toLowerCase()] = e.converters[i]; for (; r = u[++s];)if ("*" !== r) { if ("*" !== l && l !== r) { if (i = a[l + " " + r] || a["* " + r], !i) for (n in a) if (o = n.split(" "), o[1] === r && (i = a[l + " " + o[0]] || a["* " + o[0]])) { i === !0 ? i = a[n] : a[n] !== !0 && (r = o[0], u.splice(s--, 0, r)); break } if (i !== !0) if (i && e["throws"]) t = i(t); else try { t = i(t) } catch (c) { return { state: "parsererror", error: i ? c : "No conversion from " + l + " to " + r } } } l = r } return { state: "success", data: t } } b.ajaxSetup({ accepts: { script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript" }, contents: { script: /(?:java|ecma)script/ }, converters: { "text script": function (e) { return b.globalEval(e), e } } }), b.ajaxPrefilter("script", function (e) { e.cache === t && (e.cache = !1), e.crossDomain && (e.type = "GET", e.global = !1) }), b.ajaxTransport("script", function (e) { if (e.crossDomain) { var n, r = o.head || b("head")[0] || o.documentElement; return { send: function (t, i) { n = o.createElement("script"), n.async = !0, e.scriptCharset && (n.charset = e.scriptCharset), n.src = e.url, n.onload = n.onreadystatechange = function (e, t) { (t || !n.readyState || /loaded|complete/.test(n.readyState)) && (n.onload = n.onreadystatechange = null, n.parentNode && n.parentNode.removeChild(n), n = null, t || i(200, "success")) }, r.insertBefore(n, r.firstChild) }, abort: function () { n && n.onload(t, !0) } } } }); var On = [], Bn = /(=)\?(?=&|$)|\?\?/; b.ajaxSetup({ jsonp: "callback", jsonpCallback: function () { var e = On.pop() || b.expando + "_" + vn++; return this[e] = !0, e } }), b.ajaxPrefilter("json jsonp", function (n, r, i) { var o, a, s, u = n.jsonp !== !1 && (Bn.test(n.url) ? "url" : "string" == typeof n.data && !(n.contentType || "").indexOf("application/x-www-form-urlencoded") && Bn.test(n.data) && "data"); return u || "jsonp" === n.dataTypes[0] ? (o = n.jsonpCallback = b.isFunction(n.jsonpCallback) ? n.jsonpCallback() : n.jsonpCallback, u ? n[u] = n[u].replace(Bn, "$1" + o) : n.jsonp !== !1 && (n.url += (bn.test(n.url) ? "&" : "?") + n.jsonp + "=" + o), n.converters["script json"] = function () { return s || b.error(o + " was not called"), s[0] }, n.dataTypes[0] = "json", a = e[o], e[o] = function () { s = arguments }, i.always(function () { e[o] = a, n[o] && (n.jsonpCallback = r.jsonpCallback, On.push(o)), s && b.isFunction(a) && a(s[0]), s = a = t }), "script") : t }); var Pn, Rn, Wn = 0, $n = e.ActiveXObject && function () { var e; for (e in Pn) Pn[e](t, !0) }; function In() { try { return new e.XMLHttpRequest } catch (t) { } } function zn() { try { return new e.ActiveXObject("Microsoft.XMLHTTP") } catch (t) { } } b.ajaxSettings.xhr = e.ActiveXObject ? function () { return !this.isLocal && In() || zn() } : In, Rn = b.ajaxSettings.xhr(), b.support.cors = !!Rn && "withCredentials" in Rn, Rn = b.support.ajax = !!Rn, Rn && b.ajaxTransport(function (n) { if (!n.crossDomain || b.support.cors) { var r; return { send: function (i, o) { var a, s, u = n.xhr(); if (n.username ? u.open(n.type, n.url, n.async, n.username, n.password) : u.open(n.type, n.url, n.async), n.xhrFields) for (s in n.xhrFields) u[s] = n.xhrFields[s]; n.mimeType && u.overrideMimeType && u.overrideMimeType(n.mimeType), n.crossDomain || i["X-Requested-With"] || (i["X-Requested-With"] = "XMLHttpRequest"); try { for (s in i) u.setRequestHeader(s, i[s]) } catch (l) { } u.send(n.hasContent && n.data || null), r = function (e, i) { var s, l, c, p; try { if (r && (i || 4 === u.readyState)) if (r = t, a && (u.onreadystatechange = b.noop, $n && delete Pn[a]), i) 4 !== u.readyState && u.abort(); else { p = {}, s = u.status, l = u.getAllResponseHeaders(), "string" == typeof u.responseText && (p.text = u.responseText); try { c = u.statusText } catch (f) { c = "" } s || !n.isLocal || n.crossDomain ? 1223 === s && (s = 204) : s = p.text ? 200 : 404 } } catch (d) { i || o(-1, d) } p && o(s, c, p, l) }, n.async ? 4 === u.readyState ? setTimeout(r) : (a = ++Wn, $n && (Pn || (Pn = {}, b(e).unload($n)), Pn[a] = r), u.onreadystatechange = r) : r() }, abort: function () { r && r(t, !0) } } } }); var Xn, Un, Vn = /^(?:toggle|show|hide)$/, Yn = RegExp("^(?:([+-])=|)(" + x + ")([a-z%]*)$", "i"), Jn = /queueHooks$/, Gn = [nr], Qn = { "*": [function (e, t) { var n, r, i = this.createTween(e, t), o = Yn.exec(t), a = i.cur(), s = +a || 0, u = 1, l = 20; if (o) { if (n = +o[2], r = o[3] || (b.cssNumber[e] ? "" : "px"), "px" !== r && s) { s = b.css(i.elem, e, !0) || n || 1; do u = u || ".5", s /= u, b.style(i.elem, e, s + r); while (u !== (u = i.cur() / a) && 1 !== u && --l) } i.unit = r, i.start = s, i.end = o[1] ? s + (o[1] + 1) * n : n } return i }] }; function Kn() { return setTimeout(function () { Xn = t }), Xn = b.now() } function Zn(e, t) { b.each(t, function (t, n) { var r = (Qn[t] || []).concat(Qn["*"]), i = 0, o = r.length; for (; o > i; i++)if (r[i].call(e, t, n)) return }) } function er(e, t, n) { var r, i, o = 0, a = Gn.length, s = b.Deferred().always(function () { delete u.elem }), u = function () { if (i) return !1; var t = Xn || Kn(), n = Math.max(0, l.startTime + l.duration - t), r = n / l.duration || 0, o = 1 - r, a = 0, u = l.tweens.length; for (; u > a; a++)l.tweens[a].run(o); return s.notifyWith(e, [l, o, n]), 1 > o && u ? n : (s.resolveWith(e, [l]), !1) }, l = s.promise({ elem: e, props: b.extend({}, t), opts: b.extend(!0, { specialEasing: {} }, n), originalProperties: t, originalOptions: n, startTime: Xn || Kn(), duration: n.duration, tweens: [], createTween: function (t, n) { var r = b.Tween(e, l.opts, t, n, l.opts.specialEasing[t] || l.opts.easing); return l.tweens.push(r), r }, stop: function (t) { var n = 0, r = t ? l.tweens.length : 0; if (i) return this; for (i = !0; r > n; n++)l.tweens[n].run(1); return t ? s.resolveWith(e, [l, t]) : s.rejectWith(e, [l, t]), this } }), c = l.props; for (tr(c, l.opts.specialEasing); a > o; o++)if (r = Gn[o].call(l, e, c, l.opts)) return r; return Zn(l, c), b.isFunction(l.opts.start) && l.opts.start.call(e, l), b.fx.timer(b.extend(u, { elem: e, anim: l, queue: l.opts.queue })), l.progress(l.opts.progress).done(l.opts.done, l.opts.complete).fail(l.opts.fail).always(l.opts.always) } function tr(e, t) { var n, r, i, o, a; for (i in e) if (r = b.camelCase(i), o = t[r], n = e[i], b.isArray(n) && (o = n[1], n = e[i] = n[0]), i !== r && (e[r] = n, delete e[i]), a = b.cssHooks[r], a && "expand" in a) { n = a.expand(n), delete e[r]; for (i in n) i in e || (e[i] = n[i], t[i] = o) } else t[r] = o } b.Animation = b.extend(er, { tweener: function (e, t) { b.isFunction(e) ? (t = e, e = ["*"]) : e = e.split(" "); var n, r = 0, i = e.length; for (; i > r; r++)n = e[r], Qn[n] = Qn[n] || [], Qn[n].unshift(t) }, prefilter: function (e, t) { t ? Gn.unshift(e) : Gn.push(e) } }); function nr(e, t, n) { var r, i, o, a, s, u, l, c, p, f = this, d = e.style, h = {}, g = [], m = e.nodeType && nn(e); n.queue || (c = b._queueHooks(e, "fx"), null == c.unqueued && (c.unqueued = 0, p = c.empty.fire, c.empty.fire = function () { c.unqueued || p() }), c.unqueued++ , f.always(function () { f.always(function () { c.unqueued-- , b.queue(e, "fx").length || c.empty.fire() }) })), 1 === e.nodeType && ("height" in t || "width" in t) && (n.overflow = [d.overflow, d.overflowX, d.overflowY], "inline" === b.css(e, "display") && "none" === b.css(e, "float") && (b.support.inlineBlockNeedsLayout && "inline" !== un(e.nodeName) ? d.zoom = 1 : d.display = "inline-block")), n.overflow && (d.overflow = "hidden", b.support.shrinkWrapBlocks || f.always(function () { d.overflow = n.overflow[0], d.overflowX = n.overflow[1], d.overflowY = n.overflow[2] })); for (i in t) if (a = t[i], Vn.exec(a)) { if (delete t[i], u = u || "toggle" === a, a === (m ? "hide" : "show")) continue; g.push(i) } if (o = g.length) { s = b._data(e, "fxshow") || b._data(e, "fxshow", {}), "hidden" in s && (m = s.hidden), u && (s.hidden = !m), m ? b(e).show() : f.done(function () { b(e).hide() }), f.done(function () { var t; b._removeData(e, "fxshow"); for (t in h) b.style(e, t, h[t]) }); for (i = 0; o > i; i++)r = g[i], l = f.createTween(r, m ? s[r] : 0), h[r] = s[r] || b.style(e, r), r in s || (s[r] = l.start, m && (l.end = l.start, l.start = "width" === r || "height" === r ? 1 : 0)) } } function rr(e, t, n, r, i) { return new rr.prototype.init(e, t, n, r, i) } b.Tween = rr, rr.prototype = { constructor: rr, init: function (e, t, n, r, i, o) { this.elem = e, this.prop = n, this.easing = i || "swing", this.options = t, this.start = this.now = this.cur(), this.end = r, this.unit = o || (b.cssNumber[n] ? "" : "px") }, cur: function () { var e = rr.propHooks[this.prop]; return e && e.get ? e.get(this) : rr.propHooks._default.get(this) }, run: function (e) { var t, n = rr.propHooks[this.prop]; return this.pos = t = this.options.duration ? b.easing[this.easing](e, this.options.duration * e, 0, 1, this.options.duration) : e, this.now = (this.end - this.start) * t + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), n && n.set ? n.set(this) : rr.propHooks._default.set(this), this } }, rr.prototype.init.prototype = rr.prototype, rr.propHooks = { _default: { get: function (e) { var t; return null == e.elem[e.prop] || e.elem.style && null != e.elem.style[e.prop] ? (t = b.css(e.elem, e.prop, ""), t && "auto" !== t ? t : 0) : e.elem[e.prop] }, set: function (e) { b.fx.step[e.prop] ? b.fx.step[e.prop](e) : e.elem.style && (null != e.elem.style[b.cssProps[e.prop]] || b.cssHooks[e.prop]) ? b.style(e.elem, e.prop, e.now + e.unit) : e.elem[e.prop] = e.now } } }, rr.propHooks.scrollTop = rr.propHooks.scrollLeft = { set: function (e) { e.elem.nodeType && e.elem.parentNode && (e.elem[e.prop] = e.now) } }, b.each(["toggle", "show", "hide"], function (e, t) { var n = b.fn[t]; b.fn[t] = function (e, r, i) { return null == e || "boolean" == typeof e ? n.apply(this, arguments) : this.animate(ir(t, !0), e, r, i) } }), b.fn.extend({ fadeTo: function (e, t, n, r) { return this.filter(nn).css("opacity", 0).show().end().animate({ opacity: t }, e, n, r) }, animate: function (e, t, n, r) { var i = b.isEmptyObject(e), o = b.speed(t, n, r), a = function () { var t = er(this, b.extend({}, e), o); a.finish = function () { t.stop(!0) }, (i || b._data(this, "finish")) && t.stop(!0) }; return a.finish = a, i || o.queue === !1 ? this.each(a) : this.queue(o.queue, a) }, stop: function (e, n, r) { var i = function (e) { var t = e.stop; delete e.stop, t(r) }; return "string" != typeof e && (r = n, n = e, e = t), n && e !== !1 && this.queue(e || "fx", []), this.each(function () { var t = !0, n = null != e && e + "queueHooks", o = b.timers, a = b._data(this); if (n) a[n] && a[n].stop && i(a[n]); else for (n in a) a[n] && a[n].stop && Jn.test(n) && i(a[n]); for (n = o.length; n--;)o[n].elem !== this || null != e && o[n].queue !== e || (o[n].anim.stop(r), t = !1, o.splice(n, 1)); (t || !r) && b.dequeue(this, e) }) }, finish: function (e) { return e !== !1 && (e = e || "fx"), this.each(function () { var t, n = b._data(this), r = n[e + "queue"], i = n[e + "queueHooks"], o = b.timers, a = r ? r.length : 0; for (n.finish = !0, b.queue(this, e, []), i && i.cur && i.cur.finish && i.cur.finish.call(this), t = o.length; t--;)o[t].elem === this && o[t].queue === e && (o[t].anim.stop(!0), o.splice(t, 1)); for (t = 0; a > t; t++)r[t] && r[t].finish && r[t].finish.call(this); delete n.finish }) } }); function ir(e, t) { var n, r = { height: e }, i = 0; for (t = t ? 1 : 0; 4 > i; i += 2 - t)n = Zt[i], r["margin" + n] = r["padding" + n] = e; return t && (r.opacity = r.width = e), r } b.each({ slideDown: ir("show"), slideUp: ir("hide"), slideToggle: ir("toggle"), fadeIn: { opacity: "show" }, fadeOut: { opacity: "hide" }, fadeToggle: { opacity: "toggle" } }, function (e, t) { b.fn[e] = function (e, n, r) { return this.animate(t, e, n, r) } }), b.speed = function (e, t, n) { var r = e && "object" == typeof e ? b.extend({}, e) : { complete: n || !n && t || b.isFunction(e) && e, duration: e, easing: n && t || t && !b.isFunction(t) && t }; return r.duration = b.fx.off ? 0 : "number" == typeof r.duration ? r.duration : r.duration in b.fx.speeds ? b.fx.speeds[r.duration] : b.fx.speeds._default, (null == r.queue || r.queue === !0) && (r.queue = "fx"), r.old = r.complete, r.complete = function () { b.isFunction(r.old) && r.old.call(this), r.queue && b.dequeue(this, r.queue) }, r }, b.easing = { linear: function (e) { return e }, swing: function (e) { return .5 - Math.cos(e * Math.PI) / 2 } }, b.timers = [], b.fx = rr.prototype.init, b.fx.tick = function () { var e, n = b.timers, r = 0; for (Xn = b.now(); n.length > r; r++)e = n[r], e() || n[r] !== e || n.splice(r--, 1); n.length || b.fx.stop(), Xn = t }, b.fx.timer = function (e) { e() && b.timers.push(e) && b.fx.start() }, b.fx.interval = 13, b.fx.start = function () { Un || (Un = setInterval(b.fx.tick, b.fx.interval)) }, b.fx.stop = function () { clearInterval(Un), Un = null }, b.fx.speeds = { slow: 600, fast: 200, _default: 400 }, b.fx.step = {}, b.expr && b.expr.filters && (b.expr.filters.animated = function (e) { return b.grep(b.timers, function (t) { return e === t.elem }).length }), b.fn.offset = function (e) { if (arguments.length) return e === t ? this : this.each(function (t) { b.offset.setOffset(this, e, t) }); var n, r, o = { top: 0, left: 0 }, a = this[0], s = a && a.ownerDocument; if (s) return n = s.documentElement, b.contains(n, a) ? (typeof a.getBoundingClientRect !== i && (o = a.getBoundingClientRect()), r = or(s), { top: o.top + (r.pageYOffset || n.scrollTop) - (n.clientTop || 0), left: o.left + (r.pageXOffset || n.scrollLeft) - (n.clientLeft || 0) }) : o }, b.offset = { setOffset: function (e, t, n) { var r = b.css(e, "position"); "static" === r && (e.style.position = "relative"); var i = b(e), o = i.offset(), a = b.css(e, "top"), s = b.css(e, "left"), u = ("absolute" === r || "fixed" === r) && b.inArray("auto", [a, s]) > -1, l = {}, c = {}, p, f; u ? (c = i.position(), p = c.top, f = c.left) : (p = parseFloat(a) || 0, f = parseFloat(s) || 0), b.isFunction(t) && (t = t.call(e, n, o)), null != t.top && (l.top = t.top - o.top + p), null != t.left && (l.left = t.left - o.left + f), "using" in t ? t.using.call(e, l) : i.css(l) } }, b.fn.extend({ position: function () { if (this[0]) { var e, t, n = { top: 0, left: 0 }, r = this[0]; return "fixed" === b.css(r, "position") ? t = r.getBoundingClientRect() : (e = this.offsetParent(), t = this.offset(), b.nodeName(e[0], "html") || (n = e.offset()), n.top += b.css(e[0], "borderTopWidth", !0), n.left += b.css(e[0], "borderLeftWidth", !0)), { top: t.top - n.top - b.css(r, "marginTop", !0), left: t.left - n.left - b.css(r, "marginLeft", !0) } } }, offsetParent: function () { return this.map(function () { var e = this.offsetParent || o.documentElement; while (e && !b.nodeName(e, "html") && "static" === b.css(e, "position")) e = e.offsetParent; return e || o.documentElement }) } }), b.each({ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function (e, n) { var r = /Y/.test(n); b.fn[e] = function (i) { return b.access(this, function (e, i, o) { var a = or(e); return o === t ? a ? n in a ? a[n] : a.document.documentElement[i] : e[i] : (a ? a.scrollTo(r ? b(a).scrollLeft() : o, r ? o : b(a).scrollTop()) : e[i] = o, t) }, e, i, arguments.length, null) } }); function or(e) { return b.isWindow(e) ? e : 9 === e.nodeType ? e.defaultView || e.parentWindow : !1 } b.each({ Height: "height", Width: "width" }, function (e, n) { b.each({ padding: "inner" + e, content: n, "": "outer" + e }, function (r, i) { b.fn[i] = function (i, o) { var a = arguments.length && (r || "boolean" != typeof i), s = r || (i === !0 || o === !0 ? "margin" : "border"); return b.access(this, function (n, r, i) { var o; return b.isWindow(n) ? n.document.documentElement["client" + e] : 9 === n.nodeType ? (o = n.documentElement, Math.max(n.body["scroll" + e], o["scroll" + e], n.body["offset" + e], o["offset" + e], o["client" + e])) : i === t ? b.css(n, r, s) : b.style(n, r, i, s) }, n, a ? i : t, a, null) } }) }), e.jQuery = e.$ = b, "function" == typeof define && define.amd && define.amd.jQuery && define("jquery", [], function () { return b })
})(window);;
/*! jQuery UI - v1.10.2 - 2013-03-14
* http://jqueryui.com
* Includes: jquery.ui.core.js, jquery.ui.widget.js, jquery.ui.mouse.js, jquery.ui.draggable.js, jquery.ui.droppable.js, jquery.ui.resizable.js, jquery.ui.selectable.js, jquery.ui.sortable.js, jquery.ui.effect.js, jquery.ui.accordion.js, jquery.ui.autocomplete.js, jquery.ui.button.js, jquery.ui.datepicker.js, jquery.ui.dialog.js, jquery.ui.effect-blind.js, jquery.ui.effect-bounce.js, jquery.ui.effect-clip.js, jquery.ui.effect-drop.js, jquery.ui.effect-explode.js, jquery.ui.effect-fade.js, jquery.ui.effect-fold.js, jquery.ui.effect-highlight.js, jquery.ui.effect-pulsate.js, jquery.ui.effect-scale.js, jquery.ui.effect-shake.js, jquery.ui.effect-slide.js, jquery.ui.effect-transfer.js, jquery.ui.menu.js, jquery.ui.position.js, jquery.ui.progressbar.js, jquery.ui.slider.js, jquery.ui.spinner.js, jquery.ui.tabs.js, jquery.ui.tooltip.js
* Copyright 2013 jQuery Foundation and other contributors; Licensed MIT */
(function ($, undefined) {

    var uuid = 0,
        runiqueId = /^ui-id-\d+$/;

    // $.ui might exist from components with no dependencies, e.g., $.ui.position
    $.ui = $.ui || {};

    $.extend($.ui, {
        version: "1.10.2",

        keyCode: {
            BACKSPACE: 8,
            COMMA: 188,
            DELETE: 46,
            DOWN: 40,
            END: 35,
            ENTER: 13,
            ESCAPE: 27,
            HOME: 36,
            LEFT: 37,
            NUMPAD_ADD: 107,
            NUMPAD_DECIMAL: 110,
            NUMPAD_DIVIDE: 111,
            NUMPAD_ENTER: 108,
            NUMPAD_MULTIPLY: 106,
            NUMPAD_SUBTRACT: 109,
            PAGE_DOWN: 34,
            PAGE_UP: 33,
            PERIOD: 190,
            RIGHT: 39,
            SPACE: 32,
            TAB: 9,
            UP: 38
        }
    });

    // plugins
    $.fn.extend({
        focus: (function (orig) {
            return function (delay, fn) {
                return typeof delay === "number" ?
                    this.each(function () {
                        var elem = this;
                        setTimeout(function () {
                            $(elem).focus();
                            if (fn) {
                                fn.call(elem);
                            }
                        }, delay);
                    }) :
                    orig.apply(this, arguments);
            };
        })($.fn.focus),

        scrollParent: function () {
            var scrollParent;
            if (($.ui.ie && (/(static|relative)/).test(this.css("position"))) || (/absolute/).test(this.css("position"))) {
                scrollParent = this.parents().filter(function () {
                    return (/(relative|absolute|fixed)/).test($.css(this, "position")) && (/(auto|scroll)/).test($.css(this, "overflow") + $.css(this, "overflow-y") + $.css(this, "overflow-x"));
                }).eq(0);
            } else {
                scrollParent = this.parents().filter(function () {
                    return (/(auto|scroll)/).test($.css(this, "overflow") + $.css(this, "overflow-y") + $.css(this, "overflow-x"));
                }).eq(0);
            }

            return (/fixed/).test(this.css("position")) || !scrollParent.length ? $(document) : scrollParent;
        },

        zIndex: function (zIndex) {
            if (zIndex !== undefined) {
                return this.css("zIndex", zIndex);
            }

            if (this.length) {
                var elem = $(this[0]), position, value;
                while (elem.length && elem[0] !== document) {
                    // Ignore z-index if position is set to a value where z-index is ignored by the browser
                    // This makes behavior of this function consistent across browsers
                    // WebKit always returns auto if the element is positioned
                    position = elem.css("position");
                    if (position === "absolute" || position === "relative" || position === "fixed") {
                        // IE returns 0 when zIndex is not specified
                        // other browsers return a string
                        // we ignore the case of nested elements with an explicit value of 0
                        // <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
                        value = parseInt(elem.css("zIndex"), 10);
                        if (!isNaN(value) && value !== 0) {
                            return value;
                        }
                    }
                    elem = elem.parent();
                }
            }

            return 0;
        },

        uniqueId: function () {
            return this.each(function () {
                if (!this.id) {
                    this.id = "ui-id-" + (++uuid);
                }
            });
        },

        removeUniqueId: function () {
            return this.each(function () {
                if (runiqueId.test(this.id)) {
                    $(this).removeAttr("id");
                }
            });
        }
    });

    // selectors
    function focusable(element, isTabIndexNotNaN) {
        var map, mapName, img,
            nodeName = element.nodeName.toLowerCase();
        if ("area" === nodeName) {
            map = element.parentNode;
            mapName = map.name;
            if (!element.href || !mapName || map.nodeName.toLowerCase() !== "map") {
                return false;
            }
            img = $("img[usemap=#" + mapName + "]")[0];
            return !!img && visible(img);
        }
        return (/input|select|textarea|button|object/.test(nodeName) ?
            !element.disabled :
            "a" === nodeName ?
                element.href || isTabIndexNotNaN :
                isTabIndexNotNaN) &&
            // the element and all of its ancestors must be visible
            visible(element);
    }

    function visible(element) {
        return $.expr.filters.visible(element) &&
            !$(element).parents().addBack().filter(function () {
                return $.css(this, "visibility") === "hidden";
            }).length;
    }

    $.extend($.expr[":"], {
        data: $.expr.createPseudo ?
            $.expr.createPseudo(function (dataName) {
                return function (elem) {
                    return !!$.data(elem, dataName);
                };
            }) :
            // support: jQuery <1.8
            function (elem, i, match) {
                return !!$.data(elem, match[3]);
            },

        focusable: function (element) {
            return focusable(element, !isNaN($.attr(element, "tabindex")));
        },

        tabbable: function (element) {
            var tabIndex = $.attr(element, "tabindex"),
                isTabIndexNaN = isNaN(tabIndex);
            return (isTabIndexNaN || tabIndex >= 0) && focusable(element, !isTabIndexNaN);
        }
    });

    // support: jQuery <1.8
    if (!$("<a>").outerWidth(1).jquery) {
        $.each(["Width", "Height"], function (i, name) {
            var side = name === "Width" ? ["Left", "Right"] : ["Top", "Bottom"],
                type = name.toLowerCase(),
                orig = {
                    innerWidth: $.fn.innerWidth,
                    innerHeight: $.fn.innerHeight,
                    outerWidth: $.fn.outerWidth,
                    outerHeight: $.fn.outerHeight
                };

            function reduce(elem, size, border, margin) {
                $.each(side, function () {
                    size -= parseFloat($.css(elem, "padding" + this)) || 0;
                    if (border) {
                        size -= parseFloat($.css(elem, "border" + this + "Width")) || 0;
                    }
                    if (margin) {
                        size -= parseFloat($.css(elem, "margin" + this)) || 0;
                    }
                });
                return size;
            }

            $.fn["inner" + name] = function (size) {
                if (size === undefined) {
                    return orig["inner" + name].call(this);
                }

                return this.each(function () {
                    $(this).css(type, reduce(this, size) + "px");
                });
            };

            $.fn["outer" + name] = function (size, margin) {
                if (typeof size !== "number") {
                    return orig["outer" + name].call(this, size);
                }

                return this.each(function () {
                    $(this).css(type, reduce(this, size, true, margin) + "px");
                });
            };
        });
    }

    // support: jQuery <1.8
    if (!$.fn.addBack) {
        $.fn.addBack = function (selector) {
            return this.add(selector == null ?
                this.prevObject : this.prevObject.filter(selector)
            );
        };
    }

    // support: jQuery 1.6.1, 1.6.2 (http://bugs.jquery.com/ticket/9413)
    if ($("<a>").data("a-b", "a").removeData("a-b").data("a-b")) {
        $.fn.removeData = (function (removeData) {
            return function (key) {
                if (arguments.length) {
                    return removeData.call(this, $.camelCase(key));
                } else {
                    return removeData.call(this);
                }
            };
        })($.fn.removeData);
    }





    // deprecated
    $.ui.ie = !!/msie [\w.]+/.exec(navigator.userAgent.toLowerCase());

    $.support.selectstart = "onselectstart" in document.createElement("div");
    $.fn.extend({
        disableSelection: function () {
            return this.bind(($.support.selectstart ? "selectstart" : "mousedown") +
                ".ui-disableSelection", function (event) {
                    event.preventDefault();
                });
        },

        enableSelection: function () {
            return this.unbind(".ui-disableSelection");
        }
    });

    $.extend($.ui, {
        // $.ui.plugin is deprecated.  Use the proxy pattern instead.
        plugin: {
            add: function (module, option, set) {
                var i,
                    proto = $.ui[module].prototype;
                for (i in set) {
                    proto.plugins[i] = proto.plugins[i] || [];
                    proto.plugins[i].push([option, set[i]]);
                }
            },
            call: function (instance, name, args) {
                var i,
                    set = instance.plugins[name];
                if (!set || !instance.element[0].parentNode || instance.element[0].parentNode.nodeType === 11) {
                    return;
                }

                for (i = 0; i < set.length; i++) {
                    if (instance.options[set[i][0]]) {
                        set[i][1].apply(instance.element, args);
                    }
                }
            }
        },

        // only used by resizable
        hasScroll: function (el, a) {

            //If overflow is hidden, the element might have extra content, but the user wants to hide it
            if ($(el).css("overflow") === "hidden") {
                return false;
            }

            var scroll = (a && a === "left") ? "scrollLeft" : "scrollTop",
                has = false;

            if (el[scroll] > 0) {
                return true;
            }

            // TODO: determine which cases actually cause this to happen
            // if the element doesn't have the scroll set, see if it's possible to
            // set the scroll
            el[scroll] = 1;
            has = (el[scroll] > 0);
            el[scroll] = 0;
            return has;
        }
    });

})(jQuery);

(function ($, undefined) {

    var uuid = 0,
        slice = Array.prototype.slice,
        _cleanData = $.cleanData;
    $.cleanData = function (elems) {
        for (var i = 0, elem; (elem = elems[i]) != null; i++) {
            try {
                $(elem).triggerHandler("remove");
                // http://bugs.jquery.com/ticket/8235
            } catch (e) { }
        }
        _cleanData(elems);
    };

    $.widget = function (name, base, prototype) {
        var fullName, existingConstructor, constructor, basePrototype,
            // proxiedPrototype allows the provided prototype to remain unmodified
            // so that it can be used as a mixin for multiple widgets (#8876)
            proxiedPrototype = {},
            namespace = name.split(".")[0];

        name = name.split(".")[1];
        fullName = namespace + "-" + name;

        if (!prototype) {
            prototype = base;
            base = $.Widget;
        }

        // create selector for plugin
        $.expr[":"][fullName.toLowerCase()] = function (elem) {
            return !!$.data(elem, fullName);
        };

        $[namespace] = $[namespace] || {};
        existingConstructor = $[namespace][name];
        constructor = $[namespace][name] = function (options, element) {
            // allow instantiation without "new" keyword
            if (!this._createWidget) {
                return new constructor(options, element);
            }

            // allow instantiation without initializing for simple inheritance
            // must use "new" keyword (the code above always passes args)
            if (arguments.length) {
                this._createWidget(options, element);
            }
        };
        // extend with the existing constructor to carry over any static properties
        $.extend(constructor, existingConstructor, {
            version: prototype.version,
            // copy the object used to create the prototype in case we need to
            // redefine the widget later
            _proto: $.extend({}, prototype),
            // track widgets that inherit from this widget in case this widget is
            // redefined after a widget inherits from it
            _childConstructors: []
        });

        basePrototype = new base();
        // we need to make the options hash a property directly on the new instance
        // otherwise we'll modify the options hash on the prototype that we're
        // inheriting from
        basePrototype.options = $.widget.extend({}, basePrototype.options);
        $.each(prototype, function (prop, value) {
            if (!$.isFunction(value)) {
                proxiedPrototype[prop] = value;
                return;
            }
            proxiedPrototype[prop] = (function () {
                var _super = function () {
                    return base.prototype[prop].apply(this, arguments);
                },
                    _superApply = function (args) {
                        return base.prototype[prop].apply(this, args);
                    };
                return function () {
                    var __super = this._super,
                        __superApply = this._superApply,
                        returnValue;

                    this._super = _super;
                    this._superApply = _superApply;

                    returnValue = value.apply(this, arguments);

                    this._super = __super;
                    this._superApply = __superApply;

                    return returnValue;
                };
            })();
        });
        constructor.prototype = $.widget.extend(basePrototype, {
            // TODO: remove support for widgetEventPrefix
            // always use the name + a colon as the prefix, e.g., draggable:start
            // don't prefix for widgets that aren't DOM-based
            widgetEventPrefix: existingConstructor ? basePrototype.widgetEventPrefix : name
        }, proxiedPrototype, {
                constructor: constructor,
                namespace: namespace,
                widgetName: name,
                widgetFullName: fullName
            });

        // If this widget is being redefined then we need to find all widgets that
        // are inheriting from it and redefine all of them so that they inherit from
        // the new version of this widget. We're essentially trying to replace one
        // level in the prototype chain.
        if (existingConstructor) {
            $.each(existingConstructor._childConstructors, function (i, child) {
                var childPrototype = child.prototype;

                // redefine the child widget using the same prototype that was
                // originally used, but inherit from the new version of the base
                $.widget(childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto);
            });
            // remove the list of existing child constructors from the old constructor
            // so the old child constructors can be garbage collected
            delete existingConstructor._childConstructors;
        } else {
            base._childConstructors.push(constructor);
        }

        $.widget.bridge(name, constructor);
    };

    $.widget.extend = function (target) {
        var input = slice.call(arguments, 1),
            inputIndex = 0,
            inputLength = input.length,
            key,
            value;
        for (; inputIndex < inputLength; inputIndex++) {
            for (key in input[inputIndex]) {
                value = input[inputIndex][key];
                if (input[inputIndex].hasOwnProperty(key) && value !== undefined) {
                    // Clone objects
                    if ($.isPlainObject(value)) {
                        target[key] = $.isPlainObject(target[key]) ?
                            $.widget.extend({}, target[key], value) :
                            // Don't extend strings, arrays, etc. with objects
                            $.widget.extend({}, value);
                        // Copy everything else by reference
                    } else {
                        target[key] = value;
                    }
                }
            }
        }
        return target;
    };

    $.widget.bridge = function (name, object) {
        var fullName = object.prototype.widgetFullName || name;
        $.fn[name] = function (options) {
            var isMethodCall = typeof options === "string",
                args = slice.call(arguments, 1),
                returnValue = this;

            // allow multiple hashes to be passed on init
            options = !isMethodCall && args.length ?
                $.widget.extend.apply(null, [options].concat(args)) :
                options;

            if (isMethodCall) {
                this.each(function () {
                    var methodValue,
                        instance = $.data(this, fullName);
                    if (!instance) {
                        return $.error("cannot call methods on " + name + " prior to initialization; " +
                            "attempted to call method '" + options + "'");
                    }
                    if (!$.isFunction(instance[options]) || options.charAt(0) === "_") {
                        return $.error("no such method '" + options + "' for " + name + " widget instance");
                    }
                    methodValue = instance[options].apply(instance, args);
                    if (methodValue !== instance && methodValue !== undefined) {
                        returnValue = methodValue && methodValue.jquery ?
                            returnValue.pushStack(methodValue.get()) :
                            methodValue;
                        return false;
                    }
                });
            } else {
                this.each(function () {
                    var instance = $.data(this, fullName);
                    if (instance) {
                        instance.option(options || {})._init();
                    } else {
                        $.data(this, fullName, new object(options, this));
                    }
                });
            }

            return returnValue;
        };
    };

    $.Widget = function ( /* options, element */) { };
    $.Widget._childConstructors = [];

    $.Widget.prototype = {
        widgetName: "widget",
        widgetEventPrefix: "",
        defaultElement: "<div>",
        options: {
            disabled: false,

            // callbacks
            create: null
        },
        _createWidget: function (options, element) {
            element = $(element || this.defaultElement || this)[0];
            this.element = $(element);
            this.uuid = uuid++;
            this.eventNamespace = "." + this.widgetName + this.uuid;
            this.options = $.widget.extend({},
                this.options,
                this._getCreateOptions(),
                options);

            this.bindings = $();
            this.hoverable = $();
            this.focusable = $();

            if (element !== this) {
                $.data(element, this.widgetFullName, this);
                this._on(true, this.element, {
                    remove: function (event) {
                        if (event.target === element) {
                            this.destroy();
                        }
                    }
                });
                this.document = $(element.style ?
                    // element within the document
                    element.ownerDocument :
                    // element is window or document
                    element.document || element);
                this.window = $(this.document[0].defaultView || this.document[0].parentWindow);
            }

            this._create();
            this._trigger("create", null, this._getCreateEventData());
            this._init();
        },
        _getCreateOptions: $.noop,
        _getCreateEventData: $.noop,
        _create: $.noop,
        _init: $.noop,

        destroy: function () {
            this._destroy();
            // we can probably remove the unbind calls in 2.0
            // all event bindings should go through this._on()
            this.element
                .unbind(this.eventNamespace)
                // 1.9 BC for #7810
                // TODO remove dual storage
                .removeData(this.widgetName)
                .removeData(this.widgetFullName)
                // support: jquery <1.6.3
                // http://bugs.jquery.com/ticket/9413
                .removeData($.camelCase(this.widgetFullName));
            this.widget()
                .unbind(this.eventNamespace)
                .removeAttr("aria-disabled")
                .removeClass(
                this.widgetFullName + "-disabled " +
                "ui-state-disabled");

            // clean up events and states
            this.bindings.unbind(this.eventNamespace);
            this.hoverable.removeClass("ui-state-hover");
            this.focusable.removeClass("ui-state-focus");
        },
        _destroy: $.noop,

        widget: function () {
            return this.element;
        },

        option: function (key, value) {
            var options = key,
                parts,
                curOption,
                i;

            if (arguments.length === 0) {
                // don't return a reference to the internal hash
                return $.widget.extend({}, this.options);
            }

            if (typeof key === "string") {
                // handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
                options = {};
                parts = key.split(".");
                key = parts.shift();
                if (parts.length) {
                    curOption = options[key] = $.widget.extend({}, this.options[key]);
                    for (i = 0; i < parts.length - 1; i++) {
                        curOption[parts[i]] = curOption[parts[i]] || {};
                        curOption = curOption[parts[i]];
                    }
                    key = parts.pop();
                    if (value === undefined) {
                        return curOption[key] === undefined ? null : curOption[key];
                    }
                    curOption[key] = value;
                } else {
                    if (value === undefined) {
                        return this.options[key] === undefined ? null : this.options[key];
                    }
                    options[key] = value;
                }
            }

            this._setOptions(options);

            return this;
        },
        _setOptions: function (options) {
            var key;

            for (key in options) {
                this._setOption(key, options[key]);
            }

            return this;
        },
        _setOption: function (key, value) {
            this.options[key] = value;

            if (key === "disabled") {
                this.widget()
                    .toggleClass(this.widgetFullName + "-disabled ui-state-disabled", !!value)
                    .attr("aria-disabled", value);
                this.hoverable.removeClass("ui-state-hover");
                this.focusable.removeClass("ui-state-focus");
            }

            return this;
        },

        enable: function () {
            return this._setOption("disabled", false);
        },
        disable: function () {
            return this._setOption("disabled", true);
        },

        _on: function (suppressDisabledCheck, element, handlers) {
            var delegateElement,
                instance = this;

            // no suppressDisabledCheck flag, shuffle arguments
            if (typeof suppressDisabledCheck !== "boolean") {
                handlers = element;
                element = suppressDisabledCheck;
                suppressDisabledCheck = false;
            }

            // no element argument, shuffle and use this.element
            if (!handlers) {
                handlers = element;
                element = this.element;
                delegateElement = this.widget();
            } else {
                // accept selectors, DOM elements
                element = delegateElement = $(element);
                this.bindings = this.bindings.add(element);
            }

            $.each(handlers, function (event, handler) {
                function handlerProxy() {
                    // allow widgets to customize the disabled handling
                    // - disabled as an array instead of boolean
                    // - disabled class as method for disabling individual parts
                    if (!suppressDisabledCheck &&
                        (instance.options.disabled === true ||
                            $(this).hasClass("ui-state-disabled"))) {
                        return;
                    }
                    return (typeof handler === "string" ? instance[handler] : handler)
                        .apply(instance, arguments);
                }

                // copy the guid so direct unbinding works
                if (typeof handler !== "string") {
                    handlerProxy.guid = handler.guid =
                        handler.guid || handlerProxy.guid || $.guid++;
                }

                var match = event.match(/^(\w+)\s*(.*)$/),
                    eventName = match[1] + instance.eventNamespace,
                    selector = match[2];
                if (selector) {
                    delegateElement.delegate(selector, eventName, handlerProxy);
                } else {
                    element.bind(eventName, handlerProxy);
                }
            });
        },

        _off: function (element, eventName) {
            eventName = (eventName || "").split(" ").join(this.eventNamespace + " ") + this.eventNamespace;
            element.unbind(eventName).undelegate(eventName);
        },

        _delay: function (handler, delay) {
            function handlerProxy() {
                return (typeof handler === "string" ? instance[handler] : handler)
                    .apply(instance, arguments);
            }
            var instance = this;
            return setTimeout(handlerProxy, delay || 0);
        },

        _hoverable: function (element) {
            this.hoverable = this.hoverable.add(element);
            this._on(element, {
                mouseenter: function (event) {
                    $(event.currentTarget).addClass("ui-state-hover");
                },
                mouseleave: function (event) {
                    $(event.currentTarget).removeClass("ui-state-hover");
                }
            });
        },

        _focusable: function (element) {
            this.focusable = this.focusable.add(element);
            this._on(element, {
                focusin: function (event) {
                    $(event.currentTarget).addClass("ui-state-focus");
                },
                focusout: function (event) {
                    $(event.currentTarget).removeClass("ui-state-focus");
                }
            });
        },

        _trigger: function (type, event, data) {
            var prop, orig,
                callback = this.options[type];

            data = data || {};
            event = $.Event(event);
            event.type = (type === this.widgetEventPrefix ?
                type :
                this.widgetEventPrefix + type).toLowerCase();
            // the original event may come from any element
            // so we need to reset the target on the new event
            event.target = this.element[0];

            // copy original event properties over to the new event
            orig = event.originalEvent;
            if (orig) {
                for (prop in orig) {
                    if (!(prop in event)) {
                        event[prop] = orig[prop];
                    }
                }
            }

            this.element.trigger(event, data);
            return !($.isFunction(callback) &&
                callback.apply(this.element[0], [event].concat(data)) === false ||
                event.isDefaultPrevented());
        }
    };

    $.each({ show: "fadeIn", hide: "fadeOut" }, function (method, defaultEffect) {
        $.Widget.prototype["_" + method] = function (element, options, callback) {
            if (typeof options === "string") {
                options = { effect: options };
            }
            var hasOptions,
                effectName = !options ?
                    method :
                    options === true || typeof options === "number" ?
                        defaultEffect :
                        options.effect || defaultEffect;
            options = options || {};
            if (typeof options === "number") {
                options = { duration: options };
            }
            hasOptions = !$.isEmptyObject(options);
            options.complete = callback;
            if (options.delay) {
                element.delay(options.delay);
            }
            if (hasOptions && $.effects && $.effects.effect[effectName]) {
                element[method](options);
            } else if (effectName !== method && element[effectName]) {
                element[effectName](options.duration, options.easing, callback);
            } else {
                element.queue(function (next) {
                    $(this)[method]();
                    if (callback) {
                        callback.call(element[0]);
                    }
                    next();
                });
            }
        };
    });

})(jQuery);

(function ($, undefined) {

    var mouseHandled = false;
    $(document).mouseup(function () {
        mouseHandled = false;
    });

    $.widget("ui.mouse", {
        version: "1.10.2",
        options: {
            cancel: "input,textarea,button,select,option",
            distance: 1,
            delay: 0
        },
        _mouseInit: function () {
            var that = this;

            this.element
                .bind("mousedown." + this.widgetName, function (event) {
                    return that._mouseDown(event);
                })
                .bind("click." + this.widgetName, function (event) {
                    if (true === $.data(event.target, that.widgetName + ".preventClickEvent")) {
                        $.removeData(event.target, that.widgetName + ".preventClickEvent");
                        event.stopImmediatePropagation();
                        return false;
                    }
                });

            this.started = false;
        },

        // TODO: make sure destroying one instance of mouse doesn't mess with
        // other instances of mouse
        _mouseDestroy: function () {
            this.element.unbind("." + this.widgetName);
            if (this._mouseMoveDelegate) {
                $(document)
                    .unbind("mousemove." + this.widgetName, this._mouseMoveDelegate)
                    .unbind("mouseup." + this.widgetName, this._mouseUpDelegate);
            }
        },

        _mouseDown: function (event) {
            // don't let more than one widget handle mouseStart
            if (mouseHandled) { return; }

            // we may have missed mouseup (out of window)
            (this._mouseStarted && this._mouseUp(event));

            this._mouseDownEvent = event;

            var that = this,
                btnIsLeft = (event.which === 1),
                // event.target.nodeName works around a bug in IE 8 with
                // disabled inputs (#7620)
                elIsCancel = (typeof this.options.cancel === "string" && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : false);
            if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {
                return true;
            }

            this.mouseDelayMet = !this.options.delay;
            if (!this.mouseDelayMet) {
                this._mouseDelayTimer = setTimeout(function () {
                    that.mouseDelayMet = true;
                }, this.options.delay);
            }

            if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
                this._mouseStarted = (this._mouseStart(event) !== false);
                if (!this._mouseStarted) {
                    event.preventDefault();
                    return true;
                }
            }

            // Click event may never have fired (Gecko & Opera)
            if (true === $.data(event.target, this.widgetName + ".preventClickEvent")) {
                $.removeData(event.target, this.widgetName + ".preventClickEvent");
            }

            // these delegates are required to keep context
            this._mouseMoveDelegate = function (event) {
                return that._mouseMove(event);
            };
            this._mouseUpDelegate = function (event) {
                return that._mouseUp(event);
            };
            $(document)
                .bind("mousemove." + this.widgetName, this._mouseMoveDelegate)
                .bind("mouseup." + this.widgetName, this._mouseUpDelegate);

            event.preventDefault();

            mouseHandled = true;
            return true;
        },

        _mouseMove: function (event) {
            // IE mouseup check - mouseup happened when mouse was out of window
            if ($.ui.ie && (!document.documentMode || document.documentMode < 9) && !event.button) {
                return this._mouseUp(event);
            }

            if (this._mouseStarted) {
                this._mouseDrag(event);
                return event.preventDefault();
            }

            if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
                this._mouseStarted =
                    (this._mouseStart(this._mouseDownEvent, event) !== false);
                (this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event));
            }

            return !this._mouseStarted;
        },

        _mouseUp: function (event) {
            $(document)
                .unbind("mousemove." + this.widgetName, this._mouseMoveDelegate)
                .unbind("mouseup." + this.widgetName, this._mouseUpDelegate);

            if (this._mouseStarted) {
                this._mouseStarted = false;

                if (event.target === this._mouseDownEvent.target) {
                    $.data(event.target, this.widgetName + ".preventClickEvent", true);
                }

                this._mouseStop(event);
            }

            return false;
        },

        _mouseDistanceMet: function (event) {
            return (Math.max(
                Math.abs(this._mouseDownEvent.pageX - event.pageX),
                Math.abs(this._mouseDownEvent.pageY - event.pageY)
            ) >= this.options.distance
            );
        },

        _mouseDelayMet: function (/* event */) {
            return this.mouseDelayMet;
        },

        // These are placeholder methods, to be overriden by extending plugin
        _mouseStart: function (/* event */) { },
        _mouseDrag: function (/* event */) { },
        _mouseStop: function (/* event */) { },
        _mouseCapture: function (/* event */) { return true; }
    });

})(jQuery);

(function ($, undefined) {

    $.widget("ui.draggable", $.ui.mouse, {
        version: "1.10.2",
        widgetEventPrefix: "drag",
        options: {
            addClasses: true,
            appendTo: "parent",
            axis: false,
            connectToSortable: false,
            containment: false,
            cursor: "auto",
            cursorAt: false,
            grid: false,
            handle: false,
            helper: "original",
            iframeFix: false,
            opacity: false,
            refreshPositions: false,
            revert: false,
            revertDuration: 500,
            scope: "default",
            scroll: true,
            scrollSensitivity: 20,
            scrollSpeed: 20,
            snap: false,
            snapMode: "both",
            snapTolerance: 20,
            stack: false,
            zIndex: false,

            // callbacks
            drag: null,
            start: null,
            stop: null
        },
        _create: function () {

            if (this.options.helper === "original" && !(/^(?:r|a|f)/).test(this.element.css("position"))) {
                this.element[0].style.position = "relative";
            }
            if (this.options.addClasses) {
                this.element.addClass("ui-draggable");
            }
            if (this.options.disabled) {
                this.element.addClass("ui-draggable-disabled");
            }

            this._mouseInit();

        },

        _destroy: function () {
            this.element.removeClass("ui-draggable ui-draggable-dragging ui-draggable-disabled");
            this._mouseDestroy();
        },

        _mouseCapture: function (event) {

            var o = this.options;

            // among others, prevent a drag on a resizable-handle
            if (this.helper || o.disabled || $(event.target).closest(".ui-resizable-handle").length > 0) {
                return false;
            }

            //Quit if we're not on a valid handle
            this.handle = this._getHandle(event);
            if (!this.handle) {
                return false;
            }

            $(o.iframeFix === true ? "iframe" : o.iframeFix).each(function () {
                $("<div class='ui-draggable-iframeFix' style='background: #fff;'></div>")
                    .css({
                        width: this.offsetWidth + "px", height: this.offsetHeight + "px",
                        position: "absolute", opacity: "0.001", zIndex: 1000
                    })
                    .css($(this).offset())
                    .appendTo("body");
            });

            return true;

        },

        _mouseStart: function (event) {

            var o = this.options;

            //Create and append the visible helper
            this.helper = this._createHelper(event);

            this.helper.addClass("ui-draggable-dragging");

            //Cache the helper size
            this._cacheHelperProportions();

            //If ddmanager is used for droppables, set the global draggable
            if ($.ui.ddmanager) {
                $.ui.ddmanager.current = this;
            }

            /*
             * - Position generation -
             * This block generates everything position related - it's the core of draggables.
             */

            //Cache the margins of the original element
            this._cacheMargins();

            //Store the helper's css position
            this.cssPosition = this.helper.css("position");
            this.scrollParent = this.helper.scrollParent();

            //The element's absolute position on the page minus margins
            this.offset = this.positionAbs = this.element.offset();
            this.offset = {
                top: this.offset.top - this.margins.top,
                left: this.offset.left - this.margins.left
            };

            $.extend(this.offset, {
                click: { //Where the click happened, relative to the element
                    left: event.pageX - this.offset.left,
                    top: event.pageY - this.offset.top
                },
                parent: this._getParentOffset(),
                relative: this._getRelativeOffset() //This is a relative to absolute position minus the actual position calculation - only used for relative positioned helper
            });

            //Generate the original position
            this.originalPosition = this.position = this._generatePosition(event);
            this.originalPageX = event.pageX;
            this.originalPageY = event.pageY;

            //Adjust the mouse offset relative to the helper if "cursorAt" is supplied
            (o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));

            //Set a containment if given in the options
            if (o.containment) {
                this._setContainment();
            }

            //Trigger event + callbacks
            if (this._trigger("start", event) === false) {
                this._clear();
                return false;
            }

            //Recache the helper size
            this._cacheHelperProportions();

            //Prepare the droppable offsets
            if ($.ui.ddmanager && !o.dropBehaviour) {
                $.ui.ddmanager.prepareOffsets(this, event);
            }


            this._mouseDrag(event, true); //Execute the drag once - this causes the helper not to be visible before getting its correct position

            //If the ddmanager is used for droppables, inform the manager that dragging has started (see #5003)
            if ($.ui.ddmanager) {
                $.ui.ddmanager.dragStart(this, event);
            }

            return true;
        },

        _mouseDrag: function (event, noPropagation) {

            //Compute the helpers position
            this.position = this._generatePosition(event);
            this.positionAbs = this._convertPositionTo("absolute");

            //Call plugins and callbacks and use the resulting position if something is returned
            if (!noPropagation) {
                var ui = this._uiHash();
                if (this._trigger("drag", event, ui) === false) {
                    this._mouseUp({});
                    return false;
                }
                this.position = ui.position;
            }

            if (!this.options.axis || this.options.axis !== "y") {
                this.helper[0].style.left = this.position.left + "px";
            }
            if (!this.options.axis || this.options.axis !== "x") {
                this.helper[0].style.top = this.position.top + "px";
            }
            if ($.ui.ddmanager) {
                $.ui.ddmanager.drag(this, event);
            }

            return false;
        },

        _mouseStop: function (event) {

            //If we are using droppables, inform the manager about the drop
            var element,
                that = this,
                elementInDom = false,
                dropped = false;
            if ($.ui.ddmanager && !this.options.dropBehaviour) {
                dropped = $.ui.ddmanager.drop(this, event);
            }

            //if a drop comes from outside (a sortable)
            if (this.dropped) {
                dropped = this.dropped;
                this.dropped = false;
            }

            //if the original element is no longer in the DOM don't bother to continue (see #8269)
            element = this.element[0];
            while (element && (element = element.parentNode)) {
                if (element === document) {
                    elementInDom = true;
                }
            }
            if (!elementInDom && this.options.helper === "original") {
                return false;
            }

            if ((this.options.revert === "invalid" && !dropped) || (this.options.revert === "valid" && dropped) || this.options.revert === true || ($.isFunction(this.options.revert) && this.options.revert.call(this.element, dropped))) {
                $(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration, 10), function () {
                    if (that._trigger("stop", event) !== false) {
                        that._clear();
                    }
                });
            } else {
                if (this._trigger("stop", event) !== false) {
                    this._clear();
                }
            }

            return false;
        },

        _mouseUp: function (event) {
            //Remove frame helpers
            $("div.ui-draggable-iframeFix").each(function () {
                this.parentNode.removeChild(this);
            });

            //If the ddmanager is used for droppables, inform the manager that dragging has stopped (see #5003)
            if ($.ui.ddmanager) {
                $.ui.ddmanager.dragStop(this, event);
            }

            return $.ui.mouse.prototype._mouseUp.call(this, event);
        },

        cancel: function () {

            if (this.helper.is(".ui-draggable-dragging")) {
                this._mouseUp({});
            } else {
                this._clear();
            }

            return this;

        },

        _getHandle: function (event) {
            return this.options.handle ?
                !!$(event.target).closest(this.element.find(this.options.handle)).length :
                true;
        },

        _createHelper: function (event) {

            var o = this.options,
                helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event])) : (o.helper === "clone" ? this.element.clone().removeAttr("id") : this.element);

            if (!helper.parents("body").length) {
                helper.appendTo((o.appendTo === "parent" ? this.element[0].parentNode : o.appendTo));
            }

            if (helper[0] !== this.element[0] && !(/(fixed|absolute)/).test(helper.css("position"))) {
                helper.css("position", "absolute");
            }

            return helper;

        },

        _adjustOffsetFromHelper: function (obj) {
            if (typeof obj === "string") {
                obj = obj.split(" ");
            }
            if ($.isArray(obj)) {
                obj = { left: +obj[0], top: +obj[1] || 0 };
            }
            if ("left" in obj) {
                this.offset.click.left = obj.left + this.margins.left;
            }
            if ("right" in obj) {
                this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
            }
            if ("top" in obj) {
                this.offset.click.top = obj.top + this.margins.top;
            }
            if ("bottom" in obj) {
                this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
            }
        },

        _getParentOffset: function () {

            //Get the offsetParent and cache its position
            this.offsetParent = this.helper.offsetParent();
            var po = this.offsetParent.offset();

            // This is a special case where we need to modify a offset calculated on start, since the following happened:
            // 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent
            // 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that
            //    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
            if (this.cssPosition === "absolute" && this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) {
                po.left += this.scrollParent.scrollLeft();
                po.top += this.scrollParent.scrollTop();
            }

            //This needs to be actually done for all browsers, since pageX/pageY includes this information
            //Ugly IE fix
            if ((this.offsetParent[0] === document.body) ||
                (this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() === "html" && $.ui.ie)) {
                po = { top: 0, left: 0 };
            }

            return {
                top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"), 10) || 0),
                left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"), 10) || 0)
            };

        },

        _getRelativeOffset: function () {

            if (this.cssPosition === "relative") {
                var p = this.element.position();
                return {
                    top: p.top - (parseInt(this.helper.css("top"), 10) || 0) + this.scrollParent.scrollTop(),
                    left: p.left - (parseInt(this.helper.css("left"), 10) || 0) + this.scrollParent.scrollLeft()
                };
            } else {
                return { top: 0, left: 0 };
            }

        },

        _cacheMargins: function () {
            this.margins = {
                left: (parseInt(this.element.css("marginLeft"), 10) || 0),
                top: (parseInt(this.element.css("marginTop"), 10) || 0),
                right: (parseInt(this.element.css("marginRight"), 10) || 0),
                bottom: (parseInt(this.element.css("marginBottom"), 10) || 0)
            };
        },

        _cacheHelperProportions: function () {
            this.helperProportions = {
                width: this.helper.outerWidth(),
                height: this.helper.outerHeight()
            };
        },

        _setContainment: function () {

            var over, c, ce,
                o = this.options;

            if (o.containment === "parent") {
                o.containment = this.helper[0].parentNode;
            }
            if (o.containment === "document" || o.containment === "window") {
                this.containment = [
                    o.containment === "document" ? 0 : $(window).scrollLeft() - this.offset.relative.left - this.offset.parent.left,
                    o.containment === "document" ? 0 : $(window).scrollTop() - this.offset.relative.top - this.offset.parent.top,
                    (o.containment === "document" ? 0 : $(window).scrollLeft()) + $(o.containment === "document" ? document : window).width() - this.helperProportions.width - this.margins.left,
                    (o.containment === "document" ? 0 : $(window).scrollTop()) + ($(o.containment === "document" ? document : window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top
                ];
            }

            if (!(/^(document|window|parent)$/).test(o.containment) && o.containment.constructor !== Array) {
                c = $(o.containment);
                ce = c[0];

                if (!ce) {
                    return;
                }

                over = ($(ce).css("overflow") !== "hidden");

                this.containment = [
                    (parseInt($(ce).css("borderLeftWidth"), 10) || 0) + (parseInt($(ce).css("paddingLeft"), 10) || 0),
                    (parseInt($(ce).css("borderTopWidth"), 10) || 0) + (parseInt($(ce).css("paddingTop"), 10) || 0),
                    (over ? Math.max(ce.scrollWidth, ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css("borderRightWidth"), 10) || 0) - (parseInt($(ce).css("paddingRight"), 10) || 0) - this.helperProportions.width - this.margins.left - this.margins.right,
                    (over ? Math.max(ce.scrollHeight, ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css("borderBottomWidth"), 10) || 0) - (parseInt($(ce).css("paddingBottom"), 10) || 0) - this.helperProportions.height - this.margins.top - this.margins.bottom
                ];
                this.relative_container = c;

            } else if (o.containment.constructor === Array) {
                this.containment = o.containment;
            }

        },

        _convertPositionTo: function (d, pos) {

            if (!pos) {
                pos = this.position;
            }

            var mod = d === "absolute" ? 1 : -1,
                scroll = this.cssPosition === "absolute" && !(this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);

            return {
                top: (
                    pos.top +                               // The absolute mouse position
                    this.offset.relative.top * mod +                    // Only for relative positioned nodes: Relative offset from element to offset parent
                    this.offset.parent.top * mod -                    // The offsetParent's offset without borders (offset + border)
                    ((this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : (scrollIsRootNode ? 0 : scroll.scrollTop())) * mod)
                ),
                left: (
                    pos.left +                                // The absolute mouse position
                    this.offset.relative.left * mod +                   // Only for relative positioned nodes: Relative offset from element to offset parent
                    this.offset.parent.left * mod -                   // The offsetParent's offset without borders (offset + border)
                    ((this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft()) * mod)
                )
            };

        },

        _generatePosition: function (event) {

            var containment, co, top, left,
                o = this.options,
                scroll = this.cssPosition === "absolute" && !(this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent,
                scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName),
                pageX = event.pageX,
                pageY = event.pageY;

            /*
             * - Position constraining -
             * Constrain the position to a mix of grid, containment.
             */

            if (this.originalPosition) { //If we are not dragging yet, we won't check for options
                if (this.containment) {
                    if (this.relative_container) {
                        co = this.relative_container.offset();
                        containment = [this.containment[0] + co.left,
                        this.containment[1] + co.top,
                        this.containment[2] + co.left,
                        this.containment[3] + co.top];
                    }
                    else {
                        containment = this.containment;
                    }

                    if (event.pageX - this.offset.click.left < containment[0]) {
                        pageX = containment[0] + this.offset.click.left;
                    }
                    if (event.pageY - this.offset.click.top < containment[1]) {
                        pageY = containment[1] + this.offset.click.top;
                    }
                    if (event.pageX - this.offset.click.left > containment[2]) {
                        pageX = containment[2] + this.offset.click.left;
                    }
                    if (event.pageY - this.offset.click.top > containment[3]) {
                        pageY = containment[3] + this.offset.click.top;
                    }
                }

                if (o.grid) {
                    //Check for grid elements set to 0 to prevent divide by 0 error causing invalid argument errors in IE (see ticket #6950)
                    top = o.grid[1] ? this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1] : this.originalPageY;
                    pageY = containment ? ((top - this.offset.click.top >= containment[1] || top - this.offset.click.top > containment[3]) ? top : ((top - this.offset.click.top >= containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;

                    left = o.grid[0] ? this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0] : this.originalPageX;
                    pageX = containment ? ((left - this.offset.click.left >= containment[0] || left - this.offset.click.left > containment[2]) ? left : ((left - this.offset.click.left >= containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;
                }

            }

            return {
                top: (
                    pageY -                                 // The absolute mouse position
                    this.offset.click.top -                       // Click offset (relative to the element)
                    this.offset.relative.top -                        // Only for relative positioned nodes: Relative offset from element to offset parent
                    this.offset.parent.top +                        // The offsetParent's offset without borders (offset + border)
                    ((this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : (scrollIsRootNode ? 0 : scroll.scrollTop())))
                ),
                left: (
                    pageX -                                 // The absolute mouse position
                    this.offset.click.left -                        // Click offset (relative to the element)
                    this.offset.relative.left -                       // Only for relative positioned nodes: Relative offset from element to offset parent
                    this.offset.parent.left +                       // The offsetParent's offset without borders (offset + border)
                    ((this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft()))
                )
            };

        },

        _clear: function () {
            this.helper.removeClass("ui-draggable-dragging");
            if (this.helper[0] !== this.element[0] && !this.cancelHelperRemoval) {
                this.helper.remove();
            }
            this.helper = null;
            this.cancelHelperRemoval = false;
        },

        // From now on bulk stuff - mainly helpers

        _trigger: function (type, event, ui) {
            ui = ui || this._uiHash();
            $.ui.plugin.call(this, type, [event, ui]);
            //The absolute position has to be recalculated after plugins
            if (type === "drag") {
                this.positionAbs = this._convertPositionTo("absolute");
            }
            return $.Widget.prototype._trigger.call(this, type, event, ui);
        },

        plugins: {},

        _uiHash: function () {
            return {
                helper: this.helper,
                position: this.position,
                originalPosition: this.originalPosition,
                offset: this.positionAbs
            };
        }

    });

    $.ui.plugin.add("draggable", "connectToSortable", {
        start: function (event, ui) {

            var inst = $(this).data("ui-draggable"), o = inst.options,
                uiSortable = $.extend({}, ui, { item: inst.element });
            inst.sortables = [];
            $(o.connectToSortable).each(function () {
                var sortable = $.data(this, "ui-sortable");
                if (sortable && !sortable.options.disabled) {
                    inst.sortables.push({
                        instance: sortable,
                        shouldRevert: sortable.options.revert
                    });
                    sortable.refreshPositions();  // Call the sortable's refreshPositions at drag start to refresh the containerCache since the sortable container cache is used in drag and needs to be up to date (this will ensure it's initialised as well as being kept in step with any changes that might have happened on the page).
                    sortable._trigger("activate", event, uiSortable);
                }
            });

        },
        stop: function (event, ui) {

            //If we are still over the sortable, we fake the stop event of the sortable, but also remove helper
            var inst = $(this).data("ui-draggable"),
                uiSortable = $.extend({}, ui, { item: inst.element });

            $.each(inst.sortables, function () {
                if (this.instance.isOver) {

                    this.instance.isOver = 0;

                    inst.cancelHelperRemoval = true; //Don't remove the helper in the draggable instance
                    this.instance.cancelHelperRemoval = false; //Remove it in the sortable instance (so sortable plugins like revert still work)

                    //The sortable revert is supported, and we have to set a temporary dropped variable on the draggable to support revert: "valid/invalid"
                    if (this.shouldRevert) {
                        this.instance.options.revert = this.shouldRevert;
                    }

                    //Trigger the stop of the sortable
                    this.instance._mouseStop(event);

                    this.instance.options.helper = this.instance.options._helper;

                    //If the helper has been the original item, restore properties in the sortable
                    if (inst.options.helper === "original") {
                        this.instance.currentItem.css({ top: "auto", left: "auto" });
                    }

                } else {
                    this.instance.cancelHelperRemoval = false; //Remove the helper in the sortable instance
                    this.instance._trigger("deactivate", event, uiSortable);
                }

            });

        },
        drag: function (event, ui) {

            var inst = $(this).data("ui-draggable"), that = this;

            $.each(inst.sortables, function () {

                var innermostIntersecting = false,
                    thisSortable = this;

                //Copy over some variables to allow calling the sortable's native _intersectsWith
                this.instance.positionAbs = inst.positionAbs;
                this.instance.helperProportions = inst.helperProportions;
                this.instance.offset.click = inst.offset.click;

                if (this.instance._intersectsWith(this.instance.containerCache)) {
                    innermostIntersecting = true;
                    $.each(inst.sortables, function () {
                        this.instance.positionAbs = inst.positionAbs;
                        this.instance.helperProportions = inst.helperProportions;
                        this.instance.offset.click = inst.offset.click;
                        if (this !== thisSortable &&
                            this.instance._intersectsWith(this.instance.containerCache) &&
                            $.contains(thisSortable.instance.element[0], this.instance.element[0])
                        ) {
                            innermostIntersecting = false;
                        }
                        return innermostIntersecting;
                    });
                }


                if (innermostIntersecting) {
                    //If it intersects, we use a little isOver variable and set it once, so our move-in stuff gets fired only once
                    if (!this.instance.isOver) {

                        this.instance.isOver = 1;
                        //Now we fake the start of dragging for the sortable instance,
                        //by cloning the list group item, appending it to the sortable and using it as inst.currentItem
                        //We can then fire the start event of the sortable with our passed browser event, and our own helper (so it doesn't create a new one)
                        this.instance.currentItem = $(that).clone().removeAttr("id").appendTo(this.instance.element).data("ui-sortable-item", true);
                        this.instance.options._helper = this.instance.options.helper; //Store helper option to later restore it
                        this.instance.options.helper = function () { return ui.helper[0]; };

                        event.target = this.instance.currentItem[0];
                        this.instance._mouseCapture(event, true);
                        this.instance._mouseStart(event, true, true);

                        //Because the browser event is way off the new appended portlet, we modify a couple of variables to reflect the changes
                        this.instance.offset.click.top = inst.offset.click.top;
                        this.instance.offset.click.left = inst.offset.click.left;
                        this.instance.offset.parent.left -= inst.offset.parent.left - this.instance.offset.parent.left;
                        this.instance.offset.parent.top -= inst.offset.parent.top - this.instance.offset.parent.top;

                        inst._trigger("toSortable", event);
                        inst.dropped = this.instance.element; //draggable revert needs that
                        //hack so receive/update callbacks work (mostly)
                        inst.currentItem = inst.element;
                        this.instance.fromOutside = inst;

                    }

                    //Provided we did all the previous steps, we can fire the drag event of the sortable on every draggable drag, when it intersects with the sortable
                    if (this.instance.currentItem) {
                        this.instance._mouseDrag(event);
                    }

                } else {

                    //If it doesn't intersect with the sortable, and it intersected before,
                    //we fake the drag stop of the sortable, but make sure it doesn't remove the helper by using cancelHelperRemoval
                    if (this.instance.isOver) {

                        this.instance.isOver = 0;
                        this.instance.cancelHelperRemoval = true;

                        //Prevent reverting on this forced stop
                        this.instance.options.revert = false;

                        // The out event needs to be triggered independently
                        this.instance._trigger("out", event, this.instance._uiHash(this.instance));

                        this.instance._mouseStop(event, true);
                        this.instance.options.helper = this.instance.options._helper;

                        //Now we remove our currentItem, the list group clone again, and the placeholder, and animate the helper back to it's original size
                        this.instance.currentItem.remove();
                        if (this.instance.placeholder) {
                            this.instance.placeholder.remove();
                        }

                        inst._trigger("fromSortable", event);
                        inst.dropped = false; //draggable revert needs that
                    }

                }

            });

        }
    });

    $.ui.plugin.add("draggable", "cursor", {
        start: function () {
            var t = $("body"), o = $(this).data("ui-draggable").options;
            if (t.css("cursor")) {
                o._cursor = t.css("cursor");
            }
            t.css("cursor", o.cursor);
        },
        stop: function () {
            var o = $(this).data("ui-draggable").options;
            if (o._cursor) {
                $("body").css("cursor", o._cursor);
            }
        }
    });

    $.ui.plugin.add("draggable", "opacity", {
        start: function (event, ui) {
            var t = $(ui.helper), o = $(this).data("ui-draggable").options;
            if (t.css("opacity")) {
                o._opacity = t.css("opacity");
            }
            t.css("opacity", o.opacity);
        },
        stop: function (event, ui) {
            var o = $(this).data("ui-draggable").options;
            if (o._opacity) {
                $(ui.helper).css("opacity", o._opacity);
            }
        }
    });

    $.ui.plugin.add("draggable", "scroll", {
        start: function () {
            var i = $(this).data("ui-draggable");
            if (i.scrollParent[0] !== document && i.scrollParent[0].tagName !== "HTML") {
                i.overflowOffset = i.scrollParent.offset();
            }
        },
        drag: function (event) {

            var i = $(this).data("ui-draggable"), o = i.options, scrolled = false;

            if (i.scrollParent[0] !== document && i.scrollParent[0].tagName !== "HTML") {

                if (!o.axis || o.axis !== "x") {
                    if ((i.overflowOffset.top + i.scrollParent[0].offsetHeight) - event.pageY < o.scrollSensitivity) {
                        i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop + o.scrollSpeed;
                    } else if (event.pageY - i.overflowOffset.top < o.scrollSensitivity) {
                        i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop - o.scrollSpeed;
                    }
                }

                if (!o.axis || o.axis !== "y") {
                    if ((i.overflowOffset.left + i.scrollParent[0].offsetWidth) - event.pageX < o.scrollSensitivity) {
                        i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft + o.scrollSpeed;
                    } else if (event.pageX - i.overflowOffset.left < o.scrollSensitivity) {
                        i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft - o.scrollSpeed;
                    }
                }

            } else {

                if (!o.axis || o.axis !== "x") {
                    if (event.pageY - $(document).scrollTop() < o.scrollSensitivity) {
                        scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
                    } else if ($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity) {
                        scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);
                    }
                }

                if (!o.axis || o.axis !== "y") {
                    if (event.pageX - $(document).scrollLeft() < o.scrollSensitivity) {
                        scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
                    } else if ($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity) {
                        scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);
                    }
                }

            }

            if (scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {
                $.ui.ddmanager.prepareOffsets(i, event);
            }

        }
    });

    $.ui.plugin.add("draggable", "snap", {
        start: function () {

            var i = $(this).data("ui-draggable"),
                o = i.options;

            i.snapElements = [];

            $(o.snap.constructor !== String ? (o.snap.items || ":data(ui-draggable)") : o.snap).each(function () {
                var $t = $(this),
                    $o = $t.offset();
                if (this !== i.element[0]) {
                    i.snapElements.push({
                        item: this,
                        width: $t.outerWidth(), height: $t.outerHeight(),
                        top: $o.top, left: $o.left
                    });
                }
            });

        },
        drag: function (event, ui) {

            var ts, bs, ls, rs, l, r, t, b, i, first,
                inst = $(this).data("ui-draggable"),
                o = inst.options,
                d = o.snapTolerance,
                x1 = ui.offset.left, x2 = x1 + inst.helperProportions.width,
                y1 = ui.offset.top, y2 = y1 + inst.helperProportions.height;

            for (i = inst.snapElements.length - 1; i >= 0; i--) {

                l = inst.snapElements[i].left;
                r = l + inst.snapElements[i].width;
                t = inst.snapElements[i].top;
                b = t + inst.snapElements[i].height;

                //Yes, I know, this is insane ;)
                if (!((l - d < x1 && x1 < r + d && t - d < y1 && y1 < b + d) || (l - d < x1 && x1 < r + d && t - d < y2 && y2 < b + d) || (l - d < x2 && x2 < r + d && t - d < y1 && y1 < b + d) || (l - d < x2 && x2 < r + d && t - d < y2 && y2 < b + d))) {
                    if (inst.snapElements[i].snapping) {
                        (inst.options.snap.release && inst.options.snap.release.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
                    }
                    inst.snapElements[i].snapping = false;
                    continue;
                }

                if (o.snapMode !== "inner") {
                    ts = Math.abs(t - y2) <= d;
                    bs = Math.abs(b - y1) <= d;
                    ls = Math.abs(l - x2) <= d;
                    rs = Math.abs(r - x1) <= d;
                    if (ts) {
                        ui.position.top = inst._convertPositionTo("relative", { top: t - inst.helperProportions.height, left: 0 }).top - inst.margins.top;
                    }
                    if (bs) {
                        ui.position.top = inst._convertPositionTo("relative", { top: b, left: 0 }).top - inst.margins.top;
                    }
                    if (ls) {
                        ui.position.left = inst._convertPositionTo("relative", { top: 0, left: l - inst.helperProportions.width }).left - inst.margins.left;
                    }
                    if (rs) {
                        ui.position.left = inst._convertPositionTo("relative", { top: 0, left: r }).left - inst.margins.left;
                    }
                }

                first = (ts || bs || ls || rs);

                if (o.snapMode !== "outer") {
                    ts = Math.abs(t - y1) <= d;
                    bs = Math.abs(b - y2) <= d;
                    ls = Math.abs(l - x1) <= d;
                    rs = Math.abs(r - x2) <= d;
                    if (ts) {
                        ui.position.top = inst._convertPositionTo("relative", { top: t, left: 0 }).top - inst.margins.top;
                    }
                    if (bs) {
                        ui.position.top = inst._convertPositionTo("relative", { top: b - inst.helperProportions.height, left: 0 }).top - inst.margins.top;
                    }
                    if (ls) {
                        ui.position.left = inst._convertPositionTo("relative", { top: 0, left: l }).left - inst.margins.left;
                    }
                    if (rs) {
                        ui.position.left = inst._convertPositionTo("relative", { top: 0, left: r - inst.helperProportions.width }).left - inst.margins.left;
                    }
                }

                if (!inst.snapElements[i].snapping && (ts || bs || ls || rs || first)) {
                    (inst.options.snap.snap && inst.options.snap.snap.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
                }
                inst.snapElements[i].snapping = (ts || bs || ls || rs || first);

            }

        }
    });

    $.ui.plugin.add("draggable", "stack", {
        start: function () {
            var min,
                o = this.data("ui-draggable").options,
                group = $.makeArray($(o.stack)).sort(function (a, b) {
                    return (parseInt($(a).css("zIndex"), 10) || 0) - (parseInt($(b).css("zIndex"), 10) || 0);
                });

            if (!group.length) { return; }

            min = parseInt($(group[0]).css("zIndex"), 10) || 0;
            $(group).each(function (i) {
                $(this).css("zIndex", min + i);
            });
            this.css("zIndex", (min + group.length));
        }
    });

    $.ui.plugin.add("draggable", "zIndex", {
        start: function (event, ui) {
            var t = $(ui.helper), o = $(this).data("ui-draggable").options;
            if (t.css("zIndex")) {
                o._zIndex = t.css("zIndex");
            }
            t.css("zIndex", o.zIndex);
        },
        stop: function (event, ui) {
            var o = $(this).data("ui-draggable").options;
            if (o._zIndex) {
                $(ui.helper).css("zIndex", o._zIndex);
            }
        }
    });

})(jQuery);

(function ($, undefined) {

    function isOverAxis(x, reference, size) {
        return (x > reference) && (x < (reference + size));
    }

    $.widget("ui.droppable", {
        version: "1.10.2",
        widgetEventPrefix: "drop",
        options: {
            accept: "*",
            activeClass: false,
            addClasses: true,
            greedy: false,
            hoverClass: false,
            scope: "default",
            tolerance: "intersect",

            // callbacks
            activate: null,
            deactivate: null,
            drop: null,
            out: null,
            over: null
        },
        _create: function () {

            var o = this.options,
                accept = o.accept;

            this.isover = false;
            this.isout = true;

            this.accept = $.isFunction(accept) ? accept : function (d) {
                return d.is(accept);
            };

            //Store the droppable's proportions
            this.proportions = { width: this.element[0].offsetWidth, height: this.element[0].offsetHeight };

            // Add the reference and positions to the manager
            $.ui.ddmanager.droppables[o.scope] = $.ui.ddmanager.droppables[o.scope] || [];
            $.ui.ddmanager.droppables[o.scope].push(this);

            (o.addClasses && this.element.addClass("ui-droppable"));

        },

        _destroy: function () {
            var i = 0,
                drop = $.ui.ddmanager.droppables[this.options.scope];

            for (; i < drop.length; i++) {
                if (drop[i] === this) {
                    drop.splice(i, 1);
                }
            }

            this.element.removeClass("ui-droppable ui-droppable-disabled");
        },

        _setOption: function (key, value) {

            if (key === "accept") {
                this.accept = $.isFunction(value) ? value : function (d) {
                    return d.is(value);
                };
            }
            $.Widget.prototype._setOption.apply(this, arguments);
        },

        _activate: function (event) {
            var draggable = $.ui.ddmanager.current;
            if (this.options.activeClass) {
                this.element.addClass(this.options.activeClass);
            }
            if (draggable) {
                this._trigger("activate", event, this.ui(draggable));
            }
        },

        _deactivate: function (event) {
            var draggable = $.ui.ddmanager.current;
            if (this.options.activeClass) {
                this.element.removeClass(this.options.activeClass);
            }
            if (draggable) {
                this._trigger("deactivate", event, this.ui(draggable));
            }
        },

        _over: function (event) {

            var draggable = $.ui.ddmanager.current;

            // Bail if draggable and droppable are same element
            if (!draggable || (draggable.currentItem || draggable.element)[0] === this.element[0]) {
                return;
            }

            if (this.accept.call(this.element[0], (draggable.currentItem || draggable.element))) {
                if (this.options.hoverClass) {
                    this.element.addClass(this.options.hoverClass);
                }
                this._trigger("over", event, this.ui(draggable));
            }

        },

        _out: function (event) {

            var draggable = $.ui.ddmanager.current;

            // Bail if draggable and droppable are same element
            if (!draggable || (draggable.currentItem || draggable.element)[0] === this.element[0]) {
                return;
            }

            if (this.accept.call(this.element[0], (draggable.currentItem || draggable.element))) {
                if (this.options.hoverClass) {
                    this.element.removeClass(this.options.hoverClass);
                }
                this._trigger("out", event, this.ui(draggable));
            }

        },

        _drop: function (event, custom) {

            var draggable = custom || $.ui.ddmanager.current,
                childrenIntersection = false;

            // Bail if draggable and droppable are same element
            if (!draggable || (draggable.currentItem || draggable.element)[0] === this.element[0]) {
                return false;
            }

            this.element.find(":data(ui-droppable)").not(".ui-draggable-dragging").each(function () {
                var inst = $.data(this, "ui-droppable");
                if (
                    inst.options.greedy &&
                    !inst.options.disabled &&
                    inst.options.scope === draggable.options.scope &&
                    inst.accept.call(inst.element[0], (draggable.currentItem || draggable.element)) &&
                    $.ui.intersect(draggable, $.extend(inst, { offset: inst.element.offset() }), inst.options.tolerance)
                ) { childrenIntersection = true; return false; }
            });
            if (childrenIntersection) {
                return false;
            }

            if (this.accept.call(this.element[0], (draggable.currentItem || draggable.element))) {
                if (this.options.activeClass) {
                    this.element.removeClass(this.options.activeClass);
                }
                if (this.options.hoverClass) {
                    this.element.removeClass(this.options.hoverClass);
                }
                this._trigger("drop", event, this.ui(draggable));
                return this.element;
            }

            return false;

        },

        ui: function (c) {
            return {
                draggable: (c.currentItem || c.element),
                helper: c.helper,
                position: c.position,
                offset: c.positionAbs
            };
        }

    });

    $.ui.intersect = function (draggable, droppable, toleranceMode) {

        if (!droppable.offset) {
            return false;
        }

        var draggableLeft, draggableTop,
            x1 = (draggable.positionAbs || draggable.position.absolute).left, x2 = x1 + draggable.helperProportions.width,
            y1 = (draggable.positionAbs || draggable.position.absolute).top, y2 = y1 + draggable.helperProportions.height,
            l = droppable.offset.left, r = l + droppable.proportions.width,
            t = droppable.offset.top, b = t + droppable.proportions.height;

        switch (toleranceMode) {
            case "fit":
                return (l <= x1 && x2 <= r && t <= y1 && y2 <= b);
            case "intersect":
                return (l < x1 + (draggable.helperProportions.width / 2) && // Right Half
                    x2 - (draggable.helperProportions.width / 2) < r && // Left Half
                    t < y1 + (draggable.helperProportions.height / 2) && // Bottom Half
                    y2 - (draggable.helperProportions.height / 2) < b); // Top Half
            case "pointer":
                draggableLeft = ((draggable.positionAbs || draggable.position.absolute).left + (draggable.clickOffset || draggable.offset.click).left);
                draggableTop = ((draggable.positionAbs || draggable.position.absolute).top + (draggable.clickOffset || draggable.offset.click).top);
                return isOverAxis(draggableTop, t, droppable.proportions.height) && isOverAxis(draggableLeft, l, droppable.proportions.width);
            case "touch":
                return (
                    (y1 >= t && y1 <= b) || // Top edge touching
                    (y2 >= t && y2 <= b) || // Bottom edge touching
                    (y1 < t && y2 > b)    // Surrounded vertically
                ) && (
                        (x1 >= l && x1 <= r) || // Left edge touching
                        (x2 >= l && x2 <= r) || // Right edge touching
                        (x1 < l && x2 > r)    // Surrounded horizontally
                    );
            default:
                return false;
        }

    };

    /*
      This manager tracks offsets of draggables and droppables
    */
    $.ui.ddmanager = {
        current: null,
        droppables: { "default": [] },
        prepareOffsets: function (t, event) {

            var i, j,
                m = $.ui.ddmanager.droppables[t.options.scope] || [],
                type = event ? event.type : null, // workaround for #2317
                list = (t.currentItem || t.element).find(":data(ui-droppable)").addBack();

            droppablesLoop: for (i = 0; i < m.length; i++) {

                //No disabled and non-accepted
                if (m[i].options.disabled || (t && !m[i].accept.call(m[i].element[0], (t.currentItem || t.element)))) {
                    continue;
                }

                // Filter out elements in the current dragged item
                for (j = 0; j < list.length; j++) {
                    if (list[j] === m[i].element[0]) {
                        m[i].proportions.height = 0;
                        continue droppablesLoop;
                    }
                }

                m[i].visible = m[i].element.css("display") !== "none";
                if (!m[i].visible) {
                    continue;
                }

                //Activate the droppable if used directly from draggables
                if (type === "mousedown") {
                    m[i]._activate.call(m[i], event);
                }

                m[i].offset = m[i].element.offset();
                m[i].proportions = { width: m[i].element[0].offsetWidth, height: m[i].element[0].offsetHeight };

            }

        },
        drop: function (draggable, event) {

            var dropped = false;
            // Create a copy of the droppables in case the list changes during the drop (#9116)
            $.each(($.ui.ddmanager.droppables[draggable.options.scope] || []).slice(), function () {

                if (!this.options) {
                    return;
                }
                if (!this.options.disabled && this.visible && $.ui.intersect(draggable, this, this.options.tolerance)) {
                    dropped = this._drop.call(this, event) || dropped;
                }

                if (!this.options.disabled && this.visible && this.accept.call(this.element[0], (draggable.currentItem || draggable.element))) {
                    this.isout = true;
                    this.isover = false;
                    this._deactivate.call(this, event);
                }

            });
            return dropped;

        },
        dragStart: function (draggable, event) {
            //Listen for scrolling so that if the dragging causes scrolling the position of the droppables can be recalculated (see #5003)
            draggable.element.parentsUntil("body").bind("scroll.droppable", function () {
                if (!draggable.options.refreshPositions) {
                    $.ui.ddmanager.prepareOffsets(draggable, event);
                }
            });
        },
        drag: function (draggable, event) {

            //If you have a highly dynamic page, you might try this option. It renders positions every time you move the mouse.
            if (draggable.options.refreshPositions) {
                $.ui.ddmanager.prepareOffsets(draggable, event);
            }

            //Run through all droppables and check their positions based on specific tolerance options
            $.each($.ui.ddmanager.droppables[draggable.options.scope] || [], function () {

                if (this.options.disabled || this.greedyChild || !this.visible) {
                    return;
                }

                var parentInstance, scope, parent,
                    intersects = $.ui.intersect(draggable, this, this.options.tolerance),
                    c = !intersects && this.isover ? "isout" : (intersects && !this.isover ? "isover" : null);
                if (!c) {
                    return;
                }

                if (this.options.greedy) {
                    // find droppable parents with same scope
                    scope = this.options.scope;
                    parent = this.element.parents(":data(ui-droppable)").filter(function () {
                        return $.data(this, "ui-droppable").options.scope === scope;
                    });

                    if (parent.length) {
                        parentInstance = $.data(parent[0], "ui-droppable");
                        parentInstance.greedyChild = (c === "isover");
                    }
                }

                // we just moved into a greedy child
                if (parentInstance && c === "isover") {
                    parentInstance.isover = false;
                    parentInstance.isout = true;
                    parentInstance._out.call(parentInstance, event);
                }

                this[c] = true;
                this[c === "isout" ? "isover" : "isout"] = false;
                this[c === "isover" ? "_over" : "_out"].call(this, event);

                // we just moved out of a greedy child
                if (parentInstance && c === "isout") {
                    parentInstance.isout = false;
                    parentInstance.isover = true;
                    parentInstance._over.call(parentInstance, event);
                }
            });

        },
        dragStop: function (draggable, event) {
            draggable.element.parentsUntil("body").unbind("scroll.droppable");
            //Call prepareOffsets one final time since IE does not fire return scroll events when overflow was caused by drag (see #5003)
            if (!draggable.options.refreshPositions) {
                $.ui.ddmanager.prepareOffsets(draggable, event);
            }
        }
    };

})(jQuery);

(function ($, undefined) {

    function num(v) {
        return parseInt(v, 10) || 0;
    }

    function isNumber(value) {
        return !isNaN(parseInt(value, 10));
    }

    $.widget("ui.resizable", $.ui.mouse, {
        version: "1.10.2",
        widgetEventPrefix: "resize",
        options: {
            alsoResize: false,
            animate: false,
            animateDuration: "slow",
            animateEasing: "swing",
            aspectRatio: false,
            autoHide: false,
            containment: false,
            ghost: false,
            grid: false,
            handles: "e,s,se",
            helper: false,
            maxHeight: null,
            maxWidth: null,
            minHeight: 10,
            minWidth: 10,
            // See #7960
            zIndex: 90,

            // callbacks
            resize: null,
            start: null,
            stop: null
        },
        _create: function () {

            var n, i, handle, axis, hname,
                that = this,
                o = this.options;
            this.element.addClass("ui-resizable");

            $.extend(this, {
                _aspectRatio: !!(o.aspectRatio),
                aspectRatio: o.aspectRatio,
                originalElement: this.element,
                _proportionallyResizeElements: [],
                _helper: o.helper || o.ghost || o.animate ? o.helper || "ui-resizable-helper" : null
            });

            //Wrap the element if it cannot hold child nodes
            if (this.element[0].nodeName.match(/canvas|textarea|input|select|button|img/i)) {

                //Create a wrapper element and set the wrapper to the new current internal element
                this.element.wrap(
                    $("<div class='ui-wrapper' style='overflow: hidden;'></div>").css({
                        position: this.element.css("position"),
                        width: this.element.outerWidth(),
                        height: this.element.outerHeight(),
                        top: this.element.css("top"),
                        left: this.element.css("left")
                    })
                );

                //Overwrite the original this.element
                this.element = this.element.parent().data(
                    "ui-resizable", this.element.data("ui-resizable")
                );

                this.elementIsWrapper = true;

                //Move margins to the wrapper
                this.element.css({ marginLeft: this.originalElement.css("marginLeft"), marginTop: this.originalElement.css("marginTop"), marginRight: this.originalElement.css("marginRight"), marginBottom: this.originalElement.css("marginBottom") });
                this.originalElement.css({ marginLeft: 0, marginTop: 0, marginRight: 0, marginBottom: 0 });

                //Prevent Safari textarea resize
                this.originalResizeStyle = this.originalElement.css("resize");
                this.originalElement.css("resize", "none");

                //Push the actual element to our proportionallyResize internal array
                this._proportionallyResizeElements.push(this.originalElement.css({ position: "static", zoom: 1, display: "block" }));

                // avoid IE jump (hard set the margin)
                this.originalElement.css({ margin: this.originalElement.css("margin") });

                // fix handlers offset
                this._proportionallyResize();

            }

            this.handles = o.handles || (!$(".ui-resizable-handle", this.element).length ? "e,s,se" : { n: ".ui-resizable-n", e: ".ui-resizable-e", s: ".ui-resizable-s", w: ".ui-resizable-w", se: ".ui-resizable-se", sw: ".ui-resizable-sw", ne: ".ui-resizable-ne", nw: ".ui-resizable-nw" });
            if (this.handles.constructor === String) {

                if (this.handles === "all") {
                    this.handles = "n,e,s,w,se,sw,ne,nw";
                }

                n = this.handles.split(",");
                this.handles = {};

                for (i = 0; i < n.length; i++) {

                    handle = $.trim(n[i]);
                    hname = "ui-resizable-" + handle;
                    axis = $("<div class='ui-resizable-handle " + hname + "'></div>");

                    // Apply zIndex to all handles - see #7960
                    axis.css({ zIndex: o.zIndex });

                    //TODO : What's going on here?
                    if ("se" === handle) {
                        axis.addClass("ui-icon ui-icon-gripsmall-diagonal-se");
                    }

                    //Insert into internal handles object and append to element
                    this.handles[handle] = ".ui-resizable-" + handle;
                    this.element.append(axis);
                }

            }

            this._renderAxis = function (target) {

                var i, axis, padPos, padWrapper;

                target = target || this.element;

                for (i in this.handles) {

                    if (this.handles[i].constructor === String) {
                        this.handles[i] = $(this.handles[i], this.element).show();
                    }

                    //Apply pad to wrapper element, needed to fix axis position (textarea, inputs, scrolls)
                    if (this.elementIsWrapper && this.originalElement[0].nodeName.match(/textarea|input|select|button/i)) {

                        axis = $(this.handles[i], this.element);

                        //Checking the correct pad and border
                        padWrapper = /sw|ne|nw|se|n|s/.test(i) ? axis.outerHeight() : axis.outerWidth();

                        //The padding type i have to apply...
                        padPos = ["padding",
                            /ne|nw|n/.test(i) ? "Top" :
                                /se|sw|s/.test(i) ? "Bottom" :
                                    /^e$/.test(i) ? "Right" : "Left"].join("");

                        target.css(padPos, padWrapper);

                        this._proportionallyResize();

                    }

                    //TODO: What's that good for? There's not anything to be executed left
                    if (!$(this.handles[i]).length) {
                        continue;
                    }
                }
            };

            //TODO: make renderAxis a prototype function
            this._renderAxis(this.element);

            this._handles = $(".ui-resizable-handle", this.element)
                .disableSelection();

            //Matching axis name
            this._handles.mouseover(function () {
                if (!that.resizing) {
                    if (this.className) {
                        axis = this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i);
                    }
                    //Axis, default = se
                    that.axis = axis && axis[1] ? axis[1] : "se";
                }
            });

            //If we want to auto hide the elements
            if (o.autoHide) {
                this._handles.hide();
                $(this.element)
                    .addClass("ui-resizable-autohide")
                    .mouseenter(function () {
                        if (o.disabled) {
                            return;
                        }
                        $(this).removeClass("ui-resizable-autohide");
                        that._handles.show();
                    })
                    .mouseleave(function () {
                        if (o.disabled) {
                            return;
                        }
                        if (!that.resizing) {
                            $(this).addClass("ui-resizable-autohide");
                            that._handles.hide();
                        }
                    });
            }

            //Initialize the mouse interaction
            this._mouseInit();

        },

        _destroy: function () {

            this._mouseDestroy();

            var wrapper,
                _destroy = function (exp) {
                    $(exp).removeClass("ui-resizable ui-resizable-disabled ui-resizable-resizing")
                        .removeData("resizable").removeData("ui-resizable").unbind(".resizable").find(".ui-resizable-handle").remove();
                };

            //TODO: Unwrap at same DOM position
            if (this.elementIsWrapper) {
                _destroy(this.element);
                wrapper = this.element;
                this.originalElement.css({
                    position: wrapper.css("position"),
                    width: wrapper.outerWidth(),
                    height: wrapper.outerHeight(),
                    top: wrapper.css("top"),
                    left: wrapper.css("left")
                }).insertAfter(wrapper);
                wrapper.remove();
            }

            this.originalElement.css("resize", this.originalResizeStyle);
            _destroy(this.originalElement);

            return this;
        },

        _mouseCapture: function (event) {
            var i, handle,
                capture = false;

            for (i in this.handles) {
                handle = $(this.handles[i])[0];
                if (handle === event.target || $.contains(handle, event.target)) {
                    capture = true;
                }
            }

            return !this.options.disabled && capture;
        },

        _mouseStart: function (event) {

            var curleft, curtop, cursor,
                o = this.options,
                iniPos = this.element.position(),
                el = this.element;

            this.resizing = true;

            // bugfix for http://dev.jquery.com/ticket/1749
            if ((/absolute/).test(el.css("position"))) {
                el.css({ position: "absolute", top: el.css("top"), left: el.css("left") });
            } else if (el.is(".ui-draggable")) {
                el.css({ position: "absolute", top: iniPos.top, left: iniPos.left });
            }

            this._renderProxy();

            curleft = num(this.helper.css("left"));
            curtop = num(this.helper.css("top"));

            if (o.containment) {
                curleft += $(o.containment).scrollLeft() || 0;
                curtop += $(o.containment).scrollTop() || 0;
            }

            //Store needed variables
            this.offset = this.helper.offset();
            this.position = { left: curleft, top: curtop };
            this.size = this._helper ? { width: el.outerWidth(), height: el.outerHeight() } : { width: el.width(), height: el.height() };
            this.originalSize = this._helper ? { width: el.outerWidth(), height: el.outerHeight() } : { width: el.width(), height: el.height() };
            this.originalPosition = { left: curleft, top: curtop };
            this.sizeDiff = { width: el.outerWidth() - el.width(), height: el.outerHeight() - el.height() };
            this.originalMousePosition = { left: event.pageX, top: event.pageY };

            //Aspect Ratio
            this.aspectRatio = (typeof o.aspectRatio === "number") ? o.aspectRatio : ((this.originalSize.width / this.originalSize.height) || 1);

            cursor = $(".ui-resizable-" + this.axis).css("cursor");
            $("body").css("cursor", cursor === "auto" ? this.axis + "-resize" : cursor);

            el.addClass("ui-resizable-resizing");
            this._propagate("start", event);
            return true;
        },

        _mouseDrag: function (event) {

            //Increase performance, avoid regex
            var data,
                el = this.helper, props = {},
                smp = this.originalMousePosition,
                a = this.axis,
                prevTop = this.position.top,
                prevLeft = this.position.left,
                prevWidth = this.size.width,
                prevHeight = this.size.height,
                dx = (event.pageX - smp.left) || 0,
                dy = (event.pageY - smp.top) || 0,
                trigger = this._change[a];

            if (!trigger) {
                return false;
            }

            // Calculate the attrs that will be change
            data = trigger.apply(this, [event, dx, dy]);

            // Put this in the mouseDrag handler since the user can start pressing shift while resizing
            this._updateVirtualBoundaries(event.shiftKey);
            if (this._aspectRatio || event.shiftKey) {
                data = this._updateRatio(data, event);
            }

            data = this._respectSize(data, event);

            this._updateCache(data);

            // plugins callbacks need to be called first
            this._propagate("resize", event);

            if (this.position.top !== prevTop) {
                props.top = this.position.top + "px";
            }
            if (this.position.left !== prevLeft) {
                props.left = this.position.left + "px";
            }
            if (this.size.width !== prevWidth) {
                props.width = this.size.width + "px";
            }
            if (this.size.height !== prevHeight) {
                props.height = this.size.height + "px";
            }
            el.css(props);

            if (!this._helper && this._proportionallyResizeElements.length) {
                this._proportionallyResize();
            }

            // Call the user callback if the element was resized
            if (!$.isEmptyObject(props)) {
                this._trigger("resize", event, this.ui());
            }

            return false;
        },

        _mouseStop: function (event) {

            this.resizing = false;
            var pr, ista, soffseth, soffsetw, s, left, top,
                o = this.options, that = this;

            if (this._helper) {

                pr = this._proportionallyResizeElements;
                ista = pr.length && (/textarea/i).test(pr[0].nodeName);
                soffseth = ista && $.ui.hasScroll(pr[0], "left") /* TODO - jump height */ ? 0 : that.sizeDiff.height;
                soffsetw = ista ? 0 : that.sizeDiff.width;

                s = { width: (that.helper.width() - soffsetw), height: (that.helper.height() - soffseth) };
                left = (parseInt(that.element.css("left"), 10) + (that.position.left - that.originalPosition.left)) || null;
                top = (parseInt(that.element.css("top"), 10) + (that.position.top - that.originalPosition.top)) || null;

                if (!o.animate) {
                    this.element.css($.extend(s, { top: top, left: left }));
                }

                that.helper.height(that.size.height);
                that.helper.width(that.size.width);

                if (this._helper && !o.animate) {
                    this._proportionallyResize();
                }
            }

            $("body").css("cursor", "auto");

            this.element.removeClass("ui-resizable-resizing");

            this._propagate("stop", event);

            if (this._helper) {
                this.helper.remove();
            }

            return false;

        },

        _updateVirtualBoundaries: function (forceAspectRatio) {
            var pMinWidth, pMaxWidth, pMinHeight, pMaxHeight, b,
                o = this.options;

            b = {
                minWidth: isNumber(o.minWidth) ? o.minWidth : 0,
                maxWidth: isNumber(o.maxWidth) ? o.maxWidth : Infinity,
                minHeight: isNumber(o.minHeight) ? o.minHeight : 0,
                maxHeight: isNumber(o.maxHeight) ? o.maxHeight : Infinity
            };

            if (this._aspectRatio || forceAspectRatio) {
                // We want to create an enclosing box whose aspect ration is the requested one
                // First, compute the "projected" size for each dimension based on the aspect ratio and other dimension
                pMinWidth = b.minHeight * this.aspectRatio;
                pMinHeight = b.minWidth / this.aspectRatio;
                pMaxWidth = b.maxHeight * this.aspectRatio;
                pMaxHeight = b.maxWidth / this.aspectRatio;

                if (pMinWidth > b.minWidth) {
                    b.minWidth = pMinWidth;
                }
                if (pMinHeight > b.minHeight) {
                    b.minHeight = pMinHeight;
                }
                if (pMaxWidth < b.maxWidth) {
                    b.maxWidth = pMaxWidth;
                }
                if (pMaxHeight < b.maxHeight) {
                    b.maxHeight = pMaxHeight;
                }
            }
            this._vBoundaries = b;
        },

        _updateCache: function (data) {
            this.offset = this.helper.offset();
            if (isNumber(data.left)) {
                this.position.left = data.left;
            }
            if (isNumber(data.top)) {
                this.position.top = data.top;
            }
            if (isNumber(data.height)) {
                this.size.height = data.height;
            }
            if (isNumber(data.width)) {
                this.size.width = data.width;
            }
        },

        _updateRatio: function (data) {

            var cpos = this.position,
                csize = this.size,
                a = this.axis;

            if (isNumber(data.height)) {
                data.width = (data.height * this.aspectRatio);
            } else if (isNumber(data.width)) {
                data.height = (data.width / this.aspectRatio);
            }

            if (a === "sw") {
                data.left = cpos.left + (csize.width - data.width);
                data.top = null;
            }
            if (a === "nw") {
                data.top = cpos.top + (csize.height - data.height);
                data.left = cpos.left + (csize.width - data.width);
            }

            return data;
        },

        _respectSize: function (data) {

            var o = this._vBoundaries,
                a = this.axis,
                ismaxw = isNumber(data.width) && o.maxWidth && (o.maxWidth < data.width), ismaxh = isNumber(data.height) && o.maxHeight && (o.maxHeight < data.height),
                isminw = isNumber(data.width) && o.minWidth && (o.minWidth > data.width), isminh = isNumber(data.height) && o.minHeight && (o.minHeight > data.height),
                dw = this.originalPosition.left + this.originalSize.width,
                dh = this.position.top + this.size.height,
                cw = /sw|nw|w/.test(a), ch = /nw|ne|n/.test(a);
            if (isminw) {
                data.width = o.minWidth;
            }
            if (isminh) {
                data.height = o.minHeight;
            }
            if (ismaxw) {
                data.width = o.maxWidth;
            }
            if (ismaxh) {
                data.height = o.maxHeight;
            }

            if (isminw && cw) {
                data.left = dw - o.minWidth;
            }
            if (ismaxw && cw) {
                data.left = dw - o.maxWidth;
            }
            if (isminh && ch) {
                data.top = dh - o.minHeight;
            }
            if (ismaxh && ch) {
                data.top = dh - o.maxHeight;
            }

            // fixing jump error on top/left - bug #2330
            if (!data.width && !data.height && !data.left && data.top) {
                data.top = null;
            } else if (!data.width && !data.height && !data.top && data.left) {
                data.left = null;
            }

            return data;
        },

        _proportionallyResize: function () {

            if (!this._proportionallyResizeElements.length) {
                return;
            }

            var i, j, borders, paddings, prel,
                element = this.helper || this.element;

            for (i = 0; i < this._proportionallyResizeElements.length; i++) {

                prel = this._proportionallyResizeElements[i];

                if (!this.borderDif) {
                    this.borderDif = [];
                    borders = [prel.css("borderTopWidth"), prel.css("borderRightWidth"), prel.css("borderBottomWidth"), prel.css("borderLeftWidth")];
                    paddings = [prel.css("paddingTop"), prel.css("paddingRight"), prel.css("paddingBottom"), prel.css("paddingLeft")];

                    for (j = 0; j < borders.length; j++) {
                        this.borderDif[j] = (parseInt(borders[j], 10) || 0) + (parseInt(paddings[j], 10) || 0);
                    }
                }

                prel.css({
                    height: (element.height() - this.borderDif[0] - this.borderDif[2]) || 0,
                    width: (element.width() - this.borderDif[1] - this.borderDif[3]) || 0
                });

            }

        },

        _renderProxy: function () {

            var el = this.element, o = this.options;
            this.elementOffset = el.offset();

            if (this._helper) {

                this.helper = this.helper || $("<div style='overflow:hidden;'></div>");

                this.helper.addClass(this._helper).css({
                    width: this.element.outerWidth() - 1,
                    height: this.element.outerHeight() - 1,
                    position: "absolute",
                    left: this.elementOffset.left + "px",
                    top: this.elementOffset.top + "px",
                    zIndex: ++o.zIndex //TODO: Don't modify option
                });

                this.helper
                    .appendTo("body")
                    .disableSelection();

            } else {
                this.helper = this.element;
            }

        },

        _change: {
            e: function (event, dx) {
                return { width: this.originalSize.width + dx };
            },
            w: function (event, dx) {
                var cs = this.originalSize, sp = this.originalPosition;
                return { left: sp.left + dx, width: cs.width - dx };
            },
            n: function (event, dx, dy) {
                var cs = this.originalSize, sp = this.originalPosition;
                return { top: sp.top + dy, height: cs.height - dy };
            },
            s: function (event, dx, dy) {
                return { height: this.originalSize.height + dy };
            },
            se: function (event, dx, dy) {
                return $.extend(this._change.s.apply(this, arguments), this._change.e.apply(this, [event, dx, dy]));
            },
            sw: function (event, dx, dy) {
                return $.extend(this._change.s.apply(this, arguments), this._change.w.apply(this, [event, dx, dy]));
            },
            ne: function (event, dx, dy) {
                return $.extend(this._change.n.apply(this, arguments), this._change.e.apply(this, [event, dx, dy]));
            },
            nw: function (event, dx, dy) {
                return $.extend(this._change.n.apply(this, arguments), this._change.w.apply(this, [event, dx, dy]));
            }
        },

        _propagate: function (n, event) {
            $.ui.plugin.call(this, n, [event, this.ui()]);
            (n !== "resize" && this._trigger(n, event, this.ui()));
        },

        plugins: {},

        ui: function () {
            return {
                originalElement: this.originalElement,
                element: this.element,
                helper: this.helper,
                position: this.position,
                size: this.size,
                originalSize: this.originalSize,
                originalPosition: this.originalPosition
            };
        }

    });

    /*
     * Resizable Extensions
     */

    $.ui.plugin.add("resizable", "animate", {

        stop: function (event) {
            var that = $(this).data("ui-resizable"),
                o = that.options,
                pr = that._proportionallyResizeElements,
                ista = pr.length && (/textarea/i).test(pr[0].nodeName),
                soffseth = ista && $.ui.hasScroll(pr[0], "left") /* TODO - jump height */ ? 0 : that.sizeDiff.height,
                soffsetw = ista ? 0 : that.sizeDiff.width,
                style = { width: (that.size.width - soffsetw), height: (that.size.height - soffseth) },
                left = (parseInt(that.element.css("left"), 10) + (that.position.left - that.originalPosition.left)) || null,
                top = (parseInt(that.element.css("top"), 10) + (that.position.top - that.originalPosition.top)) || null;

            that.element.animate(
                $.extend(style, top && left ? { top: top, left: left } : {}), {
                    duration: o.animateDuration,
                    easing: o.animateEasing,
                    step: function () {

                        var data = {
                            width: parseInt(that.element.css("width"), 10),
                            height: parseInt(that.element.css("height"), 10),
                            top: parseInt(that.element.css("top"), 10),
                            left: parseInt(that.element.css("left"), 10)
                        };

                        if (pr && pr.length) {
                            $(pr[0]).css({ width: data.width, height: data.height });
                        }

                        // propagating resize, and updating values for each animation step
                        that._updateCache(data);
                        that._propagate("resize", event);

                    }
                }
            );
        }

    });

    $.ui.plugin.add("resizable", "containment", {

        start: function () {
            var element, p, co, ch, cw, width, height,
                that = $(this).data("ui-resizable"),
                o = that.options,
                el = that.element,
                oc = o.containment,
                ce = (oc instanceof $) ? oc.get(0) : (/parent/.test(oc)) ? el.parent().get(0) : oc;

            if (!ce) {
                return;
            }

            that.containerElement = $(ce);

            if (/document/.test(oc) || oc === document) {
                that.containerOffset = { left: 0, top: 0 };
                that.containerPosition = { left: 0, top: 0 };

                that.parentData = {
                    element: $(document), left: 0, top: 0,
                    width: $(document).width(), height: $(document).height() || document.body.parentNode.scrollHeight
                };
            }

            // i'm a node, so compute top, left, right, bottom
            else {
                element = $(ce);
                p = [];
                $(["Top", "Right", "Left", "Bottom"]).each(function (i, name) { p[i] = num(element.css("padding" + name)); });

                that.containerOffset = element.offset();
                that.containerPosition = element.position();
                that.containerSize = { height: (element.innerHeight() - p[3]), width: (element.innerWidth() - p[1]) };

                co = that.containerOffset;
                ch = that.containerSize.height;
                cw = that.containerSize.width;
                width = ($.ui.hasScroll(ce, "left") ? ce.scrollWidth : cw);
                height = ($.ui.hasScroll(ce) ? ce.scrollHeight : ch);

                that.parentData = {
                    element: ce, left: co.left, top: co.top, width: width, height: height
                };
            }
        },

        resize: function (event) {
            var woset, hoset, isParent, isOffsetRelative,
                that = $(this).data("ui-resizable"),
                o = that.options,
                co = that.containerOffset, cp = that.position,
                pRatio = that._aspectRatio || event.shiftKey,
                cop = { top: 0, left: 0 }, ce = that.containerElement;

            if (ce[0] !== document && (/static/).test(ce.css("position"))) {
                cop = co;
            }

            if (cp.left < (that._helper ? co.left : 0)) {
                that.size.width = that.size.width + (that._helper ? (that.position.left - co.left) : (that.position.left - cop.left));
                if (pRatio) {
                    that.size.height = that.size.width / that.aspectRatio;
                }
                that.position.left = o.helper ? co.left : 0;
            }

            if (cp.top < (that._helper ? co.top : 0)) {
                that.size.height = that.size.height + (that._helper ? (that.position.top - co.top) : that.position.top);
                if (pRatio) {
                    that.size.width = that.size.height * that.aspectRatio;
                }
                that.position.top = that._helper ? co.top : 0;
            }

            that.offset.left = that.parentData.left + that.position.left;
            that.offset.top = that.parentData.top + that.position.top;

            woset = Math.abs((that._helper ? that.offset.left - cop.left : (that.offset.left - cop.left)) + that.sizeDiff.width);
            hoset = Math.abs((that._helper ? that.offset.top - cop.top : (that.offset.top - co.top)) + that.sizeDiff.height);

            isParent = that.containerElement.get(0) === that.element.parent().get(0);
            isOffsetRelative = /relative|absolute/.test(that.containerElement.css("position"));

            if (isParent && isOffsetRelative) {
                woset -= that.parentData.left;
            }

            if (woset + that.size.width >= that.parentData.width) {
                that.size.width = that.parentData.width - woset;
                if (pRatio) {
                    that.size.height = that.size.width / that.aspectRatio;
                }
            }

            if (hoset + that.size.height >= that.parentData.height) {
                that.size.height = that.parentData.height - hoset;
                if (pRatio) {
                    that.size.width = that.size.height * that.aspectRatio;
                }
            }
        },

        stop: function () {
            var that = $(this).data("ui-resizable"),
                o = that.options,
                co = that.containerOffset,
                cop = that.containerPosition,
                ce = that.containerElement,
                helper = $(that.helper),
                ho = helper.offset(),
                w = helper.outerWidth() - that.sizeDiff.width,
                h = helper.outerHeight() - that.sizeDiff.height;

            if (that._helper && !o.animate && (/relative/).test(ce.css("position"))) {
                $(this).css({ left: ho.left - cop.left - co.left, width: w, height: h });
            }

            if (that._helper && !o.animate && (/static/).test(ce.css("position"))) {
                $(this).css({ left: ho.left - cop.left - co.left, width: w, height: h });
            }

        }
    });

    $.ui.plugin.add("resizable", "alsoResize", {

        start: function () {
            var that = $(this).data("ui-resizable"),
                o = that.options,
                _store = function (exp) {
                    $(exp).each(function () {
                        var el = $(this);
                        el.data("ui-resizable-alsoresize", {
                            width: parseInt(el.width(), 10), height: parseInt(el.height(), 10),
                            left: parseInt(el.css("left"), 10), top: parseInt(el.css("top"), 10)
                        });
                    });
                };

            if (typeof (o.alsoResize) === "object" && !o.alsoResize.parentNode) {
                if (o.alsoResize.length) { o.alsoResize = o.alsoResize[0]; _store(o.alsoResize); }
                else { $.each(o.alsoResize, function (exp) { _store(exp); }); }
            } else {
                _store(o.alsoResize);
            }
        },

        resize: function (event, ui) {
            var that = $(this).data("ui-resizable"),
                o = that.options,
                os = that.originalSize,
                op = that.originalPosition,
                delta = {
                    height: (that.size.height - os.height) || 0, width: (that.size.width - os.width) || 0,
                    top: (that.position.top - op.top) || 0, left: (that.position.left - op.left) || 0
                },

                _alsoResize = function (exp, c) {
                    $(exp).each(function () {
                        var el = $(this), start = $(this).data("ui-resizable-alsoresize"), style = {},
                            css = c && c.length ? c : el.parents(ui.originalElement[0]).length ? ["width", "height"] : ["width", "height", "top", "left"];

                        $.each(css, function (i, prop) {
                            var sum = (start[prop] || 0) + (delta[prop] || 0);
                            if (sum && sum >= 0) {
                                style[prop] = sum || null;
                            }
                        });

                        el.css(style);
                    });
                };

            if (typeof (o.alsoResize) === "object" && !o.alsoResize.nodeType) {
                $.each(o.alsoResize, function (exp, c) { _alsoResize(exp, c); });
            } else {
                _alsoResize(o.alsoResize);
            }
        },

        stop: function () {
            $(this).removeData("resizable-alsoresize");
        }
    });

    $.ui.plugin.add("resizable", "ghost", {

        start: function () {

            var that = $(this).data("ui-resizable"), o = that.options, cs = that.size;

            that.ghost = that.originalElement.clone();
            that.ghost
                .css({ opacity: 0.25, display: "block", position: "relative", height: cs.height, width: cs.width, margin: 0, left: 0, top: 0 })
                .addClass("ui-resizable-ghost")
                .addClass(typeof o.ghost === "string" ? o.ghost : "");

            that.ghost.appendTo(that.helper);

        },

        resize: function () {
            var that = $(this).data("ui-resizable");
            if (that.ghost) {
                that.ghost.css({ position: "relative", height: that.size.height, width: that.size.width });
            }
        },

        stop: function () {
            var that = $(this).data("ui-resizable");
            if (that.ghost && that.helper) {
                that.helper.get(0).removeChild(that.ghost.get(0));
            }
        }

    });

    $.ui.plugin.add("resizable", "grid", {

        resize: function () {
            var that = $(this).data("ui-resizable"),
                o = that.options,
                cs = that.size,
                os = that.originalSize,
                op = that.originalPosition,
                a = that.axis,
                grid = typeof o.grid === "number" ? [o.grid, o.grid] : o.grid,
                gridX = (grid[0] || 1),
                gridY = (grid[1] || 1),
                ox = Math.round((cs.width - os.width) / gridX) * gridX,
                oy = Math.round((cs.height - os.height) / gridY) * gridY,
                newWidth = os.width + ox,
                newHeight = os.height + oy,
                isMaxWidth = o.maxWidth && (o.maxWidth < newWidth),
                isMaxHeight = o.maxHeight && (o.maxHeight < newHeight),
                isMinWidth = o.minWidth && (o.minWidth > newWidth),
                isMinHeight = o.minHeight && (o.minHeight > newHeight);

            o.grid = grid;

            if (isMinWidth) {
                newWidth = newWidth + gridX;
            }
            if (isMinHeight) {
                newHeight = newHeight + gridY;
            }
            if (isMaxWidth) {
                newWidth = newWidth - gridX;
            }
            if (isMaxHeight) {
                newHeight = newHeight - gridY;
            }

            if (/^(se|s|e)$/.test(a)) {
                that.size.width = newWidth;
                that.size.height = newHeight;
            } else if (/^(ne)$/.test(a)) {
                that.size.width = newWidth;
                that.size.height = newHeight;
                that.position.top = op.top - oy;
            } else if (/^(sw)$/.test(a)) {
                that.size.width = newWidth;
                that.size.height = newHeight;
                that.position.left = op.left - ox;
            } else {
                that.size.width = newWidth;
                that.size.height = newHeight;
                that.position.top = op.top - oy;
                that.position.left = op.left - ox;
            }
        }

    });

})(jQuery);

(function ($, undefined) {

    $.widget("ui.selectable", $.ui.mouse, {
        version: "1.10.2",
        options: {
            appendTo: "body",
            autoRefresh: true,
            distance: 0,
            filter: "*",
            tolerance: "touch",

            // callbacks
            selected: null,
            selecting: null,
            start: null,
            stop: null,
            unselected: null,
            unselecting: null
        },
        _create: function () {
            var selectees,
                that = this;

            this.element.addClass("ui-selectable");

            this.dragged = false;

            // cache selectee children based on filter
            this.refresh = function () {
                selectees = $(that.options.filter, that.element[0]);
                selectees.addClass("ui-selectee");
                selectees.each(function () {
                    var $this = $(this),
                        pos = $this.offset();
                    $.data(this, "selectable-item", {
                        element: this,
                        $element: $this,
                        left: pos.left,
                        top: pos.top,
                        right: pos.left + $this.outerWidth(),
                        bottom: pos.top + $this.outerHeight(),
                        startselected: false,
                        selected: $this.hasClass("ui-selected"),
                        selecting: $this.hasClass("ui-selecting"),
                        unselecting: $this.hasClass("ui-unselecting")
                    });
                });
            };
            this.refresh();

            this.selectees = selectees.addClass("ui-selectee");

            this._mouseInit();

            this.helper = $("<div class='ui-selectable-helper'></div>");
        },

        _destroy: function () {
            this.selectees
                .removeClass("ui-selectee")
                .removeData("selectable-item");
            this.element
                .removeClass("ui-selectable ui-selectable-disabled");
            this._mouseDestroy();
        },

        _mouseStart: function (event) {
            var that = this,
                options = this.options;

            this.opos = [event.pageX, event.pageY];

            if (this.options.disabled) {
                return;
            }

            this.selectees = $(options.filter, this.element[0]);

            this._trigger("start", event);

            $(options.appendTo).append(this.helper);
            // position helper (lasso)
            this.helper.css({
                "left": event.pageX,
                "top": event.pageY,
                "width": 0,
                "height": 0
            });

            if (options.autoRefresh) {
                this.refresh();
            }

            this.selectees.filter(".ui-selected").each(function () {
                var selectee = $.data(this, "selectable-item");
                selectee.startselected = true;
                if (!event.metaKey && !event.ctrlKey) {
                    selectee.$element.removeClass("ui-selected");
                    selectee.selected = false;
                    selectee.$element.addClass("ui-unselecting");
                    selectee.unselecting = true;
                    // selectable UNSELECTING callback
                    that._trigger("unselecting", event, {
                        unselecting: selectee.element
                    });
                }
            });

            $(event.target).parents().addBack().each(function () {
                var doSelect,
                    selectee = $.data(this, "selectable-item");
                if (selectee) {
                    doSelect = (!event.metaKey && !event.ctrlKey) || !selectee.$element.hasClass("ui-selected");
                    selectee.$element
                        .removeClass(doSelect ? "ui-unselecting" : "ui-selected")
                        .addClass(doSelect ? "ui-selecting" : "ui-unselecting");
                    selectee.unselecting = !doSelect;
                    selectee.selecting = doSelect;
                    selectee.selected = doSelect;
                    // selectable (UN)SELECTING callback
                    if (doSelect) {
                        that._trigger("selecting", event, {
                            selecting: selectee.element
                        });
                    } else {
                        that._trigger("unselecting", event, {
                            unselecting: selectee.element
                        });
                    }
                    return false;
                }
            });

        },

        _mouseDrag: function (event) {

            this.dragged = true;

            if (this.options.disabled) {
                return;
            }

            var tmp,
                that = this,
                options = this.options,
                x1 = this.opos[0],
                y1 = this.opos[1],
                x2 = event.pageX,
                y2 = event.pageY;

            if (x1 > x2) { tmp = x2; x2 = x1; x1 = tmp; }
            if (y1 > y2) { tmp = y2; y2 = y1; y1 = tmp; }
            this.helper.css({ left: x1, top: y1, width: x2 - x1, height: y2 - y1 });

            this.selectees.each(function () {
                var selectee = $.data(this, "selectable-item"),
                    hit = false;

                //prevent helper from being selected if appendTo: selectable
                if (!selectee || selectee.element === that.element[0]) {
                    return;
                }

                if (options.tolerance === "touch") {
                    hit = (!(selectee.left > x2 || selectee.right < x1 || selectee.top > y2 || selectee.bottom < y1));
                } else if (options.tolerance === "fit") {
                    hit = (selectee.left > x1 && selectee.right < x2 && selectee.top > y1 && selectee.bottom < y2);
                }

                if (hit) {
                    // SELECT
                    if (selectee.selected) {
                        selectee.$element.removeClass("ui-selected");
                        selectee.selected = false;
                    }
                    if (selectee.unselecting) {
                        selectee.$element.removeClass("ui-unselecting");
                        selectee.unselecting = false;
                    }
                    if (!selectee.selecting) {
                        selectee.$element.addClass("ui-selecting");
                        selectee.selecting = true;
                        // selectable SELECTING callback
                        that._trigger("selecting", event, {
                            selecting: selectee.element
                        });
                    }
                } else {
                    // UNSELECT
                    if (selectee.selecting) {
                        if ((event.metaKey || event.ctrlKey) && selectee.startselected) {
                            selectee.$element.removeClass("ui-selecting");
                            selectee.selecting = false;
                            selectee.$element.addClass("ui-selected");
                            selectee.selected = true;
                        } else {
                            selectee.$element.removeClass("ui-selecting");
                            selectee.selecting = false;
                            if (selectee.startselected) {
                                selectee.$element.addClass("ui-unselecting");
                                selectee.unselecting = true;
                            }
                            // selectable UNSELECTING callback
                            that._trigger("unselecting", event, {
                                unselecting: selectee.element
                            });
                        }
                    }
                    if (selectee.selected) {
                        if (!event.metaKey && !event.ctrlKey && !selectee.startselected) {
                            selectee.$element.removeClass("ui-selected");
                            selectee.selected = false;

                            selectee.$element.addClass("ui-unselecting");
                            selectee.unselecting = true;
                            // selectable UNSELECTING callback
                            that._trigger("unselecting", event, {
                                unselecting: selectee.element
                            });
                        }
                    }
                }
            });

            return false;
        },

        _mouseStop: function (event) {
            var that = this;

            this.dragged = false;

            $(".ui-unselecting", this.element[0]).each(function () {
                var selectee = $.data(this, "selectable-item");
                selectee.$element.removeClass("ui-unselecting");
                selectee.unselecting = false;
                selectee.startselected = false;
                that._trigger("unselected", event, {
                    unselected: selectee.element
                });
            });
            $(".ui-selecting", this.element[0]).each(function () {
                var selectee = $.data(this, "selectable-item");
                selectee.$element.removeClass("ui-selecting").addClass("ui-selected");
                selectee.selecting = false;
                selectee.selected = true;
                selectee.startselected = true;
                that._trigger("selected", event, {
                    selected: selectee.element
                });
            });
            this._trigger("stop", event);

            this.helper.remove();

            return false;
        }

    });

})(jQuery);

(function ($, undefined) {

    /*jshint loopfunc: true */

    function isOverAxis(x, reference, size) {
        return (x > reference) && (x < (reference + size));
    }

    function isFloating(item) {
        return (/left|right/).test(item.css("float")) || (/inline|table-cell/).test(item.css("display"));
    }

    $.widget("ui.sortable", $.ui.mouse, {
        version: "1.10.2",
        widgetEventPrefix: "sort",
        ready: false,
        options: {
            appendTo: "parent",
            axis: false,
            connectWith: false,
            containment: false,
            cursor: "auto",
            cursorAt: false,
            dropOnEmpty: true,
            forcePlaceholderSize: false,
            forceHelperSize: false,
            grid: false,
            handle: false,
            helper: "original",
            items: "> *",
            opacity: false,
            placeholder: false,
            revert: false,
            scroll: true,
            scrollSensitivity: 20,
            scrollSpeed: 20,
            scope: "default",
            tolerance: "intersect",
            zIndex: 1000,

            // callbacks
            activate: null,
            beforeStop: null,
            change: null,
            deactivate: null,
            out: null,
            over: null,
            receive: null,
            remove: null,
            sort: null,
            start: null,
            stop: null,
            update: null
        },
        _create: function () {

            var o = this.options;
            this.containerCache = {};
            this.element.addClass("ui-sortable");

            //Get the items
            this.refresh();

            //Let's determine if the items are being displayed horizontally
            this.floating = this.items.length ? o.axis === "x" || isFloating(this.items[0].item) : false;

            //Let's determine the parent's offset
            this.offset = this.element.offset();

            //Initialize mouse events for interaction
            this._mouseInit();

            //We're ready to go
            this.ready = true;

        },

        _destroy: function () {
            this.element
                .removeClass("ui-sortable ui-sortable-disabled");
            this._mouseDestroy();

            for (var i = this.items.length - 1; i >= 0; i--) {
                this.items[i].item.removeData(this.widgetName + "-item");
            }

            return this;
        },

        _setOption: function (key, value) {
            if (key === "disabled") {
                this.options[key] = value;

                this.widget().toggleClass("ui-sortable-disabled", !!value);
            } else {
                // Don't call widget base _setOption for disable as it adds ui-state-disabled class
                $.Widget.prototype._setOption.apply(this, arguments);
            }
        },

        _mouseCapture: function (event, overrideHandle) {
            var currentItem = null,
                validHandle = false,
                that = this;

            if (this.reverting) {
                return false;
            }

            if (this.options.disabled || this.options.type === "static") {
                return false;
            }

            //We have to refresh the items data once first
            this._refreshItems(event);

            //Find out if the clicked node (or one of its parents) is a actual item in this.items
            $(event.target).parents().each(function () {
                if ($.data(this, that.widgetName + "-item") === that) {
                    currentItem = $(this);
                    return false;
                }
            });
            if ($.data(event.target, that.widgetName + "-item") === that) {
                currentItem = $(event.target);
            }

            if (!currentItem) {
                return false;
            }
            if (this.options.handle && !overrideHandle) {
                $(this.options.handle, currentItem).find("*").addBack().each(function () {
                    if (this === event.target) {
                        validHandle = true;
                    }
                });
                if (!validHandle) {
                    return false;
                }
            }

            this.currentItem = currentItem;
            this._removeCurrentsFromItems();
            return true;

        },

        _mouseStart: function (event, overrideHandle, noActivation) {

            var i, body,
                o = this.options;

            this.currentContainer = this;

            //We only need to call refreshPositions, because the refreshItems call has been moved to mouseCapture
            this.refreshPositions();

            //Create and append the visible helper
            this.helper = this._createHelper(event);

            //Cache the helper size
            this._cacheHelperProportions();

            /*
             * - Position generation -
             * This block generates everything position related - it's the core of draggables.
             */

            //Cache the margins of the original element
            this._cacheMargins();

            //Get the next scrolling parent
            this.scrollParent = this.helper.scrollParent();

            //The element's absolute position on the page minus margins
            this.offset = this.currentItem.offset();
            this.offset = {
                top: this.offset.top - this.margins.top,
                left: this.offset.left - this.margins.left
            };

            $.extend(this.offset, {
                click: { //Where the click happened, relative to the element
                    left: event.pageX - this.offset.left,
                    top: event.pageY - this.offset.top
                },
                parent: this._getParentOffset(),
                relative: this._getRelativeOffset() //This is a relative to absolute position minus the actual position calculation - only used for relative positioned helper
            });

            // Only after we got the offset, we can change the helper's position to absolute
            // TODO: Still need to figure out a way to make relative sorting possible
            this.helper.css("position", "absolute");
            this.cssPosition = this.helper.css("position");

            //Generate the original position
            this.originalPosition = this._generatePosition(event);
            this.originalPageX = event.pageX;
            this.originalPageY = event.pageY;

            //Adjust the mouse offset relative to the helper if "cursorAt" is supplied
            (o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));

            //Cache the former DOM position
            this.domPosition = { prev: this.currentItem.prev()[0], parent: this.currentItem.parent()[0] };

            //If the helper is not the original, hide the original so it's not playing any role during the drag, won't cause anything bad this way
            if (this.helper[0] !== this.currentItem[0]) {
                this.currentItem.hide();
            }

            //Create the placeholder
            this._createPlaceholder();

            //Set a containment if given in the options
            if (o.containment) {
                this._setContainment();
            }

            if (o.cursor && o.cursor !== "auto") { // cursor option
                body = this.document.find("body");

                // support: IE
                this.storedCursor = body.css("cursor");
                body.css("cursor", o.cursor);

                this.storedStylesheet = $("<style>*{ cursor: " + o.cursor + " !important; }</style>").appendTo(body);
            }

            if (o.opacity) { // opacity option
                if (this.helper.css("opacity")) {
                    this._storedOpacity = this.helper.css("opacity");
                }
                this.helper.css("opacity", o.opacity);
            }

            if (o.zIndex) { // zIndex option
                if (this.helper.css("zIndex")) {
                    this._storedZIndex = this.helper.css("zIndex");
                }
                this.helper.css("zIndex", o.zIndex);
            }

            //Prepare scrolling
            if (this.scrollParent[0] !== document && this.scrollParent[0].tagName !== "HTML") {
                this.overflowOffset = this.scrollParent.offset();
            }

            //Call callbacks
            this._trigger("start", event, this._uiHash());

            //Recache the helper size
            if (!this._preserveHelperProportions) {
                this._cacheHelperProportions();
            }


            //Post "activate" events to possible containers
            if (!noActivation) {
                for (i = this.containers.length - 1; i >= 0; i--) {
                    this.containers[i]._trigger("activate", event, this._uiHash(this));
                }
            }

            //Prepare possible droppables
            if ($.ui.ddmanager) {
                $.ui.ddmanager.current = this;
            }

            if ($.ui.ddmanager && !o.dropBehaviour) {
                $.ui.ddmanager.prepareOffsets(this, event);
            }

            this.dragging = true;

            this.helper.addClass("ui-sortable-helper");
            this._mouseDrag(event); //Execute the drag once - this causes the helper not to be visible before getting its correct position
            return true;

        },

        _mouseDrag: function (event) {
            var i, item, itemElement, intersection,
                o = this.options,
                scrolled = false;

            //Compute the helpers position
            this.position = this._generatePosition(event);
            this.positionAbs = this._convertPositionTo("absolute");

            if (!this.lastPositionAbs) {
                this.lastPositionAbs = this.positionAbs;
            }

            //Do scrolling
            if (this.options.scroll) {
                if (this.scrollParent[0] !== document && this.scrollParent[0].tagName !== "HTML") {

                    if ((this.overflowOffset.top + this.scrollParent[0].offsetHeight) - event.pageY < o.scrollSensitivity) {
                        this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop + o.scrollSpeed;
                    } else if (event.pageY - this.overflowOffset.top < o.scrollSensitivity) {
                        this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop - o.scrollSpeed;
                    }

                    if ((this.overflowOffset.left + this.scrollParent[0].offsetWidth) - event.pageX < o.scrollSensitivity) {
                        this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft + o.scrollSpeed;
                    } else if (event.pageX - this.overflowOffset.left < o.scrollSensitivity) {
                        this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft - o.scrollSpeed;
                    }

                } else {

                    if (event.pageY - $(document).scrollTop() < o.scrollSensitivity) {
                        scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
                    } else if ($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity) {
                        scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);
                    }

                    if (event.pageX - $(document).scrollLeft() < o.scrollSensitivity) {
                        scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
                    } else if ($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity) {
                        scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);
                    }

                }

                if (scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {
                    $.ui.ddmanager.prepareOffsets(this, event);
                }
            }

            //Regenerate the absolute position used for position checks
            this.positionAbs = this._convertPositionTo("absolute");

            //Set the helper position
            if (!this.options.axis || this.options.axis !== "y") {
                this.helper[0].style.left = this.position.left + "px";
            }
            if (!this.options.axis || this.options.axis !== "x") {
                this.helper[0].style.top = this.position.top + "px";
            }

            //Rearrange
            for (i = this.items.length - 1; i >= 0; i--) {

                //Cache variables and intersection, continue if no intersection
                item = this.items[i];
                itemElement = item.item[0];
                intersection = this._intersectsWithPointer(item);
                if (!intersection) {
                    continue;
                }

                // Only put the placeholder inside the current Container, skip all
                // items form other containers. This works because when moving
                // an item from one container to another the
                // currentContainer is switched before the placeholder is moved.
                //
                // Without this moving items in "sub-sortables" can cause the placeholder to jitter
                // beetween the outer and inner container.
                if (item.instance !== this.currentContainer) {
                    continue;
                }

                // cannot intersect with itself
                // no useless actions that have been done before
                // no action if the item moved is the parent of the item checked
                if (itemElement !== this.currentItem[0] &&
                    this.placeholder[intersection === 1 ? "next" : "prev"]()[0] !== itemElement &&
                    !$.contains(this.placeholder[0], itemElement) &&
                    (this.options.type === "semi-dynamic" ? !$.contains(this.element[0], itemElement) : true)
                ) {

                    this.direction = intersection === 1 ? "down" : "up";

                    if (this.options.tolerance === "pointer" || this._intersectsWithSides(item)) {
                        this._rearrange(event, item);
                    } else {
                        break;
                    }

                    this._trigger("change", event, this._uiHash());
                    break;
                }
            }

            //Post events to containers
            this._contactContainers(event);

            //Interconnect with droppables
            if ($.ui.ddmanager) {
                $.ui.ddmanager.drag(this, event);
            }

            //Call callbacks
            this._trigger("sort", event, this._uiHash());

            this.lastPositionAbs = this.positionAbs;
            return false;

        },

        _mouseStop: function (event, noPropagation) {

            if (!event) {
                return;
            }

            //If we are using droppables, inform the manager about the drop
            if ($.ui.ddmanager && !this.options.dropBehaviour) {
                $.ui.ddmanager.drop(this, event);
            }

            if (this.options.revert) {
                var that = this,
                    cur = this.placeholder.offset(),
                    axis = this.options.axis,
                    animation = {};

                if (!axis || axis === "x") {
                    animation.left = cur.left - this.offset.parent.left - this.margins.left + (this.offsetParent[0] === document.body ? 0 : this.offsetParent[0].scrollLeft);
                }
                if (!axis || axis === "y") {
                    animation.top = cur.top - this.offset.parent.top - this.margins.top + (this.offsetParent[0] === document.body ? 0 : this.offsetParent[0].scrollTop);
                }
                this.reverting = true;
                $(this.helper).animate(animation, parseInt(this.options.revert, 10) || 500, function () {
                    that._clear(event);
                });
            } else {
                this._clear(event, noPropagation);
            }

            return false;

        },

        cancel: function () {

            if (this.dragging) {

                this._mouseUp({ target: null });

                if (this.options.helper === "original") {
                    this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");
                } else {
                    this.currentItem.show();
                }

                //Post deactivating events to containers
                for (var i = this.containers.length - 1; i >= 0; i--) {
                    this.containers[i]._trigger("deactivate", null, this._uiHash(this));
                    if (this.containers[i].containerCache.over) {
                        this.containers[i]._trigger("out", null, this._uiHash(this));
                        this.containers[i].containerCache.over = 0;
                    }
                }

            }

            if (this.placeholder) {
                //$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!
                if (this.placeholder[0].parentNode) {
                    this.placeholder[0].parentNode.removeChild(this.placeholder[0]);
                }
                if (this.options.helper !== "original" && this.helper && this.helper[0].parentNode) {
                    this.helper.remove();
                }

                $.extend(this, {
                    helper: null,
                    dragging: false,
                    reverting: false,
                    _noFinalSort: null
                });

                if (this.domPosition.prev) {
                    $(this.domPosition.prev).after(this.currentItem);
                } else {
                    $(this.domPosition.parent).prepend(this.currentItem);
                }
            }

            return this;

        },

        serialize: function (o) {

            var items = this._getItemsAsjQuery(o && o.connected),
                str = [];
            o = o || {};

            $(items).each(function () {
                var res = ($(o.item || this).attr(o.attribute || "id") || "").match(o.expression || (/(.+)[\-=_](.+)/));
                if (res) {
                    str.push((o.key || res[1] + "[]") + "=" + (o.key && o.expression ? res[1] : res[2]));
                }
            });

            if (!str.length && o.key) {
                str.push(o.key + "=");
            }

            return str.join("&");

        },

        toArray: function (o) {

            var items = this._getItemsAsjQuery(o && o.connected),
                ret = [];

            o = o || {};

            items.each(function () { ret.push($(o.item || this).attr(o.attribute || "id") || ""); });
            return ret;

        },

        /* Be careful with the following core functions */
        _intersectsWith: function (item) {

            var x1 = this.positionAbs.left,
                x2 = x1 + this.helperProportions.width,
                y1 = this.positionAbs.top,
                y2 = y1 + this.helperProportions.height,
                l = item.left,
                r = l + item.width,
                t = item.top,
                b = t + item.height,
                dyClick = this.offset.click.top,
                dxClick = this.offset.click.left,
                isOverElement = (y1 + dyClick) > t && (y1 + dyClick) < b && (x1 + dxClick) > l && (x1 + dxClick) < r;

            if (this.options.tolerance === "pointer" ||
                this.options.forcePointerForContainers ||
                (this.options.tolerance !== "pointer" && this.helperProportions[this.floating ? "width" : "height"] > item[this.floating ? "width" : "height"])
            ) {
                return isOverElement;
            } else {

                return (l < x1 + (this.helperProportions.width / 2) && // Right Half
                    x2 - (this.helperProportions.width / 2) < r && // Left Half
                    t < y1 + (this.helperProportions.height / 2) && // Bottom Half
                    y2 - (this.helperProportions.height / 2) < b); // Top Half

            }
        },

        _intersectsWithPointer: function (item) {

            var isOverElementHeight = (this.options.axis === "x") || isOverAxis(this.positionAbs.top + this.offset.click.top, item.top, item.height),
                isOverElementWidth = (this.options.axis === "y") || isOverAxis(this.positionAbs.left + this.offset.click.left, item.left, item.width),
                isOverElement = isOverElementHeight && isOverElementWidth,
                verticalDirection = this._getDragVerticalDirection(),
                horizontalDirection = this._getDragHorizontalDirection();

            if (!isOverElement) {
                return false;
            }

            return this.floating ?
                (((horizontalDirection && horizontalDirection === "right") || verticalDirection === "down") ? 2 : 1)
                : (verticalDirection && (verticalDirection === "down" ? 2 : 1));

        },

        _intersectsWithSides: function (item) {

            var isOverBottomHalf = isOverAxis(this.positionAbs.top + this.offset.click.top, item.top + (item.height / 2), item.height),
                isOverRightHalf = isOverAxis(this.positionAbs.left + this.offset.click.left, item.left + (item.width / 2), item.width),
                verticalDirection = this._getDragVerticalDirection(),
                horizontalDirection = this._getDragHorizontalDirection();

            if (this.floating && horizontalDirection) {
                return ((horizontalDirection === "right" && isOverRightHalf) || (horizontalDirection === "left" && !isOverRightHalf));
            } else {
                return verticalDirection && ((verticalDirection === "down" && isOverBottomHalf) || (verticalDirection === "up" && !isOverBottomHalf));
            }

        },

        _getDragVerticalDirection: function () {
            var delta = this.positionAbs.top - this.lastPositionAbs.top;
            return delta !== 0 && (delta > 0 ? "down" : "up");
        },

        _getDragHorizontalDirection: function () {
            var delta = this.positionAbs.left - this.lastPositionAbs.left;
            return delta !== 0 && (delta > 0 ? "right" : "left");
        },

        refresh: function (event) {
            this._refreshItems(event);
            this.refreshPositions();
            return this;
        },

        _connectWith: function () {
            var options = this.options;
            return options.connectWith.constructor === String ? [options.connectWith] : options.connectWith;
        },

        _getItemsAsjQuery: function (connected) {

            var i, j, cur, inst,
                items = [],
                queries = [],
                connectWith = this._connectWith();

            if (connectWith && connected) {
                for (i = connectWith.length - 1; i >= 0; i--) {
                    cur = $(connectWith[i]);
                    for (j = cur.length - 1; j >= 0; j--) {
                        inst = $.data(cur[j], this.widgetFullName);
                        if (inst && inst !== this && !inst.options.disabled) {
                            queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element) : $(inst.options.items, inst.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), inst]);
                        }
                    }
                }
            }

            queries.push([$.isFunction(this.options.items) ? this.options.items.call(this.element, null, { options: this.options, item: this.currentItem }) : $(this.options.items, this.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), this]);

            for (i = queries.length - 1; i >= 0; i--) {
                queries[i][0].each(function () {
                    items.push(this);
                });
            }

            return $(items);

        },

        _removeCurrentsFromItems: function () {

            var list = this.currentItem.find(":data(" + this.widgetName + "-item)");

            this.items = $.grep(this.items, function (item) {
                for (var j = 0; j < list.length; j++) {
                    if (list[j] === item.item[0]) {
                        return false;
                    }
                }
                return true;
            });

        },

        _refreshItems: function (event) {

            this.items = [];
            this.containers = [this];

            var i, j, cur, inst, targetData, _queries, item, queriesLength,
                items = this.items,
                queries = [[$.isFunction(this.options.items) ? this.options.items.call(this.element[0], event, { item: this.currentItem }) : $(this.options.items, this.element), this]],
                connectWith = this._connectWith();

            if (connectWith && this.ready) { //Shouldn't be run the first time through due to massive slow-down
                for (i = connectWith.length - 1; i >= 0; i--) {
                    cur = $(connectWith[i]);
                    for (j = cur.length - 1; j >= 0; j--) {
                        inst = $.data(cur[j], this.widgetFullName);
                        if (inst && inst !== this && !inst.options.disabled) {
                            queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element[0], event, { item: this.currentItem }) : $(inst.options.items, inst.element), inst]);
                            this.containers.push(inst);
                        }
                    }
                }
            }

            for (i = queries.length - 1; i >= 0; i--) {
                targetData = queries[i][1];
                _queries = queries[i][0];

                for (j = 0, queriesLength = _queries.length; j < queriesLength; j++) {
                    item = $(_queries[j]);

                    item.data(this.widgetName + "-item", targetData); // Data for target checking (mouse manager)

                    items.push({
                        item: item,
                        instance: targetData,
                        width: 0, height: 0,
                        left: 0, top: 0
                    });
                }
            }

        },

        refreshPositions: function (fast) {

            //This has to be redone because due to the item being moved out/into the offsetParent, the offsetParent's position will change
            if (this.offsetParent && this.helper) {
                this.offset.parent = this._getParentOffset();
            }

            var i, item, t, p;

            for (i = this.items.length - 1; i >= 0; i--) {
                item = this.items[i];

                //We ignore calculating positions of all connected containers when we're not over them
                if (item.instance !== this.currentContainer && this.currentContainer && item.item[0] !== this.currentItem[0]) {
                    continue;
                }

                t = this.options.toleranceElement ? $(this.options.toleranceElement, item.item) : item.item;

                if (!fast) {
                    item.width = t.outerWidth();
                    item.height = t.outerHeight();
                }

                p = t.offset();
                item.left = p.left;
                item.top = p.top;
            }

            if (this.options.custom && this.options.custom.refreshContainers) {
                this.options.custom.refreshContainers.call(this);
            } else {
                for (i = this.containers.length - 1; i >= 0; i--) {
                    p = this.containers[i].element.offset();
                    this.containers[i].containerCache.left = p.left;
                    this.containers[i].containerCache.top = p.top;
                    this.containers[i].containerCache.width = this.containers[i].element.outerWidth();
                    this.containers[i].containerCache.height = this.containers[i].element.outerHeight();
                }
            }

            return this;
        },

        _createPlaceholder: function (that) {
            that = that || this;
            var className,
                o = that.options;

            if (!o.placeholder || o.placeholder.constructor === String) {
                className = o.placeholder;
                o.placeholder = {
                    element: function () {

                        var nodeName = that.currentItem[0].nodeName.toLowerCase(),
                            element = $(that.document[0].createElement(nodeName))
                                .addClass(className || that.currentItem[0].className + " ui-sortable-placeholder")
                                .removeClass("ui-sortable-helper");

                        if (nodeName === "tr") {
                            // Use a high colspan to force the td to expand the full
                            // width of the table (browsers are smart enough to
                            // handle this properly)
                            element.append("<td colspan='99'>&#160;</td>");
                        } else if (nodeName === "img") {
                            element.attr("src", that.currentItem.attr("src"));
                        }

                        if (!className) {
                            element.css("visibility", "hidden");
                        }

                        return element;
                    },
                    update: function (container, p) {

                        // 1. If a className is set as 'placeholder option, we don't force sizes - the class is responsible for that
                        // 2. The option 'forcePlaceholderSize can be enabled to force it even if a class name is specified
                        if (className && !o.forcePlaceholderSize) {
                            return;
                        }

                        //If the element doesn't have a actual height by itself (without styles coming from a stylesheet), it receives the inline height from the dragged item
                        if (!p.height()) { p.height(that.currentItem.innerHeight() - parseInt(that.currentItem.css("paddingTop") || 0, 10) - parseInt(that.currentItem.css("paddingBottom") || 0, 10)); }
                        if (!p.width()) { p.width(that.currentItem.innerWidth() - parseInt(that.currentItem.css("paddingLeft") || 0, 10) - parseInt(that.currentItem.css("paddingRight") || 0, 10)); }
                    }
                };
            }

            //Create the placeholder
            that.placeholder = $(o.placeholder.element.call(that.element, that.currentItem));

            //Append it after the actual current item
            that.currentItem.after(that.placeholder);

            //Update the size of the placeholder (TODO: Logic to fuzzy, see line 316/317)
            o.placeholder.update(that, that.placeholder);

        },

        _contactContainers: function (event) {
            var i, j, dist, itemWithLeastDistance, posProperty, sizeProperty, base, cur, nearBottom, floating,
                innermostContainer = null,
                innermostIndex = null;

            // get innermost container that intersects with item
            for (i = this.containers.length - 1; i >= 0; i--) {

                // never consider a container that's located within the item itself
                if ($.contains(this.currentItem[0], this.containers[i].element[0])) {
                    continue;
                }

                if (this._intersectsWith(this.containers[i].containerCache)) {

                    // if we've already found a container and it's more "inner" than this, then continue
                    if (innermostContainer && $.contains(this.containers[i].element[0], innermostContainer.element[0])) {
                        continue;
                    }

                    innermostContainer = this.containers[i];
                    innermostIndex = i;

                } else {
                    // container doesn't intersect. trigger "out" event if necessary
                    if (this.containers[i].containerCache.over) {
                        this.containers[i]._trigger("out", event, this._uiHash(this));
                        this.containers[i].containerCache.over = 0;
                    }
                }

            }

            // if no intersecting containers found, return
            if (!innermostContainer) {
                return;
            }

            // move the item into the container if it's not there already
            if (this.containers.length === 1) {
                if (!this.containers[innermostIndex].containerCache.over) {
                    this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));
                    this.containers[innermostIndex].containerCache.over = 1;
                }
            } else {

                //When entering a new container, we will find the item with the least distance and append our item near it
                dist = 10000;
                itemWithLeastDistance = null;
                floating = innermostContainer.floating || isFloating(this.currentItem);
                posProperty = floating ? "left" : "top";
                sizeProperty = floating ? "width" : "height";
                base = this.positionAbs[posProperty] + this.offset.click[posProperty];
                for (j = this.items.length - 1; j >= 0; j--) {
                    if (!$.contains(this.containers[innermostIndex].element[0], this.items[j].item[0])) {
                        continue;
                    }
                    if (this.items[j].item[0] === this.currentItem[0]) {
                        continue;
                    }
                    if (floating && !isOverAxis(this.positionAbs.top + this.offset.click.top, this.items[j].top, this.items[j].height)) {
                        continue;
                    }
                    cur = this.items[j].item.offset()[posProperty];
                    nearBottom = false;
                    if (Math.abs(cur - base) > Math.abs(cur + this.items[j][sizeProperty] - base)) {
                        nearBottom = true;
                        cur += this.items[j][sizeProperty];
                    }

                    if (Math.abs(cur - base) < dist) {
                        dist = Math.abs(cur - base); itemWithLeastDistance = this.items[j];
                        this.direction = nearBottom ? "up" : "down";
                    }
                }

                //Check if dropOnEmpty is enabled
                if (!itemWithLeastDistance && !this.options.dropOnEmpty) {
                    return;
                }

                if (this.currentContainer === this.containers[innermostIndex]) {
                    return;
                }

                itemWithLeastDistance ? this._rearrange(event, itemWithLeastDistance, null, true) : this._rearrange(event, null, this.containers[innermostIndex].element, true);
                this._trigger("change", event, this._uiHash());
                this.containers[innermostIndex]._trigger("change", event, this._uiHash(this));
                this.currentContainer = this.containers[innermostIndex];

                //Update the placeholder
                this.options.placeholder.update(this.currentContainer, this.placeholder);

                this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));
                this.containers[innermostIndex].containerCache.over = 1;
            }


        },

        _createHelper: function (event) {

            var o = this.options,
                helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event, this.currentItem])) : (o.helper === "clone" ? this.currentItem.clone() : this.currentItem);

            //Add the helper to the DOM if that didn't happen already
            if (!helper.parents("body").length) {
                $(o.appendTo !== "parent" ? o.appendTo : this.currentItem[0].parentNode)[0].appendChild(helper[0]);
            }

            if (helper[0] === this.currentItem[0]) {
                this._storedCSS = { width: this.currentItem[0].style.width, height: this.currentItem[0].style.height, position: this.currentItem.css("position"), top: this.currentItem.css("top"), left: this.currentItem.css("left") };
            }

            if (!helper[0].style.width || o.forceHelperSize) {
                helper.width(this.currentItem.width());
            }
            if (!helper[0].style.height || o.forceHelperSize) {
                helper.height(this.currentItem.height());
            }

            return helper;

        },

        _adjustOffsetFromHelper: function (obj) {
            if (typeof obj === "string") {
                obj = obj.split(" ");
            }
            if ($.isArray(obj)) {
                obj = { left: +obj[0], top: +obj[1] || 0 };
            }
            if ("left" in obj) {
                this.offset.click.left = obj.left + this.margins.left;
            }
            if ("right" in obj) {
                this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
            }
            if ("top" in obj) {
                this.offset.click.top = obj.top + this.margins.top;
            }
            if ("bottom" in obj) {
                this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
            }
        },

        _getParentOffset: function () {


            //Get the offsetParent and cache its position
            this.offsetParent = this.helper.offsetParent();
            var po = this.offsetParent.offset();

            // This is a special case where we need to modify a offset calculated on start, since the following happened:
            // 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent
            // 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that
            //    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
            if (this.cssPosition === "absolute" && this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) {
                po.left += this.scrollParent.scrollLeft();
                po.top += this.scrollParent.scrollTop();
            }

            // This needs to be actually done for all browsers, since pageX/pageY includes this information
            // with an ugly IE fix
            if (this.offsetParent[0] === document.body || (this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() === "html" && $.ui.ie)) {
                po = { top: 0, left: 0 };
            }

            return {
                top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"), 10) || 0),
                left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"), 10) || 0)
            };

        },

        _getRelativeOffset: function () {

            if (this.cssPosition === "relative") {
                var p = this.currentItem.position();
                return {
                    top: p.top - (parseInt(this.helper.css("top"), 10) || 0) + this.scrollParent.scrollTop(),
                    left: p.left - (parseInt(this.helper.css("left"), 10) || 0) + this.scrollParent.scrollLeft()
                };
            } else {
                return { top: 0, left: 0 };
            }

        },

        _cacheMargins: function () {
            this.margins = {
                left: (parseInt(this.currentItem.css("marginLeft"), 10) || 0),
                top: (parseInt(this.currentItem.css("marginTop"), 10) || 0)
            };
        },

        _cacheHelperProportions: function () {
            this.helperProportions = {
                width: this.helper.outerWidth(),
                height: this.helper.outerHeight()
            };
        },

        _setContainment: function () {

            var ce, co, over,
                o = this.options;
            if (o.containment === "parent") {
                o.containment = this.helper[0].parentNode;
            }
            if (o.containment === "document" || o.containment === "window") {
                this.containment = [
                    0 - this.offset.relative.left - this.offset.parent.left,
                    0 - this.offset.relative.top - this.offset.parent.top,
                    $(o.containment === "document" ? document : window).width() - this.helperProportions.width - this.margins.left,
                    ($(o.containment === "document" ? document : window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top
                ];
            }

            if (!(/^(document|window|parent)$/).test(o.containment)) {
                ce = $(o.containment)[0];
                co = $(o.containment).offset();
                over = ($(ce).css("overflow") !== "hidden");

                this.containment = [
                    co.left + (parseInt($(ce).css("borderLeftWidth"), 10) || 0) + (parseInt($(ce).css("paddingLeft"), 10) || 0) - this.margins.left,
                    co.top + (parseInt($(ce).css("borderTopWidth"), 10) || 0) + (parseInt($(ce).css("paddingTop"), 10) || 0) - this.margins.top,
                    co.left + (over ? Math.max(ce.scrollWidth, ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css("borderLeftWidth"), 10) || 0) - (parseInt($(ce).css("paddingRight"), 10) || 0) - this.helperProportions.width - this.margins.left,
                    co.top + (over ? Math.max(ce.scrollHeight, ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css("borderTopWidth"), 10) || 0) - (parseInt($(ce).css("paddingBottom"), 10) || 0) - this.helperProportions.height - this.margins.top
                ];
            }

        },

        _convertPositionTo: function (d, pos) {

            if (!pos) {
                pos = this.position;
            }
            var mod = d === "absolute" ? 1 : -1,
                scroll = this.cssPosition === "absolute" && !(this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent,
                scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);

            return {
                top: (
                    pos.top +                               // The absolute mouse position
                    this.offset.relative.top * mod +                    // Only for relative positioned nodes: Relative offset from element to offset parent
                    this.offset.parent.top * mod -                      // The offsetParent's offset without borders (offset + border)
                    ((this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : (scrollIsRootNode ? 0 : scroll.scrollTop())) * mod)
                ),
                left: (
                    pos.left +                                // The absolute mouse position
                    this.offset.relative.left * mod +                   // Only for relative positioned nodes: Relative offset from element to offset parent
                    this.offset.parent.left * mod -                   // The offsetParent's offset without borders (offset + border)
                    ((this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft()) * mod)
                )
            };

        },

        _generatePosition: function (event) {

            var top, left,
                o = this.options,
                pageX = event.pageX,
                pageY = event.pageY,
                scroll = this.cssPosition === "absolute" && !(this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);

            // This is another very weird special case that only happens for relative elements:
            // 1. If the css position is relative
            // 2. and the scroll parent is the document or similar to the offset parent
            // we have to refresh the relative offset during the scroll so there are no jumps
            if (this.cssPosition === "relative" && !(this.scrollParent[0] !== document && this.scrollParent[0] !== this.offsetParent[0])) {
                this.offset.relative = this._getRelativeOffset();
            }

            /*
             * - Position constraining -
             * Constrain the position to a mix of grid, containment.
             */

            if (this.originalPosition) { //If we are not dragging yet, we won't check for options

                if (this.containment) {
                    if (event.pageX - this.offset.click.left < this.containment[0]) {
                        pageX = this.containment[0] + this.offset.click.left;
                    }
                    if (event.pageY - this.offset.click.top < this.containment[1]) {
                        pageY = this.containment[1] + this.offset.click.top;
                    }
                    if (event.pageX - this.offset.click.left > this.containment[2]) {
                        pageX = this.containment[2] + this.offset.click.left;
                    }
                    if (event.pageY - this.offset.click.top > this.containment[3]) {
                        pageY = this.containment[3] + this.offset.click.top;
                    }
                }

                if (o.grid) {
                    top = this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1];
                    pageY = this.containment ? ((top - this.offset.click.top >= this.containment[1] && top - this.offset.click.top <= this.containment[3]) ? top : ((top - this.offset.click.top >= this.containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;

                    left = this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0];
                    pageX = this.containment ? ((left - this.offset.click.left >= this.containment[0] && left - this.offset.click.left <= this.containment[2]) ? left : ((left - this.offset.click.left >= this.containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;
                }

            }

            return {
                top: (
                    pageY -                               // The absolute mouse position
                    this.offset.click.top -                         // Click offset (relative to the element)
                    this.offset.relative.top -                     // Only for relative positioned nodes: Relative offset from element to offset parent
                    this.offset.parent.top +                        // The offsetParent's offset without borders (offset + border)
                    ((this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : (scrollIsRootNode ? 0 : scroll.scrollTop())))
                ),
                left: (
                    pageX -                               // The absolute mouse position
                    this.offset.click.left -                        // Click offset (relative to the element)
                    this.offset.relative.left -                     // Only for relative positioned nodes: Relative offset from element to offset parent
                    this.offset.parent.left +                       // The offsetParent's offset without borders (offset + border)
                    ((this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft()))
                )
            };

        },

        _rearrange: function (event, i, a, hardRefresh) {

            a ? a[0].appendChild(this.placeholder[0]) : i.item[0].parentNode.insertBefore(this.placeholder[0], (this.direction === "down" ? i.item[0] : i.item[0].nextSibling));

            //Various things done here to improve the performance:
            // 1. we create a setTimeout, that calls refreshPositions
            // 2. on the instance, we have a counter variable, that get's higher after every append
            // 3. on the local scope, we copy the counter variable, and check in the timeout, if it's still the same
            // 4. this lets only the last addition to the timeout stack through
            this.counter = this.counter ? ++this.counter : 1;
            var counter = this.counter;

            this._delay(function () {
                if (counter === this.counter) {
                    this.refreshPositions(!hardRefresh); //Precompute after each DOM insertion, NOT on mousemove
                }
            });

        },

        _clear: function (event, noPropagation) {

            this.reverting = false;
            // We delay all events that have to be triggered to after the point where the placeholder has been removed and
            // everything else normalized again
            var i,
                delayedTriggers = [];

            // We first have to update the dom position of the actual currentItem
            // Note: don't do it if the current item is already removed (by a user), or it gets reappended (see #4088)
            if (!this._noFinalSort && this.currentItem.parent().length) {
                this.placeholder.before(this.currentItem);
            }
            this._noFinalSort = null;

            if (this.helper[0] === this.currentItem[0]) {
                for (i in this._storedCSS) {
                    if (this._storedCSS[i] === "auto" || this._storedCSS[i] === "static") {
                        this._storedCSS[i] = "";
                    }
                }
                this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");
            } else {
                this.currentItem.show();
            }

            if (this.fromOutside && !noPropagation) {
                delayedTriggers.push(function (event) { this._trigger("receive", event, this._uiHash(this.fromOutside)); });
            }
            if ((this.fromOutside || this.domPosition.prev !== this.currentItem.prev().not(".ui-sortable-helper")[0] || this.domPosition.parent !== this.currentItem.parent()[0]) && !noPropagation) {
                delayedTriggers.push(function (event) { this._trigger("update", event, this._uiHash()); }); //Trigger update callback if the DOM position has changed
            }

            // Check if the items Container has Changed and trigger appropriate
            // events.
            if (this !== this.currentContainer) {
                if (!noPropagation) {
                    delayedTriggers.push(function (event) { this._trigger("remove", event, this._uiHash()); });
                    delayedTriggers.push((function (c) { return function (event) { c._trigger("receive", event, this._uiHash(this)); }; }).call(this, this.currentContainer));
                    delayedTriggers.push((function (c) { return function (event) { c._trigger("update", event, this._uiHash(this)); }; }).call(this, this.currentContainer));
                }
            }


            //Post events to containers
            for (i = this.containers.length - 1; i >= 0; i--) {
                if (!noPropagation) {
                    delayedTriggers.push((function (c) { return function (event) { c._trigger("deactivate", event, this._uiHash(this)); }; }).call(this, this.containers[i]));
                }
                if (this.containers[i].containerCache.over) {
                    delayedTriggers.push((function (c) { return function (event) { c._trigger("out", event, this._uiHash(this)); }; }).call(this, this.containers[i]));
                    this.containers[i].containerCache.over = 0;
                }
            }

            //Do what was originally in plugins
            if (this.storedCursor) {
                this.document.find("body").css("cursor", this.storedCursor);
                this.storedStylesheet.remove();
            }
            if (this._storedOpacity) {
                this.helper.css("opacity", this._storedOpacity);
            }
            if (this._storedZIndex) {
                this.helper.css("zIndex", this._storedZIndex === "auto" ? "" : this._storedZIndex);
            }

            this.dragging = false;
            if (this.cancelHelperRemoval) {
                if (!noPropagation) {
                    this._trigger("beforeStop", event, this._uiHash());
                    for (i = 0; i < delayedTriggers.length; i++) {
                        delayedTriggers[i].call(this, event);
                    } //Trigger all delayed events
                    this._trigger("stop", event, this._uiHash());
                }

                this.fromOutside = false;
                return false;
            }

            if (!noPropagation) {
                this._trigger("beforeStop", event, this._uiHash());
            }

            //$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!
            this.placeholder[0].parentNode.removeChild(this.placeholder[0]);

            if (this.helper[0] !== this.currentItem[0]) {
                this.helper.remove();
            }
            this.helper = null;

            if (!noPropagation) {
                for (i = 0; i < delayedTriggers.length; i++) {
                    delayedTriggers[i].call(this, event);
                } //Trigger all delayed events
                this._trigger("stop", event, this._uiHash());
            }

            this.fromOutside = false;
            return true;

        },

        _trigger: function () {
            if ($.Widget.prototype._trigger.apply(this, arguments) === false) {
                this.cancel();
            }
        },

        _uiHash: function (_inst) {
            var inst = _inst || this;
            return {
                helper: inst.helper,
                placeholder: inst.placeholder || $([]),
                position: inst.position,
                originalPosition: inst.originalPosition,
                offset: inst.positionAbs,
                item: inst.currentItem,
                sender: _inst ? _inst.element : null
            };
        }

    });

})(jQuery);

(function ($, undefined) {

    var dataSpace = "ui-effects-";

    $.effects = {
        effect: {}
    };

    /*!
     * jQuery Color Animations v2.1.2
     * https://github.com/jquery/jquery-color
     *
     * Copyright 2013 jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     *
     * Date: Wed Jan 16 08:47:09 2013 -0600
     */
    (function (jQuery, undefined) {

        var stepHooks = "backgroundColor borderBottomColor borderLeftColor borderRightColor borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor",

            // plusequals test for += 100 -= 100
            rplusequals = /^([\-+])=\s*(\d+\.?\d*)/,
            // a set of RE's that can match strings and generate color tuples.
            stringParsers = [{
                re: /rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
                parse: function (execResult) {
                    return [
                        execResult[1],
                        execResult[2],
                        execResult[3],
                        execResult[4]
                    ];
                }
            }, {
                re: /rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
                parse: function (execResult) {
                    return [
                        execResult[1] * 2.55,
                        execResult[2] * 2.55,
                        execResult[3] * 2.55,
                        execResult[4]
                    ];
                }
            }, {
                // this regex ignores A-F because it's compared against an already lowercased string
                re: /#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})/,
                parse: function (execResult) {
                    return [
                        parseInt(execResult[1], 16),
                        parseInt(execResult[2], 16),
                        parseInt(execResult[3], 16)
                    ];
                }
            }, {
                // this regex ignores A-F because it's compared against an already lowercased string
                re: /#([a-f0-9])([a-f0-9])([a-f0-9])/,
                parse: function (execResult) {
                    return [
                        parseInt(execResult[1] + execResult[1], 16),
                        parseInt(execResult[2] + execResult[2], 16),
                        parseInt(execResult[3] + execResult[3], 16)
                    ];
                }
            }, {
                re: /hsla?\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
                space: "hsla",
                parse: function (execResult) {
                    return [
                        execResult[1],
                        execResult[2] / 100,
                        execResult[3] / 100,
                        execResult[4]
                    ];
                }
            }],

            // jQuery.Color( )
            color = jQuery.Color = function (color, green, blue, alpha) {
                return new jQuery.Color.fn.parse(color, green, blue, alpha);
            },
            spaces = {
                rgba: {
                    props: {
                        red: {
                            idx: 0,
                            type: "byte"
                        },
                        green: {
                            idx: 1,
                            type: "byte"
                        },
                        blue: {
                            idx: 2,
                            type: "byte"
                        }
                    }
                },

                hsla: {
                    props: {
                        hue: {
                            idx: 0,
                            type: "degrees"
                        },
                        saturation: {
                            idx: 1,
                            type: "percent"
                        },
                        lightness: {
                            idx: 2,
                            type: "percent"
                        }
                    }
                }
            },
            propTypes = {
                "byte": {
                    floor: true,
                    max: 255
                },
                "percent": {
                    max: 1
                },
                "degrees": {
                    mod: 360,
                    floor: true
                }
            },
            support = color.support = {},

            // element for support tests
            supportElem = jQuery("<p>")[0],

            // colors = jQuery.Color.names
            colors,

            // local aliases of functions called often
            each = jQuery.each;

        // determine rgba support immediately
        supportElem.style.cssText = "background-color:rgba(1,1,1,.5)";
        support.rgba = supportElem.style.backgroundColor.indexOf("rgba") > -1;

        // define cache name and alpha properties
        // for rgba and hsla spaces
        each(spaces, function (spaceName, space) {
            space.cache = "_" + spaceName;
            space.props.alpha = {
                idx: 3,
                type: "percent",
                def: 1
            };
        });

        function clamp(value, prop, allowEmpty) {
            var type = propTypes[prop.type] || {};

            if (value == null) {
                return (allowEmpty || !prop.def) ? null : prop.def;
            }

            // ~~ is an short way of doing floor for positive numbers
            value = type.floor ? ~~value : parseFloat(value);

            // IE will pass in empty strings as value for alpha,
            // which will hit this case
            if (isNaN(value)) {
                return prop.def;
            }

            if (type.mod) {
                // we add mod before modding to make sure that negatives values
                // get converted properly: -10 -> 350
                return (value + type.mod) % type.mod;
            }

            // for now all property types without mod have min and max
            return 0 > value ? 0 : type.max < value ? type.max : value;
        }

        function stringParse(string) {
            var inst = color(),
                rgba = inst._rgba = [];

            string = string.toLowerCase();

            each(stringParsers, function (i, parser) {
                var parsed,
                    match = parser.re.exec(string),
                    values = match && parser.parse(match),
                    spaceName = parser.space || "rgba";

                if (values) {
                    parsed = inst[spaceName](values);

                    // if this was an rgba parse the assignment might happen twice
                    // oh well....
                    inst[spaces[spaceName].cache] = parsed[spaces[spaceName].cache];
                    rgba = inst._rgba = parsed._rgba;

                    // exit each( stringParsers ) here because we matched
                    return false;
                }
            });

            // Found a stringParser that handled it
            if (rgba.length) {

                // if this came from a parsed string, force "transparent" when alpha is 0
                // chrome, (and maybe others) return "transparent" as rgba(0,0,0,0)
                if (rgba.join() === "0,0,0,0") {
                    jQuery.extend(rgba, colors.transparent);
                }
                return inst;
            }

            // named colors
            return colors[string];
        }

        color.fn = jQuery.extend(color.prototype, {
            parse: function (red, green, blue, alpha) {
                if (red === undefined) {
                    this._rgba = [null, null, null, null];
                    return this;
                }
                if (red.jquery || red.nodeType) {
                    red = jQuery(red).css(green);
                    green = undefined;
                }

                var inst = this,
                    type = jQuery.type(red),
                    rgba = this._rgba = [];

                // more than 1 argument specified - assume ( red, green, blue, alpha )
                if (green !== undefined) {
                    red = [red, green, blue, alpha];
                    type = "array";
                }

                if (type === "string") {
                    return this.parse(stringParse(red) || colors._default);
                }

                if (type === "array") {
                    each(spaces.rgba.props, function (key, prop) {
                        rgba[prop.idx] = clamp(red[prop.idx], prop);
                    });
                    return this;
                }

                if (type === "object") {
                    if (red instanceof color) {
                        each(spaces, function (spaceName, space) {
                            if (red[space.cache]) {
                                inst[space.cache] = red[space.cache].slice();
                            }
                        });
                    } else {
                        each(spaces, function (spaceName, space) {
                            var cache = space.cache;
                            each(space.props, function (key, prop) {

                                // if the cache doesn't exist, and we know how to convert
                                if (!inst[cache] && space.to) {

                                    // if the value was null, we don't need to copy it
                                    // if the key was alpha, we don't need to copy it either
                                    if (key === "alpha" || red[key] == null) {
                                        return;
                                    }
                                    inst[cache] = space.to(inst._rgba);
                                }

                                // this is the only case where we allow nulls for ALL properties.
                                // call clamp with alwaysAllowEmpty
                                inst[cache][prop.idx] = clamp(red[key], prop, true);
                            });

                            // everything defined but alpha?
                            if (inst[cache] && jQuery.inArray(null, inst[cache].slice(0, 3)) < 0) {
                                // use the default of 1
                                inst[cache][3] = 1;
                                if (space.from) {
                                    inst._rgba = space.from(inst[cache]);
                                }
                            }
                        });
                    }
                    return this;
                }
            },
            is: function (compare) {
                var is = color(compare),
                    same = true,
                    inst = this;

                each(spaces, function (_, space) {
                    var localCache,
                        isCache = is[space.cache];
                    if (isCache) {
                        localCache = inst[space.cache] || space.to && space.to(inst._rgba) || [];
                        each(space.props, function (_, prop) {
                            if (isCache[prop.idx] != null) {
                                same = (isCache[prop.idx] === localCache[prop.idx]);
                                return same;
                            }
                        });
                    }
                    return same;
                });
                return same;
            },
            _space: function () {
                var used = [],
                    inst = this;
                each(spaces, function (spaceName, space) {
                    if (inst[space.cache]) {
                        used.push(spaceName);
                    }
                });
                return used.pop();
            },
            transition: function (other, distance) {
                var end = color(other),
                    spaceName = end._space(),
                    space = spaces[spaceName],
                    startColor = this.alpha() === 0 ? color("transparent") : this,
                    start = startColor[space.cache] || space.to(startColor._rgba),
                    result = start.slice();

                end = end[space.cache];
                each(space.props, function (key, prop) {
                    var index = prop.idx,
                        startValue = start[index],
                        endValue = end[index],
                        type = propTypes[prop.type] || {};

                    // if null, don't override start value
                    if (endValue === null) {
                        return;
                    }
                    // if null - use end
                    if (startValue === null) {
                        result[index] = endValue;
                    } else {
                        if (type.mod) {
                            if (endValue - startValue > type.mod / 2) {
                                startValue += type.mod;
                            } else if (startValue - endValue > type.mod / 2) {
                                startValue -= type.mod;
                            }
                        }
                        result[index] = clamp((endValue - startValue) * distance + startValue, prop);
                    }
                });
                return this[spaceName](result);
            },
            blend: function (opaque) {
                // if we are already opaque - return ourself
                if (this._rgba[3] === 1) {
                    return this;
                }

                var rgb = this._rgba.slice(),
                    a = rgb.pop(),
                    blend = color(opaque)._rgba;

                return color(jQuery.map(rgb, function (v, i) {
                    return (1 - a) * blend[i] + a * v;
                }));
            },
            toRgbaString: function () {
                var prefix = "rgba(",
                    rgba = jQuery.map(this._rgba, function (v, i) {
                        return v == null ? (i > 2 ? 1 : 0) : v;
                    });

                if (rgba[3] === 1) {
                    rgba.pop();
                    prefix = "rgb(";
                }

                return prefix + rgba.join() + ")";
            },
            toHslaString: function () {
                var prefix = "hsla(",
                    hsla = jQuery.map(this.hsla(), function (v, i) {
                        if (v == null) {
                            v = i > 2 ? 1 : 0;
                        }

                        // catch 1 and 2
                        if (i && i < 3) {
                            v = Math.round(v * 100) + "%";
                        }
                        return v;
                    });

                if (hsla[3] === 1) {
                    hsla.pop();
                    prefix = "hsl(";
                }
                return prefix + hsla.join() + ")";
            },
            toHexString: function (includeAlpha) {
                var rgba = this._rgba.slice(),
                    alpha = rgba.pop();

                if (includeAlpha) {
                    rgba.push(~~(alpha * 255));
                }

                return "#" + jQuery.map(rgba, function (v) {

                    // default to 0 when nulls exist
                    v = (v || 0).toString(16);
                    return v.length === 1 ? "0" + v : v;
                }).join("");
            },
            toString: function () {
                return this._rgba[3] === 0 ? "transparent" : this.toRgbaString();
            }
        });
        color.fn.parse.prototype = color.fn;

        // hsla conversions adapted from:
        // https://code.google.com/p/maashaack/source/browse/packages/graphics/trunk/src/graphics/colors/HUE2RGB.as?r=5021

        function hue2rgb(p, q, h) {
            h = (h + 1) % 1;
            if (h * 6 < 1) {
                return p + (q - p) * h * 6;
            }
            if (h * 2 < 1) {
                return q;
            }
            if (h * 3 < 2) {
                return p + (q - p) * ((2 / 3) - h) * 6;
            }
            return p;
        }

        spaces.hsla.to = function (rgba) {
            if (rgba[0] == null || rgba[1] == null || rgba[2] == null) {
                return [null, null, null, rgba[3]];
            }
            var r = rgba[0] / 255,
                g = rgba[1] / 255,
                b = rgba[2] / 255,
                a = rgba[3],
                max = Math.max(r, g, b),
                min = Math.min(r, g, b),
                diff = max - min,
                add = max + min,
                l = add * 0.5,
                h, s;

            if (min === max) {
                h = 0;
            } else if (r === max) {
                h = (60 * (g - b) / diff) + 360;
            } else if (g === max) {
                h = (60 * (b - r) / diff) + 120;
            } else {
                h = (60 * (r - g) / diff) + 240;
            }

            // chroma (diff) == 0 means greyscale which, by definition, saturation = 0%
            // otherwise, saturation is based on the ratio of chroma (diff) to lightness (add)
            if (diff === 0) {
                s = 0;
            } else if (l <= 0.5) {
                s = diff / add;
            } else {
                s = diff / (2 - add);
            }
            return [Math.round(h) % 360, s, l, a == null ? 1 : a];
        };

        spaces.hsla.from = function (hsla) {
            if (hsla[0] == null || hsla[1] == null || hsla[2] == null) {
                return [null, null, null, hsla[3]];
            }
            var h = hsla[0] / 360,
                s = hsla[1],
                l = hsla[2],
                a = hsla[3],
                q = l <= 0.5 ? l * (1 + s) : l + s - l * s,
                p = 2 * l - q;

            return [
                Math.round(hue2rgb(p, q, h + (1 / 3)) * 255),
                Math.round(hue2rgb(p, q, h) * 255),
                Math.round(hue2rgb(p, q, h - (1 / 3)) * 255),
                a
            ];
        };


        each(spaces, function (spaceName, space) {
            var props = space.props,
                cache = space.cache,
                to = space.to,
                from = space.from;

            // makes rgba() and hsla()
            color.fn[spaceName] = function (value) {

                // generate a cache for this space if it doesn't exist
                if (to && !this[cache]) {
                    this[cache] = to(this._rgba);
                }
                if (value === undefined) {
                    return this[cache].slice();
                }

                var ret,
                    type = jQuery.type(value),
                    arr = (type === "array" || type === "object") ? value : arguments,
                    local = this[cache].slice();

                each(props, function (key, prop) {
                    var val = arr[type === "object" ? key : prop.idx];
                    if (val == null) {
                        val = local[prop.idx];
                    }
                    local[prop.idx] = clamp(val, prop);
                });

                if (from) {
                    ret = color(from(local));
                    ret[cache] = local;
                    return ret;
                } else {
                    return color(local);
                }
            };

            // makes red() green() blue() alpha() hue() saturation() lightness()
            each(props, function (key, prop) {
                // alpha is included in more than one space
                if (color.fn[key]) {
                    return;
                }
                color.fn[key] = function (value) {
                    var vtype = jQuery.type(value),
                        fn = (key === "alpha" ? (this._hsla ? "hsla" : "rgba") : spaceName),
                        local = this[fn](),
                        cur = local[prop.idx],
                        match;

                    if (vtype === "undefined") {
                        return cur;
                    }

                    if (vtype === "function") {
                        value = value.call(this, cur);
                        vtype = jQuery.type(value);
                    }
                    if (value == null && prop.empty) {
                        return this;
                    }
                    if (vtype === "string") {
                        match = rplusequals.exec(value);
                        if (match) {
                            value = cur + parseFloat(match[2]) * (match[1] === "+" ? 1 : -1);
                        }
                    }
                    local[prop.idx] = value;
                    return this[fn](local);
                };
            });
        });

        // add cssHook and .fx.step function for each named hook.
        // accept a space separated string of properties
        color.hook = function (hook) {
            var hooks = hook.split(" ");
            each(hooks, function (i, hook) {
                jQuery.cssHooks[hook] = {
                    set: function (elem, value) {
                        var parsed, curElem,
                            backgroundColor = "";

                        if (value !== "transparent" && (jQuery.type(value) !== "string" || (parsed = stringParse(value)))) {
                            value = color(parsed || value);
                            if (!support.rgba && value._rgba[3] !== 1) {
                                curElem = hook === "backgroundColor" ? elem.parentNode : elem;
                                while (
                                    (backgroundColor === "" || backgroundColor === "transparent") &&
                                    curElem && curElem.style
                                ) {
                                    try {
                                        backgroundColor = jQuery.css(curElem, "backgroundColor");
                                        curElem = curElem.parentNode;
                                    } catch (e) {
                                    }
                                }

                                value = value.blend(backgroundColor && backgroundColor !== "transparent" ?
                                    backgroundColor :
                                    "_default");
                            }

                            value = value.toRgbaString();
                        }
                        try {
                            elem.style[hook] = value;
                        } catch (e) {
                            // wrapped to prevent IE from throwing errors on "invalid" values like 'auto' or 'inherit'
                        }
                    }
                };
                jQuery.fx.step[hook] = function (fx) {
                    if (!fx.colorInit) {
                        fx.start = color(fx.elem, hook);
                        fx.end = color(fx.end);
                        fx.colorInit = true;
                    }
                    jQuery.cssHooks[hook].set(fx.elem, fx.start.transition(fx.end, fx.pos));
                };
            });

        };

        color.hook(stepHooks);

        jQuery.cssHooks.borderColor = {
            expand: function (value) {
                var expanded = {};

                each(["Top", "Right", "Bottom", "Left"], function (i, part) {
                    expanded["border" + part + "Color"] = value;
                });
                return expanded;
            }
        };

        // Basic color names only.
        // Usage of any of the other color names requires adding yourself or including
        // jquery.color.svg-names.js.
        colors = jQuery.Color.names = {
            // 4.1. Basic color keywords
            aqua: "#00ffff",
            black: "#000000",
            blue: "#0000ff",
            fuchsia: "#ff00ff",
            gray: "#808080",
            green: "#008000",
            lime: "#00ff00",
            maroon: "#800000",
            navy: "#000080",
            olive: "#808000",
            purple: "#800080",
            red: "#ff0000",
            silver: "#c0c0c0",
            teal: "#008080",
            white: "#ffffff",
            yellow: "#ffff00",

            // 4.2.3. "transparent" color keyword
            transparent: [null, null, null, 0],

            _default: "#ffffff"
        };

    })(jQuery);


    /******************************************************************************/
    /****************************** CLASS ANIMATIONS ******************************/
    /******************************************************************************/
    (function () {

        var classAnimationActions = ["add", "remove", "toggle"],
            shorthandStyles = {
                border: 1,
                borderBottom: 1,
                borderColor: 1,
                borderLeft: 1,
                borderRight: 1,
                borderTop: 1,
                borderWidth: 1,
                margin: 1,
                padding: 1
            };

        $.each(["borderLeftStyle", "borderRightStyle", "borderBottomStyle", "borderTopStyle"], function (_, prop) {
            $.fx.step[prop] = function (fx) {
                if (fx.end !== "none" && !fx.setAttr || fx.pos === 1 && !fx.setAttr) {
                    jQuery.style(fx.elem, prop, fx.end);
                    fx.setAttr = true;
                }
            };
        });

        function getElementStyles(elem) {
            var key, len,
                style = elem.ownerDocument.defaultView ?
                    elem.ownerDocument.defaultView.getComputedStyle(elem, null) :
                    elem.currentStyle,
                styles = {};

            if (style && style.length && style[0] && style[style[0]]) {
                len = style.length;
                while (len--) {
                    key = style[len];
                    if (typeof style[key] === "string") {
                        styles[$.camelCase(key)] = style[key];
                    }
                }
                // support: Opera, IE <9
            } else {
                for (key in style) {
                    if (typeof style[key] === "string") {
                        styles[key] = style[key];
                    }
                }
            }

            return styles;
        }


        function styleDifference(oldStyle, newStyle) {
            var diff = {},
                name, value;

            for (name in newStyle) {
                value = newStyle[name];
                if (oldStyle[name] !== value) {
                    if (!shorthandStyles[name]) {
                        if ($.fx.step[name] || !isNaN(parseFloat(value))) {
                            diff[name] = value;
                        }
                    }
                }
            }

            return diff;
        }

        // support: jQuery <1.8
        if (!$.fn.addBack) {
            $.fn.addBack = function (selector) {
                return this.add(selector == null ?
                    this.prevObject : this.prevObject.filter(selector)
                );
            };
        }

        $.effects.animateClass = function (value, duration, easing, callback) {
            var o = $.speed(duration, easing, callback);

            return this.queue(function () {
                var animated = $(this),
                    baseClass = animated.attr("class") || "",
                    applyClassChange,
                    allAnimations = o.children ? animated.find("*").addBack() : animated;

                // map the animated objects to store the original styles.
                allAnimations = allAnimations.map(function () {
                    var el = $(this);
                    return {
                        el: el,
                        start: getElementStyles(this)
                    };
                });

                // apply class change
                applyClassChange = function () {
                    $.each(classAnimationActions, function (i, action) {
                        if (value[action]) {
                            animated[action + "Class"](value[action]);
                        }
                    });
                };
                applyClassChange();

                // map all animated objects again - calculate new styles and diff
                allAnimations = allAnimations.map(function () {
                    this.end = getElementStyles(this.el[0]);
                    this.diff = styleDifference(this.start, this.end);
                    return this;
                });

                // apply original class
                animated.attr("class", baseClass);

                // map all animated objects again - this time collecting a promise
                allAnimations = allAnimations.map(function () {
                    var styleInfo = this,
                        dfd = $.Deferred(),
                        opts = $.extend({}, o, {
                            queue: false,
                            complete: function () {
                                dfd.resolve(styleInfo);
                            }
                        });

                    this.el.animate(this.diff, opts);
                    return dfd.promise();
                });

                // once all animations have completed:
                $.when.apply($, allAnimations.get()).done(function () {

                    // set the final class
                    applyClassChange();

                    // for each animated element,
                    // clear all css properties that were animated
                    $.each(arguments, function () {
                        var el = this.el;
                        $.each(this.diff, function (key) {
                            el.css(key, "");
                        });
                    });

                    // this is guarnteed to be there if you use jQuery.speed()
                    // it also handles dequeuing the next anim...
                    o.complete.call(animated[0]);
                });
            });
        };

        $.fn.extend({
            addClass: (function (orig) {
                return function (classNames, speed, easing, callback) {
                    return speed ?
                        $.effects.animateClass.call(this,
                            { add: classNames }, speed, easing, callback) :
                        orig.apply(this, arguments);
                };
            })($.fn.addClass),

            removeClass: (function (orig) {
                return function (classNames, speed, easing, callback) {
                    return arguments.length > 1 ?
                        $.effects.animateClass.call(this,
                            { remove: classNames }, speed, easing, callback) :
                        orig.apply(this, arguments);
                };
            })($.fn.removeClass),

            toggleClass: (function (orig) {
                return function (classNames, force, speed, easing, callback) {
                    if (typeof force === "boolean" || force === undefined) {
                        if (!speed) {
                            // without speed parameter
                            return orig.apply(this, arguments);
                        } else {
                            return $.effects.animateClass.call(this,
                                (force ? { add: classNames } : { remove: classNames }),
                                speed, easing, callback);
                        }
                    } else {
                        // without force parameter
                        return $.effects.animateClass.call(this,
                            { toggle: classNames }, force, speed, easing);
                    }
                };
            })($.fn.toggleClass),

            switchClass: function (remove, add, speed, easing, callback) {
                return $.effects.animateClass.call(this, {
                    add: add,
                    remove: remove
                }, speed, easing, callback);
            }
        });

    })();

    /******************************************************************************/
    /*********************************** EFFECTS **********************************/
    /******************************************************************************/

    (function () {

        $.extend($.effects, {
            version: "1.10.2",

            // Saves a set of properties in a data storage
            save: function (element, set) {
                for (var i = 0; i < set.length; i++) {
                    if (set[i] !== null) {
                        element.data(dataSpace + set[i], element[0].style[set[i]]);
                    }
                }
            },

            // Restores a set of previously saved properties from a data storage
            restore: function (element, set) {
                var val, i;
                for (i = 0; i < set.length; i++) {
                    if (set[i] !== null) {
                        val = element.data(dataSpace + set[i]);
                        // support: jQuery 1.6.2
                        // http://bugs.jquery.com/ticket/9917
                        // jQuery 1.6.2 incorrectly returns undefined for any falsy value.
                        // We can't differentiate between "" and 0 here, so we just assume
                        // empty string since it's likely to be a more common value...
                        if (val === undefined) {
                            val = "";
                        }
                        element.css(set[i], val);
                    }
                }
            },

            setMode: function (el, mode) {
                if (mode === "toggle") {
                    mode = el.is(":hidden") ? "show" : "hide";
                }
                return mode;
            },

            // Translates a [top,left] array into a baseline value
            // this should be a little more flexible in the future to handle a string & hash
            getBaseline: function (origin, original) {
                var y, x;
                switch (origin[0]) {
                    case "top": y = 0; break;
                    case "middle": y = 0.5; break;
                    case "bottom": y = 1; break;
                    default: y = origin[0] / original.height;
                }
                switch (origin[1]) {
                    case "left": x = 0; break;
                    case "center": x = 0.5; break;
                    case "right": x = 1; break;
                    default: x = origin[1] / original.width;
                }
                return {
                    x: x,
                    y: y
                };
            },

            // Wraps the element around a wrapper that copies position properties
            createWrapper: function (element) {

                // if the element is already wrapped, return it
                if (element.parent().is(".ui-effects-wrapper")) {
                    return element.parent();
                }

                // wrap the element
                var props = {
                    width: element.outerWidth(true),
                    height: element.outerHeight(true),
                    "float": element.css("float")
                },
                    wrapper = $("<div></div>")
                        .addClass("ui-effects-wrapper")
                        .css({
                            fontSize: "100%",
                            background: "transparent",
                            border: "none",
                            margin: 0,
                            padding: 0
                        }),
                    // Store the size in case width/height are defined in % - Fixes #5245
                    size = {
                        width: element.width(),
                        height: element.height()
                    },
                    active = document.activeElement;

                // support: Firefox
                // Firefox incorrectly exposes anonymous content
                // https://bugzilla.mozilla.org/show_bug.cgi?id=561664
                try {
                    active.id;
                } catch (e) {
                    active = document.body;
                }

                element.wrap(wrapper);

                // Fixes #7595 - Elements lose focus when wrapped.
                if (element[0] === active || $.contains(element[0], active)) {
                    $(active).focus();
                }

                wrapper = element.parent(); //Hotfix for jQuery 1.4 since some change in wrap() seems to actually lose the reference to the wrapped element

                // transfer positioning properties to the wrapper
                if (element.css("position") === "static") {
                    wrapper.css({ position: "relative" });
                    element.css({ position: "relative" });
                } else {
                    $.extend(props, {
                        position: element.css("position"),
                        zIndex: element.css("z-index")
                    });
                    $.each(["top", "left", "bottom", "right"], function (i, pos) {
                        props[pos] = element.css(pos);
                        if (isNaN(parseInt(props[pos], 10))) {
                            props[pos] = "auto";
                        }
                    });
                    element.css({
                        position: "relative",
                        top: 0,
                        left: 0,
                        right: "auto",
                        bottom: "auto"
                    });
                }
                element.css(size);

                return wrapper.css(props).show();
            },

            removeWrapper: function (element) {
                var active = document.activeElement;

                if (element.parent().is(".ui-effects-wrapper")) {
                    element.parent().replaceWith(element);

                    // Fixes #7595 - Elements lose focus when wrapped.
                    if (element[0] === active || $.contains(element[0], active)) {
                        $(active).focus();
                    }
                }


                return element;
            },

            setTransition: function (element, list, factor, value) {
                value = value || {};
                $.each(list, function (i, x) {
                    var unit = element.cssUnit(x);
                    if (unit[0] > 0) {
                        value[x] = unit[0] * factor + unit[1];
                    }
                });
                return value;
            }
        });

        // return an effect options object for the given parameters:
        function _normalizeArguments(effect, options, speed, callback) {

            // allow passing all options as the first parameter
            if ($.isPlainObject(effect)) {
                options = effect;
                effect = effect.effect;
            }

            // convert to an object
            effect = { effect: effect };

            // catch (effect, null, ...)
            if (options == null) {
                options = {};
            }

            // catch (effect, callback)
            if ($.isFunction(options)) {
                callback = options;
                speed = null;
                options = {};
            }

            // catch (effect, speed, ?)
            if (typeof options === "number" || $.fx.speeds[options]) {
                callback = speed;
                speed = options;
                options = {};
            }

            // catch (effect, options, callback)
            if ($.isFunction(speed)) {
                callback = speed;
                speed = null;
            }

            // add options to effect
            if (options) {
                $.extend(effect, options);
            }

            speed = speed || options.duration;
            effect.duration = $.fx.off ? 0 :
                typeof speed === "number" ? speed :
                    speed in $.fx.speeds ? $.fx.speeds[speed] :
                        $.fx.speeds._default;

            effect.complete = callback || options.complete;

            return effect;
        }

        function standardAnimationOption(option) {
            // Valid standard speeds (nothing, number, named speed)
            if (!option || typeof option === "number" || $.fx.speeds[option]) {
                return true;
            }

            // Invalid strings - treat as "normal" speed
            if (typeof option === "string" && !$.effects.effect[option]) {
                return true;
            }

            // Complete callback
            if ($.isFunction(option)) {
                return true;
            }

            // Options hash (but not naming an effect)
            if (typeof option === "object" && !option.effect) {
                return true;
            }

            // Didn't match any standard API
            return false;
        }

        $.fn.extend({
            effect: function ( /* effect, options, speed, callback */) {
                var args = _normalizeArguments.apply(this, arguments),
                    mode = args.mode,
                    queue = args.queue,
                    effectMethod = $.effects.effect[args.effect];

                if ($.fx.off || !effectMethod) {
                    // delegate to the original method (e.g., .show()) if possible
                    if (mode) {
                        return this[mode](args.duration, args.complete);
                    } else {
                        return this.each(function () {
                            if (args.complete) {
                                args.complete.call(this);
                            }
                        });
                    }
                }

                function run(next) {
                    var elem = $(this),
                        complete = args.complete,
                        mode = args.mode;

                    function done() {
                        if ($.isFunction(complete)) {
                            complete.call(elem[0]);
                        }
                        if ($.isFunction(next)) {
                            next();
                        }
                    }

                    // If the element already has the correct final state, delegate to
                    // the core methods so the internal tracking of "olddisplay" works.
                    if (elem.is(":hidden") ? mode === "hide" : mode === "show") {
                        elem[mode]();
                        done();
                    } else {
                        effectMethod.call(elem[0], args, done);
                    }
                }

                return queue === false ? this.each(run) : this.queue(queue || "fx", run);
            },

            show: (function (orig) {
                return function (option) {
                    if (standardAnimationOption(option)) {
                        return orig.apply(this, arguments);
                    } else {
                        var args = _normalizeArguments.apply(this, arguments);
                        args.mode = "show";
                        return this.effect.call(this, args);
                    }
                };
            })($.fn.show),

            hide: (function (orig) {
                return function (option) {
                    if (standardAnimationOption(option)) {
                        return orig.apply(this, arguments);
                    } else {
                        var args = _normalizeArguments.apply(this, arguments);
                        args.mode = "hide";
                        return this.effect.call(this, args);
                    }
                };
            })($.fn.hide),

            toggle: (function (orig) {
                return function (option) {
                    if (standardAnimationOption(option) || typeof option === "boolean") {
                        return orig.apply(this, arguments);
                    } else {
                        var args = _normalizeArguments.apply(this, arguments);
                        args.mode = "toggle";
                        return this.effect.call(this, args);
                    }
                };
            })($.fn.toggle),

            // helper functions
            cssUnit: function (key) {
                var style = this.css(key),
                    val = [];

                $.each(["em", "px", "%", "pt"], function (i, unit) {
                    if (style.indexOf(unit) > 0) {
                        val = [parseFloat(style), unit];
                    }
                });
                return val;
            }
        });

    })();

    /******************************************************************************/
    /*********************************** EASING ***********************************/
    /******************************************************************************/

    (function () {

        // based on easing equations from Robert Penner (http://www.robertpenner.com/easing)

        var baseEasings = {};

        $.each(["Quad", "Cubic", "Quart", "Quint", "Expo"], function (i, name) {
            baseEasings[name] = function (p) {
                return Math.pow(p, i + 2);
            };
        });

        $.extend(baseEasings, {
            Sine: function (p) {
                return 1 - Math.cos(p * Math.PI / 2);
            },
            Circ: function (p) {
                return 1 - Math.sqrt(1 - p * p);
            },
            Elastic: function (p) {
                return p === 0 || p === 1 ? p :
                    -Math.pow(2, 8 * (p - 1)) * Math.sin(((p - 1) * 80 - 7.5) * Math.PI / 15);
            },
            Back: function (p) {
                return p * p * (3 * p - 2);
            },
            Bounce: function (p) {
                var pow2,
                    bounce = 4;

                while (p < ((pow2 = Math.pow(2, --bounce)) - 1) / 11) { }
                return 1 / Math.pow(4, 3 - bounce) - 7.5625 * Math.pow((pow2 * 3 - 2) / 22 - p, 2);
            }
        });

        $.each(baseEasings, function (name, easeIn) {
            $.easing["easeIn" + name] = easeIn;
            $.easing["easeOut" + name] = function (p) {
                return 1 - easeIn(1 - p);
            };
            $.easing["easeInOut" + name] = function (p) {
                return p < 0.5 ?
                    easeIn(p * 2) / 2 :
                    1 - easeIn(p * -2 + 2) / 2;
            };
        });

    })();

})(jQuery);

(function ($, undefined) {

    var uid = 0,
        hideProps = {},
        showProps = {};

    hideProps.height = hideProps.paddingTop = hideProps.paddingBottom =
        hideProps.borderTopWidth = hideProps.borderBottomWidth = "hide";
    showProps.height = showProps.paddingTop = showProps.paddingBottom =
        showProps.borderTopWidth = showProps.borderBottomWidth = "show";

    $.widget("ui.accordion", {
        version: "1.10.2",
        options: {
            active: 0,
            animate: {},
            collapsible: false,
            event: "click",
            header: "> li > :first-child,> :not(li):even",
            heightStyle: "auto",
            icons: {
                activeHeader: "ui-icon-triangle-1-s",
                header: "ui-icon-triangle-1-e"
            },

            // callbacks
            activate: null,
            beforeActivate: null
        },

        _create: function () {
            var options = this.options;
            this.prevShow = this.prevHide = $();
            this.element.addClass("ui-accordion ui-widget ui-helper-reset")
                // ARIA
                .attr("role", "tablist");

            // don't allow collapsible: false and active: false / null
            if (!options.collapsible && (options.active === false || options.active == null)) {
                options.active = 0;
            }

            this._processPanels();
            // handle negative values
            if (options.active < 0) {
                options.active += this.headers.length;
            }
            this._refresh();
        },

        _getCreateEventData: function () {
            return {
                header: this.active,
                panel: !this.active.length ? $() : this.active.next(),
                content: !this.active.length ? $() : this.active.next()
            };
        },

        _createIcons: function () {
            var icons = this.options.icons;
            if (icons) {
                $("<span>")
                    .addClass("ui-accordion-header-icon ui-icon " + icons.header)
                    .prependTo(this.headers);
                this.active.children(".ui-accordion-header-icon")
                    .removeClass(icons.header)
                    .addClass(icons.activeHeader);
                this.headers.addClass("ui-accordion-icons");
            }
        },

        _destroyIcons: function () {
            this.headers
                .removeClass("ui-accordion-icons")
                .children(".ui-accordion-header-icon")
                .remove();
        },

        _destroy: function () {
            var contents;

            // clean up main element
            this.element
                .removeClass("ui-accordion ui-widget ui-helper-reset")
                .removeAttr("role");

            // clean up headers
            this.headers
                .removeClass("ui-accordion-header ui-accordion-header-active ui-helper-reset ui-state-default ui-corner-all ui-state-active ui-state-disabled ui-corner-top")
                .removeAttr("role")
                .removeAttr("aria-selected")
                .removeAttr("aria-controls")
                .removeAttr("tabIndex")
                .each(function () {
                    if (/^ui-accordion/.test(this.id)) {
                        this.removeAttribute("id");
                    }
                });
            this._destroyIcons();

            // clean up content panels
            contents = this.headers.next()
                .css("display", "")
                .removeAttr("role")
                .removeAttr("aria-expanded")
                .removeAttr("aria-hidden")
                .removeAttr("aria-labelledby")
                .removeClass("ui-helper-reset ui-widget-content ui-corner-bottom ui-accordion-content ui-accordion-content-active ui-state-disabled")
                .each(function () {
                    if (/^ui-accordion/.test(this.id)) {
                        this.removeAttribute("id");
                    }
                });
            if (this.options.heightStyle !== "content") {
                contents.css("height", "");
            }
        },

        _setOption: function (key, value) {
            if (key === "active") {
                // _activate() will handle invalid values and update this.options
                this._activate(value);
                return;
            }

            if (key === "event") {
                if (this.options.event) {
                    this._off(this.headers, this.options.event);
                }
                this._setupEvents(value);
            }

            this._super(key, value);

            // setting collapsible: false while collapsed; open first panel
            if (key === "collapsible" && !value && this.options.active === false) {
                this._activate(0);
            }

            if (key === "icons") {
                this._destroyIcons();
                if (value) {
                    this._createIcons();
                }
            }

            // #5332 - opacity doesn't cascade to positioned elements in IE
            // so we need to add the disabled class to the headers and panels
            if (key === "disabled") {
                this.headers.add(this.headers.next())
                    .toggleClass("ui-state-disabled", !!value);
            }
        },

        _keydown: function (event) {
            /*jshint maxcomplexity:15*/
            if (event.altKey || event.ctrlKey) {
                return;
            }

            var keyCode = $.ui.keyCode,
                length = this.headers.length,
                currentIndex = this.headers.index(event.target),
                toFocus = false;

            switch (event.keyCode) {
                case keyCode.RIGHT:
                case keyCode.DOWN:
                    toFocus = this.headers[(currentIndex + 1) % length];
                    break;
                case keyCode.LEFT:
                case keyCode.UP:
                    toFocus = this.headers[(currentIndex - 1 + length) % length];
                    break;
                case keyCode.SPACE:
                case keyCode.ENTER:
                    this._eventHandler(event);
                    break;
                case keyCode.HOME:
                    toFocus = this.headers[0];
                    break;
                case keyCode.END:
                    toFocus = this.headers[length - 1];
                    break;
            }

            if (toFocus) {
                $(event.target).attr("tabIndex", -1);
                $(toFocus).attr("tabIndex", 0);
                toFocus.focus();
                event.preventDefault();
            }
        },

        _panelKeyDown: function (event) {
            if (event.keyCode === $.ui.keyCode.UP && event.ctrlKey) {
                $(event.currentTarget).prev().focus();
            }
        },

        refresh: function () {
            var options = this.options;
            this._processPanels();

            // was collapsed or no panel
            if ((options.active === false && options.collapsible === true) || !this.headers.length) {
                options.active = false;
                this.active = $();
                // active false only when collapsible is true
            } if (options.active === false) {
                this._activate(0);
                // was active, but active panel is gone
            } else if (this.active.length && !$.contains(this.element[0], this.active[0])) {
                // all remaining panel are disabled
                if (this.headers.length === this.headers.find(".ui-state-disabled").length) {
                    options.active = false;
                    this.active = $();
                    // activate previous panel
                } else {
                    this._activate(Math.max(0, options.active - 1));
                }
                // was active, active panel still exists
            } else {
                // make sure active index is correct
                options.active = this.headers.index(this.active);
            }

            this._destroyIcons();

            this._refresh();
        },

        _processPanels: function () {
            this.headers = this.element.find(this.options.header)
                .addClass("ui-accordion-header ui-helper-reset ui-state-default ui-corner-all");

            this.headers.next()
                .addClass("ui-accordion-content ui-helper-reset ui-widget-content ui-corner-bottom")
                .filter(":not(.ui-accordion-content-active)")
                .hide();
        },

        _refresh: function () {
            var maxHeight,
                options = this.options,
                heightStyle = options.heightStyle,
                parent = this.element.parent(),
                accordionId = this.accordionId = "ui-accordion-" +
                    (this.element.attr("id") || ++uid);

            this.active = this._findActive(options.active)
                .addClass("ui-accordion-header-active ui-state-active ui-corner-top")
                .removeClass("ui-corner-all");
            this.active.next()
                .addClass("ui-accordion-content-active")
                .show();

            this.headers
                .attr("role", "tab")
                .each(function (i) {
                    var header = $(this),
                        headerId = header.attr("id"),
                        panel = header.next(),
                        panelId = panel.attr("id");
                    if (!headerId) {
                        headerId = accordionId + "-header-" + i;
                        header.attr("id", headerId);
                    }
                    if (!panelId) {
                        panelId = accordionId + "-panel-" + i;
                        panel.attr("id", panelId);
                    }
                    header.attr("aria-controls", panelId);
                    panel.attr("aria-labelledby", headerId);
                })
                .next()
                .attr("role", "tabpanel");

            this.headers
                .not(this.active)
                .attr({
                    "aria-selected": "false",
                    tabIndex: -1
                })
                .next()
                .attr({
                    "aria-expanded": "false",
                    "aria-hidden": "true"
                })
                .hide();

            // make sure at least one header is in the tab order
            if (!this.active.length) {
                this.headers.eq(0).attr("tabIndex", 0);
            } else {
                this.active.attr({
                    "aria-selected": "true",
                    tabIndex: 0
                })
                    .next()
                    .attr({
                        "aria-expanded": "true",
                        "aria-hidden": "false"
                    });
            }

            this._createIcons();

            this._setupEvents(options.event);

            if (heightStyle === "fill") {
                maxHeight = parent.height();
                this.element.siblings(":visible").each(function () {
                    var elem = $(this),
                        position = elem.css("position");

                    if (position === "absolute" || position === "fixed") {
                        return;
                    }
                    maxHeight -= elem.outerHeight(true);
                });

                this.headers.each(function () {
                    maxHeight -= $(this).outerHeight(true);
                });

                this.headers.next()
                    .each(function () {
                        $(this).height(Math.max(0, maxHeight -
                            $(this).innerHeight() + $(this).height()));
                    })
                    .css("overflow", "auto");
            } else if (heightStyle === "auto") {
                maxHeight = 0;
                this.headers.next()
                    .each(function () {
                        maxHeight = Math.max(maxHeight, $(this).css("height", "").height());
                    })
                    .height(maxHeight);
            }
        },

        _activate: function (index) {
            var active = this._findActive(index)[0];

            // trying to activate the already active panel
            if (active === this.active[0]) {
                return;
            }

            // trying to collapse, simulate a click on the currently active header
            active = active || this.active[0];

            this._eventHandler({
                target: active,
                currentTarget: active,
                preventDefault: $.noop
            });
        },

        _findActive: function (selector) {
            return typeof selector === "number" ? this.headers.eq(selector) : $();
        },

        _setupEvents: function (event) {
            var events = {
                keydown: "_keydown"
            };
            if (event) {
                $.each(event.split(" "), function (index, eventName) {
                    events[eventName] = "_eventHandler";
                });
            }

            this._off(this.headers.add(this.headers.next()));
            this._on(this.headers, events);
            this._on(this.headers.next(), { keydown: "_panelKeyDown" });
            this._hoverable(this.headers);
            this._focusable(this.headers);
        },

        _eventHandler: function (event) {
            var options = this.options,
                active = this.active,
                clicked = $(event.currentTarget),
                clickedIsActive = clicked[0] === active[0],
                collapsing = clickedIsActive && options.collapsible,
                toShow = collapsing ? $() : clicked.next(),
                toHide = active.next(),
                eventData = {
                    oldHeader: active,
                    oldPanel: toHide,
                    newHeader: collapsing ? $() : clicked,
                    newPanel: toShow
                };

            event.preventDefault();

            if (
                // click on active header, but not collapsible
                (clickedIsActive && !options.collapsible) ||
                // allow canceling activation
                (this._trigger("beforeActivate", event, eventData) === false)) {
                return;
            }

            options.active = collapsing ? false : this.headers.index(clicked);

            // when the call to ._toggle() comes after the class changes
            // it causes a very odd bug in IE 8 (see #6720)
            this.active = clickedIsActive ? $() : clicked;
            this._toggle(eventData);

            // switch classes
            // corner classes on the previously active header stay after the animation
            active.removeClass("ui-accordion-header-active ui-state-active");
            if (options.icons) {
                active.children(".ui-accordion-header-icon")
                    .removeClass(options.icons.activeHeader)
                    .addClass(options.icons.header);
            }

            if (!clickedIsActive) {
                clicked
                    .removeClass("ui-corner-all")
                    .addClass("ui-accordion-header-active ui-state-active ui-corner-top");
                if (options.icons) {
                    clicked.children(".ui-accordion-header-icon")
                        .removeClass(options.icons.header)
                        .addClass(options.icons.activeHeader);
                }

                clicked
                    .next()
                    .addClass("ui-accordion-content-active");
            }
        },

        _toggle: function (data) {
            var toShow = data.newPanel,
                toHide = this.prevShow.length ? this.prevShow : data.oldPanel;

            // handle activating a panel during the animation for another activation
            this.prevShow.add(this.prevHide).stop(true, true);
            this.prevShow = toShow;
            this.prevHide = toHide;

            if (this.options.animate) {
                this._animate(toShow, toHide, data);
            } else {
                toHide.hide();
                toShow.show();
                this._toggleComplete(data);
            }

            toHide.attr({
                "aria-expanded": "false",
                "aria-hidden": "true"
            });
            toHide.prev().attr("aria-selected", "false");
            // if we're switching panels, remove the old header from the tab order
            // if we're opening from collapsed state, remove the previous header from the tab order
            // if we're collapsing, then keep the collapsing header in the tab order
            if (toShow.length && toHide.length) {
                toHide.prev().attr("tabIndex", -1);
            } else if (toShow.length) {
                this.headers.filter(function () {
                    return $(this).attr("tabIndex") === 0;
                })
                    .attr("tabIndex", -1);
            }

            toShow
                .attr({
                    "aria-expanded": "true",
                    "aria-hidden": "false"
                })
                .prev()
                .attr({
                    "aria-selected": "true",
                    tabIndex: 0
                });
        },

        _animate: function (toShow, toHide, data) {
            var total, easing, duration,
                that = this,
                adjust = 0,
                down = toShow.length &&
                    (!toHide.length || (toShow.index() < toHide.index())),
                animate = this.options.animate || {},
                options = down && animate.down || animate,
                complete = function () {
                    that._toggleComplete(data);
                };

            if (typeof options === "number") {
                duration = options;
            }
            if (typeof options === "string") {
                easing = options;
            }
            // fall back from options to animation in case of partial down settings
            easing = easing || options.easing || animate.easing;
            duration = duration || options.duration || animate.duration;

            if (!toHide.length) {
                return toShow.animate(showProps, duration, easing, complete);
            }
            if (!toShow.length) {
                return toHide.animate(hideProps, duration, easing, complete);
            }

            total = toShow.show().outerHeight();
            toHide.animate(hideProps, {
                duration: duration,
                easing: easing,
                step: function (now, fx) {
                    fx.now = Math.round(now);
                }
            });
            toShow
                .hide()
                .animate(showProps, {
                    duration: duration,
                    easing: easing,
                    complete: complete,
                    step: function (now, fx) {
                        fx.now = Math.round(now);
                        if (fx.prop !== "height") {
                            adjust += fx.now;
                        } else if (that.options.heightStyle !== "content") {
                            fx.now = Math.round(total - toHide.outerHeight() - adjust);
                            adjust = 0;
                        }
                    }
                });
        },

        _toggleComplete: function (data) {
            var toHide = data.oldPanel;

            toHide
                .removeClass("ui-accordion-content-active")
                .prev()
                .removeClass("ui-corner-top")
                .addClass("ui-corner-all");

            // Work around for rendering bug in IE (#5421)
            if (toHide.length) {
                toHide.parent()[0].className = toHide.parent()[0].className;
            }

            this._trigger("activate", null, data);
        }
    });

})(jQuery);

(function ($, undefined) {

    // used to prevent race conditions with remote data sources
    var requestIndex = 0;

    $.widget("ui.autocomplete", {
        version: "1.10.2",
        defaultElement: "<input>",
        options: {
            appendTo: null,
            autoFocus: false,
            delay: 300,
            minLength: 1,
            position: {
                my: "left top",
                at: "left bottom",
                collision: "none"
            },
            source: null,

            // callbacks
            change: null,
            close: null,
            focus: null,
            open: null,
            response: null,
            search: null,
            select: null
        },

        pending: 0,

        _create: function () {
            // Some browsers only repeat keydown events, not keypress events,
            // so we use the suppressKeyPress flag to determine if we've already
            // handled the keydown event. #7269
            // Unfortunately the code for & in keypress is the same as the up arrow,
            // so we use the suppressKeyPressRepeat flag to avoid handling keypress
            // events when we know the keydown event was used to modify the
            // search term. #7799
            var suppressKeyPress, suppressKeyPressRepeat, suppressInput,
                nodeName = this.element[0].nodeName.toLowerCase(),
                isTextarea = nodeName === "textarea",
                isInput = nodeName === "input";

            this.isMultiLine =
                // Textareas are always multi-line
                isTextarea ? true :
                    // Inputs are always single-line, even if inside a contentEditable element
                    // IE also treats inputs as contentEditable
                    isInput ? false :
                        // All other element types are determined by whether or not they're contentEditable
                        this.element.prop("isContentEditable");

            this.valueMethod = this.element[isTextarea || isInput ? "val" : "text"];
            this.isNewMenu = true;

            this.element
                .addClass("ui-autocomplete-input")
                .attr("autocomplete", "off");

            this._on(this.element, {
                keydown: function (event) {
                    /*jshint maxcomplexity:15*/
                    if (this.element.prop("readOnly")) {
                        suppressKeyPress = true;
                        suppressInput = true;
                        suppressKeyPressRepeat = true;
                        return;
                    }

                    suppressKeyPress = false;
                    suppressInput = false;
                    suppressKeyPressRepeat = false;
                    var keyCode = $.ui.keyCode;
                    switch (event.keyCode) {
                        case keyCode.PAGE_UP:
                            suppressKeyPress = true;
                            this._move("previousPage", event);
                            break;
                        case keyCode.PAGE_DOWN:
                            suppressKeyPress = true;
                            this._move("nextPage", event);
                            break;
                        case keyCode.UP:
                            suppressKeyPress = true;
                            this._keyEvent("previous", event);
                            break;
                        case keyCode.DOWN:
                            suppressKeyPress = true;
                            this._keyEvent("next", event);
                            break;
                        case keyCode.ENTER:
                        case keyCode.NUMPAD_ENTER:
                            // when menu is open and has focus
                            if (this.menu.active) {
                                // #6055 - Opera still allows the keypress to occur
                                // which causes forms to submit
                                suppressKeyPress = true;
                                event.preventDefault();
                                this.menu.select(event);
                            }
                            break;
                        case keyCode.TAB:
                            if (this.menu.active) {
                                this.menu.select(event);
                            }
                            break;
                        case keyCode.ESCAPE:
                            if (this.menu.element.is(":visible")) {
                                this._value(this.term);
                                this.close(event);
                                // Different browsers have different default behavior for escape
                                // Single press can mean undo or clear
                                // Double press in IE means clear the whole form
                                event.preventDefault();
                            }
                            break;
                        default:
                            suppressKeyPressRepeat = true;
                            // search timeout should be triggered before the input value is changed
                            this._searchTimeout(event);
                            break;
                    }
                },
                keypress: function (event) {
                    if (suppressKeyPress) {
                        suppressKeyPress = false;
                        event.preventDefault();
                        return;
                    }
                    if (suppressKeyPressRepeat) {
                        return;
                    }

                    // replicate some key handlers to allow them to repeat in Firefox and Opera
                    var keyCode = $.ui.keyCode;
                    switch (event.keyCode) {
                        case keyCode.PAGE_UP:
                            this._move("previousPage", event);
                            break;
                        case keyCode.PAGE_DOWN:
                            this._move("nextPage", event);
                            break;
                        case keyCode.UP:
                            this._keyEvent("previous", event);
                            break;
                        case keyCode.DOWN:
                            this._keyEvent("next", event);
                            break;
                    }
                },
                input: function (event) {
                    if (suppressInput) {
                        suppressInput = false;
                        event.preventDefault();
                        return;
                    }
                    this._searchTimeout(event);
                },
                focus: function () {
                    this.selectedItem = null;
                    this.previous = this._value();
                },
                blur: function (event) {
                    if (this.cancelBlur) {
                        delete this.cancelBlur;
                        return;
                    }

                    clearTimeout(this.searching);
                    this.close(event);
                    this._change(event);
                }
            });

            this._initSource();
            this.menu = $("<ul>")
                .addClass("ui-autocomplete ui-front")
                .appendTo(this._appendTo())
                .menu({
                    // custom key handling for now
                    input: $(),
                    // disable ARIA support, the live region takes care of that
                    role: null
                })
                .hide()
                .data("ui-menu");

            this._on(this.menu.element, {
                mousedown: function (event) {
                    // prevent moving focus out of the text field
                    event.preventDefault();

                    // IE doesn't prevent moving focus even with event.preventDefault()
                    // so we set a flag to know when we should ignore the blur event
                    this.cancelBlur = true;
                    this._delay(function () {
                        delete this.cancelBlur;
                    });

                    // clicking on the scrollbar causes focus to shift to the body
                    // but we can't detect a mouseup or a click immediately afterward
                    // so we have to track the next mousedown and close the menu if
                    // the user clicks somewhere outside of the autocomplete
                    var menuElement = this.menu.element[0];
                    if (!$(event.target).closest(".ui-menu-item").length) {
                        this._delay(function () {
                            var that = this;
                            this.document.one("mousedown", function (event) {
                                if (event.target !== that.element[0] &&
                                    event.target !== menuElement &&
                                    !$.contains(menuElement, event.target)) {
                                    that.close();
                                }
                            });
                        });
                    }
                },
                menufocus: function (event, ui) {
                    // support: Firefox
                    // Prevent accidental activation of menu items in Firefox (#7024 #9118)
                    if (this.isNewMenu) {
                        this.isNewMenu = false;
                        if (event.originalEvent && /^mouse/.test(event.originalEvent.type)) {
                            this.menu.blur();

                            this.document.one("mousemove", function () {
                                $(event.target).trigger(event.originalEvent);
                            });

                            return;
                        }
                    }

                    var item = ui.item.data("ui-autocomplete-item");
                    if (false !== this._trigger("focus", event, { item: item })) {
                        // use value to match what will end up in the input, if it was a key event
                        if (event.originalEvent && /^key/.test(event.originalEvent.type)) {
                            this._value(item.value);
                        }
                    } else {
                        // Normally the input is populated with the item's value as the
                        // menu is navigated, causing screen readers to notice a change and
                        // announce the item. Since the focus event was canceled, this doesn't
                        // happen, so we update the live region so that screen readers can
                        // still notice the change and announce it.
                        this.liveRegion.text(item.value);
                    }
                },
                menuselect: function (event, ui) {
                    var item = ui.item.data("ui-autocomplete-item"),
                        previous = this.previous;

                    // only trigger when focus was lost (click on menu)
                    if (this.element[0] !== this.document[0].activeElement) {
                        this.element.focus();
                        this.previous = previous;
                        // #6109 - IE triggers two focus events and the second
                        // is asynchronous, so we need to reset the previous
                        // term synchronously and asynchronously :-(
                        this._delay(function () {
                            this.previous = previous;
                            this.selectedItem = item;
                        });
                    }

                    if (false !== this._trigger("select", event, { item: item })) {
                        this._value(item.value);
                    }
                    // reset the term after the select event
                    // this allows custom select handling to work properly
                    this.term = this._value();

                    this.close(event);
                    this.selectedItem = item;
                }
            });

            this.liveRegion = $("<span>", {
                role: "status",
                "aria-live": "polite"
            })
                .addClass("ui-helper-hidden-accessible")
                .insertAfter(this.element);

            // turning off autocomplete prevents the browser from remembering the
            // value when navigating through history, so we re-enable autocomplete
            // if the page is unloaded before the widget is destroyed. #7790
            this._on(this.window, {
                beforeunload: function () {
                    this.element.removeAttr("autocomplete");
                }
            });
        },

        _destroy: function () {
            clearTimeout(this.searching);
            this.element
                .removeClass("ui-autocomplete-input")
                .removeAttr("autocomplete");
            this.menu.element.remove();
            this.liveRegion.remove();
        },

        _setOption: function (key, value) {
            this._super(key, value);
            if (key === "source") {
                this._initSource();
            }
            if (key === "appendTo") {
                this.menu.element.appendTo(this._appendTo());
            }
            if (key === "disabled" && value && this.xhr) {
                this.xhr.abort();
            }
        },

        _appendTo: function () {
            var element = this.options.appendTo;

            if (element) {
                element = element.jquery || element.nodeType ?
                    $(element) :
                    this.document.find(element).eq(0);
            }

            if (!element) {
                element = this.element.closest(".ui-front");
            }

            if (!element.length) {
                element = this.document[0].body;
            }

            return element;
        },

        _initSource: function () {
            var array, url,
                that = this;
            if ($.isArray(this.options.source)) {
                array = this.options.source;
                this.source = function (request, response) {
                    response($.ui.autocomplete.filter(array, request.term));
                };
            } else if (typeof this.options.source === "string") {
                url = this.options.source;
                this.source = function (request, response) {
                    if (that.xhr) {
                        that.xhr.abort();
                    }
                    that.xhr = $.ajax({
                        url: url,
                        data: request,
                        dataType: "json",
                        success: function (data) {
                            response(data);
                        },
                        error: function () {
                            response([]);
                        }
                    });
                };
            } else {
                this.source = this.options.source;
            }
        },

        _searchTimeout: function (event) {
            clearTimeout(this.searching);
            this.searching = this._delay(function () {
                // only search if the value has changed
                if (this.term !== this._value()) {
                    this.selectedItem = null;
                    this.search(null, event);
                }
            }, this.options.delay);
        },

        search: function (value, event) {
            value = value != null ? value : this._value();

            // always save the actual value, not the one passed as an argument
            this.term = this._value();

            if (value.length < this.options.minLength) {
                return this.close(event);
            }

            if (this._trigger("search", event) === false) {
                return;
            }

            return this._search(value);
        },

        _search: function (value) {
            this.pending++;
            this.element.addClass("ui-autocomplete-loading");
            this.cancelSearch = false;

            this.source({ term: value }, this._response());
        },

        _response: function () {
            var that = this,
                index = ++requestIndex;

            return function (content) {
                if (index === requestIndex) {
                    that.__response(content);
                }

                that.pending--;
                if (!that.pending) {
                    that.element.removeClass("ui-autocomplete-loading");
                }
            };
        },

        __response: function (content) {
            if (content) {
                content = this._normalize(content);
            }
            this._trigger("response", null, { content: content });
            if (!this.options.disabled && content && content.length && !this.cancelSearch) {
                this._suggest(content);
                this._trigger("open");
            } else {
                // use ._close() instead of .close() so we don't cancel future searches
                this._close();
            }
        },

        close: function (event) {
            this.cancelSearch = true;
            this._close(event);
        },

        _close: function (event) {
            if (this.menu.element.is(":visible")) {
                this.menu.element.hide();
                this.menu.blur();
                this.isNewMenu = true;
                this._trigger("close", event);
            }
        },

        _change: function (event) {
            if (this.previous !== this._value()) {
                this._trigger("change", event, { item: this.selectedItem });
            }
        },

        _normalize: function (items) {
            // assume all items have the right format when the first item is complete
            if (items.length && items[0].label && items[0].value) {
                return items;
            }
            return $.map(items, function (item) {
                if (typeof item === "string") {
                    return {
                        label: item,
                        value: item
                    };
                }
                return $.extend({
                    label: item.label || item.value,
                    value: item.value || item.label
                }, item);
            });
        },

        _suggest: function (items) {
            var ul = this.menu.element.empty();
            this._renderMenu(ul, items);
            this.isNewMenu = true;
            this.menu.refresh();

            // size and position menu
            ul.show();
            this._resizeMenu();
            ul.position($.extend({
                of: this.element
            }, this.options.position));

            if (this.options.autoFocus) {
                this.menu.next();
            }
        },

        _resizeMenu: function () {
            var ul = this.menu.element;
            ul.outerWidth(Math.max(
                // Firefox wraps long text (possibly a rounding bug)
                // so we add 1px to avoid the wrapping (#7513)
                ul.width("").outerWidth() + 1,
                this.element.outerWidth()
            ));
        },

        _renderMenu: function (ul, items) {
            var that = this;
            $.each(items, function (index, item) {
                that._renderItemData(ul, item);
            });
        },

        _renderItemData: function (ul, item) {
            return this._renderItem(ul, item).data("ui-autocomplete-item", item);
        },

        _renderItem: function (ul, item) {
            return $("<li>")
                .append($("<a>").text(item.label))
                .appendTo(ul);
        },

        _move: function (direction, event) {
            if (!this.menu.element.is(":visible")) {
                this.search(null, event);
                return;
            }
            if (this.menu.isFirstItem() && /^previous/.test(direction) ||
                this.menu.isLastItem() && /^next/.test(direction)) {
                this._value(this.term);
                this.menu.blur();
                return;
            }
            this.menu[direction](event);
        },

        widget: function () {
            return this.menu.element;
        },

        _value: function () {
            return this.valueMethod.apply(this.element, arguments);
        },

        _keyEvent: function (keyEvent, event) {
            if (!this.isMultiLine || this.menu.element.is(":visible")) {
                this._move(keyEvent, event);

                // prevents moving cursor to beginning/end of the text field in some browsers
                event.preventDefault();
            }
        }
    });

    $.extend($.ui.autocomplete, {
        escapeRegex: function (value) {
            return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
        },
        filter: function (array, term) {
            var matcher = new RegExp($.ui.autocomplete.escapeRegex(term), "i");
            return $.grep(array, function (value) {
                return matcher.test(value.label || value.value || value);
            });
        }
    });


    // live region extension, adding a `messages` option
    // NOTE: This is an experimental API. We are still investigating
    // a full solution for string manipulation and internationalization.
    $.widget("ui.autocomplete", $.ui.autocomplete, {
        options: {
            messages: {
                noResults: "No search results.",
                results: function (amount) {
                    return amount + (amount > 1 ? " results are" : " result is") +
                        " available, use up and down arrow keys to navigate.";
                }
            }
        },

        __response: function (content) {
            var message;
            this._superApply(arguments);
            if (this.options.disabled || this.cancelSearch) {
                return;
            }
            if (content && content.length) {
                message = this.options.messages.results(content.length);
            } else {
                message = this.options.messages.noResults;
            }
            this.liveRegion.text(message);
        }
    });

}(jQuery));

(function ($, undefined) {

    var lastActive, startXPos, startYPos, clickDragged,
        baseClasses = "ui-button ui-widget ui-state-default ui-corner-all",
        stateClasses = "ui-state-hover ui-state-active ",
        typeClasses = "ui-button-icons-only ui-button-icon-only ui-button-text-icons ui-button-text-icon-primary ui-button-text-icon-secondary ui-button-text-only",
        formResetHandler = function () {
            var buttons = $(this).find(":ui-button");
            setTimeout(function () {
                buttons.button("refresh");
            }, 1);
        },
        radioGroup = function (radio) {
            var name = radio.name,
                form = radio.form,
                radios = $([]);
            if (name) {
                name = name.replace(/'/g, "\\'");
                if (form) {
                    radios = $(form).find("[name='" + name + "']");
                } else {
                    radios = $("[name='" + name + "']", radio.ownerDocument)
                        .filter(function () {
                            return !this.form;
                        });
                }
            }
            return radios;
        };

    $.widget("ui.button", {
        version: "1.10.2",
        defaultElement: "<button>",
        options: {
            disabled: null,
            text: true,
            label: null,
            icons: {
                primary: null,
                secondary: null
            }
        },
        _create: function () {
            this.element.closest("form")
                .unbind("reset" + this.eventNamespace)
                .bind("reset" + this.eventNamespace, formResetHandler);

            if (typeof this.options.disabled !== "boolean") {
                this.options.disabled = !!this.element.prop("disabled");
            } else {
                this.element.prop("disabled", this.options.disabled);
            }

            this._determineButtonType();
            this.hasTitle = !!this.buttonElement.attr("title");

            var that = this,
                options = this.options,
                toggleButton = this.type === "checkbox" || this.type === "radio",
                activeClass = !toggleButton ? "ui-state-active" : "",
                focusClass = "ui-state-focus";

            if (options.label === null) {
                options.label = (this.type === "input" ? this.buttonElement.val() : this.buttonElement.html());
            }

            this._hoverable(this.buttonElement);

            this.buttonElement
                .addClass(baseClasses)
                .attr("role", "button")
                .bind("mouseenter" + this.eventNamespace, function () {
                    if (options.disabled) {
                        return;
                    }
                    if (this === lastActive) {
                        $(this).addClass("ui-state-active");
                    }
                })
                .bind("mouseleave" + this.eventNamespace, function () {
                    if (options.disabled) {
                        return;
                    }
                    $(this).removeClass(activeClass);
                })
                .bind("click" + this.eventNamespace, function (event) {
                    if (options.disabled) {
                        event.preventDefault();
                        event.stopImmediatePropagation();
                    }
                });

            this.element
                .bind("focus" + this.eventNamespace, function () {
                    // no need to check disabled, focus won't be triggered anyway
                    that.buttonElement.addClass(focusClass);
                })
                .bind("blur" + this.eventNamespace, function () {
                    that.buttonElement.removeClass(focusClass);
                });

            if (toggleButton) {
                this.element.bind("change" + this.eventNamespace, function () {
                    if (clickDragged) {
                        return;
                    }
                    that.refresh();
                });
                // if mouse moves between mousedown and mouseup (drag) set clickDragged flag
                // prevents issue where button state changes but checkbox/radio checked state
                // does not in Firefox (see ticket #6970)
                this.buttonElement
                    .bind("mousedown" + this.eventNamespace, function (event) {
                        if (options.disabled) {
                            return;
                        }
                        clickDragged = false;
                        startXPos = event.pageX;
                        startYPos = event.pageY;
                    })
                    .bind("mouseup" + this.eventNamespace, function (event) {
                        if (options.disabled) {
                            return;
                        }
                        if (startXPos !== event.pageX || startYPos !== event.pageY) {
                            clickDragged = true;
                        }
                    });
            }

            if (this.type === "checkbox") {
                this.buttonElement.bind("click" + this.eventNamespace, function () {
                    if (options.disabled || clickDragged) {
                        return false;
                    }
                });
            } else if (this.type === "radio") {
                this.buttonElement.bind("click" + this.eventNamespace, function () {
                    if (options.disabled || clickDragged) {
                        return false;
                    }
                    $(this).addClass("ui-state-active");
                    that.buttonElement.attr("aria-pressed", "true");

                    var radio = that.element[0];
                    radioGroup(radio)
                        .not(radio)
                        .map(function () {
                            return $(this).button("widget")[0];
                        })
                        .removeClass("ui-state-active")
                        .attr("aria-pressed", "false");
                });
            } else {
                this.buttonElement
                    .bind("mousedown" + this.eventNamespace, function () {
                        if (options.disabled) {
                            return false;
                        }
                        $(this).addClass("ui-state-active");
                        lastActive = this;
                        that.document.one("mouseup", function () {
                            lastActive = null;
                        });
                    })
                    .bind("mouseup" + this.eventNamespace, function () {
                        if (options.disabled) {
                            return false;
                        }
                        $(this).removeClass("ui-state-active");
                    })
                    .bind("keydown" + this.eventNamespace, function (event) {
                        if (options.disabled) {
                            return false;
                        }
                        if (event.keyCode === $.ui.keyCode.SPACE || event.keyCode === $.ui.keyCode.ENTER) {
                            $(this).addClass("ui-state-active");
                        }
                    })
                    // see #8559, we bind to blur here in case the button element loses
                    // focus between keydown and keyup, it would be left in an "active" state
                    .bind("keyup" + this.eventNamespace + " blur" + this.eventNamespace, function () {
                        $(this).removeClass("ui-state-active");
                    });

                if (this.buttonElement.is("a")) {
                    this.buttonElement.keyup(function (event) {
                        if (event.keyCode === $.ui.keyCode.SPACE) {
                            // TODO pass through original event correctly (just as 2nd argument doesn't work)
                            $(this).click();
                        }
                    });
                }
            }

            // TODO: pull out $.Widget's handling for the disabled option into
            // $.Widget.prototype._setOptionDisabled so it's easy to proxy and can
            // be overridden by individual plugins
            this._setOption("disabled", options.disabled);
            this._resetButton();
        },

        _determineButtonType: function () {
            var ancestor, labelSelector, checked;

            if (this.element.is("[type=checkbox]")) {
                this.type = "checkbox";
            } else if (this.element.is("[type=radio]")) {
                this.type = "radio";
            } else if (this.element.is("input")) {
                this.type = "input";
            } else {
                this.type = "button";
            }

            if (this.type === "checkbox" || this.type === "radio") {
                // we don't search against the document in case the element
                // is disconnected from the DOM
                ancestor = this.element.parents().last();
                labelSelector = "label[for='" + this.element.attr("id") + "']";
                this.buttonElement = ancestor.find(labelSelector);
                if (!this.buttonElement.length) {
                    ancestor = ancestor.length ? ancestor.siblings() : this.element.siblings();
                    this.buttonElement = ancestor.filter(labelSelector);
                    if (!this.buttonElement.length) {
                        this.buttonElement = ancestor.find(labelSelector);
                    }
                }
                this.element.addClass("ui-helper-hidden-accessible");

                checked = this.element.is(":checked");
                if (checked) {
                    this.buttonElement.addClass("ui-state-active");
                }
                this.buttonElement.prop("aria-pressed", checked);
            } else {
                this.buttonElement = this.element;
            }
        },

        widget: function () {
            return this.buttonElement;
        },

        _destroy: function () {
            this.element
                .removeClass("ui-helper-hidden-accessible");
            this.buttonElement
                .removeClass(baseClasses + " " + stateClasses + " " + typeClasses)
                .removeAttr("role")
                .removeAttr("aria-pressed")
                .html(this.buttonElement.find(".ui-button-text").html());

            if (!this.hasTitle) {
                this.buttonElement.removeAttr("title");
            }
        },

        _setOption: function (key, value) {
            this._super(key, value);
            if (key === "disabled") {
                if (value) {
                    this.element.prop("disabled", true);
                } else {
                    this.element.prop("disabled", false);
                }
                return;
            }
            this._resetButton();
        },

        refresh: function () {
            //See #8237 & #8828
            var isDisabled = this.element.is("input, button") ? this.element.is(":disabled") : this.element.hasClass("ui-button-disabled");

            if (isDisabled !== this.options.disabled) {
                this._setOption("disabled", isDisabled);
            }
            if (this.type === "radio") {
                radioGroup(this.element[0]).each(function () {
                    if ($(this).is(":checked")) {
                        $(this).button("widget")
                            .addClass("ui-state-active")
                            .attr("aria-pressed", "true");
                    } else {
                        $(this).button("widget")
                            .removeClass("ui-state-active")
                            .attr("aria-pressed", "false");
                    }
                });
            } else if (this.type === "checkbox") {
                if (this.element.is(":checked")) {
                    this.buttonElement
                        .addClass("ui-state-active")
                        .attr("aria-pressed", "true");
                } else {
                    this.buttonElement
                        .removeClass("ui-state-active")
                        .attr("aria-pressed", "false");
                }
            }
        },

        _resetButton: function () {
            if (this.type === "input") {
                if (this.options.label) {
                    this.element.val(this.options.label);
                }
                return;
            }
            var buttonElement = this.buttonElement.removeClass(typeClasses),
                buttonText = $("<span></span>", this.document[0])
                    .addClass("ui-button-text")
                    .html(this.options.label)
                    .appendTo(buttonElement.empty())
                    .text(),
                icons = this.options.icons,
                multipleIcons = icons.primary && icons.secondary,
                buttonClasses = [];

            if (icons.primary || icons.secondary) {
                if (this.options.text) {
                    buttonClasses.push("ui-button-text-icon" + (multipleIcons ? "s" : (icons.primary ? "-primary" : "-secondary")));
                }

                if (icons.primary) {
                    buttonElement.prepend("<span class='ui-button-icon-primary ui-icon " + icons.primary + "'></span>");
                }

                if (icons.secondary) {
                    buttonElement.append("<span class='ui-button-icon-secondary ui-icon " + icons.secondary + "'></span>");
                }

                if (!this.options.text) {
                    buttonClasses.push(multipleIcons ? "ui-button-icons-only" : "ui-button-icon-only");

                    if (!this.hasTitle) {
                        buttonElement.attr("title", $.trim(buttonText));
                    }
                }
            } else {
                buttonClasses.push("ui-button-text-only");
            }
            buttonElement.addClass(buttonClasses.join(" "));
        }
    });

    $.widget("ui.buttonset", {
        version: "1.10.2",
        options: {
            items: "button, input[type=button], input[type=submit], input[type=reset], input[type=checkbox], input[type=radio], a, :data(ui-button)"
        },

        _create: function () {
            this.element.addClass("ui-buttonset");
        },

        _init: function () {
            this.refresh();
        },

        _setOption: function (key, value) {
            if (key === "disabled") {
                this.buttons.button("option", key, value);
            }

            this._super(key, value);
        },

        refresh: function () {
            var rtl = this.element.css("direction") === "rtl";

            this.buttons = this.element.find(this.options.items)
                .filter(":ui-button")
                .button("refresh")
                .end()
                .not(":ui-button")
                .button()
                .end()
                .map(function () {
                    return $(this).button("widget")[0];
                })
                .removeClass("ui-corner-all ui-corner-left ui-corner-right")
                .filter(":first")
                .addClass(rtl ? "ui-corner-right" : "ui-corner-left")
                .end()
                .filter(":last")
                .addClass(rtl ? "ui-corner-left" : "ui-corner-right")
                .end()
                .end();
        },

        _destroy: function () {
            this.element.removeClass("ui-buttonset");
            this.buttons
                .map(function () {
                    return $(this).button("widget")[0];
                })
                .removeClass("ui-corner-left ui-corner-right")
                .end()
                .button("destroy");
        }
    });

}(jQuery));

(function ($, undefined) {

    $.extend($.ui, { datepicker: { version: "1.10.2" } });

    var PROP_NAME = "datepicker",
        dpuuid = new Date().getTime(),
        instActive;

    /* Date picker manager.
       Use the singleton instance of this class, $.datepicker, to interact with the date picker.
       Settings for (groups of) date pickers are maintained in an instance object,
       allowing multiple different settings on the same page. */

    function Datepicker() {
        this._curInst = null; // The current instance in use
        this._keyEvent = false; // If the last event was a key event
        this._disabledInputs = []; // List of date picker inputs that have been disabled
        this._datepickerShowing = false; // True if the popup picker is showing , false if not
        this._inDialog = false; // True if showing within a "dialog", false if not
        this._mainDivId = "ui-datepicker-div"; // The ID of the main datepicker division
        this._inlineClass = "ui-datepicker-inline"; // The name of the inline marker class
        this._appendClass = "ui-datepicker-append"; // The name of the append marker class
        this._triggerClass = "ui-datepicker-trigger"; // The name of the trigger marker class
        this._dialogClass = "ui-datepicker-dialog"; // The name of the dialog marker class
        this._disableClass = "ui-datepicker-disabled"; // The name of the disabled covering marker class
        this._unselectableClass = "ui-datepicker-unselectable"; // The name of the unselectable cell marker class
        this._currentClass = "ui-datepicker-current-day"; // The name of the current day marker class
        this._dayOverClass = "ui-datepicker-days-cell-over"; // The name of the day hover marker class
        this.regional = []; // Available regional settings, indexed by language code
        this.regional[""] = { // Default regional settings
            closeText: "Done", // Display text for close link
            prevText: "Prev", // Display text for previous month link
            nextText: "Next", // Display text for next month link
            currentText: "Today", // Display text for current month link
            monthNames: ["January", "February", "March", "April", "May", "June",
                "July", "August", "September", "October", "November", "December"], // Names of months for drop-down and formatting
            monthNamesShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], // For formatting
            dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], // For formatting
            dayNamesShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], // For formatting
            dayNamesMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"], // Column headings for days starting at Sunday
            weekHeader: "Wk", // Column header for week of the year
            dateFormat: "mm/dd/yy", // See format options on parseDate
            firstDay: 0, // The first day of the week, Sun = 0, Mon = 1, ...
            isRTL: false, // True if right-to-left language, false if left-to-right
            showMonthAfterYear: false, // True if the year select precedes month, false for month then year
            yearSuffix: "" // Additional text to append to the year in the month headers
        };
        this._defaults = { // Global defaults for all the date picker instances
            showOn: "focus", // "focus" for popup on focus,
            // "button" for trigger button, or "both" for either
            showAnim: "fadeIn", // Name of jQuery animation for popup
            showOptions: {}, // Options for enhanced animations
            defaultDate: null, // Used when field is blank: actual date,
            // +/-number for offset from today, null for today
            appendText: "", // Display text following the input box, e.g. showing the format
            buttonText: "...", // Text for trigger button
            buttonImage: "", // URL for trigger button image
            buttonImageOnly: false, // True if the image appears alone, false if it appears on a button
            hideIfNoPrevNext: false, // True to hide next/previous month links
            // if not applicable, false to just disable them
            navigationAsDateFormat: false, // True if date formatting applied to prev/today/next links
            gotoCurrent: false, // True if today link goes back to current selection instead
            changeMonth: false, // True if month can be selected directly, false if only prev/next
            changeYear: false, // True if year can be selected directly, false if only prev/next
            yearRange: "c-10:c+10", // Range of years to display in drop-down,
            // either relative to today's year (-nn:+nn), relative to currently displayed year
            // (c-nn:c+nn), absolute (nnnn:nnnn), or a combination of the above (nnnn:-n)
            showOtherMonths: false, // True to show dates in other months, false to leave blank
            selectOtherMonths: false, // True to allow selection of dates in other months, false for unselectable
            showWeek: false, // True to show week of the year, false to not show it
            calculateWeek: this.iso8601Week, // How to calculate the week of the year,
            // takes a Date and returns the number of the week for it
            shortYearCutoff: "+10", // Short year values < this are in the current century,
            // > this are in the previous century,
            // string value starting with "+" for current year + value
            minDate: null, // The earliest selectable date, or null for no limit
            maxDate: null, // The latest selectable date, or null for no limit
            duration: "fast", // Duration of display/closure
            beforeShowDay: null, // Function that takes a date and returns an array with
            // [0] = true if selectable, false if not, [1] = custom CSS class name(s) or "",
            // [2] = cell title (optional), e.g. $.datepicker.noWeekends
            beforeShow: null, // Function that takes an input field and
            // returns a set of custom settings for the date picker
            onSelect: null, // Define a callback function when a date is selected
            onChangeMonthYear: null, // Define a callback function when the month or year is changed
            onClose: null, // Define a callback function when the datepicker is closed
            numberOfMonths: 1, // Number of months to show at a time
            showCurrentAtPos: 0, // The position in multipe months at which to show the current month (starting at 0)
            stepMonths: 1, // Number of months to step back/forward
            stepBigMonths: 12, // Number of months to step back/forward for the big links
            altField: "", // Selector for an alternate field to store selected dates into
            altFormat: "", // The date format to use for the alternate field
            constrainInput: true, // The input is constrained by the current date format
            showButtonPanel: false, // True to show button panel, false to not show it
            autoSize: false, // True to size the input for the date format, false to leave as is
            disabled: false // The initial disabled state
        };
        $.extend(this._defaults, this.regional[""]);
        this.dpDiv = bindHover($("<div id='" + this._mainDivId + "' class='ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>"));
    }

    $.extend(Datepicker.prototype, {
        /* Class name added to elements to indicate already configured with a date picker. */
        markerClassName: "hasDatepicker",

        //Keep track of the maximum number of rows displayed (see #7043)
        maxRows: 4,

        // TODO rename to "widget" when switching to widget factory
        _widgetDatepicker: function () {
            return this.dpDiv;
        },

        /* Override the default settings for all instances of the date picker.
         * @param  settings  object - the new settings to use as defaults (anonymous object)
         * @return the manager object
         */
        setDefaults: function (settings) {
            extendRemove(this._defaults, settings || {});
            return this;
        },

        /* Attach the date picker to a jQuery selection.
         * @param  target element - the target input field or division or span
         * @param  settings  object - the new settings to use for this date picker instance (anonymous)
         */
        _attachDatepicker: function (target, settings) {
            var nodeName, inline, inst;
            nodeName = target.nodeName.toLowerCase();
            inline = (nodeName === "div" || nodeName === "span");
            if (!target.id) {
                this.uuid += 1;
                target.id = "dp" + this.uuid;
            }
            inst = this._newInst($(target), inline);
            inst.settings = $.extend({}, settings || {});
            if (nodeName === "input") {
                this._connectDatepicker(target, inst);
            } else if (inline) {
                this._inlineDatepicker(target, inst);
            }
        },

        /* Create a new instance object. */
        _newInst: function (target, inline) {
            var id = target[0].id.replace(/([^A-Za-z0-9_\-])/g, "\\\\$1"); // escape jQuery meta chars
            return {
                id: id, input: target, // associated target
                selectedDay: 0, selectedMonth: 0, selectedYear: 0, // current selection
                drawMonth: 0, drawYear: 0, // month being drawn
                inline: inline, // is datepicker inline or not
                dpDiv: (!inline ? this.dpDiv : // presentation div
                    bindHover($("<div class='" + this._inlineClass + " ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>")))
            };
        },

        /* Attach the date picker to an input field. */
        _connectDatepicker: function (target, inst) {
            var input = $(target);
            inst.append = $([]);
            inst.trigger = $([]);
            if (input.hasClass(this.markerClassName)) {
                return;
            }
            this._attachments(input, inst);
            input.addClass(this.markerClassName).keydown(this._doKeyDown).
                keypress(this._doKeyPress).keyup(this._doKeyUp);
            this._autoSize(inst);
            $.data(target, PROP_NAME, inst);
            //If disabled option is true, disable the datepicker once it has been attached to the input (see ticket #5665)
            if (inst.settings.disabled) {
                this._disableDatepicker(target);
            }
        },

        /* Make attachments based on settings. */
        _attachments: function (input, inst) {
            var showOn, buttonText, buttonImage,
                appendText = this._get(inst, "appendText"),
                isRTL = this._get(inst, "isRTL");

            if (inst.append) {
                inst.append.remove();
            }
            if (appendText) {
                inst.append = $("<span class='" + this._appendClass + "'>" + appendText + "</span>");
                input[isRTL ? "before" : "after"](inst.append);
            }

            input.unbind("focus", this._showDatepicker);

            if (inst.trigger) {
                inst.trigger.remove();
            }

            showOn = this._get(inst, "showOn");
            if (showOn === "focus" || showOn === "both") { // pop-up date picker when in the marked field
                input.focus(this._showDatepicker);
            }
            if (showOn === "button" || showOn === "both") { // pop-up date picker when button clicked
                buttonText = this._get(inst, "buttonText");
                buttonImage = this._get(inst, "buttonImage");
                inst.trigger = $(this._get(inst, "buttonImageOnly") ?
                    $("<img/>").addClass(this._triggerClass).
                        attr({ src: buttonImage, alt: buttonText, title: buttonText }) :
                    $("<button type='button'></button>").addClass(this._triggerClass).
                        html(!buttonImage ? buttonText : $("<img/>").attr(
                            { src: buttonImage, alt: buttonText, title: buttonText })));
                input[isRTL ? "before" : "after"](inst.trigger);
                inst.trigger.click(function () {
                    if ($.datepicker._datepickerShowing && $.datepicker._lastInput === input[0]) {
                        $.datepicker._hideDatepicker();
                    } else if ($.datepicker._datepickerShowing && $.datepicker._lastInput !== input[0]) {
                        $.datepicker._hideDatepicker();
                        $.datepicker._showDatepicker(input[0]);
                    } else {
                        $.datepicker._showDatepicker(input[0]);
                    }
                    return false;
                });
            }
        },

        /* Apply the maximum length for the date format. */
        _autoSize: function (inst) {
            if (this._get(inst, "autoSize") && !inst.inline) {
                var findMax, max, maxI, i,
                    date = new Date(2009, 12 - 1, 20), // Ensure double digits
                    dateFormat = this._get(inst, "dateFormat");

                if (dateFormat.match(/[DM]/)) {
                    findMax = function (names) {
                        max = 0;
                        maxI = 0;
                        for (i = 0; i < names.length; i++) {
                            if (names[i].length > max) {
                                max = names[i].length;
                                maxI = i;
                            }
                        }
                        return maxI;
                    };
                    date.setMonth(findMax(this._get(inst, (dateFormat.match(/MM/) ?
                        "monthNames" : "monthNamesShort"))));
                    date.setDate(findMax(this._get(inst, (dateFormat.match(/DD/) ?
                        "dayNames" : "dayNamesShort"))) + 20 - date.getDay());
                }
                inst.input.attr("size", this._formatDate(inst, date).length);
            }
        },

        /* Attach an inline date picker to a div. */
        _inlineDatepicker: function (target, inst) {
            var divSpan = $(target);
            if (divSpan.hasClass(this.markerClassName)) {
                return;
            }
            divSpan.addClass(this.markerClassName).append(inst.dpDiv);
            $.data(target, PROP_NAME, inst);
            this._setDate(inst, this._getDefaultDate(inst), true);
            this._updateDatepicker(inst);
            this._updateAlternate(inst);
            //If disabled option is true, disable the datepicker before showing it (see ticket #5665)
            if (inst.settings.disabled) {
                this._disableDatepicker(target);
            }
            // Set display:block in place of inst.dpDiv.show() which won't work on disconnected elements
            // http://bugs.jqueryui.com/ticket/7552 - A Datepicker created on a detached div has zero height
            inst.dpDiv.css("display", "block");
        },

        /* Pop-up the date picker in a "dialog" box.
         * @param  input element - ignored
         * @param  date string or Date - the initial date to display
         * @param  onSelect  function - the function to call when a date is selected
         * @param  settings  object - update the dialog date picker instance's settings (anonymous object)
         * @param  pos int[2] - coordinates for the dialog's position within the screen or
         *          event - with x/y coordinates or
         *          leave empty for default (screen centre)
         * @return the manager object
         */
        _dialogDatepicker: function (input, date, onSelect, settings, pos) {
            var id, browserWidth, browserHeight, scrollX, scrollY,
                inst = this._dialogInst; // internal instance

            if (!inst) {
                this.uuid += 1;
                id = "dp" + this.uuid;
                this._dialogInput = $("<input type='text' id='" + id +
                    "' style='position: absolute; top: -100px; width: 0px;'/>");
                this._dialogInput.keydown(this._doKeyDown);
                $("body").append(this._dialogInput);
                inst = this._dialogInst = this._newInst(this._dialogInput, false);
                inst.settings = {};
                $.data(this._dialogInput[0], PROP_NAME, inst);
            }
            extendRemove(inst.settings, settings || {});
            date = (date && date.constructor === Date ? this._formatDate(inst, date) : date);
            this._dialogInput.val(date);

            this._pos = (pos ? (pos.length ? pos : [pos.pageX, pos.pageY]) : null);
            if (!this._pos) {
                browserWidth = document.documentElement.clientWidth;
                browserHeight = document.documentElement.clientHeight;
                scrollX = document.documentElement.scrollLeft || document.body.scrollLeft;
                scrollY = document.documentElement.scrollTop || document.body.scrollTop;
                this._pos = // should use actual width/height below
                    [(browserWidth / 2) - 100 + scrollX, (browserHeight / 2) - 150 + scrollY];
            }

            // move input on screen for focus, but hidden behind dialog
            this._dialogInput.css("left", (this._pos[0] + 20) + "px").css("top", this._pos[1] + "px");
            inst.settings.onSelect = onSelect;
            this._inDialog = true;
            this.dpDiv.addClass(this._dialogClass);
            this._showDatepicker(this._dialogInput[0]);
            if ($.blockUI) {
                $.blockUI(this.dpDiv);
            }
            $.data(this._dialogInput[0], PROP_NAME, inst);
            return this;
        },

        /* Detach a datepicker from its control.
         * @param  target element - the target input field or division or span
         */
        _destroyDatepicker: function (target) {
            var nodeName,
                $target = $(target),
                inst = $.data(target, PROP_NAME);

            if (!$target.hasClass(this.markerClassName)) {
                return;
            }

            nodeName = target.nodeName.toLowerCase();
            $.removeData(target, PROP_NAME);
            if (nodeName === "input") {
                inst.append.remove();
                inst.trigger.remove();
                $target.removeClass(this.markerClassName).
                    unbind("focus", this._showDatepicker).
                    unbind("keydown", this._doKeyDown).
                    unbind("keypress", this._doKeyPress).
                    unbind("keyup", this._doKeyUp);
            } else if (nodeName === "div" || nodeName === "span") {
                $target.removeClass(this.markerClassName).empty();
            }
        },

        /* Enable the date picker to a jQuery selection.
         * @param  target element - the target input field or division or span
         */
        _enableDatepicker: function (target) {
            var nodeName, inline,
                $target = $(target),
                inst = $.data(target, PROP_NAME);

            if (!$target.hasClass(this.markerClassName)) {
                return;
            }

            nodeName = target.nodeName.toLowerCase();
            if (nodeName === "input") {
                target.disabled = false;
                inst.trigger.filter("button").
                    each(function () { this.disabled = false; }).end().
                    filter("img").css({ opacity: "1.0", cursor: "" });
            } else if (nodeName === "div" || nodeName === "span") {
                inline = $target.children("." + this._inlineClass);
                inline.children().removeClass("ui-state-disabled");
                inline.find("select.ui-datepicker-month, select.ui-datepicker-year").
                    prop("disabled", false);
            }
            this._disabledInputs = $.map(this._disabledInputs,
                function (value) { return (value === target ? null : value); }); // delete entry
        },

        /* Disable the date picker to a jQuery selection.
         * @param  target element - the target input field or division or span
         */
        _disableDatepicker: function (target) {
            var nodeName, inline,
                $target = $(target),
                inst = $.data(target, PROP_NAME);

            if (!$target.hasClass(this.markerClassName)) {
                return;
            }

            nodeName = target.nodeName.toLowerCase();
            if (nodeName === "input") {
                target.disabled = true;
                inst.trigger.filter("button").
                    each(function () { this.disabled = true; }).end().
                    filter("img").css({ opacity: "0.5", cursor: "default" });
            } else if (nodeName === "div" || nodeName === "span") {
                inline = $target.children("." + this._inlineClass);
                inline.children().addClass("ui-state-disabled");
                inline.find("select.ui-datepicker-month, select.ui-datepicker-year").
                    prop("disabled", true);
            }
            this._disabledInputs = $.map(this._disabledInputs,
                function (value) { return (value === target ? null : value); }); // delete entry
            this._disabledInputs[this._disabledInputs.length] = target;
        },

        /* Is the first field in a jQuery collection disabled as a datepicker?
         * @param  target element - the target input field or division or span
         * @return boolean - true if disabled, false if enabled
         */
        _isDisabledDatepicker: function (target) {
            if (!target) {
                return false;
            }
            for (var i = 0; i < this._disabledInputs.length; i++) {
                if (this._disabledInputs[i] === target) {
                    return true;
                }
            }
            return false;
        },

        /* Retrieve the instance data for the target control.
         * @param  target  element - the target input field or division or span
         * @return  object - the associated instance data
         * @throws  error if a jQuery problem getting data
         */
        _getInst: function (target) {
            try {
                return $.data(target, PROP_NAME);
            }
            catch (err) {
                throw "Missing instance data for this datepicker";
            }
        },

        /* Update or retrieve the settings for a date picker attached to an input field or division.
         * @param  target  element - the target input field or division or span
         * @param  name object - the new settings to update or
         *        string - the name of the setting to change or retrieve,
         *        when retrieving also "all" for all instance settings or
         *        "defaults" for all global defaults
         * @param  value   any - the new value for the setting
         *        (omit if above is an object or to retrieve a value)
         */
        _optionDatepicker: function (target, name, value) {
            var settings, date, minDate, maxDate,
                inst = this._getInst(target);

            if (arguments.length === 2 && typeof name === "string") {
                return (name === "defaults" ? $.extend({}, $.datepicker._defaults) :
                    (inst ? (name === "all" ? $.extend({}, inst.settings) :
                        this._get(inst, name)) : null));
            }

            settings = name || {};
            if (typeof name === "string") {
                settings = {};
                settings[name] = value;
            }

            if (inst) {
                if (this._curInst === inst) {
                    this._hideDatepicker();
                }

                date = this._getDateDatepicker(target, true);
                minDate = this._getMinMaxDate(inst, "min");
                maxDate = this._getMinMaxDate(inst, "max");
                extendRemove(inst.settings, settings);
                // reformat the old minDate/maxDate values if dateFormat changes and a new minDate/maxDate isn't provided
                if (minDate !== null && settings.dateFormat !== undefined && settings.minDate === undefined) {
                    inst.settings.minDate = this._formatDate(inst, minDate);
                }
                if (maxDate !== null && settings.dateFormat !== undefined && settings.maxDate === undefined) {
                    inst.settings.maxDate = this._formatDate(inst, maxDate);
                }
                if ("disabled" in settings) {
                    if (settings.disabled) {
                        this._disableDatepicker(target);
                    } else {
                        this._enableDatepicker(target);
                    }
                }
                this._attachments($(target), inst);
                this._autoSize(inst);
                this._setDate(inst, date);
                this._updateAlternate(inst);
                this._updateDatepicker(inst);
            }
        },

        // change method deprecated
        _changeDatepicker: function (target, name, value) {
            this._optionDatepicker(target, name, value);
        },

        /* Redraw the date picker attached to an input field or division.
         * @param  target  element - the target input field or division or span
         */
        _refreshDatepicker: function (target) {
            var inst = this._getInst(target);
            if (inst) {
                this._updateDatepicker(inst);
            }
        },

        /* Set the dates for a jQuery selection.
         * @param  target element - the target input field or division or span
         * @param  date Date - the new date
         */
        _setDateDatepicker: function (target, date) {
            var inst = this._getInst(target);
            if (inst) {
                this._setDate(inst, date);
                this._updateDatepicker(inst);
                this._updateAlternate(inst);
            }
        },

        /* Get the date(s) for the first entry in a jQuery selection.
         * @param  target element - the target input field or division or span
         * @param  noDefault boolean - true if no default date is to be used
         * @return Date - the current date
         */
        _getDateDatepicker: function (target, noDefault) {
            var inst = this._getInst(target);
            if (inst && !inst.inline) {
                this._setDateFromField(inst, noDefault);
            }
            return (inst ? this._getDate(inst) : null);
        },

        /* Handle keystrokes. */
        _doKeyDown: function (event) {
            var onSelect, dateStr, sel,
                inst = $.datepicker._getInst(event.target),
                handled = true,
                isRTL = inst.dpDiv.is(".ui-datepicker-rtl");

            inst._keyEvent = true;
            if ($.datepicker._datepickerShowing) {
                switch (event.keyCode) {
                    case 9: $.datepicker._hideDatepicker();
                        handled = false;
                        break; // hide on tab out
                    case 13: sel = $("td." + $.datepicker._dayOverClass + ":not(." +
                        $.datepicker._currentClass + ")", inst.dpDiv);
                        if (sel[0]) {
                            $.datepicker._selectDay(event.target, inst.selectedMonth, inst.selectedYear, sel[0]);
                        }

                        onSelect = $.datepicker._get(inst, "onSelect");
                        if (onSelect) {
                            dateStr = $.datepicker._formatDate(inst);

                            // trigger custom callback
                            onSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]);
                        } else {
                            $.datepicker._hideDatepicker();
                        }

                        return false; // don't submit the form
                    case 27: $.datepicker._hideDatepicker();
                        break; // hide on escape
                    case 33: $.datepicker._adjustDate(event.target, (event.ctrlKey ?
                        -$.datepicker._get(inst, "stepBigMonths") :
                        -$.datepicker._get(inst, "stepMonths")), "M");
                        break; // previous month/year on page up/+ ctrl
                    case 34: $.datepicker._adjustDate(event.target, (event.ctrlKey ?
                        +$.datepicker._get(inst, "stepBigMonths") :
                        +$.datepicker._get(inst, "stepMonths")), "M");
                        break; // next month/year on page down/+ ctrl
                    case 35: if (event.ctrlKey || event.metaKey) {
                        $.datepicker._clearDate(event.target);
                    }
                        handled = event.ctrlKey || event.metaKey;
                        break; // clear on ctrl or command +end
                    case 36: if (event.ctrlKey || event.metaKey) {
                        $.datepicker._gotoToday(event.target);
                    }
                        handled = event.ctrlKey || event.metaKey;
                        break; // current on ctrl or command +home
                    case 37: if (event.ctrlKey || event.metaKey) {
                        $.datepicker._adjustDate(event.target, (isRTL ? +1 : -1), "D");
                    }
                        handled = event.ctrlKey || event.metaKey;
                        // -1 day on ctrl or command +left
                        if (event.originalEvent.altKey) {
                            $.datepicker._adjustDate(event.target, (event.ctrlKey ?
                                -$.datepicker._get(inst, "stepBigMonths") :
                                -$.datepicker._get(inst, "stepMonths")), "M");
                        }
                        // next month/year on alt +left on Mac
                        break;
                    case 38: if (event.ctrlKey || event.metaKey) {
                        $.datepicker._adjustDate(event.target, -7, "D");
                    }
                        handled = event.ctrlKey || event.metaKey;
                        break; // -1 week on ctrl or command +up
                    case 39: if (event.ctrlKey || event.metaKey) {
                        $.datepicker._adjustDate(event.target, (isRTL ? -1 : +1), "D");
                    }
                        handled = event.ctrlKey || event.metaKey;
                        // +1 day on ctrl or command +right
                        if (event.originalEvent.altKey) {
                            $.datepicker._adjustDate(event.target, (event.ctrlKey ?
                                +$.datepicker._get(inst, "stepBigMonths") :
                                +$.datepicker._get(inst, "stepMonths")), "M");
                        }
                        // next month/year on alt +right
                        break;
                    case 40: if (event.ctrlKey || event.metaKey) {
                        $.datepicker._adjustDate(event.target, +7, "D");
                    }
                        handled = event.ctrlKey || event.metaKey;
                        break; // +1 week on ctrl or command +down
                    default: handled = false;
                }
            } else if (event.keyCode === 36 && event.ctrlKey) { // display the date picker on ctrl+home
                $.datepicker._showDatepicker(this);
            } else {
                handled = false;
            }

            if (handled) {
                event.preventDefault();
                event.stopPropagation();
            }
        },

        /* Filter entered characters - based on date format. */
        _doKeyPress: function (event) {
            var chars, chr,
                inst = $.datepicker._getInst(event.target);

            if ($.datepicker._get(inst, "constrainInput")) {
                chars = $.datepicker._possibleChars($.datepicker._get(inst, "dateFormat"));
                chr = String.fromCharCode(event.charCode == null ? event.keyCode : event.charCode);
                return event.ctrlKey || event.metaKey || (chr < " " || !chars || chars.indexOf(chr) > -1);
            }
        },

        /* Synchronise manual entry and field/alternate field. */
        _doKeyUp: function (event) {
            var date,
                inst = $.datepicker._getInst(event.target);

            if (inst.input.val() !== inst.lastVal) {
                try {
                    date = $.datepicker.parseDate($.datepicker._get(inst, "dateFormat"),
                        (inst.input ? inst.input.val() : null),
                        $.datepicker._getFormatConfig(inst));

                    if (date) { // only if valid
                        $.datepicker._setDateFromField(inst);
                        $.datepicker._updateAlternate(inst);
                        $.datepicker._updateDatepicker(inst);
                    }
                }
                catch (err) {
                }
            }
            return true;
        },

        /* Pop-up the date picker for a given input field.
         * If false returned from beforeShow event handler do not show.
         * @param  input  element - the input field attached to the date picker or
         *          event - if triggered by focus
         */
        _showDatepicker: function (input) {
            input = input.target || input;
            if (input.nodeName.toLowerCase() !== "input") { // find from button/image trigger
                input = $("input", input.parentNode)[0];
            }

            if ($.datepicker._isDisabledDatepicker(input) || $.datepicker._lastInput === input) { // already here
                return;
            }

            var inst, beforeShow, beforeShowSettings, isFixed,
                offset, showAnim, duration;

            inst = $.datepicker._getInst(input);
            if ($.datepicker._curInst && $.datepicker._curInst !== inst) {
                $.datepicker._curInst.dpDiv.stop(true, true);
                if (inst && $.datepicker._datepickerShowing) {
                    $.datepicker._hideDatepicker($.datepicker._curInst.input[0]);
                }
            }

            beforeShow = $.datepicker._get(inst, "beforeShow");
            beforeShowSettings = beforeShow ? beforeShow.apply(input, [input, inst]) : {};
            if (beforeShowSettings === false) {
                return;
            }
            extendRemove(inst.settings, beforeShowSettings);

            inst.lastVal = null;
            $.datepicker._lastInput = input;
            $.datepicker._setDateFromField(inst);

            if ($.datepicker._inDialog) { // hide cursor
                input.value = "";
            }
            if (!$.datepicker._pos) { // position below input
                $.datepicker._pos = $.datepicker._findPos(input);
                $.datepicker._pos[1] += input.offsetHeight; // add the height
            }

            isFixed = false;
            $(input).parents().each(function () {
                isFixed |= $(this).css("position") === "fixed";
                return !isFixed;
            });

            offset = { left: $.datepicker._pos[0], top: $.datepicker._pos[1] };
            $.datepicker._pos = null;
            //to avoid flashes on Firefox
            inst.dpDiv.empty();
            // determine sizing offscreen
            inst.dpDiv.css({ position: "absolute", display: "block", top: "-1000px" });
            $.datepicker._updateDatepicker(inst);
            // fix width for dynamic number of date pickers
            // and adjust position before showing
            offset = $.datepicker._checkOffset(inst, offset, isFixed);
            inst.dpDiv.css({
                position: ($.datepicker._inDialog && $.blockUI ?
                    "static" : (isFixed ? "fixed" : "absolute")), display: "none",
                left: offset.left + "px", top: offset.top + "px"
            });

            if (!inst.inline) {
                showAnim = $.datepicker._get(inst, "showAnim");
                duration = $.datepicker._get(inst, "duration");
                inst.dpDiv.zIndex($(input).zIndex() + 1);
                $.datepicker._datepickerShowing = true;

                if ($.effects && $.effects.effect[showAnim]) {
                    inst.dpDiv.show(showAnim, $.datepicker._get(inst, "showOptions"), duration);
                } else {
                    inst.dpDiv[showAnim || "show"](showAnim ? duration : null);
                }

                if (inst.input.is(":visible") && !inst.input.is(":disabled")) {
                    inst.input.focus();
                }
                $.datepicker._curInst = inst;
            }
        },

        /* Generate the date picker content. */
        _updateDatepicker: function (inst) {
            this.maxRows = 4; //Reset the max number of rows being displayed (see #7043)
            instActive = inst; // for delegate hover events
            inst.dpDiv.empty().append(this._generateHTML(inst));
            this._attachHandlers(inst);
            inst.dpDiv.find("." + this._dayOverClass + " a").mouseover();

            var origyearshtml,
                numMonths = this._getNumberOfMonths(inst),
                cols = numMonths[1],
                width = 17;

            inst.dpDiv.removeClass("ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4").width("");
            if (cols > 1) {
                inst.dpDiv.addClass("ui-datepicker-multi-" + cols).css("width", (width * cols) + "em");
            }
            inst.dpDiv[(numMonths[0] !== 1 || numMonths[1] !== 1 ? "add" : "remove") +
                "Class"]("ui-datepicker-multi");
            inst.dpDiv[(this._get(inst, "isRTL") ? "add" : "remove") +
                "Class"]("ui-datepicker-rtl");

            // #6694 - don't focus the input if it's already focused
            // this breaks the change event in IE
            if (inst === $.datepicker._curInst && $.datepicker._datepickerShowing && inst.input &&
                inst.input.is(":visible") && !inst.input.is(":disabled") && inst.input[0] !== document.activeElement) {
                inst.input.focus();
            }

            // deffered render of the years select (to avoid flashes on Firefox)
            if (inst.yearshtml) {
                origyearshtml = inst.yearshtml;
                setTimeout(function () {
                    //assure that inst.yearshtml didn't change.
                    if (origyearshtml === inst.yearshtml && inst.yearshtml) {
                        inst.dpDiv.find("select.ui-datepicker-year:first").replaceWith(inst.yearshtml);
                    }
                    origyearshtml = inst.yearshtml = null;
                }, 0);
            }
        },

        /* Retrieve the size of left and top borders for an element.
         * @param  elem  (jQuery object) the element of interest
         * @return  (number[2]) the left and top borders
         */
        _getBorders: function (elem) {
            var convert = function (value) {
                return { thin: 1, medium: 2, thick: 3 }[value] || value;
            };
            return [parseFloat(convert(elem.css("border-left-width"))),
            parseFloat(convert(elem.css("border-top-width")))];
        },

        /* Check positioning to remain on screen. */
        _checkOffset: function (inst, offset, isFixed) {
            var dpWidth = inst.dpDiv.outerWidth(),
                dpHeight = inst.dpDiv.outerHeight(),
                inputWidth = inst.input ? inst.input.outerWidth() : 0,
                inputHeight = inst.input ? inst.input.outerHeight() : 0,
                viewWidth = document.documentElement.clientWidth + (isFixed ? 0 : $(document).scrollLeft()),
                viewHeight = document.documentElement.clientHeight + (isFixed ? 0 : $(document).scrollTop());

            offset.left -= (this._get(inst, "isRTL") ? (dpWidth - inputWidth) : 0);
            offset.left -= (isFixed && offset.left === inst.input.offset().left) ? $(document).scrollLeft() : 0;
            offset.top -= (isFixed && offset.top === (inst.input.offset().top + inputHeight)) ? $(document).scrollTop() : 0;

            // now check if datepicker is showing outside window viewport - move to a better place if so.
            offset.left -= Math.min(offset.left, (offset.left + dpWidth > viewWidth && viewWidth > dpWidth) ?
                Math.abs(offset.left + dpWidth - viewWidth) : 0);
            offset.top -= Math.min(offset.top, (offset.top + dpHeight > viewHeight && viewHeight > dpHeight) ?
                Math.abs(dpHeight + inputHeight) : 0);

            return offset;
        },

        /* Find an object's position on the screen. */
        _findPos: function (obj) {
            var position,
                inst = this._getInst(obj),
                isRTL = this._get(inst, "isRTL");

            while (obj && (obj.type === "hidden" || obj.nodeType !== 1 || $.expr.filters.hidden(obj))) {
                obj = obj[isRTL ? "previousSibling" : "nextSibling"];
            }

            position = $(obj).offset();
            return [position.left, position.top];
        },

        /* Hide the date picker from view.
         * @param  input  element - the input field attached to the date picker
         */
        _hideDatepicker: function (input) {
            var showAnim, duration, postProcess, onClose,
                inst = this._curInst;

            if (!inst || (input && inst !== $.data(input, PROP_NAME))) {
                return;
            }

            if (this._datepickerShowing) {
                showAnim = this._get(inst, "showAnim");
                duration = this._get(inst, "duration");
                postProcess = function () {
                    $.datepicker._tidyDialog(inst);
                };

                // DEPRECATED: after BC for 1.8.x $.effects[ showAnim ] is not needed
                if ($.effects && ($.effects.effect[showAnim] || $.effects[showAnim])) {
                    inst.dpDiv.hide(showAnim, $.datepicker._get(inst, "showOptions"), duration, postProcess);
                } else {
                    inst.dpDiv[(showAnim === "slideDown" ? "slideUp" :
                        (showAnim === "fadeIn" ? "fadeOut" : "hide"))]((showAnim ? duration : null), postProcess);
                }

                if (!showAnim) {
                    postProcess();
                }
                this._datepickerShowing = false;

                onClose = this._get(inst, "onClose");
                if (onClose) {
                    onClose.apply((inst.input ? inst.input[0] : null), [(inst.input ? inst.input.val() : ""), inst]);
                }

                this._lastInput = null;
                if (this._inDialog) {
                    this._dialogInput.css({ position: "absolute", left: "0", top: "-100px" });
                    if ($.blockUI) {
                        $.unblockUI();
                        $("body").append(this.dpDiv);
                    }
                }
                this._inDialog = false;
            }
        },

        /* Tidy up after a dialog display. */
        _tidyDialog: function (inst) {
            inst.dpDiv.removeClass(this._dialogClass).unbind(".ui-datepicker-calendar");
        },

        /* Close date picker if clicked elsewhere. */
        _checkExternalClick: function (event) {
            if (!$.datepicker._curInst) {
                return;
            }

            var $target = $(event.target),
                inst = $.datepicker._getInst($target[0]);

            if ((($target[0].id !== $.datepicker._mainDivId &&
                $target.parents("#" + $.datepicker._mainDivId).length === 0 &&
                !$target.hasClass($.datepicker.markerClassName) &&
                !$target.closest("." + $.datepicker._triggerClass).length &&
                $.datepicker._datepickerShowing && !($.datepicker._inDialog && $.blockUI))) ||
                ($target.hasClass($.datepicker.markerClassName) && $.datepicker._curInst !== inst)) {
                $.datepicker._hideDatepicker();
            }
        },

        /* Adjust one of the date sub-fields. */
        _adjustDate: function (id, offset, period) {
            var target = $(id),
                inst = this._getInst(target[0]);

            if (this._isDisabledDatepicker(target[0])) {
                return;
            }
            this._adjustInstDate(inst, offset +
                (period === "M" ? this._get(inst, "showCurrentAtPos") : 0), // undo positioning
                period);
            this._updateDatepicker(inst);
        },

        /* Action for current link. */
        _gotoToday: function (id) {
            var date,
                target = $(id),
                inst = this._getInst(target[0]);

            if (this._get(inst, "gotoCurrent") && inst.currentDay) {
                inst.selectedDay = inst.currentDay;
                inst.drawMonth = inst.selectedMonth = inst.currentMonth;
                inst.drawYear = inst.selectedYear = inst.currentYear;
            } else {
                date = new Date();
                inst.selectedDay = date.getDate();
                inst.drawMonth = inst.selectedMonth = date.getMonth();
                inst.drawYear = inst.selectedYear = date.getFullYear();
            }
            this._notifyChange(inst);
            this._adjustDate(target);
        },

        /* Action for selecting a new month/year. */
        _selectMonthYear: function (id, select, period) {
            var target = $(id),
                inst = this._getInst(target[0]);

            inst["selected" + (period === "M" ? "Month" : "Year")] =
                inst["draw" + (period === "M" ? "Month" : "Year")] =
                parseInt(select.options[select.selectedIndex].value, 10);

            this._notifyChange(inst);
            this._adjustDate(target);
        },

        /* Action for selecting a day. */
        _selectDay: function (id, month, year, td) {
            var inst,
                target = $(id);

            if ($(td).hasClass(this._unselectableClass) || this._isDisabledDatepicker(target[0])) {
                return;
            }

            inst = this._getInst(target[0]);
            inst.selectedDay = inst.currentDay = $("a", td).html();
            inst.selectedMonth = inst.currentMonth = month;
            inst.selectedYear = inst.currentYear = year;
            this._selectDate(id, this._formatDate(inst,
                inst.currentDay, inst.currentMonth, inst.currentYear));
        },

        /* Erase the input field and hide the date picker. */
        _clearDate: function (id) {
            var target = $(id);
            this._selectDate(target, "");
        },

        /* Update the input field with the selected date. */
        _selectDate: function (id, dateStr) {
            var onSelect,
                target = $(id),
                inst = this._getInst(target[0]);

            dateStr = (dateStr != null ? dateStr : this._formatDate(inst));
            if (inst.input) {
                inst.input.val(dateStr);
            }
            this._updateAlternate(inst);

            onSelect = this._get(inst, "onSelect");
            if (onSelect) {
                onSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]);  // trigger custom callback
            } else if (inst.input) {
                inst.input.trigger("change"); // fire the change event
            }

            if (inst.inline) {
                this._updateDatepicker(inst);
            } else {
                this._hideDatepicker();
                this._lastInput = inst.input[0];
                if (typeof (inst.input[0]) !== "object") {
                    inst.input.focus(); // restore focus
                }
                this._lastInput = null;
            }
        },

        /* Update any alternate field to synchronise with the main field. */
        _updateAlternate: function (inst) {
            var altFormat, date, dateStr,
                altField = this._get(inst, "altField");

            if (altField) { // update alternate field too
                altFormat = this._get(inst, "altFormat") || this._get(inst, "dateFormat");
                date = this._getDate(inst);
                dateStr = this.formatDate(altFormat, date, this._getFormatConfig(inst));
                $(altField).each(function () { $(this).val(dateStr); });
            }
        },

        /* Set as beforeShowDay function to prevent selection of weekends.
         * @param  date  Date - the date to customise
         * @return [boolean, string] - is this date selectable?, what is its CSS class?
         */
        noWeekends: function (date) {
            var day = date.getDay();
            return [(day > 0 && day < 6), ""];
        },

        /* Set as calculateWeek to determine the week of the year based on the ISO 8601 definition.
         * @param  date  Date - the date to get the week for
         * @return  number - the number of the week within the year that contains this date
         */
        iso8601Week: function (date) {
            var time,
                checkDate = new Date(date.getTime());

            // Find Thursday of this week starting on Monday
            checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));

            time = checkDate.getTime();
            checkDate.setMonth(0); // Compare with Jan 1
            checkDate.setDate(1);
            return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
        },

        /* Parse a string value into a date object.
         * See formatDate below for the possible formats.
         *
         * @param  format string - the expected format of the date
         * @param  value string - the date in the above format
         * @param  settings Object - attributes include:
         *          shortYearCutoff  number - the cutoff year for determining the century (optional)
         *          dayNamesShort string[7] - abbreviated names of the days from Sunday (optional)
         *          dayNames    string[7] - names of the days from Sunday (optional)
         *          monthNamesShort string[12] - abbreviated names of the months (optional)
         *          monthNames    string[12] - names of the months (optional)
         * @return  Date - the extracted date value or null if value is blank
         */
        parseDate: function (format, value, settings) {
            if (format == null || value == null) {
                throw "Invalid arguments";
            }

            value = (typeof value === "object" ? value.toString() : value + "");
            if (value === "") {
                return null;
            }

            var iFormat, dim, extra,
                iValue = 0,
                shortYearCutoffTemp = (settings ? settings.shortYearCutoff : null) || this._defaults.shortYearCutoff,
                shortYearCutoff = (typeof shortYearCutoffTemp !== "string" ? shortYearCutoffTemp :
                    new Date().getFullYear() % 100 + parseInt(shortYearCutoffTemp, 10)),
                dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort,
                dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames,
                monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort,
                monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames,
                year = -1,
                month = -1,
                day = -1,
                doy = -1,
                literal = false,
                date,
                // Check whether a format character is doubled
                lookAhead = function (match) {
                    var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);
                    if (matches) {
                        iFormat++;
                    }
                    return matches;
                },
                // Extract a number from the string value
                getNumber = function (match) {
                    var isDoubled = lookAhead(match),
                        size = (match === "@" ? 14 : (match === "!" ? 20 :
                            (match === "y" && isDoubled ? 4 : (match === "o" ? 3 : 2)))),
                        digits = new RegExp("^\\d{1," + size + "}"),
                        num = value.substring(iValue).match(digits);
                    if (!num) {
                        throw "Missing number at position " + iValue;
                    }
                    iValue += num[0].length;
                    return parseInt(num[0], 10);
                },
                // Extract a name from the string value and convert to an index
                getName = function (match, shortNames, longNames) {
                    var index = -1,
                        names = $.map(lookAhead(match) ? longNames : shortNames, function (v, k) {
                            return [[k, v]];
                        }).sort(function (a, b) {
                            return -(a[1].length - b[1].length);
                        });

                    $.each(names, function (i, pair) {
                        var name = pair[1];
                        if (value.substr(iValue, name.length).toLowerCase() === name.toLowerCase()) {
                            index = pair[0];
                            iValue += name.length;
                            return false;
                        }
                    });
                    if (index !== -1) {
                        return index + 1;
                    } else {
                        throw "Unknown name at position " + iValue;
                    }
                },
                // Confirm that a literal character matches the string value
                checkLiteral = function () {
                    if (value.charAt(iValue) !== format.charAt(iFormat)) {
                        throw "Unexpected literal at position " + iValue;
                    }
                    iValue++;
                };

            for (iFormat = 0; iFormat < format.length; iFormat++) {
                if (literal) {
                    if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
                        literal = false;
                    } else {
                        checkLiteral();
                    }
                } else {
                    switch (format.charAt(iFormat)) {
                        case "d":
                            day = getNumber("d");
                            break;
                        case "D":
                            getName("D", dayNamesShort, dayNames);
                            break;
                        case "o":
                            doy = getNumber("o");
                            break;
                        case "m":
                            month = getNumber("m");
                            break;
                        case "M":
                            month = getName("M", monthNamesShort, monthNames);
                            break;
                        case "y":
                            year = getNumber("y");
                            break;
                        case "@":
                            date = new Date(getNumber("@"));
                            year = date.getFullYear();
                            month = date.getMonth() + 1;
                            day = date.getDate();
                            break;
                        case "!":
                            date = new Date((getNumber("!") - this._ticksTo1970) / 10000);
                            year = date.getFullYear();
                            month = date.getMonth() + 1;
                            day = date.getDate();
                            break;
                        case "'":
                            if (lookAhead("'")) {
                                checkLiteral();
                            } else {
                                literal = true;
                            }
                            break;
                        default:
                            checkLiteral();
                    }
                }
            }

            if (iValue < value.length) {
                extra = value.substr(iValue);
                if (!/^\s+/.test(extra)) {
                    throw "Extra/unparsed characters found in date: " + extra;
                }
            }

            if (year === -1) {
                year = new Date().getFullYear();
            } else if (year < 100) {
                year += new Date().getFullYear() - new Date().getFullYear() % 100 +
                    (year <= shortYearCutoff ? 0 : -100);
            }

            if (doy > -1) {
                month = 1;
                day = doy;
                do {
                    dim = this._getDaysInMonth(year, month - 1);
                    if (day <= dim) {
                        break;
                    }
                    month++;
                    day -= dim;
                } while (true);
            }

            date = this._daylightSavingAdjust(new Date(year, month - 1, day));
            if (date.getFullYear() !== year || date.getMonth() + 1 !== month || date.getDate() !== day) {
                throw "Invalid date"; // E.g. 31/02/00
            }
            return date;
        },

        /* Standard date formats. */
        ATOM: "yy-mm-dd", // RFC 3339 (ISO 8601)
        COOKIE: "D, dd M yy",
        ISO_8601: "yy-mm-dd",
        RFC_822: "D, d M y",
        RFC_850: "DD, dd-M-y",
        RFC_1036: "D, d M y",
        RFC_1123: "D, d M yy",
        RFC_2822: "D, d M yy",
        RSS: "D, d M y", // RFC 822
        TICKS: "!",
        TIMESTAMP: "@",
        W3C: "yy-mm-dd", // ISO 8601

        _ticksTo1970: (((1970 - 1) * 365 + Math.floor(1970 / 4) - Math.floor(1970 / 100) +
            Math.floor(1970 / 400)) * 24 * 60 * 60 * 10000000),

        /* Format a date object into a string value.
         * The format can be combinations of the following:
         * d  - day of month (no leading zero)
         * dd - day of month (two digit)
         * o  - day of year (no leading zeros)
         * oo - day of year (three digit)
         * D  - day name short
         * DD - day name long
         * m  - month of year (no leading zero)
         * mm - month of year (two digit)
         * M  - month name short
         * MM - month name long
         * y  - year (two digit)
         * yy - year (four digit)
         * @ - Unix timestamp (ms since 01/01/1970)
         * ! - Windows ticks (100ns since 01/01/0001)
         * "..." - literal text
         * '' - single quote
         *
         * @param  format string - the desired format of the date
         * @param  date Date - the date value to format
         * @param  settings Object - attributes include:
         *          dayNamesShort string[7] - abbreviated names of the days from Sunday (optional)
         *          dayNames    string[7] - names of the days from Sunday (optional)
         *          monthNamesShort string[12] - abbreviated names of the months (optional)
         *          monthNames    string[12] - names of the months (optional)
         * @return  string - the date in the above format
         */
        formatDate: function (format, date, settings) {
            if (!date) {
                return "";
            }

            var iFormat,
                dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort,
                dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames,
                monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort,
                monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames,
                // Check whether a format character is doubled
                lookAhead = function (match) {
                    var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);
                    if (matches) {
                        iFormat++;
                    }
                    return matches;
                },
                // Format a number, with leading zero if necessary
                formatNumber = function (match, value, len) {
                    var num = "" + value;
                    if (lookAhead(match)) {
                        while (num.length < len) {
                            num = "0" + num;
                        }
                    }
                    return num;
                },
                // Format a name, short or long as requested
                formatName = function (match, value, shortNames, longNames) {
                    return (lookAhead(match) ? longNames[value] : shortNames[value]);
                },
                output = "",
                literal = false;

            if (date) {
                for (iFormat = 0; iFormat < format.length; iFormat++) {
                    if (literal) {
                        if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
                            literal = false;
                        } else {
                            output += format.charAt(iFormat);
                        }
                    } else {
                        switch (format.charAt(iFormat)) {
                            case "d":
                                output += formatNumber("d", date.getDate(), 2);
                                break;
                            case "D":
                                output += formatName("D", date.getDay(), dayNamesShort, dayNames);
                                break;
                            case "o":
                                output += formatNumber("o",
                                    Math.round((new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTime() - new Date(date.getFullYear(), 0, 0).getTime()) / 86400000), 3);
                                break;
                            case "m":
                                output += formatNumber("m", date.getMonth() + 1, 2);
                                break;
                            case "M":
                                output += formatName("M", date.getMonth(), monthNamesShort, monthNames);
                                break;
                            case "y":
                                output += (lookAhead("y") ? date.getFullYear() :
                                    (date.getYear() % 100 < 10 ? "0" : "") + date.getYear() % 100);
                                break;
                            case "@":
                                output += date.getTime();
                                break;
                            case "!":
                                output += date.getTime() * 10000 + this._ticksTo1970;
                                break;
                            case "'":
                                if (lookAhead("'")) {
                                    output += "'";
                                } else {
                                    literal = true;
                                }
                                break;
                            default:
                                output += format.charAt(iFormat);
                        }
                    }
                }
            }
            return output;
        },

        /* Extract all possible characters from the date format. */
        _possibleChars: function (format) {
            var iFormat,
                chars = "",
                literal = false,
                // Check whether a format character is doubled
                lookAhead = function (match) {
                    var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);
                    if (matches) {
                        iFormat++;
                    }
                    return matches;
                };

            for (iFormat = 0; iFormat < format.length; iFormat++) {
                if (literal) {
                    if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
                        literal = false;
                    } else {
                        chars += format.charAt(iFormat);
                    }
                } else {
                    switch (format.charAt(iFormat)) {
                        case "d": case "m": case "y": case "@":
                            chars += "0123456789";
                            break;
                        case "D": case "M":
                            return null; // Accept anything
                        case "'":
                            if (lookAhead("'")) {
                                chars += "'";
                            } else {
                                literal = true;
                            }
                            break;
                        default:
                            chars += format.charAt(iFormat);
                    }
                }
            }
            return chars;
        },

        /* Get a setting value, defaulting if necessary. */
        _get: function (inst, name) {
            return inst.settings[name] !== undefined ?
                inst.settings[name] : this._defaults[name];
        },

        /* Parse existing date and initialise date picker. */
        _setDateFromField: function (inst, noDefault) {
            if (inst.input.val() === inst.lastVal) {
                return;
            }

            var dateFormat = this._get(inst, "dateFormat"),
                dates = inst.lastVal = inst.input ? inst.input.val() : null,
                defaultDate = this._getDefaultDate(inst),
                date = defaultDate,
                settings = this._getFormatConfig(inst);

            try {
                date = this.parseDate(dateFormat, dates, settings) || defaultDate;
            } catch (event) {
                dates = (noDefault ? "" : dates);
            }
            inst.selectedDay = date.getDate();
            inst.drawMonth = inst.selectedMonth = date.getMonth();
            inst.drawYear = inst.selectedYear = date.getFullYear();
            inst.currentDay = (dates ? date.getDate() : 0);
            inst.currentMonth = (dates ? date.getMonth() : 0);
            inst.currentYear = (dates ? date.getFullYear() : 0);
            this._adjustInstDate(inst);
        },

        /* Retrieve the default date shown on opening. */
        _getDefaultDate: function (inst) {
            return this._restrictMinMax(inst,
                this._determineDate(inst, this._get(inst, "defaultDate"), new Date()));
        },

        /* A date may be specified as an exact value or a relative one. */
        _determineDate: function (inst, date, defaultDate) {
            var offsetNumeric = function (offset) {
                var date = new Date();
                date.setDate(date.getDate() + offset);
                return date;
            },
                offsetString = function (offset) {
                    try {
                        return $.datepicker.parseDate($.datepicker._get(inst, "dateFormat"),
                            offset, $.datepicker._getFormatConfig(inst));
                    }
                    catch (e) {
                        // Ignore
                    }

                    var date = (offset.toLowerCase().match(/^c/) ?
                        $.datepicker._getDate(inst) : null) || new Date(),
                        year = date.getFullYear(),
                        month = date.getMonth(),
                        day = date.getDate(),
                        pattern = /([+\-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g,
                        matches = pattern.exec(offset);

                    while (matches) {
                        switch (matches[2] || "d") {
                            case "d": case "D":
                                day += parseInt(matches[1], 10); break;
                            case "w": case "W":
                                day += parseInt(matches[1], 10) * 7; break;
                            case "m": case "M":
                                month += parseInt(matches[1], 10);
                                day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
                                break;
                            case "y": case "Y":
                                year += parseInt(matches[1], 10);
                                day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
                                break;
                        }
                        matches = pattern.exec(offset);
                    }
                    return new Date(year, month, day);
                },
                newDate = (date == null || date === "" ? defaultDate : (typeof date === "string" ? offsetString(date) :
                    (typeof date === "number" ? (isNaN(date) ? defaultDate : offsetNumeric(date)) : new Date(date.getTime()))));

            newDate = (newDate && newDate.toString() === "Invalid Date" ? defaultDate : newDate);
            if (newDate) {
                newDate.setHours(0);
                newDate.setMinutes(0);
                newDate.setSeconds(0);
                newDate.setMilliseconds(0);
            }
            return this._daylightSavingAdjust(newDate);
        },

        /* Handle switch to/from daylight saving.
         * Hours may be non-zero on daylight saving cut-over:
         * > 12 when midnight changeover, but then cannot generate
         * midnight datetime, so jump to 1AM, otherwise reset.
         * @param  date  (Date) the date to check
         * @return  (Date) the corrected date
         */
        _daylightSavingAdjust: function (date) {
            if (!date) {
                return null;
            }
            date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);
            return date;
        },

        /* Set the date(s) directly. */
        _setDate: function (inst, date, noChange) {
            var clear = !date,
                origMonth = inst.selectedMonth,
                origYear = inst.selectedYear,
                newDate = this._restrictMinMax(inst, this._determineDate(inst, date, new Date()));

            inst.selectedDay = inst.currentDay = newDate.getDate();
            inst.drawMonth = inst.selectedMonth = inst.currentMonth = newDate.getMonth();
            inst.drawYear = inst.selectedYear = inst.currentYear = newDate.getFullYear();
            if ((origMonth !== inst.selectedMonth || origYear !== inst.selectedYear) && !noChange) {
                this._notifyChange(inst);
            }
            this._adjustInstDate(inst);
            if (inst.input) {
                inst.input.val(clear ? "" : this._formatDate(inst));
            }
        },

        /* Retrieve the date(s) directly. */
        _getDate: function (inst) {
            var startDate = (!inst.currentYear || (inst.input && inst.input.val() === "") ? null :
                this._daylightSavingAdjust(new Date(
                    inst.currentYear, inst.currentMonth, inst.currentDay)));
            return startDate;
        },

        /* Attach the onxxx handlers.  These are declared statically so
         * they work with static code transformers like Caja.
         */
        _attachHandlers: function (inst) {
            var stepMonths = this._get(inst, "stepMonths"),
                id = "#" + inst.id.replace(/\\\\/g, "\\");
            inst.dpDiv.find("[data-handler]").map(function () {
                var handler = {
                    prev: function () {
                        window["DP_jQuery_" + dpuuid].datepicker._adjustDate(id, -stepMonths, "M");
                    },
                    next: function () {
                        window["DP_jQuery_" + dpuuid].datepicker._adjustDate(id, +stepMonths, "M");
                    },
                    hide: function () {
                        window["DP_jQuery_" + dpuuid].datepicker._hideDatepicker();
                    },
                    today: function () {
                        window["DP_jQuery_" + dpuuid].datepicker._gotoToday(id);
                    },
                    selectDay: function () {
                        window["DP_jQuery_" + dpuuid].datepicker._selectDay(id, +this.getAttribute("data-month"), +this.getAttribute("data-year"), this);
                        return false;
                    },
                    selectMonth: function () {
                        window["DP_jQuery_" + dpuuid].datepicker._selectMonthYear(id, this, "M");
                        return false;
                    },
                    selectYear: function () {
                        window["DP_jQuery_" + dpuuid].datepicker._selectMonthYear(id, this, "Y");
                        return false;
                    }
                };
                $(this).bind(this.getAttribute("data-event"), handler[this.getAttribute("data-handler")]);
            });
        },

        /* Generate the HTML for the current state of the date picker. */
        _generateHTML: function (inst) {
            var maxDraw, prevText, prev, nextText, next, currentText, gotoDate,
                controls, buttonPanel, firstDay, showWeek, dayNames, dayNamesMin,
                monthNames, monthNamesShort, beforeShowDay, showOtherMonths,
                selectOtherMonths, defaultDate, html, dow, row, group, col, selectedDate,
                cornerClass, calender, thead, day, daysInMonth, leadDays, curRows, numRows,
                printDate, dRow, tbody, daySettings, otherMonth, unselectable,
                tempDate = new Date(),
                today = this._daylightSavingAdjust(
                    new Date(tempDate.getFullYear(), tempDate.getMonth(), tempDate.getDate())), // clear time
                isRTL = this._get(inst, "isRTL"),
                showButtonPanel = this._get(inst, "showButtonPanel"),
                hideIfNoPrevNext = this._get(inst, "hideIfNoPrevNext"),
                navigationAsDateFormat = this._get(inst, "navigationAsDateFormat"),
                numMonths = this._getNumberOfMonths(inst),
                showCurrentAtPos = this._get(inst, "showCurrentAtPos"),
                stepMonths = this._get(inst, "stepMonths"),
                isMultiMonth = (numMonths[0] !== 1 || numMonths[1] !== 1),
                currentDate = this._daylightSavingAdjust((!inst.currentDay ? new Date(9999, 9, 9) :
                    new Date(inst.currentYear, inst.currentMonth, inst.currentDay))),
                minDate = this._getMinMaxDate(inst, "min"),
                maxDate = this._getMinMaxDate(inst, "max"),
                drawMonth = inst.drawMonth - showCurrentAtPos,
                drawYear = inst.drawYear;

            if (drawMonth < 0) {
                drawMonth += 12;
                drawYear--;
            }
            if (maxDate) {
                maxDraw = this._daylightSavingAdjust(new Date(maxDate.getFullYear(),
                    maxDate.getMonth() - (numMonths[0] * numMonths[1]) + 1, maxDate.getDate()));
                maxDraw = (minDate && maxDraw < minDate ? minDate : maxDraw);
                while (this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1)) > maxDraw) {
                    drawMonth--;
                    if (drawMonth < 0) {
                        drawMonth = 11;
                        drawYear--;
                    }
                }
            }
            inst.drawMonth = drawMonth;
            inst.drawYear = drawYear;

            prevText = this._get(inst, "prevText");
            prevText = (!navigationAsDateFormat ? prevText : this.formatDate(prevText,
                this._daylightSavingAdjust(new Date(drawYear, drawMonth - stepMonths, 1)),
                this._getFormatConfig(inst)));

            prev = (this._canAdjustMonth(inst, -1, drawYear, drawMonth) ?
                "<a class='ui-datepicker-prev ui-corner-all' data-handler='prev' data-event='click'" +
                " title='" + prevText + "'><span class='ui-icon ui-icon-circle-triangle-" + (isRTL ? "e" : "w") + "'>" + prevText + "</span></a>" :
                (hideIfNoPrevNext ? "" : "<a class='ui-datepicker-prev ui-corner-all ui-state-disabled' title='" + prevText + "'><span class='ui-icon ui-icon-circle-triangle-" + (isRTL ? "e" : "w") + "'>" + prevText + "</span></a>"));

            nextText = this._get(inst, "nextText");
            nextText = (!navigationAsDateFormat ? nextText : this.formatDate(nextText,
                this._daylightSavingAdjust(new Date(drawYear, drawMonth + stepMonths, 1)),
                this._getFormatConfig(inst)));

            next = (this._canAdjustMonth(inst, +1, drawYear, drawMonth) ?
                "<a class='ui-datepicker-next ui-corner-all' data-handler='next' data-event='click'" +
                " title='" + nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + (isRTL ? "w" : "e") + "'>" + nextText + "</span></a>" :
                (hideIfNoPrevNext ? "" : "<a class='ui-datepicker-next ui-corner-all ui-state-disabled' title='" + nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + (isRTL ? "w" : "e") + "'>" + nextText + "</span></a>"));

            currentText = this._get(inst, "currentText");
            gotoDate = (this._get(inst, "gotoCurrent") && inst.currentDay ? currentDate : today);
            currentText = (!navigationAsDateFormat ? currentText :
                this.formatDate(currentText, gotoDate, this._getFormatConfig(inst)));

            controls = (!inst.inline ? "<button type='button' class='ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all' data-handler='hide' data-event='click'>" +
                this._get(inst, "closeText") + "</button>" : "");

            buttonPanel = (showButtonPanel) ? "<div class='ui-datepicker-buttonpane ui-widget-content'>" + (isRTL ? controls : "") +
                (this._isInRange(inst, gotoDate) ? "<button type='button' class='ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all' data-handler='today' data-event='click'" +
                    ">" + currentText + "</button>" : "") + (isRTL ? "" : controls) + "</div>" : "";

            firstDay = parseInt(this._get(inst, "firstDay"), 10);
            firstDay = (isNaN(firstDay) ? 0 : firstDay);

            showWeek = this._get(inst, "showWeek");
            dayNames = this._get(inst, "dayNames");
            dayNamesMin = this._get(inst, "dayNamesMin");
            monthNames = this._get(inst, "monthNames");
            monthNamesShort = this._get(inst, "monthNamesShort");
            beforeShowDay = this._get(inst, "beforeShowDay");
            showOtherMonths = this._get(inst, "showOtherMonths");
            selectOtherMonths = this._get(inst, "selectOtherMonths");
            defaultDate = this._getDefaultDate(inst);
            html = "";
            dow;
            for (row = 0; row < numMonths[0]; row++) {
                group = "";
                this.maxRows = 4;
                for (col = 0; col < numMonths[1]; col++) {
                    selectedDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, inst.selectedDay));
                    cornerClass = " ui-corner-all";
                    calender = "";
                    if (isMultiMonth) {
                        calender += "<div class='ui-datepicker-group";
                        if (numMonths[1] > 1) {
                            switch (col) {
                                case 0: calender += " ui-datepicker-group-first";
                                    cornerClass = " ui-corner-" + (isRTL ? "right" : "left"); break;
                                case numMonths[1] - 1: calender += " ui-datepicker-group-last";
                                    cornerClass = " ui-corner-" + (isRTL ? "left" : "right"); break;
                                default: calender += " ui-datepicker-group-middle"; cornerClass = ""; break;
                            }
                        }
                        calender += "'>";
                    }
                    calender += "<div class='ui-datepicker-header ui-widget-header ui-helper-clearfix" + cornerClass + "'>" +
                        (/all|left/.test(cornerClass) && row === 0 ? (isRTL ? next : prev) : "") +
                        (/all|right/.test(cornerClass) && row === 0 ? (isRTL ? prev : next) : "") +
                        this._generateMonthYearHeader(inst, drawMonth, drawYear, minDate, maxDate,
                            row > 0 || col > 0, monthNames, monthNamesShort) + // draw month headers
                        "</div><table class='ui-datepicker-calendar'><thead>" +
                        "<tr>";
                    thead = (showWeek ? "<th class='ui-datepicker-week-col'>" + this._get(inst, "weekHeader") + "</th>" : "");
                    for (dow = 0; dow < 7; dow++) { // days of the week
                        day = (dow + firstDay) % 7;
                        thead += "<th" + ((dow + firstDay + 6) % 7 >= 5 ? " class='ui-datepicker-week-end'" : "") + ">" +
                            "<span title='" + dayNames[day] + "'>" + dayNamesMin[day] + "</span></th>";
                    }
                    calender += thead + "</tr></thead><tbody>";
                    daysInMonth = this._getDaysInMonth(drawYear, drawMonth);
                    if (drawYear === inst.selectedYear && drawMonth === inst.selectedMonth) {
                        inst.selectedDay = Math.min(inst.selectedDay, daysInMonth);
                    }
                    leadDays = (this._getFirstDayOfMonth(drawYear, drawMonth) - firstDay + 7) % 7;
                    curRows = Math.ceil((leadDays + daysInMonth) / 7); // calculate the number of rows to generate
                    numRows = (isMultiMonth ? this.maxRows > curRows ? this.maxRows : curRows : curRows); //If multiple months, use the higher number of rows (see #7043)
                    this.maxRows = numRows;
                    printDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1 - leadDays));
                    for (dRow = 0; dRow < numRows; dRow++) { // create date picker rows
                        calender += "<tr>";
                        tbody = (!showWeek ? "" : "<td class='ui-datepicker-week-col'>" +
                            this._get(inst, "calculateWeek")(printDate) + "</td>");
                        for (dow = 0; dow < 7; dow++) { // create date picker days
                            daySettings = (beforeShowDay ?
                                beforeShowDay.apply((inst.input ? inst.input[0] : null), [printDate]) : [true, ""]);
                            otherMonth = (printDate.getMonth() !== drawMonth);
                            unselectable = (otherMonth && !selectOtherMonths) || !daySettings[0] ||
                                (minDate && printDate < minDate) || (maxDate && printDate > maxDate);
                            tbody += "<td class='" +
                                ((dow + firstDay + 6) % 7 >= 5 ? " ui-datepicker-week-end" : "") + // highlight weekends
                                (otherMonth ? " ui-datepicker-other-month" : "") + // highlight days from other months
                                ((printDate.getTime() === selectedDate.getTime() && drawMonth === inst.selectedMonth && inst._keyEvent) || // user pressed key
                                    (defaultDate.getTime() === printDate.getTime() && defaultDate.getTime() === selectedDate.getTime()) ?
                                    // or defaultDate is current printedDate and defaultDate is selectedDate
                                    " " + this._dayOverClass : "") + // highlight selected day
                                (unselectable ? " " + this._unselectableClass + " ui-state-disabled" : "") +  // highlight unselectable days
                                (otherMonth && !showOtherMonths ? "" : " " + daySettings[1] + // highlight custom dates
                                    (printDate.getTime() === currentDate.getTime() ? " " + this._currentClass : "") + // highlight selected day
                                    (printDate.getTime() === today.getTime() ? " ui-datepicker-today" : "")) + "'" + // highlight today (if different)
                                ((!otherMonth || showOtherMonths) && daySettings[2] ? " title='" + daySettings[2].replace(/'/g, "&#39;") + "'" : "") + // cell title
                                (unselectable ? "" : " data-handler='selectDay' data-event='click' data-month='" + printDate.getMonth() + "' data-year='" + printDate.getFullYear() + "'") + ">" + // actions
                                (otherMonth && !showOtherMonths ? "&#xa0;" : // display for other months
                                    (unselectable ? "<span class='ui-state-default'>" + printDate.getDate() + "</span>" : "<a class='ui-state-default" +
                                        (printDate.getTime() === today.getTime() ? " ui-state-highlight" : "") +
                                        (printDate.getTime() === currentDate.getTime() ? " ui-state-active" : "") + // highlight selected day
                                        (otherMonth ? " ui-priority-secondary" : "") + // distinguish dates from other months
                                        "' href='#'>" + printDate.getDate() + "</a>")) + "</td>"; // display selectable date
                            printDate.setDate(printDate.getDate() + 1);
                            printDate = this._daylightSavingAdjust(printDate);
                        }
                        calender += tbody + "</tr>";
                    }
                    drawMonth++;
                    if (drawMonth > 11) {
                        drawMonth = 0;
                        drawYear++;
                    }
                    calender += "</tbody></table>" + (isMultiMonth ? "</div>" +
                        ((numMonths[0] > 0 && col === numMonths[1] - 1) ? "<div class='ui-datepicker-row-break'></div>" : "") : "");
                    group += calender;
                }
                html += group;
            }
            html += buttonPanel;
            inst._keyEvent = false;
            return html;
        },

        /* Generate the month and year header. */
        _generateMonthYearHeader: function (inst, drawMonth, drawYear, minDate, maxDate,
            secondary, monthNames, monthNamesShort) {

            var inMinYear, inMaxYear, month, years, thisYear, determineYear, year, endYear,
                changeMonth = this._get(inst, "changeMonth"),
                changeYear = this._get(inst, "changeYear"),
                showMonthAfterYear = this._get(inst, "showMonthAfterYear"),
                html = "<div class='ui-datepicker-title'>",
                monthHtml = "";

            // month selection
            if (secondary || !changeMonth) {
                monthHtml += "<span class='ui-datepicker-month'>" + monthNames[drawMonth] + "</span>";
            } else {
                inMinYear = (minDate && minDate.getFullYear() === drawYear);
                inMaxYear = (maxDate && maxDate.getFullYear() === drawYear);
                monthHtml += "<select class='ui-datepicker-month' data-handler='selectMonth' data-event='change'>";
                for (month = 0; month < 12; month++) {
                    if ((!inMinYear || month >= minDate.getMonth()) && (!inMaxYear || month <= maxDate.getMonth())) {
                        monthHtml += "<option value='" + month + "'" +
                            (month === drawMonth ? " selected='selected'" : "") +
                            ">" + monthNamesShort[month] + "</option>";
                    }
                }
                monthHtml += "</select>";
            }

            if (!showMonthAfterYear) {
                html += monthHtml + (secondary || !(changeMonth && changeYear) ? "&#xa0;" : "");
            }

            // year selection
            if (!inst.yearshtml) {
                inst.yearshtml = "";
                if (secondary || !changeYear) {
                    html += "<span class='ui-datepicker-year'>" + drawYear + "</span>";
                } else {
                    // determine range of years to display
                    years = this._get(inst, "yearRange").split(":");
                    thisYear = new Date().getFullYear();
                    determineYear = function (value) {
                        var year = (value.match(/c[+\-].*/) ? drawYear + parseInt(value.substring(1), 10) :
                            (value.match(/[+\-].*/) ? thisYear + parseInt(value, 10) :
                                parseInt(value, 10)));
                        return (isNaN(year) ? thisYear : year);
                    };
                    year = determineYear(years[0]);
                    endYear = Math.max(year, determineYear(years[1] || ""));
                    year = (minDate ? Math.max(year, minDate.getFullYear()) : year);
                    endYear = (maxDate ? Math.min(endYear, maxDate.getFullYear()) : endYear);
                    inst.yearshtml += "<select class='ui-datepicker-year' data-handler='selectYear' data-event='change'>";
                    for (; year <= endYear; year++) {
                        inst.yearshtml += "<option value='" + year + "'" +
                            (year === drawYear ? " selected='selected'" : "") +
                            ">" + year + "</option>";
                    }
                    inst.yearshtml += "</select>";

                    html += inst.yearshtml;
                    inst.yearshtml = null;
                }
            }

            html += this._get(inst, "yearSuffix");
            if (showMonthAfterYear) {
                html += (secondary || !(changeMonth && changeYear) ? "&#xa0;" : "") + monthHtml;
            }
            html += "</div>"; // Close datepicker_header
            return html;
        },

        /* Adjust one of the date sub-fields. */
        _adjustInstDate: function (inst, offset, period) {
            var year = inst.drawYear + (period === "Y" ? offset : 0),
                month = inst.drawMonth + (period === "M" ? offset : 0),
                day = Math.min(inst.selectedDay, this._getDaysInMonth(year, month)) + (period === "D" ? offset : 0),
                date = this._restrictMinMax(inst, this._daylightSavingAdjust(new Date(year, month, day)));

            inst.selectedDay = date.getDate();
            inst.drawMonth = inst.selectedMonth = date.getMonth();
            inst.drawYear = inst.selectedYear = date.getFullYear();
            if (period === "M" || period === "Y") {
                this._notifyChange(inst);
            }
        },

        /* Ensure a date is within any min/max bounds. */
        _restrictMinMax: function (inst, date) {
            var minDate = this._getMinMaxDate(inst, "min"),
                maxDate = this._getMinMaxDate(inst, "max"),
                newDate = (minDate && date < minDate ? minDate : date);
            return (maxDate && newDate > maxDate ? maxDate : newDate);
        },

        /* Notify change of month/year. */
        _notifyChange: function (inst) {
            var onChange = this._get(inst, "onChangeMonthYear");
            if (onChange) {
                onChange.apply((inst.input ? inst.input[0] : null),
                    [inst.selectedYear, inst.selectedMonth + 1, inst]);
            }
        },

        /* Determine the number of months to show. */
        _getNumberOfMonths: function (inst) {
            var numMonths = this._get(inst, "numberOfMonths");
            return (numMonths == null ? [1, 1] : (typeof numMonths === "number" ? [1, numMonths] : numMonths));
        },

        /* Determine the current maximum date - ensure no time components are set. */
        _getMinMaxDate: function (inst, minMax) {
            return this._determineDate(inst, this._get(inst, minMax + "Date"), null);
        },

        /* Find the number of days in a given month. */
        _getDaysInMonth: function (year, month) {
            return 32 - this._daylightSavingAdjust(new Date(year, month, 32)).getDate();
        },

        /* Find the day of the week of the first of a month. */
        _getFirstDayOfMonth: function (year, month) {
            return new Date(year, month, 1).getDay();
        },

        /* Determines if we should allow a "next/prev" month display change. */
        _canAdjustMonth: function (inst, offset, curYear, curMonth) {
            var numMonths = this._getNumberOfMonths(inst),
                date = this._daylightSavingAdjust(new Date(curYear,
                    curMonth + (offset < 0 ? offset : numMonths[0] * numMonths[1]), 1));

            if (offset < 0) {
                date.setDate(this._getDaysInMonth(date.getFullYear(), date.getMonth()));
            }
            return this._isInRange(inst, date);
        },

        /* Is the given date in the accepted range? */
        _isInRange: function (inst, date) {
            var yearSplit, currentYear,
                minDate = this._getMinMaxDate(inst, "min"),
                maxDate = this._getMinMaxDate(inst, "max"),
                minYear = null,
                maxYear = null,
                years = this._get(inst, "yearRange");
            if (years) {
                yearSplit = years.split(":");
                currentYear = new Date().getFullYear();
                minYear = parseInt(yearSplit[0], 10);
                maxYear = parseInt(yearSplit[1], 10);
                if (yearSplit[0].match(/[+\-].*/)) {
                    minYear += currentYear;
                }
                if (yearSplit[1].match(/[+\-].*/)) {
                    maxYear += currentYear;
                }
            }

            return ((!minDate || date.getTime() >= minDate.getTime()) &&
                (!maxDate || date.getTime() <= maxDate.getTime()) &&
                (!minYear || date.getFullYear() >= minYear) &&
                (!maxYear || date.getFullYear() <= maxYear));
        },

        /* Provide the configuration settings for formatting/parsing. */
        _getFormatConfig: function (inst) {
            var shortYearCutoff = this._get(inst, "shortYearCutoff");
            shortYearCutoff = (typeof shortYearCutoff !== "string" ? shortYearCutoff :
                new Date().getFullYear() % 100 + parseInt(shortYearCutoff, 10));
            return {
                shortYearCutoff: shortYearCutoff,
                dayNamesShort: this._get(inst, "dayNamesShort"), dayNames: this._get(inst, "dayNames"),
                monthNamesShort: this._get(inst, "monthNamesShort"), monthNames: this._get(inst, "monthNames")
            };
        },

        /* Format the given date for display. */
        _formatDate: function (inst, day, month, year) {
            if (!day) {
                inst.currentDay = inst.selectedDay;
                inst.currentMonth = inst.selectedMonth;
                inst.currentYear = inst.selectedYear;
            }
            var date = (day ? (typeof day === "object" ? day :
                this._daylightSavingAdjust(new Date(year, month, day))) :
                this._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay)));
            return this.formatDate(this._get(inst, "dateFormat"), date, this._getFormatConfig(inst));
        }
    });

    /*
     * Bind hover events for datepicker elements.
     * Done via delegate so the binding only occurs once in the lifetime of the parent div.
     * Global instActive, set by _updateDatepicker allows the handlers to find their way back to the active picker.
     */
    function bindHover(dpDiv) {
        var selector = "button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a";
        return dpDiv.delegate(selector, "mouseout", function () {
            $(this).removeClass("ui-state-hover");
            if (this.className.indexOf("ui-datepicker-prev") !== -1) {
                $(this).removeClass("ui-datepicker-prev-hover");
            }
            if (this.className.indexOf("ui-datepicker-next") !== -1) {
                $(this).removeClass("ui-datepicker-next-hover");
            }
        })
            .delegate(selector, "mouseover", function () {
                if (!$.datepicker._isDisabledDatepicker(instActive.inline ? dpDiv.parent()[0] : instActive.input[0])) {
                    $(this).parents(".ui-datepicker-calendar").find("a").removeClass("ui-state-hover");
                    $(this).addClass("ui-state-hover");
                    if (this.className.indexOf("ui-datepicker-prev") !== -1) {
                        $(this).addClass("ui-datepicker-prev-hover");
                    }
                    if (this.className.indexOf("ui-datepicker-next") !== -1) {
                        $(this).addClass("ui-datepicker-next-hover");
                    }
                }
            });
    }

    /* jQuery extend now ignores nulls! */
    function extendRemove(target, props) {
        $.extend(target, props);
        for (var name in props) {
            if (props[name] == null) {
                target[name] = props[name];
            }
        }
        return target;
    }

    /* Invoke the datepicker functionality.
       @param  options  string - a command, optionally followed by additional parameters or
              Object - settings for attaching new datepicker functionality
       @return  jQuery object */
    $.fn.datepicker = function (options) {

        /* Verify an empty collection wasn't passed - Fixes #6976 */
        if (!this.length) {
            return this;
        }

        /* Initialise the date picker. */
        if (!$.datepicker.initialized) {
            $(document).mousedown($.datepicker._checkExternalClick);
            $.datepicker.initialized = true;
        }

        /* Append datepicker main container to body if not exist. */
        if ($("#" + $.datepicker._mainDivId).length === 0) {
            $("body").append($.datepicker.dpDiv);
        }

        var otherArgs = Array.prototype.slice.call(arguments, 1);
        if (typeof options === "string" && (options === "isDisabled" || options === "getDate" || options === "widget")) {
            return $.datepicker["_" + options + "Datepicker"].
                apply($.datepicker, [this[0]].concat(otherArgs));
        }
        if (options === "option" && arguments.length === 2 && typeof arguments[1] === "string") {
            return $.datepicker["_" + options + "Datepicker"].
                apply($.datepicker, [this[0]].concat(otherArgs));
        }
        return this.each(function () {
            typeof options === "string" ?
                $.datepicker["_" + options + "Datepicker"].
                    apply($.datepicker, [this].concat(otherArgs)) :
                $.datepicker._attachDatepicker(this, options);
        });
    };

    $.datepicker = new Datepicker(); // singleton instance
    $.datepicker.initialized = false;
    $.datepicker.uuid = new Date().getTime();
    $.datepicker.version = "1.10.2";

    // Workaround for #4055
    // Add another global to avoid noConflict issues with inline event handlers
    window["DP_jQuery_" + dpuuid] = $;

})(jQuery);

(function ($, undefined) {

    var sizeRelatedOptions = {
        buttons: true,
        height: true,
        maxHeight: true,
        maxWidth: true,
        minHeight: true,
        minWidth: true,
        width: true
    },
        resizableRelatedOptions = {
            maxHeight: true,
            maxWidth: true,
            minHeight: true,
            minWidth: true
        };

    $.widget("ui.dialog", {
        version: "1.10.2",
        options: {
            appendTo: "body",
            autoOpen: true,
            buttons: [],
            closeOnEscape: true,
            closeText: "close",
            dialogClass: "",
            draggable: true,
            hide: null,
            height: "auto",
            maxHeight: null,
            maxWidth: null,
            minHeight: 150,
            minWidth: 150,
            modal: false,
            position: {
                my: "center",
                at: "center",
                of: window,
                collision: "fit",
                // Ensure the titlebar is always visible
                using: function (pos) {
                    var topOffset = $(this).css(pos).offset().top;
                    if (topOffset < 0) {
                        $(this).css("top", pos.top - topOffset);
                    }
                }
            },
            resizable: true,
            show: null,
            title: null,
            width: 300,

            // callbacks
            beforeClose: null,
            close: null,
            drag: null,
            dragStart: null,
            dragStop: null,
            focus: null,
            open: null,
            resize: null,
            resizeStart: null,
            resizeStop: null
        },

        _create: function () {
            this.originalCss = {
                display: this.element[0].style.display,
                width: this.element[0].style.width,
                minHeight: this.element[0].style.minHeight,
                maxHeight: this.element[0].style.maxHeight,
                height: this.element[0].style.height
            };
            this.originalPosition = {
                parent: this.element.parent(),
                index: this.element.parent().children().index(this.element)
            };
            this.originalTitle = this.element.attr("title");
            this.options.title = this.options.title || this.originalTitle;

            this._createWrapper();

            this.element
                .show()
                .removeAttr("title")
                .addClass("ui-dialog-content ui-widget-content")
                .appendTo(this.uiDialog);

            this._createTitlebar();
            this._createButtonPane();

            if (this.options.draggable && $.fn.draggable) {
                this._makeDraggable();
            }
            if (this.options.resizable && $.fn.resizable) {
                this._makeResizable();
            }

            this._isOpen = false;
        },

        _init: function () {
            if (this.options.autoOpen) {
                this.open();
            }
        },

        _appendTo: function () {
            var element = this.options.appendTo;
            if (element && (element.jquery || element.nodeType)) {
                return $(element);
            }
            return this.document.find(element || "body").eq(0);
        },

        _destroy: function () {
            var next,
                originalPosition = this.originalPosition;

            this._destroyOverlay();

            this.element
                .removeUniqueId()
                .removeClass("ui-dialog-content ui-widget-content")
                .css(this.originalCss)
                // Without detaching first, the following becomes really slow
                .detach();

            this.uiDialog.stop(true, true).remove();

            if (this.originalTitle) {
                this.element.attr("title", this.originalTitle);
            }

            next = originalPosition.parent.children().eq(originalPosition.index);
            // Don't try to place the dialog next to itself (#8613)
            if (next.length && next[0] !== this.element[0]) {
                next.before(this.element);
            } else {
                originalPosition.parent.append(this.element);
            }
        },

        widget: function () {
            return this.uiDialog;
        },

        disable: $.noop,
        enable: $.noop,

        close: function (event) {
            var that = this;

            if (!this._isOpen || this._trigger("beforeClose", event) === false) {
                return;
            }

            this._isOpen = false;
            this._destroyOverlay();

            if (!this.opener.filter(":focusable").focus().length) {
                // Hiding a focused element doesn't trigger blur in WebKit
                // so in case we have nothing to focus on, explicitly blur the active element
                // https://bugs.webkit.org/show_bug.cgi?id=47182
                $(this.document[0].activeElement).blur();
            }

            this._hide(this.uiDialog, this.options.hide, function () {
                that._trigger("close", event);
            });
        },

        isOpen: function () {
            return this._isOpen;
        },

        moveToTop: function () {
            this._moveToTop();
        },

        _moveToTop: function (event, silent) {
            var moved = !!this.uiDialog.nextAll(":visible").insertBefore(this.uiDialog).length;
            if (moved && !silent) {
                this._trigger("focus", event);
            }
            return moved;
        },

        open: function () {
            var that = this;
            if (this._isOpen) {
                if (this._moveToTop()) {
                    this._focusTabbable();
                }
                return;
            }

            this._isOpen = true;
            this.opener = $(this.document[0].activeElement);

            this._size();
            this._position();
            this._createOverlay();
            this._moveToTop(null, true);
            this._show(this.uiDialog, this.options.show, function () {
                that._focusTabbable();
                that._trigger("focus");
            });

            this._trigger("open");
        },

        _focusTabbable: function () {
            // Set focus to the first match:
            // 1. First element inside the dialog matching [autofocus]
            // 2. Tabbable element inside the content element
            // 3. Tabbable element inside the buttonpane
            // 4. The close button
            // 5. The dialog itself
            var hasFocus = this.element.find("[autofocus]");
            if (!hasFocus.length) {
                hasFocus = this.element.find(":tabbable");
            }
            if (!hasFocus.length) {
                hasFocus = this.uiDialogButtonPane.find(":tabbable");
            }
            if (!hasFocus.length) {
                hasFocus = this.uiDialogTitlebarClose.filter(":tabbable");
            }
            if (!hasFocus.length) {
                hasFocus = this.uiDialog;
            }
            hasFocus.eq(0).focus();
        },

        _keepFocus: function (event) {
            function checkFocus() {
                var activeElement = this.document[0].activeElement,
                    isActive = this.uiDialog[0] === activeElement ||
                        $.contains(this.uiDialog[0], activeElement);
                if (!isActive) {
                    this._focusTabbable();
                }
            }
            event.preventDefault();
            checkFocus.call(this);
            // support: IE
            // IE <= 8 doesn't prevent moving focus even with event.preventDefault()
            // so we check again later
            this._delay(checkFocus);
        },

        _createWrapper: function () {
            this.uiDialog = $("<div>")
                .addClass("ui-dialog ui-widget ui-widget-content ui-corner-all ui-front " +
                this.options.dialogClass)
                .hide()
                .attr({
                    // Setting tabIndex makes the div focusable
                    tabIndex: -1,
                    role: "dialog"
                })
                .appendTo(this._appendTo());

            this._on(this.uiDialog, {
                keydown: function (event) {
                    if (this.options.closeOnEscape && !event.isDefaultPrevented() && event.keyCode &&
                        event.keyCode === $.ui.keyCode.ESCAPE) {
                        event.preventDefault();
                        this.close(event);
                        return;
                    }

                    // prevent tabbing out of dialogs
                    if (event.keyCode !== $.ui.keyCode.TAB) {
                        return;
                    }
                    var tabbables = this.uiDialog.find(":tabbable"),
                        first = tabbables.filter(":first"),
                        last = tabbables.filter(":last");

                    if ((event.target === last[0] || event.target === this.uiDialog[0]) && !event.shiftKey) {
                        first.focus(1);
                        event.preventDefault();
                    } else if ((event.target === first[0] || event.target === this.uiDialog[0]) && event.shiftKey) {
                        last.focus(1);
                        event.preventDefault();
                    }
                },
                mousedown: function (event) {
                    if (this._moveToTop(event)) {
                        this._focusTabbable();
                    }
                }
            });

            // We assume that any existing aria-describedby attribute means
            // that the dialog content is marked up properly
            // otherwise we brute force the content as the description
            if (!this.element.find("[aria-describedby]").length) {
                this.uiDialog.attr({
                    "aria-describedby": this.element.uniqueId().attr("id")
                });
            }
        },

        _createTitlebar: function () {
            var uiDialogTitle;

            this.uiDialogTitlebar = $("<div>")
                .addClass("ui-dialog-titlebar ui-widget-header ui-corner-all ui-helper-clearfix")
                .prependTo(this.uiDialog);
            this._on(this.uiDialogTitlebar, {
                mousedown: function (event) {
                    // Don't prevent click on close button (#8838)
                    // Focusing a dialog that is partially scrolled out of view
                    // causes the browser to scroll it into view, preventing the click event
                    if (!$(event.target).closest(".ui-dialog-titlebar-close")) {
                        // Dialog isn't getting focus when dragging (#8063)
                        this.uiDialog.focus();
                    }
                }
            });

            this.uiDialogTitlebarClose = $("<button></button>")
                .button({
                    label: this.options.closeText,
                    icons: {
                        primary: "ui-icon-closethick"
                    },
                    text: false
                })
                .addClass("ui-dialog-titlebar-close")
                .appendTo(this.uiDialogTitlebar);
            this._on(this.uiDialogTitlebarClose, {
                click: function (event) {
                    event.preventDefault();
                    this.close(event);
                }
            });

            uiDialogTitle = $("<span>")
                .uniqueId()
                .addClass("ui-dialog-title")
                .prependTo(this.uiDialogTitlebar);
            this._title(uiDialogTitle);

            this.uiDialog.attr({
                "aria-labelledby": uiDialogTitle.attr("id")
            });
        },

        _title: function (title) {
            if (!this.options.title) {
                title.html("&#160;");
            }
            title.text(this.options.title);
        },

        _createButtonPane: function () {
            this.uiDialogButtonPane = $("<div>")
                .addClass("ui-dialog-buttonpane ui-widget-content ui-helper-clearfix");

            this.uiButtonSet = $("<div>")
                .addClass("ui-dialog-buttonset")
                .appendTo(this.uiDialogButtonPane);

            this._createButtons();
        },

        _createButtons: function () {
            var that = this,
                buttons = this.options.buttons;

            // if we already have a button pane, remove it
            this.uiDialogButtonPane.remove();
            this.uiButtonSet.empty();

            if ($.isEmptyObject(buttons) || ($.isArray(buttons) && !buttons.length)) {
                this.uiDialog.removeClass("ui-dialog-buttons");
                return;
            }

            $.each(buttons, function (name, props) {
                var click, buttonOptions;
                props = $.isFunction(props) ?
                    { click: props, text: name } :
                    props;
                // Default to a non-submitting button
                props = $.extend({ type: "button" }, props);
                // Change the context for the click callback to be the main element
                click = props.click;
                props.click = function () {
                    click.apply(that.element[0], arguments);
                };
                buttonOptions = {
                    icons: props.icons,
                    text: props.showText
                };
                delete props.icons;
                delete props.showText;
                $("<button></button>", props)
                    .button(buttonOptions)
                    .appendTo(that.uiButtonSet);
            });
            this.uiDialog.addClass("ui-dialog-buttons");
            this.uiDialogButtonPane.appendTo(this.uiDialog);
        },

        _makeDraggable: function () {
            var that = this,
                options = this.options;

            function filteredUi(ui) {
                return {
                    position: ui.position,
                    offset: ui.offset
                };
            }

            this.uiDialog.draggable({
                cancel: ".ui-dialog-content, .ui-dialog-titlebar-close",
                handle: ".ui-dialog-titlebar",
                containment: "document",
                start: function (event, ui) {
                    $(this).addClass("ui-dialog-dragging");
                    that._blockFrames();
                    that._trigger("dragStart", event, filteredUi(ui));
                },
                drag: function (event, ui) {
                    that._trigger("drag", event, filteredUi(ui));
                },
                stop: function (event, ui) {
                    options.position = [
                        ui.position.left - that.document.scrollLeft(),
                        ui.position.top - that.document.scrollTop()
                    ];
                    $(this).removeClass("ui-dialog-dragging");
                    that._unblockFrames();
                    that._trigger("dragStop", event, filteredUi(ui));
                }
            });
        },

        _makeResizable: function () {
            var that = this,
                options = this.options,
                handles = options.resizable,
                // .ui-resizable has position: relative defined in the stylesheet
                // but dialogs have to use absolute or fixed positioning
                position = this.uiDialog.css("position"),
                resizeHandles = typeof handles === "string" ?
                    handles :
                    "n,e,s,w,se,sw,ne,nw";

            function filteredUi(ui) {
                return {
                    originalPosition: ui.originalPosition,
                    originalSize: ui.originalSize,
                    position: ui.position,
                    size: ui.size
                };
            }

            this.uiDialog.resizable({
                cancel: ".ui-dialog-content",
                containment: "document",
                alsoResize: this.element,
                maxWidth: options.maxWidth,
                maxHeight: options.maxHeight,
                minWidth: options.minWidth,
                minHeight: this._minHeight(),
                handles: resizeHandles,
                start: function (event, ui) {
                    $(this).addClass("ui-dialog-resizing");
                    that._blockFrames();
                    that._trigger("resizeStart", event, filteredUi(ui));
                },
                resize: function (event, ui) {
                    that._trigger("resize", event, filteredUi(ui));
                },
                stop: function (event, ui) {
                    options.height = $(this).height();
                    options.width = $(this).width();
                    $(this).removeClass("ui-dialog-resizing");
                    that._unblockFrames();
                    that._trigger("resizeStop", event, filteredUi(ui));
                }
            })
                .css("position", position);
        },

        _minHeight: function () {
            var options = this.options;

            return options.height === "auto" ?
                options.minHeight :
                Math.min(options.minHeight, options.height);
        },

        _position: function () {
            // Need to show the dialog to get the actual offset in the position plugin
            var isVisible = this.uiDialog.is(":visible");
            if (!isVisible) {
                this.uiDialog.show();
            }
            this.uiDialog.position(this.options.position);
            if (!isVisible) {
                this.uiDialog.hide();
            }
        },

        _setOptions: function (options) {
            var that = this,
                resize = false,
                resizableOptions = {};

            $.each(options, function (key, value) {
                that._setOption(key, value);

                if (key in sizeRelatedOptions) {
                    resize = true;
                }
                if (key in resizableRelatedOptions) {
                    resizableOptions[key] = value;
                }
            });

            if (resize) {
                this._size();
                this._position();
            }
            if (this.uiDialog.is(":data(ui-resizable)")) {
                this.uiDialog.resizable("option", resizableOptions);
            }
        },

        _setOption: function (key, value) {
            /*jshint maxcomplexity:15*/
            var isDraggable, isResizable,
                uiDialog = this.uiDialog;

            if (key === "dialogClass") {
                uiDialog
                    .removeClass(this.options.dialogClass)
                    .addClass(value);
            }

            if (key === "disabled") {
                return;
            }

            this._super(key, value);

            if (key === "appendTo") {
                this.uiDialog.appendTo(this._appendTo());
            }

            if (key === "buttons") {
                this._createButtons();
            }

            if (key === "closeText") {
                this.uiDialogTitlebarClose.button({
                    // Ensure that we always pass a string
                    label: "" + value
                });
            }

            if (key === "draggable") {
                isDraggable = uiDialog.is(":data(ui-draggable)");
                if (isDraggable && !value) {
                    uiDialog.draggable("destroy");
                }

                if (!isDraggable && value) {
                    this._makeDraggable();
                }
            }

            if (key === "position") {
                this._position();
            }

            if (key === "resizable") {
                // currently resizable, becoming non-resizable
                isResizable = uiDialog.is(":data(ui-resizable)");
                if (isResizable && !value) {
                    uiDialog.resizable("destroy");
                }

                // currently resizable, changing handles
                if (isResizable && typeof value === "string") {
                    uiDialog.resizable("option", "handles", value);
                }

                // currently non-resizable, becoming resizable
                if (!isResizable && value !== false) {
                    this._makeResizable();
                }
            }

            if (key === "title") {
                this._title(this.uiDialogTitlebar.find(".ui-dialog-title"));
            }
        },

        _size: function () {
            // If the user has resized the dialog, the .ui-dialog and .ui-dialog-content
            // divs will both have width and height set, so we need to reset them
            var nonContentHeight, minContentHeight, maxContentHeight,
                options = this.options;

            // Reset content sizing
            this.element.show().css({
                width: "auto",
                minHeight: 0,
                maxHeight: "none",
                height: 0
            });

            if (options.minWidth > options.width) {
                options.width = options.minWidth;
            }

            // reset wrapper sizing
            // determine the height of all the non-content elements
            nonContentHeight = this.uiDialog.css({
                height: "auto",
                width: options.width
            })
                .outerHeight();
            minContentHeight = Math.max(0, options.minHeight - nonContentHeight);
            maxContentHeight = typeof options.maxHeight === "number" ?
                Math.max(0, options.maxHeight - nonContentHeight) :
                "none";

            if (options.height === "auto") {
                this.element.css({
                    minHeight: minContentHeight,
                    maxHeight: maxContentHeight,
                    height: "auto"
                });
            } else {
                this.element.height(Math.max(0, options.height - nonContentHeight));
            }

            if (this.uiDialog.is(":data(ui-resizable)")) {
                this.uiDialog.resizable("option", "minHeight", this._minHeight());
            }
        },

        _blockFrames: function () {
            this.iframeBlocks = this.document.find("iframe").map(function () {
                var iframe = $(this);

                return $("<div>")
                    .css({
                        position: "absolute",
                        width: iframe.outerWidth(),
                        height: iframe.outerHeight()
                    })
                    .appendTo(iframe.parent())
                    .offset(iframe.offset())[0];
            });
        },

        _unblockFrames: function () {
            if (this.iframeBlocks) {
                this.iframeBlocks.remove();
                delete this.iframeBlocks;
            }
        },

        _allowInteraction: function (event) {
            if ($(event.target).closest(".ui-dialog").length) {
                return true;
            }

            // TODO: Remove hack when datepicker implements
            // the .ui-front logic (#8989)
            return !!$(event.target).closest(".ui-datepicker").length;
        },

        _createOverlay: function () {
            if (!this.options.modal) {
                return;
            }

            var that = this,
                widgetFullName = this.widgetFullName;
            if (!$.ui.dialog.overlayInstances) {
                // Prevent use of anchors and inputs.
                // We use a delay in case the overlay is created from an
                // event that we're going to be cancelling. (#2804)
                this._delay(function () {
                    // Handle .dialog().dialog("close") (#4065)
                    if ($.ui.dialog.overlayInstances) {
                        this.document.bind("focusin.dialog", function (event) {
                            if (!that._allowInteraction(event)) {
                                event.preventDefault();
                                $(".ui-dialog:visible:last .ui-dialog-content")
                                    .data(widgetFullName)._focusTabbable();
                            }
                        });
                    }
                });
            }

            this.overlay = $("<div>")
                .addClass("ui-widget-overlay ui-front")
                .appendTo(this._appendTo());
            this._on(this.overlay, {
                mousedown: "_keepFocus"
            });
            $.ui.dialog.overlayInstances++;
        },

        _destroyOverlay: function () {
            if (!this.options.modal) {
                return;
            }

            if (this.overlay) {
                $.ui.dialog.overlayInstances--;

                if (!$.ui.dialog.overlayInstances) {
                    this.document.unbind("focusin.dialog");
                }
                this.overlay.remove();
                this.overlay = null;
            }
        }
    });

    $.ui.dialog.overlayInstances = 0;

    // DEPRECATED
    if ($.uiBackCompat !== false) {
        // position option with array notation
        // just override with old implementation
        $.widget("ui.dialog", $.ui.dialog, {
            _position: function () {
                var position = this.options.position,
                    myAt = [],
                    offset = [0, 0],
                    isVisible;

                if (position) {
                    if (typeof position === "string" || (typeof position === "object" && "0" in position)) {
                        myAt = position.split ? position.split(" ") : [position[0], position[1]];
                        if (myAt.length === 1) {
                            myAt[1] = myAt[0];
                        }

                        $.each(["left", "top"], function (i, offsetPosition) {
                            if (+myAt[i] === myAt[i]) {
                                offset[i] = myAt[i];
                                myAt[i] = offsetPosition;
                            }
                        });

                        position = {
                            my: myAt[0] + (offset[0] < 0 ? offset[0] : "+" + offset[0]) + " " +
                                myAt[1] + (offset[1] < 0 ? offset[1] : "+" + offset[1]),
                            at: myAt.join(" ")
                        };
                    }

                    position = $.extend({}, $.ui.dialog.prototype.options.position, position);
                } else {
                    position = $.ui.dialog.prototype.options.position;
                }

                // need to show the dialog to get the actual offset in the position plugin
                isVisible = this.uiDialog.is(":visible");
                if (!isVisible) {
                    this.uiDialog.show();
                }
                this.uiDialog.position(position);
                if (!isVisible) {
                    this.uiDialog.hide();
                }
            }
        });
    }

}(jQuery));

(function ($, undefined) {

    var rvertical = /up|down|vertical/,
        rpositivemotion = /up|left|vertical|horizontal/;

    $.effects.effect.blind = function (o, done) {
        // Create element
        var el = $(this),
            props = ["position", "top", "bottom", "left", "right", "height", "width"],
            mode = $.effects.setMode(el, o.mode || "hide"),
            direction = o.direction || "up",
            vertical = rvertical.test(direction),
            ref = vertical ? "height" : "width",
            ref2 = vertical ? "top" : "left",
            motion = rpositivemotion.test(direction),
            animation = {},
            show = mode === "show",
            wrapper, distance, margin;

        // if already wrapped, the wrapper's properties are my property. #6245
        if (el.parent().is(".ui-effects-wrapper")) {
            $.effects.save(el.parent(), props);
        } else {
            $.effects.save(el, props);
        }
        el.show();
        wrapper = $.effects.createWrapper(el).css({
            overflow: "hidden"
        });

        distance = wrapper[ref]();
        margin = parseFloat(wrapper.css(ref2)) || 0;

        animation[ref] = show ? distance : 0;
        if (!motion) {
            el
                .css(vertical ? "bottom" : "right", 0)
                .css(vertical ? "top" : "left", "auto")
                .css({ position: "absolute" });

            animation[ref2] = show ? margin : distance + margin;
        }

        // start at 0 if we are showing
        if (show) {
            wrapper.css(ref, 0);
            if (!motion) {
                wrapper.css(ref2, margin + distance);
            }
        }

        // Animate
        wrapper.animate(animation, {
            duration: o.duration,
            easing: o.easing,
            queue: false,
            complete: function () {
                if (mode === "hide") {
                    el.hide();
                }
                $.effects.restore(el, props);
                $.effects.removeWrapper(el);
                done();
            }
        });

    };

})(jQuery);

(function ($, undefined) {

    $.effects.effect.bounce = function (o, done) {
        var el = $(this),
            props = ["position", "top", "bottom", "left", "right", "height", "width"],

            // defaults:
            mode = $.effects.setMode(el, o.mode || "effect"),
            hide = mode === "hide",
            show = mode === "show",
            direction = o.direction || "up",
            distance = o.distance,
            times = o.times || 5,

            // number of internal animations
            anims = times * 2 + (show || hide ? 1 : 0),
            speed = o.duration / anims,
            easing = o.easing,

            // utility:
            ref = (direction === "up" || direction === "down") ? "top" : "left",
            motion = (direction === "up" || direction === "left"),
            i,
            upAnim,
            downAnim,

            // we will need to re-assemble the queue to stack our animations in place
            queue = el.queue(),
            queuelen = queue.length;

        // Avoid touching opacity to prevent clearType and PNG issues in IE
        if (show || hide) {
            props.push("opacity");
        }

        $.effects.save(el, props);
        el.show();
        $.effects.createWrapper(el); // Create Wrapper

        // default distance for the BIGGEST bounce is the outer Distance / 3
        if (!distance) {
            distance = el[ref === "top" ? "outerHeight" : "outerWidth"]() / 3;
        }

        if (show) {
            downAnim = { opacity: 1 };
            downAnim[ref] = 0;

            // if we are showing, force opacity 0 and set the initial position
            // then do the "first" animation
            el.css("opacity", 0)
                .css(ref, motion ? -distance * 2 : distance * 2)
                .animate(downAnim, speed, easing);
        }

        // start at the smallest distance if we are hiding
        if (hide) {
            distance = distance / Math.pow(2, times - 1);
        }

        downAnim = {};
        downAnim[ref] = 0;
        // Bounces up/down/left/right then back to 0 -- times * 2 animations happen here
        for (i = 0; i < times; i++) {
            upAnim = {};
            upAnim[ref] = (motion ? "-=" : "+=") + distance;

            el.animate(upAnim, speed, easing)
                .animate(downAnim, speed, easing);

            distance = hide ? distance * 2 : distance / 2;
        }

        // Last Bounce when Hiding
        if (hide) {
            upAnim = { opacity: 0 };
            upAnim[ref] = (motion ? "-=" : "+=") + distance;

            el.animate(upAnim, speed, easing);
        }

        el.queue(function () {
            if (hide) {
                el.hide();
            }
            $.effects.restore(el, props);
            $.effects.removeWrapper(el);
            done();
        });

        // inject all the animations we just queued to be first in line (after "inprogress")
        if (queuelen > 1) {
            queue.splice.apply(queue,
                [1, 0].concat(queue.splice(queuelen, anims + 1)));
        }
        el.dequeue();

    };

})(jQuery);

(function ($, undefined) {

    $.effects.effect.clip = function (o, done) {
        // Create element
        var el = $(this),
            props = ["position", "top", "bottom", "left", "right", "height", "width"],
            mode = $.effects.setMode(el, o.mode || "hide"),
            show = mode === "show",
            direction = o.direction || "vertical",
            vert = direction === "vertical",
            size = vert ? "height" : "width",
            position = vert ? "top" : "left",
            animation = {},
            wrapper, animate, distance;

        // Save & Show
        $.effects.save(el, props);
        el.show();

        // Create Wrapper
        wrapper = $.effects.createWrapper(el).css({
            overflow: "hidden"
        });
        animate = (el[0].tagName === "IMG") ? wrapper : el;
        distance = animate[size]();

        // Shift
        if (show) {
            animate.css(size, 0);
            animate.css(position, distance / 2);
        }

        // Create Animation Object:
        animation[size] = show ? distance : 0;
        animation[position] = show ? 0 : distance / 2;

        // Animate
        animate.animate(animation, {
            queue: false,
            duration: o.duration,
            easing: o.easing,
            complete: function () {
                if (!show) {
                    el.hide();
                }
                $.effects.restore(el, props);
                $.effects.removeWrapper(el);
                done();
            }
        });

    };

})(jQuery);

(function ($, undefined) {

    $.effects.effect.drop = function (o, done) {

        var el = $(this),
            props = ["position", "top", "bottom", "left", "right", "opacity", "height", "width"],
            mode = $.effects.setMode(el, o.mode || "hide"),
            show = mode === "show",
            direction = o.direction || "left",
            ref = (direction === "up" || direction === "down") ? "top" : "left",
            motion = (direction === "up" || direction === "left") ? "pos" : "neg",
            animation = {
                opacity: show ? 1 : 0
            },
            distance;

        // Adjust
        $.effects.save(el, props);
        el.show();
        $.effects.createWrapper(el);

        distance = o.distance || el[ref === "top" ? "outerHeight" : "outerWidth"](true) / 2;

        if (show) {
            el
                .css("opacity", 0)
                .css(ref, motion === "pos" ? -distance : distance);
        }

        // Animation
        animation[ref] = (show ?
            (motion === "pos" ? "+=" : "-=") :
            (motion === "pos" ? "-=" : "+=")) +
            distance;

        // Animate
        el.animate(animation, {
            queue: false,
            duration: o.duration,
            easing: o.easing,
            complete: function () {
                if (mode === "hide") {
                    el.hide();
                }
                $.effects.restore(el, props);
                $.effects.removeWrapper(el);
                done();
            }
        });
    };

})(jQuery);

(function ($, undefined) {

    $.effects.effect.explode = function (o, done) {

        var rows = o.pieces ? Math.round(Math.sqrt(o.pieces)) : 3,
            cells = rows,
            el = $(this),
            mode = $.effects.setMode(el, o.mode || "hide"),
            show = mode === "show",

            // show and then visibility:hidden the element before calculating offset
            offset = el.show().css("visibility", "hidden").offset(),

            // width and height of a piece
            width = Math.ceil(el.outerWidth() / cells),
            height = Math.ceil(el.outerHeight() / rows),
            pieces = [],

            // loop
            i, j, left, top, mx, my;

        // children animate complete:
        function childComplete() {
            pieces.push(this);
            if (pieces.length === rows * cells) {
                animComplete();
            }
        }

        // clone the element for each row and cell.
        for (i = 0; i < rows; i++) { // ===>
            top = offset.top + i * height;
            my = i - (rows - 1) / 2;

            for (j = 0; j < cells; j++) { // |||
                left = offset.left + j * width;
                mx = j - (cells - 1) / 2;

                // Create a clone of the now hidden main element that will be absolute positioned
                // within a wrapper div off the -left and -top equal to size of our pieces
                el
                    .clone()
                    .appendTo("body")
                    .wrap("<div></div>")
                    .css({
                        position: "absolute",
                        visibility: "visible",
                        left: -j * width,
                        top: -i * height
                    })

                    // select the wrapper - make it overflow: hidden and absolute positioned based on
                    // where the original was located +left and +top equal to the size of pieces
                    .parent()
                    .addClass("ui-effects-explode")
                    .css({
                        position: "absolute",
                        overflow: "hidden",
                        width: width,
                        height: height,
                        left: left + (show ? mx * width : 0),
                        top: top + (show ? my * height : 0),
                        opacity: show ? 0 : 1
                    }).animate({
                        left: left + (show ? 0 : mx * width),
                        top: top + (show ? 0 : my * height),
                        opacity: show ? 1 : 0
                    }, o.duration || 500, o.easing, childComplete);
            }
        }

        function animComplete() {
            el.css({
                visibility: "visible"
            });
            $(pieces).remove();
            if (!show) {
                el.hide();
            }
            done();
        }
    };

})(jQuery);

(function ($, undefined) {

    $.effects.effect.fade = function (o, done) {
        var el = $(this),
            mode = $.effects.setMode(el, o.mode || "toggle");

        el.animate({
            opacity: mode
        }, {
                queue: false,
                duration: o.duration,
                easing: o.easing,
                complete: done
            });
    };

})(jQuery);

(function ($, undefined) {

    $.effects.effect.fold = function (o, done) {

        // Create element
        var el = $(this),
            props = ["position", "top", "bottom", "left", "right", "height", "width"],
            mode = $.effects.setMode(el, o.mode || "hide"),
            show = mode === "show",
            hide = mode === "hide",
            size = o.size || 15,
            percent = /([0-9]+)%/.exec(size),
            horizFirst = !!o.horizFirst,
            widthFirst = show !== horizFirst,
            ref = widthFirst ? ["width", "height"] : ["height", "width"],
            duration = o.duration / 2,
            wrapper, distance,
            animation1 = {},
            animation2 = {};

        $.effects.save(el, props);
        el.show();

        // Create Wrapper
        wrapper = $.effects.createWrapper(el).css({
            overflow: "hidden"
        });
        distance = widthFirst ?
            [wrapper.width(), wrapper.height()] :
            [wrapper.height(), wrapper.width()];

        if (percent) {
            size = parseInt(percent[1], 10) / 100 * distance[hide ? 0 : 1];
        }
        if (show) {
            wrapper.css(horizFirst ? {
                height: 0,
                width: size
            } : {
                    height: size,
                    width: 0
                });
        }

        // Animation
        animation1[ref[0]] = show ? distance[0] : size;
        animation2[ref[1]] = show ? distance[1] : 0;

        // Animate
        wrapper
            .animate(animation1, duration, o.easing)
            .animate(animation2, duration, o.easing, function () {
                if (hide) {
                    el.hide();
                }
                $.effects.restore(el, props);
                $.effects.removeWrapper(el);
                done();
            });

    };

})(jQuery);

(function ($, undefined) {

    $.effects.effect.highlight = function (o, done) {
        var elem = $(this),
            props = ["backgroundImage", "backgroundColor", "opacity"],
            mode = $.effects.setMode(elem, o.mode || "show"),
            animation = {
                backgroundColor: elem.css("backgroundColor")
            };

        if (mode === "hide") {
            animation.opacity = 0;
        }

        $.effects.save(elem, props);

        elem
            .show()
            .css({
                backgroundImage: "none",
                backgroundColor: o.color || "#ffff99"
            })
            .animate(animation, {
                queue: false,
                duration: o.duration,
                easing: o.easing,
                complete: function () {
                    if (mode === "hide") {
                        elem.hide();
                    }
                    $.effects.restore(elem, props);
                    done();
                }
            });
    };

})(jQuery);

(function ($, undefined) {

    $.effects.effect.pulsate = function (o, done) {
        var elem = $(this),
            mode = $.effects.setMode(elem, o.mode || "show"),
            show = mode === "show",
            hide = mode === "hide",
            showhide = (show || mode === "hide"),

            // showing or hiding leaves of the "last" animation
            anims = ((o.times || 5) * 2) + (showhide ? 1 : 0),
            duration = o.duration / anims,
            animateTo = 0,
            queue = elem.queue(),
            queuelen = queue.length,
            i;

        if (show || !elem.is(":visible")) {
            elem.css("opacity", 0).show();
            animateTo = 1;
        }

        // anims - 1 opacity "toggles"
        for (i = 1; i < anims; i++) {
            elem.animate({
                opacity: animateTo
            }, duration, o.easing);
            animateTo = 1 - animateTo;
        }

        elem.animate({
            opacity: animateTo
        }, duration, o.easing);

        elem.queue(function () {
            if (hide) {
                elem.hide();
            }
            done();
        });

        // We just queued up "anims" animations, we need to put them next in the queue
        if (queuelen > 1) {
            queue.splice.apply(queue,
                [1, 0].concat(queue.splice(queuelen, anims + 1)));
        }
        elem.dequeue();
    };

})(jQuery);

(function ($, undefined) {

    $.effects.effect.puff = function (o, done) {
        var elem = $(this),
            mode = $.effects.setMode(elem, o.mode || "hide"),
            hide = mode === "hide",
            percent = parseInt(o.percent, 10) || 150,
            factor = percent / 100,
            original = {
                height: elem.height(),
                width: elem.width(),
                outerHeight: elem.outerHeight(),
                outerWidth: elem.outerWidth()
            };

        $.extend(o, {
            effect: "scale",
            queue: false,
            fade: true,
            mode: mode,
            complete: done,
            percent: hide ? percent : 100,
            from: hide ?
                original :
                {
                    height: original.height * factor,
                    width: original.width * factor,
                    outerHeight: original.outerHeight * factor,
                    outerWidth: original.outerWidth * factor
                }
        });

        elem.effect(o);
    };

    $.effects.effect.scale = function (o, done) {

        // Create element
        var el = $(this),
            options = $.extend(true, {}, o),
            mode = $.effects.setMode(el, o.mode || "effect"),
            percent = parseInt(o.percent, 10) ||
                (parseInt(o.percent, 10) === 0 ? 0 : (mode === "hide" ? 0 : 100)),
            direction = o.direction || "both",
            origin = o.origin,
            original = {
                height: el.height(),
                width: el.width(),
                outerHeight: el.outerHeight(),
                outerWidth: el.outerWidth()
            },
            factor = {
                y: direction !== "horizontal" ? (percent / 100) : 1,
                x: direction !== "vertical" ? (percent / 100) : 1
            };

        // We are going to pass this effect to the size effect:
        options.effect = "size";
        options.queue = false;
        options.complete = done;

        // Set default origin and restore for show/hide
        if (mode !== "effect") {
            options.origin = origin || ["middle", "center"];
            options.restore = true;
        }

        options.from = o.from || (mode === "show" ? {
            height: 0,
            width: 0,
            outerHeight: 0,
            outerWidth: 0
        } : original);
        options.to = {
            height: original.height * factor.y,
            width: original.width * factor.x,
            outerHeight: original.outerHeight * factor.y,
            outerWidth: original.outerWidth * factor.x
        };

        // Fade option to support puff
        if (options.fade) {
            if (mode === "show") {
                options.from.opacity = 0;
                options.to.opacity = 1;
            }
            if (mode === "hide") {
                options.from.opacity = 1;
                options.to.opacity = 0;
            }
        }

        // Animate
        el.effect(options);

    };

    $.effects.effect.size = function (o, done) {

        // Create element
        var original, baseline, factor,
            el = $(this),
            props0 = ["position", "top", "bottom", "left", "right", "width", "height", "overflow", "opacity"],

            // Always restore
            props1 = ["position", "top", "bottom", "left", "right", "overflow", "opacity"],

            // Copy for children
            props2 = ["width", "height", "overflow"],
            cProps = ["fontSize"],
            vProps = ["borderTopWidth", "borderBottomWidth", "paddingTop", "paddingBottom"],
            hProps = ["borderLeftWidth", "borderRightWidth", "paddingLeft", "paddingRight"],

            // Set options
            mode = $.effects.setMode(el, o.mode || "effect"),
            restore = o.restore || mode !== "effect",
            scale = o.scale || "both",
            origin = o.origin || ["middle", "center"],
            position = el.css("position"),
            props = restore ? props0 : props1,
            zero = {
                height: 0,
                width: 0,
                outerHeight: 0,
                outerWidth: 0
            };

        if (mode === "show") {
            el.show();
        }
        original = {
            height: el.height(),
            width: el.width(),
            outerHeight: el.outerHeight(),
            outerWidth: el.outerWidth()
        };

        if (o.mode === "toggle" && mode === "show") {
            el.from = o.to || zero;
            el.to = o.from || original;
        } else {
            el.from = o.from || (mode === "show" ? zero : original);
            el.to = o.to || (mode === "hide" ? zero : original);
        }

        // Set scaling factor
        factor = {
            from: {
                y: el.from.height / original.height,
                x: el.from.width / original.width
            },
            to: {
                y: el.to.height / original.height,
                x: el.to.width / original.width
            }
        };

        // Scale the css box
        if (scale === "box" || scale === "both") {

            // Vertical props scaling
            if (factor.from.y !== factor.to.y) {
                props = props.concat(vProps);
                el.from = $.effects.setTransition(el, vProps, factor.from.y, el.from);
                el.to = $.effects.setTransition(el, vProps, factor.to.y, el.to);
            }

            // Horizontal props scaling
            if (factor.from.x !== factor.to.x) {
                props = props.concat(hProps);
                el.from = $.effects.setTransition(el, hProps, factor.from.x, el.from);
                el.to = $.effects.setTransition(el, hProps, factor.to.x, el.to);
            }
        }

        // Scale the content
        if (scale === "content" || scale === "both") {

            // Vertical props scaling
            if (factor.from.y !== factor.to.y) {
                props = props.concat(cProps).concat(props2);
                el.from = $.effects.setTransition(el, cProps, factor.from.y, el.from);
                el.to = $.effects.setTransition(el, cProps, factor.to.y, el.to);
            }
        }

        $.effects.save(el, props);
        el.show();
        $.effects.createWrapper(el);
        el.css("overflow", "hidden").css(el.from);

        // Adjust
        if (origin) { // Calculate baseline shifts
            baseline = $.effects.getBaseline(origin, original);
            el.from.top = (original.outerHeight - el.outerHeight()) * baseline.y;
            el.from.left = (original.outerWidth - el.outerWidth()) * baseline.x;
            el.to.top = (original.outerHeight - el.to.outerHeight) * baseline.y;
            el.to.left = (original.outerWidth - el.to.outerWidth) * baseline.x;
        }
        el.css(el.from); // set top & left

        // Animate
        if (scale === "content" || scale === "both") { // Scale the children

            // Add margins/font-size
            vProps = vProps.concat(["marginTop", "marginBottom"]).concat(cProps);
            hProps = hProps.concat(["marginLeft", "marginRight"]);
            props2 = props0.concat(vProps).concat(hProps);

            el.find("*[width]").each(function () {
                var child = $(this),
                    c_original = {
                        height: child.height(),
                        width: child.width(),
                        outerHeight: child.outerHeight(),
                        outerWidth: child.outerWidth()
                    };
                if (restore) {
                    $.effects.save(child, props2);
                }

                child.from = {
                    height: c_original.height * factor.from.y,
                    width: c_original.width * factor.from.x,
                    outerHeight: c_original.outerHeight * factor.from.y,
                    outerWidth: c_original.outerWidth * factor.from.x
                };
                child.to = {
                    height: c_original.height * factor.to.y,
                    width: c_original.width * factor.to.x,
                    outerHeight: c_original.height * factor.to.y,
                    outerWidth: c_original.width * factor.to.x
                };

                // Vertical props scaling
                if (factor.from.y !== factor.to.y) {
                    child.from = $.effects.setTransition(child, vProps, factor.from.y, child.from);
                    child.to = $.effects.setTransition(child, vProps, factor.to.y, child.to);
                }

                // Horizontal props scaling
                if (factor.from.x !== factor.to.x) {
                    child.from = $.effects.setTransition(child, hProps, factor.from.x, child.from);
                    child.to = $.effects.setTransition(child, hProps, factor.to.x, child.to);
                }

                // Animate children
                child.css(child.from);
                child.animate(child.to, o.duration, o.easing, function () {

                    // Restore children
                    if (restore) {
                        $.effects.restore(child, props2);
                    }
                });
            });
        }

        // Animate
        el.animate(el.to, {
            queue: false,
            duration: o.duration,
            easing: o.easing,
            complete: function () {
                if (el.to.opacity === 0) {
                    el.css("opacity", el.from.opacity);
                }
                if (mode === "hide") {
                    el.hide();
                }
                $.effects.restore(el, props);
                if (!restore) {

                    // we need to calculate our new positioning based on the scaling
                    if (position === "static") {
                        el.css({
                            position: "relative",
                            top: el.to.top,
                            left: el.to.left
                        });
                    } else {
                        $.each(["top", "left"], function (idx, pos) {
                            el.css(pos, function (_, str) {
                                var val = parseInt(str, 10),
                                    toRef = idx ? el.to.left : el.to.top;

                                // if original was "auto", recalculate the new value from wrapper
                                if (str === "auto") {
                                    return toRef + "px";
                                }

                                return val + toRef + "px";
                            });
                        });
                    }
                }

                $.effects.removeWrapper(el);
                done();
            }
        });

    };

})(jQuery);

(function ($, undefined) {

    $.effects.effect.shake = function (o, done) {

        var el = $(this),
            props = ["position", "top", "bottom", "left", "right", "height", "width"],
            mode = $.effects.setMode(el, o.mode || "effect"),
            direction = o.direction || "left",
            distance = o.distance || 20,
            times = o.times || 3,
            anims = times * 2 + 1,
            speed = Math.round(o.duration / anims),
            ref = (direction === "up" || direction === "down") ? "top" : "left",
            positiveMotion = (direction === "up" || direction === "left"),
            animation = {},
            animation1 = {},
            animation2 = {},
            i,

            // we will need to re-assemble the queue to stack our animations in place
            queue = el.queue(),
            queuelen = queue.length;

        $.effects.save(el, props);
        el.show();
        $.effects.createWrapper(el);

        // Animation
        animation[ref] = (positiveMotion ? "-=" : "+=") + distance;
        animation1[ref] = (positiveMotion ? "+=" : "-=") + distance * 2;
        animation2[ref] = (positiveMotion ? "-=" : "+=") + distance * 2;

        // Animate
        el.animate(animation, speed, o.easing);

        // Shakes
        for (i = 1; i < times; i++) {
            el.animate(animation1, speed, o.easing).animate(animation2, speed, o.easing);
        }
        el
            .animate(animation1, speed, o.easing)
            .animate(animation, speed / 2, o.easing)
            .queue(function () {
                if (mode === "hide") {
                    el.hide();
                }
                $.effects.restore(el, props);
                $.effects.removeWrapper(el);
                done();
            });

        // inject all the animations we just queued to be first in line (after "inprogress")
        if (queuelen > 1) {
            queue.splice.apply(queue,
                [1, 0].concat(queue.splice(queuelen, anims + 1)));
        }
        el.dequeue();

    };

})(jQuery);

(function ($, undefined) {

    $.effects.effect.slide = function (o, done) {

        // Create element
        var el = $(this),
            props = ["position", "top", "bottom", "left", "right", "width", "height"],
            mode = $.effects.setMode(el, o.mode || "show"),
            show = mode === "show",
            direction = o.direction || "left",
            ref = (direction === "up" || direction === "down") ? "top" : "left",
            positiveMotion = (direction === "up" || direction === "left"),
            distance,
            animation = {};

        // Adjust
        $.effects.save(el, props);
        el.show();
        distance = o.distance || el[ref === "top" ? "outerHeight" : "outerWidth"](true);

        $.effects.createWrapper(el).css({
            overflow: "hidden"
        });

        if (show) {
            el.css(ref, positiveMotion ? (isNaN(distance) ? "-" + distance : -distance) : distance);
        }

        // Animation
        animation[ref] = (show ?
            (positiveMotion ? "+=" : "-=") :
            (positiveMotion ? "-=" : "+=")) +
            distance;

        // Animate
        el.animate(animation, {
            queue: false,
            duration: o.duration,
            easing: o.easing,
            complete: function () {
                if (mode === "hide") {
                    el.hide();
                }
                $.effects.restore(el, props);
                $.effects.removeWrapper(el);
                done();
            }
        });
    };

})(jQuery);

(function ($, undefined) {

    $.effects.effect.transfer = function (o, done) {
        var elem = $(this),
            target = $(o.to),
            targetFixed = target.css("position") === "fixed",
            body = $("body"),
            fixTop = targetFixed ? body.scrollTop() : 0,
            fixLeft = targetFixed ? body.scrollLeft() : 0,
            endPosition = target.offset(),
            animation = {
                top: endPosition.top - fixTop,
                left: endPosition.left - fixLeft,
                height: target.innerHeight(),
                width: target.innerWidth()
            },
            startPosition = elem.offset(),
            transfer = $("<div class='ui-effects-transfer'></div>")
                .appendTo(document.body)
                .addClass(o.className)
                .css({
                    top: startPosition.top - fixTop,
                    left: startPosition.left - fixLeft,
                    height: elem.innerHeight(),
                    width: elem.innerWidth(),
                    position: targetFixed ? "fixed" : "absolute"
                })
                .animate(animation, o.duration, o.easing, function () {
                    transfer.remove();
                    done();
                });
    };

})(jQuery);

(function ($, undefined) {

    $.widget("ui.menu", {
        version: "1.10.2",
        defaultElement: "<ul>",
        delay: 300,
        options: {
            icons: {
                submenu: "ui-icon-carat-1-e"
            },
            menus: "ul",
            position: {
                my: "left top",
                at: "right top"
            },
            role: "menu",

            // callbacks
            blur: null,
            focus: null,
            select: null
        },

        _create: function () {
            this.activeMenu = this.element;
            // flag used to prevent firing of the click handler
            // as the event bubbles up through nested menus
            this.mouseHandled = false;
            this.element
                .uniqueId()
                .addClass("ui-menu ui-widget ui-widget-content ui-corner-all")
                .toggleClass("ui-menu-icons", !!this.element.find(".ui-icon").length)
                .attr({
                    role: this.options.role,
                    tabIndex: 0
                })
                // need to catch all clicks on disabled menu
                // not possible through _on
                .bind("click" + this.eventNamespace, $.proxy(function (event) {
                    if (this.options.disabled) {
                        event.preventDefault();
                    }
                }, this));

            if (this.options.disabled) {
                this.element
                    .addClass("ui-state-disabled")
                    .attr("aria-disabled", "true");
            }

            this._on({
                // Prevent focus from sticking to links inside menu after clicking
                // them (focus should always stay on UL during navigation).
                "mousedown .ui-menu-item > a": function (event) {
                    event.preventDefault();
                },
                "click .ui-state-disabled > a": function (event) {
                    event.preventDefault();
                },
                "click .ui-menu-item:has(a)": function (event) {
                    var target = $(event.target).closest(".ui-menu-item");
                    if (!this.mouseHandled && target.not(".ui-state-disabled").length) {
                        this.mouseHandled = true;

                        this.select(event);
                        // Open submenu on click
                        if (target.has(".ui-menu").length) {
                            this.expand(event);
                        } else if (!this.element.is(":focus")) {
                            // Redirect focus to the menu
                            this.element.trigger("focus", [true]);

                            // If the active item is on the top level, let it stay active.
                            // Otherwise, blur the active item since it is no longer visible.
                            if (this.active && this.active.parents(".ui-menu").length === 1) {
                                clearTimeout(this.timer);
                            }
                        }
                    }
                },
                "mouseenter .ui-menu-item": function (event) {
                    var target = $(event.currentTarget);
                    // Remove ui-state-active class from siblings of the newly focused menu item
                    // to avoid a jump caused by adjacent elements both having a class with a border
                    target.siblings().children(".ui-state-active").removeClass("ui-state-active");
                    this.focus(event, target);
                },
                mouseleave: "collapseAll",
                "mouseleave .ui-menu": "collapseAll",
                focus: function (event, keepActiveItem) {
                    // If there's already an active item, keep it active
                    // If not, activate the first item
                    var item = this.active || this.element.children(".ui-menu-item").eq(0);

                    if (!keepActiveItem) {
                        this.focus(event, item);
                    }
                },
                blur: function (event) {
                    this._delay(function () {
                        if (!$.contains(this.element[0], this.document[0].activeElement)) {
                            this.collapseAll(event);
                        }
                    });
                },
                keydown: "_keydown"
            });

            this.refresh();

            // Clicks outside of a menu collapse any open menus
            this._on(this.document, {
                click: function (event) {
                    if (!$(event.target).closest(".ui-menu").length) {
                        this.collapseAll(event);
                    }

                    // Reset the mouseHandled flag
                    this.mouseHandled = false;
                }
            });
        },

        _destroy: function () {
            // Destroy (sub)menus
            this.element
                .removeAttr("aria-activedescendant")
                .find(".ui-menu").addBack()
                .removeClass("ui-menu ui-widget ui-widget-content ui-corner-all ui-menu-icons")
                .removeAttr("role")
                .removeAttr("tabIndex")
                .removeAttr("aria-labelledby")
                .removeAttr("aria-expanded")
                .removeAttr("aria-hidden")
                .removeAttr("aria-disabled")
                .removeUniqueId()
                .show();

            // Destroy menu items
            this.element.find(".ui-menu-item")
                .removeClass("ui-menu-item")
                .removeAttr("role")
                .removeAttr("aria-disabled")
                .children("a")
                .removeUniqueId()
                .removeClass("ui-corner-all ui-state-hover")
                .removeAttr("tabIndex")
                .removeAttr("role")
                .removeAttr("aria-haspopup")
                .children().each(function () {
                    var elem = $(this);
                    if (elem.data("ui-menu-submenu-carat")) {
                        elem.remove();
                    }
                });

            // Destroy menu dividers
            this.element.find(".ui-menu-divider").removeClass("ui-menu-divider ui-widget-content");
        },

        _keydown: function (event) {
            /*jshint maxcomplexity:20*/
            var match, prev, character, skip, regex,
                preventDefault = true;

            function escape(value) {
                return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
            }

            switch (event.keyCode) {
                case $.ui.keyCode.PAGE_UP:
                    this.previousPage(event);
                    break;
                case $.ui.keyCode.PAGE_DOWN:
                    this.nextPage(event);
                    break;
                case $.ui.keyCode.HOME:
                    this._move("first", "first", event);
                    break;
                case $.ui.keyCode.END:
                    this._move("last", "last", event);
                    break;
                case $.ui.keyCode.UP:
                    this.previous(event);
                    break;
                case $.ui.keyCode.DOWN:
                    this.next(event);
                    break;
                case $.ui.keyCode.LEFT:
                    this.collapse(event);
                    break;
                case $.ui.keyCode.RIGHT:
                    if (this.active && !this.active.is(".ui-state-disabled")) {
                        this.expand(event);
                    }
                    break;
                case $.ui.keyCode.ENTER:
                case $.ui.keyCode.SPACE:
                    this._activate(event);
                    break;
                case $.ui.keyCode.ESCAPE:
                    this.collapse(event);
                    break;
                default:
                    preventDefault = false;
                    prev = this.previousFilter || "";
                    character = String.fromCharCode(event.keyCode);
                    skip = false;

                    clearTimeout(this.filterTimer);

                    if (character === prev) {
                        skip = true;
                    } else {
                        character = prev + character;
                    }

                    regex = new RegExp("^" + escape(character), "i");
                    match = this.activeMenu.children(".ui-menu-item").filter(function () {
                        return regex.test($(this).children("a").text());
                    });
                    match = skip && match.index(this.active.next()) !== -1 ?
                        this.active.nextAll(".ui-menu-item") :
                        match;

                    // If no matches on the current filter, reset to the last character pressed
                    // to move down the menu to the first item that starts with that character
                    if (!match.length) {
                        character = String.fromCharCode(event.keyCode);
                        regex = new RegExp("^" + escape(character), "i");
                        match = this.activeMenu.children(".ui-menu-item").filter(function () {
                            return regex.test($(this).children("a").text());
                        });
                    }

                    if (match.length) {
                        this.focus(event, match);
                        if (match.length > 1) {
                            this.previousFilter = character;
                            this.filterTimer = this._delay(function () {
                                delete this.previousFilter;
                            }, 1000);
                        } else {
                            delete this.previousFilter;
                        }
                    } else {
                        delete this.previousFilter;
                    }
            }

            if (preventDefault) {
                event.preventDefault();
            }
        },

        _activate: function (event) {
            if (!this.active.is(".ui-state-disabled")) {
                if (this.active.children("a[aria-haspopup='true']").length) {
                    this.expand(event);
                } else {
                    this.select(event);
                }
            }
        },

        refresh: function () {
            var menus,
                icon = this.options.icons.submenu,
                submenus = this.element.find(this.options.menus);

            // Initialize nested menus
            submenus.filter(":not(.ui-menu)")
                .addClass("ui-menu ui-widget ui-widget-content ui-corner-all")
                .hide()
                .attr({
                    role: this.options.role,
                    "aria-hidden": "true",
                    "aria-expanded": "false"
                })
                .each(function () {
                    var menu = $(this),
                        item = menu.prev("a"),
                        submenuCarat = $("<span>")
                            .addClass("ui-menu-icon ui-icon " + icon)
                            .data("ui-menu-submenu-carat", true);

                    item
                        .attr("aria-haspopup", "true")
                        .prepend(submenuCarat);
                    menu.attr("aria-labelledby", item.attr("id"));
                });

            menus = submenus.add(this.element);

            // Don't refresh list items that are already adapted
            menus.children(":not(.ui-menu-item):has(a)")
                .addClass("ui-menu-item")
                .attr("role", "presentation")
                .children("a")
                .uniqueId()
                .addClass("ui-corner-all")
                .attr({
                    tabIndex: -1,
                    role: this._itemRole()
                });

            // Initialize unlinked menu-items containing spaces and/or dashes only as dividers
            menus.children(":not(.ui-menu-item)").each(function () {
                var item = $(this);
                // hyphen, em dash, en dash
                if (!/[^\-\u2014\u2013\s]/.test(item.text())) {
                    item.addClass("ui-widget-content ui-menu-divider");
                }
            });

            // Add aria-disabled attribute to any disabled menu item
            menus.children(".ui-state-disabled").attr("aria-disabled", "true");

            // If the active item has been removed, blur the menu
            if (this.active && !$.contains(this.element[0], this.active[0])) {
                this.blur();
            }
        },

        _itemRole: function () {
            return {
                menu: "menuitem",
                listbox: "option"
            }[this.options.role];
        },

        _setOption: function (key, value) {
            if (key === "icons") {
                this.element.find(".ui-menu-icon")
                    .removeClass(this.options.icons.submenu)
                    .addClass(value.submenu);
            }
            this._super(key, value);
        },

        focus: function (event, item) {
            var nested, focused;
            this.blur(event, event && event.type === "focus");

            this._scrollIntoView(item);

            this.active = item.first();
            focused = this.active.children("a").addClass("ui-state-focus");
            // Only update aria-activedescendant if there's a role
            // otherwise we assume focus is managed elsewhere
            if (this.options.role) {
                this.element.attr("aria-activedescendant", focused.attr("id"));
            }

            // Highlight active parent menu item, if any
            this.active
                .parent()
                .closest(".ui-menu-item")
                .children("a:first")
                .addClass("ui-state-active");

            if (event && event.type === "keydown") {
                this._close();
            } else {
                this.timer = this._delay(function () {
                    this._close();
                }, this.delay);
            }

            nested = item.children(".ui-menu");
            if (nested.length && (/^mouse/.test(event.type))) {
                this._startOpening(nested);
            }
            this.activeMenu = item.parent();

            this._trigger("focus", event, { item: item });
        },

        _scrollIntoView: function (item) {
            var borderTop, paddingTop, offset, scroll, elementHeight, itemHeight;
            if (this._hasScroll()) {
                borderTop = parseFloat($.css(this.activeMenu[0], "borderTopWidth")) || 0;
                paddingTop = parseFloat($.css(this.activeMenu[0], "paddingTop")) || 0;
                offset = item.offset().top - this.activeMenu.offset().top - borderTop - paddingTop;
                scroll = this.activeMenu.scrollTop();
                elementHeight = this.activeMenu.height();
                itemHeight = item.height();

                if (offset < 0) {
                    this.activeMenu.scrollTop(scroll + offset);
                } else if (offset + itemHeight > elementHeight) {
                    this.activeMenu.scrollTop(scroll + offset - elementHeight + itemHeight);
                }
            }
        },

        blur: function (event, fromFocus) {
            if (!fromFocus) {
                clearTimeout(this.timer);
            }

            if (!this.active) {
                return;
            }

            this.active.children("a").removeClass("ui-state-focus");
            this.active = null;

            this._trigger("blur", event, { item: this.active });
        },

        _startOpening: function (submenu) {
            clearTimeout(this.timer);

            // Don't open if already open fixes a Firefox bug that caused a .5 pixel
            // shift in the submenu position when mousing over the carat icon
            if (submenu.attr("aria-hidden") !== "true") {
                return;
            }

            this.timer = this._delay(function () {
                this._close();
                this._open(submenu);
            }, this.delay);
        },

        _open: function (submenu) {
            var position = $.extend({
                of: this.active
            }, this.options.position);

            clearTimeout(this.timer);
            this.element.find(".ui-menu").not(submenu.parents(".ui-menu"))
                .hide()
                .attr("aria-hidden", "true");

            submenu
                .show()
                .removeAttr("aria-hidden")
                .attr("aria-expanded", "true")
                .position(position);
        },

        collapseAll: function (event, all) {
            clearTimeout(this.timer);
            this.timer = this._delay(function () {
                // If we were passed an event, look for the submenu that contains the event
                var currentMenu = all ? this.element :
                    $(event && event.target).closest(this.element.find(".ui-menu"));

                // If we found no valid submenu ancestor, use the main menu to close all sub menus anyway
                if (!currentMenu.length) {
                    currentMenu = this.element;
                }

                this._close(currentMenu);

                this.blur(event);
                this.activeMenu = currentMenu;
            }, this.delay);
        },

        // With no arguments, closes the currently active menu - if nothing is active
        // it closes all menus.  If passed an argument, it will search for menus BELOW
        _close: function (startMenu) {
            if (!startMenu) {
                startMenu = this.active ? this.active.parent() : this.element;
            }

            startMenu
                .find(".ui-menu")
                .hide()
                .attr("aria-hidden", "true")
                .attr("aria-expanded", "false")
                .end()
                .find("a.ui-state-active")
                .removeClass("ui-state-active");
        },

        collapse: function (event) {
            var newItem = this.active &&
                this.active.parent().closest(".ui-menu-item", this.element);
            if (newItem && newItem.length) {
                this._close();
                this.focus(event, newItem);
            }
        },

        expand: function (event) {
            var newItem = this.active &&
                this.active
                    .children(".ui-menu ")
                    .children(".ui-menu-item")
                    .first();

            if (newItem && newItem.length) {
                this._open(newItem.parent());

                // Delay so Firefox will not hide activedescendant change in expanding submenu from AT
                this._delay(function () {
                    this.focus(event, newItem);
                });
            }
        },

        next: function (event) {
            this._move("next", "first", event);
        },

        previous: function (event) {
            this._move("prev", "last", event);
        },

        isFirstItem: function () {
            return this.active && !this.active.prevAll(".ui-menu-item").length;
        },

        isLastItem: function () {
            return this.active && !this.active.nextAll(".ui-menu-item").length;
        },

        _move: function (direction, filter, event) {
            var next;
            if (this.active) {
                if (direction === "first" || direction === "last") {
                    next = this.active
                    [direction === "first" ? "prevAll" : "nextAll"](".ui-menu-item")
                        .eq(-1);
                } else {
                    next = this.active
                    [direction + "All"](".ui-menu-item")
                        .eq(0);
                }
            }
            if (!next || !next.length || !this.active) {
                next = this.activeMenu.children(".ui-menu-item")[filter]();
            }

            this.focus(event, next);
        },

        nextPage: function (event) {
            var item, base, height;

            if (!this.active) {
                this.next(event);
                return;
            }
            if (this.isLastItem()) {
                return;
            }
            if (this._hasScroll()) {
                base = this.active.offset().top;
                height = this.element.height();
                this.active.nextAll(".ui-menu-item").each(function () {
                    item = $(this);
                    return item.offset().top - base - height < 0;
                });

                this.focus(event, item);
            } else {
                this.focus(event, this.activeMenu.children(".ui-menu-item")
                [!this.active ? "first" : "last"]());
            }
        },

        previousPage: function (event) {
            var item, base, height;
            if (!this.active) {
                this.next(event);
                return;
            }
            if (this.isFirstItem()) {
                return;
            }
            if (this._hasScroll()) {
                base = this.active.offset().top;
                height = this.element.height();
                this.active.prevAll(".ui-menu-item").each(function () {
                    item = $(this);
                    return item.offset().top - base + height > 0;
                });

                this.focus(event, item);
            } else {
                this.focus(event, this.activeMenu.children(".ui-menu-item").first());
            }
        },

        _hasScroll: function () {
            return this.element.outerHeight() < this.element.prop("scrollHeight");
        },

        select: function (event) {
            // TODO: It should never be possible to not have an active item at this
            // point, but the tests don't trigger mouseenter before click.
            this.active = this.active || $(event.target).closest(".ui-menu-item");
            var ui = { item: this.active };
            if (!this.active.has(".ui-menu").length) {
                this.collapseAll(event, true);
            }
            this._trigger("select", event, ui);
        }
    });

}(jQuery));

(function ($, undefined) {

    $.ui = $.ui || {};

    var cachedScrollbarWidth,
        max = Math.max,
        abs = Math.abs,
        round = Math.round,
        rhorizontal = /left|center|right/,
        rvertical = /top|center|bottom/,
        roffset = /[\+\-]\d+(\.[\d]+)?%?/,
        rposition = /^\w+/,
        rpercent = /%$/,
        _position = $.fn.position;

    function getOffsets(offsets, width, height) {
        return [
            parseFloat(offsets[0]) * (rpercent.test(offsets[0]) ? width / 100 : 1),
            parseFloat(offsets[1]) * (rpercent.test(offsets[1]) ? height / 100 : 1)
        ];
    }

    function parseCss(element, property) {
        return parseInt($.css(element, property), 10) || 0;
    }

    function getDimensions(elem) {
        var raw = elem[0];
        if (raw.nodeType === 9) {
            return {
                width: elem.width(),
                height: elem.height(),
                offset: { top: 0, left: 0 }
            };
        }
        if ($.isWindow(raw)) {
            return {
                width: elem.width(),
                height: elem.height(),
                offset: { top: elem.scrollTop(), left: elem.scrollLeft() }
            };
        }
        if (raw.preventDefault) {
            return {
                width: 0,
                height: 0,
                offset: { top: raw.pageY, left: raw.pageX }
            };
        }
        return {
            width: elem.outerWidth(),
            height: elem.outerHeight(),
            offset: elem.offset()
        };
    }

    $.position = {
        scrollbarWidth: function () {
            if (cachedScrollbarWidth !== undefined) {
                return cachedScrollbarWidth;
            }
            var w1, w2,
                div = $("<div style='display:block;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>"),
                innerDiv = div.children()[0];

            $("body").append(div);
            w1 = innerDiv.offsetWidth;
            div.css("overflow", "scroll");

            w2 = innerDiv.offsetWidth;

            if (w1 === w2) {
                w2 = div[0].clientWidth;
            }

            div.remove();

            return (cachedScrollbarWidth = w1 - w2);
        },
        getScrollInfo: function (within) {
            var overflowX = within.isWindow ? "" : within.element.css("overflow-x"),
                overflowY = within.isWindow ? "" : within.element.css("overflow-y"),
                hasOverflowX = overflowX === "scroll" ||
                    (overflowX === "auto" && within.width < within.element[0].scrollWidth),
                hasOverflowY = overflowY === "scroll" ||
                    (overflowY === "auto" && within.height < within.element[0].scrollHeight);
            return {
                width: hasOverflowY ? $.position.scrollbarWidth() : 0,
                height: hasOverflowX ? $.position.scrollbarWidth() : 0
            };
        },
        getWithinInfo: function (element) {
            var withinElement = $(element || window),
                isWindow = $.isWindow(withinElement[0]);
            return {
                element: withinElement,
                isWindow: isWindow,
                offset: withinElement.offset() || { left: 0, top: 0 },
                scrollLeft: withinElement.scrollLeft(),
                scrollTop: withinElement.scrollTop(),
                width: isWindow ? withinElement.width() : withinElement.outerWidth(),
                height: isWindow ? withinElement.height() : withinElement.outerHeight()
            };
        }
    };

    $.fn.position = function (options) {
        if (!options || !options.of) {
            return _position.apply(this, arguments);
        }

        // make a copy, we don't want to modify arguments
        options = $.extend({}, options);

        var atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions,
            target = $(options.of),
            within = $.position.getWithinInfo(options.within),
            scrollInfo = $.position.getScrollInfo(within),
            collision = (options.collision || "flip").split(" "),
            offsets = {};

        dimensions = getDimensions(target);
        if (target[0].preventDefault) {
            // force left top to allow flipping
            options.at = "left top";
        }
        targetWidth = dimensions.width;
        targetHeight = dimensions.height;
        targetOffset = dimensions.offset;
        // clone to reuse original targetOffset later
        basePosition = $.extend({}, targetOffset);

        // force my and at to have valid horizontal and vertical positions
        // if a value is missing or invalid, it will be converted to center
        $.each(["my", "at"], function () {
            var pos = (options[this] || "").split(" "),
                horizontalOffset,
                verticalOffset;

            if (pos.length === 1) {
                pos = rhorizontal.test(pos[0]) ?
                    pos.concat(["center"]) :
                    rvertical.test(pos[0]) ?
                        ["center"].concat(pos) :
                        ["center", "center"];
            }
            pos[0] = rhorizontal.test(pos[0]) ? pos[0] : "center";
            pos[1] = rvertical.test(pos[1]) ? pos[1] : "center";

            // calculate offsets
            horizontalOffset = roffset.exec(pos[0]);
            verticalOffset = roffset.exec(pos[1]);
            offsets[this] = [
                horizontalOffset ? horizontalOffset[0] : 0,
                verticalOffset ? verticalOffset[0] : 0
            ];

            // reduce to just the positions without the offsets
            options[this] = [
                rposition.exec(pos[0])[0],
                rposition.exec(pos[1])[0]
            ];
        });

        // normalize collision option
        if (collision.length === 1) {
            collision[1] = collision[0];
        }

        if (options.at[0] === "right") {
            basePosition.left += targetWidth;
        } else if (options.at[0] === "center") {
            basePosition.left += targetWidth / 2;
        }

        if (options.at[1] === "bottom") {
            basePosition.top += targetHeight;
        } else if (options.at[1] === "center") {
            basePosition.top += targetHeight / 2;
        }

        atOffset = getOffsets(offsets.at, targetWidth, targetHeight);
        basePosition.left += atOffset[0];
        basePosition.top += atOffset[1];

        return this.each(function () {
            var collisionPosition, using,
                elem = $(this),
                elemWidth = elem.outerWidth(),
                elemHeight = elem.outerHeight(),
                marginLeft = parseCss(this, "marginLeft"),
                marginTop = parseCss(this, "marginTop"),
                collisionWidth = elemWidth + marginLeft + parseCss(this, "marginRight") + scrollInfo.width,
                collisionHeight = elemHeight + marginTop + parseCss(this, "marginBottom") + scrollInfo.height,
                position = $.extend({}, basePosition),
                myOffset = getOffsets(offsets.my, elem.outerWidth(), elem.outerHeight());

            if (options.my[0] === "right") {
                position.left -= elemWidth;
            } else if (options.my[0] === "center") {
                position.left -= elemWidth / 2;
            }

            if (options.my[1] === "bottom") {
                position.top -= elemHeight;
            } else if (options.my[1] === "center") {
                position.top -= elemHeight / 2;
            }

            position.left += myOffset[0];
            position.top += myOffset[1];

            // if the browser doesn't support fractions, then round for consistent results
            if (!$.support.offsetFractions) {
                position.left = round(position.left);
                position.top = round(position.top);
            }

            collisionPosition = {
                marginLeft: marginLeft,
                marginTop: marginTop
            };

            $.each(["left", "top"], function (i, dir) {
                if ($.ui.position[collision[i]]) {
                    $.ui.position[collision[i]][dir](position, {
                        targetWidth: targetWidth,
                        targetHeight: targetHeight,
                        elemWidth: elemWidth,
                        elemHeight: elemHeight,
                        collisionPosition: collisionPosition,
                        collisionWidth: collisionWidth,
                        collisionHeight: collisionHeight,
                        offset: [atOffset[0] + myOffset[0], atOffset[1] + myOffset[1]],
                        my: options.my,
                        at: options.at,
                        within: within,
                        elem: elem
                    });
                }
            });

            if (options.using) {
                // adds feedback as second argument to using callback, if present
                using = function (props) {
                    var left = targetOffset.left - position.left,
                        right = left + targetWidth - elemWidth,
                        top = targetOffset.top - position.top,
                        bottom = top + targetHeight - elemHeight,
                        feedback = {
                            target: {
                                element: target,
                                left: targetOffset.left,
                                top: targetOffset.top,
                                width: targetWidth,
                                height: targetHeight
                            },
                            element: {
                                element: elem,
                                left: position.left,
                                top: position.top,
                                width: elemWidth,
                                height: elemHeight
                            },
                            horizontal: right < 0 ? "left" : left > 0 ? "right" : "center",
                            vertical: bottom < 0 ? "top" : top > 0 ? "bottom" : "middle"
                        };
                    if (targetWidth < elemWidth && abs(left + right) < targetWidth) {
                        feedback.horizontal = "center";
                    }
                    if (targetHeight < elemHeight && abs(top + bottom) < targetHeight) {
                        feedback.vertical = "middle";
                    }
                    if (max(abs(left), abs(right)) > max(abs(top), abs(bottom))) {
                        feedback.important = "horizontal";
                    } else {
                        feedback.important = "vertical";
                    }
                    options.using.call(this, props, feedback);
                };
            }

            elem.offset($.extend(position, { using: using }));
        });
    };

    $.ui.position = {
        fit: {
            left: function (position, data) {
                var within = data.within,
                    withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,
                    outerWidth = within.width,
                    collisionPosLeft = position.left - data.collisionPosition.marginLeft,
                    overLeft = withinOffset - collisionPosLeft,
                    overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,
                    newOverRight;

                // element is wider than within
                if (data.collisionWidth > outerWidth) {
                    // element is initially over the left side of within
                    if (overLeft > 0 && overRight <= 0) {
                        newOverRight = position.left + overLeft + data.collisionWidth - outerWidth - withinOffset;
                        position.left += overLeft - newOverRight;
                        // element is initially over right side of within
                    } else if (overRight > 0 && overLeft <= 0) {
                        position.left = withinOffset;
                        // element is initially over both left and right sides of within
                    } else {
                        if (overLeft > overRight) {
                            position.left = withinOffset + outerWidth - data.collisionWidth;
                        } else {
                            position.left = withinOffset;
                        }
                    }
                    // too far left -> align with left edge
                } else if (overLeft > 0) {
                    position.left += overLeft;
                    // too far right -> align with right edge
                } else if (overRight > 0) {
                    position.left -= overRight;
                    // adjust based on position and margin
                } else {
                    position.left = max(position.left - collisionPosLeft, position.left);
                }
            },
            top: function (position, data) {
                var within = data.within,
                    withinOffset = within.isWindow ? within.scrollTop : within.offset.top,
                    outerHeight = data.within.height,
                    collisionPosTop = position.top - data.collisionPosition.marginTop,
                    overTop = withinOffset - collisionPosTop,
                    overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,
                    newOverBottom;

                // element is taller than within
                if (data.collisionHeight > outerHeight) {
                    // element is initially over the top of within
                    if (overTop > 0 && overBottom <= 0) {
                        newOverBottom = position.top + overTop + data.collisionHeight - outerHeight - withinOffset;
                        position.top += overTop - newOverBottom;
                        // element is initially over bottom of within
                    } else if (overBottom > 0 && overTop <= 0) {
                        position.top = withinOffset;
                        // element is initially over both top and bottom of within
                    } else {
                        if (overTop > overBottom) {
                            position.top = withinOffset + outerHeight - data.collisionHeight;
                        } else {
                            position.top = withinOffset;
                        }
                    }
                    // too far up -> align with top
                } else if (overTop > 0) {
                    position.top += overTop;
                    // too far down -> align with bottom edge
                } else if (overBottom > 0) {
                    position.top -= overBottom;
                    // adjust based on position and margin
                } else {
                    position.top = max(position.top - collisionPosTop, position.top);
                }
            }
        },
        flip: {
            left: function (position, data) {
                var within = data.within,
                    withinOffset = within.offset.left + within.scrollLeft,
                    outerWidth = within.width,
                    offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,
                    collisionPosLeft = position.left - data.collisionPosition.marginLeft,
                    overLeft = collisionPosLeft - offsetLeft,
                    overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,
                    myOffset = data.my[0] === "left" ?
                        -data.elemWidth :
                        data.my[0] === "right" ?
                            data.elemWidth :
                            0,
                    atOffset = data.at[0] === "left" ?
                        data.targetWidth :
                        data.at[0] === "right" ?
                            -data.targetWidth :
                            0,
                    offset = -2 * data.offset[0],
                    newOverRight,
                    newOverLeft;

                if (overLeft < 0) {
                    newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth - outerWidth - withinOffset;
                    if (newOverRight < 0 || newOverRight < abs(overLeft)) {
                        position.left += myOffset + atOffset + offset;
                    }
                }
                else if (overRight > 0) {
                    newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset + atOffset + offset - offsetLeft;
                    if (newOverLeft > 0 || abs(newOverLeft) < overRight) {
                        position.left += myOffset + atOffset + offset;
                    }
                }
            },
            top: function (position, data) {
                var within = data.within,
                    withinOffset = within.offset.top + within.scrollTop,
                    outerHeight = within.height,
                    offsetTop = within.isWindow ? within.scrollTop : within.offset.top,
                    collisionPosTop = position.top - data.collisionPosition.marginTop,
                    overTop = collisionPosTop - offsetTop,
                    overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,
                    top = data.my[1] === "top",
                    myOffset = top ?
                        -data.elemHeight :
                        data.my[1] === "bottom" ?
                            data.elemHeight :
                            0,
                    atOffset = data.at[1] === "top" ?
                        data.targetHeight :
                        data.at[1] === "bottom" ?
                            -data.targetHeight :
                            0,
                    offset = -2 * data.offset[1],
                    newOverTop,
                    newOverBottom;
                if (overTop < 0) {
                    newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight - outerHeight - withinOffset;
                    if ((position.top + myOffset + atOffset + offset) > overTop && (newOverBottom < 0 || newOverBottom < abs(overTop))) {
                        position.top += myOffset + atOffset + offset;
                    }
                }
                else if (overBottom > 0) {
                    newOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset + offset - offsetTop;
                    if ((position.top + myOffset + atOffset + offset) > overBottom && (newOverTop > 0 || abs(newOverTop) < overBottom)) {
                        position.top += myOffset + atOffset + offset;
                    }
                }
            }
        },
        flipfit: {
            left: function () {
                $.ui.position.flip.left.apply(this, arguments);
                $.ui.position.fit.left.apply(this, arguments);
            },
            top: function () {
                $.ui.position.flip.top.apply(this, arguments);
                $.ui.position.fit.top.apply(this, arguments);
            }
        }
    };

    // fraction support test
    (function () {
        var testElement, testElementParent, testElementStyle, offsetLeft, i,
            body = document.getElementsByTagName("body")[0],
            div = document.createElement("div");

        //Create a "fake body" for testing based on method used in jQuery.support
        testElement = document.createElement(body ? "div" : "body");
        testElementStyle = {
            visibility: "hidden",
            width: 0,
            height: 0,
            border: 0,
            margin: 0,
            background: "none"
        };
        if (body) {
            $.extend(testElementStyle, {
                position: "absolute",
                left: "-1000px",
                top: "-1000px"
            });
        }
        for (i in testElementStyle) {
            testElement.style[i] = testElementStyle[i];
        }
        testElement.appendChild(div);
        testElementParent = body || document.documentElement;
        testElementParent.insertBefore(testElement, testElementParent.firstChild);

        div.style.cssText = "position: absolute; left: 10.7432222px;";

        offsetLeft = $(div).offset().left;
        $.support.offsetFractions = offsetLeft > 10 && offsetLeft < 11;

        testElement.innerHTML = "";
        testElementParent.removeChild(testElement);
    })();

}(jQuery));

(function ($, undefined) {

    $.widget("ui.progressbar", {
        version: "1.10.2",
        options: {
            max: 100,
            value: 0,

            change: null,
            complete: null
        },

        min: 0,

        _create: function () {
            // Constrain initial value
            this.oldValue = this.options.value = this._constrainedValue();

            this.element
                .addClass("ui-progressbar ui-widget ui-widget-content ui-corner-all")
                .attr({
                    // Only set static values, aria-valuenow and aria-valuemax are
                    // set inside _refreshValue()
                    role: "progressbar",
                    "aria-valuemin": this.min
                });

            this.valueDiv = $("<div class='ui-progressbar-value ui-widget-header ui-corner-left'></div>")
                .appendTo(this.element);

            this._refreshValue();
        },

        _destroy: function () {
            this.element
                .removeClass("ui-progressbar ui-widget ui-widget-content ui-corner-all")
                .removeAttr("role")
                .removeAttr("aria-valuemin")
                .removeAttr("aria-valuemax")
                .removeAttr("aria-valuenow");

            this.valueDiv.remove();
        },

        value: function (newValue) {
            if (newValue === undefined) {
                return this.options.value;
            }

            this.options.value = this._constrainedValue(newValue);
            this._refreshValue();
        },

        _constrainedValue: function (newValue) {
            if (newValue === undefined) {
                newValue = this.options.value;
            }

            this.indeterminate = newValue === false;

            // sanitize value
            if (typeof newValue !== "number") {
                newValue = 0;
            }

            return this.indeterminate ? false :
                Math.min(this.options.max, Math.max(this.min, newValue));
        },

        _setOptions: function (options) {
            // Ensure "value" option is set after other values (like max)
            var value = options.value;
            delete options.value;

            this._super(options);

            this.options.value = this._constrainedValue(value);
            this._refreshValue();
        },

        _setOption: function (key, value) {
            if (key === "max") {
                // Don't allow a max less than min
                value = Math.max(this.min, value);
            }

            this._super(key, value);
        },

        _percentage: function () {
            return this.indeterminate ? 100 : 100 * (this.options.value - this.min) / (this.options.max - this.min);
        },

        _refreshValue: function () {
            var value = this.options.value,
                percentage = this._percentage();

            this.valueDiv
                .toggle(this.indeterminate || value > this.min)
                .toggleClass("ui-corner-right", value === this.options.max)
                .width(percentage.toFixed(0) + "%");

            this.element.toggleClass("ui-progressbar-indeterminate", this.indeterminate);

            if (this.indeterminate) {
                this.element.removeAttr("aria-valuenow");
                if (!this.overlayDiv) {
                    this.overlayDiv = $("<div class='ui-progressbar-overlay'></div>").appendTo(this.valueDiv);
                }
            } else {
                this.element.attr({
                    "aria-valuemax": this.options.max,
                    "aria-valuenow": value
                });
                if (this.overlayDiv) {
                    this.overlayDiv.remove();
                    this.overlayDiv = null;
                }
            }

            if (this.oldValue !== value) {
                this.oldValue = value;
                this._trigger("change");
            }
            if (value === this.options.max) {
                this._trigger("complete");
            }
        }
    });

})(jQuery);

(function ($, undefined) {

    // number of pages in a slider
    // (how many times can you page up/down to go through the whole range)
    var numPages = 5;

    $.widget("ui.slider", $.ui.mouse, {
        version: "1.10.2",
        widgetEventPrefix: "slide",

        options: {
            animate: false,
            distance: 0,
            max: 100,
            min: 0,
            orientation: "horizontal",
            range: false,
            step: 1,
            value: 0,
            values: null,

            // callbacks
            change: null,
            slide: null,
            start: null,
            stop: null
        },

        _create: function () {
            this._keySliding = false;
            this._mouseSliding = false;
            this._animateOff = true;
            this._handleIndex = null;
            this._detectOrientation();
            this._mouseInit();

            this.element
                .addClass("ui-slider" +
                " ui-slider-" + this.orientation +
                " ui-widget" +
                " ui-widget-content" +
                " ui-corner-all");

            this._refresh();
            this._setOption("disabled", this.options.disabled);

            this._animateOff = false;
        },

        _refresh: function () {
            this._createRange();
            this._createHandles();
            this._setupEvents();
            this._refreshValue();
        },

        _createHandles: function () {
            var i, handleCount,
                options = this.options,
                existingHandles = this.element.find(".ui-slider-handle").addClass("ui-state-default ui-corner-all"),
                handle = "<a class='ui-slider-handle ui-state-default ui-corner-all' href='#'></a>",
                handles = [];

            handleCount = (options.values && options.values.length) || 1;

            if (existingHandles.length > handleCount) {
                existingHandles.slice(handleCount).remove();
                existingHandles = existingHandles.slice(0, handleCount);
            }

            for (i = existingHandles.length; i < handleCount; i++) {
                handles.push(handle);
            }

            this.handles = existingHandles.add($(handles.join("")).appendTo(this.element));

            this.handle = this.handles.eq(0);

            this.handles.each(function (i) {
                $(this).data("ui-slider-handle-index", i);
            });
        },

        _createRange: function () {
            var options = this.options,
                classes = "";

            if (options.range) {
                if (options.range === true) {
                    if (!options.values) {
                        options.values = [this._valueMin(), this._valueMin()];
                    } else if (options.values.length && options.values.length !== 2) {
                        options.values = [options.values[0], options.values[0]];
                    } else if ($.isArray(options.values)) {
                        options.values = options.values.slice(0);
                    }
                }

                if (!this.range || !this.range.length) {
                    this.range = $("<div></div>")
                        .appendTo(this.element);

                    classes = "ui-slider-range" +
                        // note: this isn't the most fittingly semantic framework class for this element,
                        // but worked best visually with a variety of themes
                        " ui-widget-header ui-corner-all";
                } else {
                    this.range.removeClass("ui-slider-range-min ui-slider-range-max")
                        // Handle range switching from true to min/max
                        .css({
                            "left": "",
                            "bottom": ""
                        });
                }

                this.range.addClass(classes +
                    ((options.range === "min" || options.range === "max") ? " ui-slider-range-" + options.range : ""));
            } else {
                this.range = $([]);
            }
        },

        _setupEvents: function () {
            var elements = this.handles.add(this.range).filter("a");
            this._off(elements);
            this._on(elements, this._handleEvents);
            this._hoverable(elements);
            this._focusable(elements);
        },

        _destroy: function () {
            this.handles.remove();
            this.range.remove();

            this.element
                .removeClass("ui-slider" +
                " ui-slider-horizontal" +
                " ui-slider-vertical" +
                " ui-widget" +
                " ui-widget-content" +
                " ui-corner-all");

            this._mouseDestroy();
        },

        _mouseCapture: function (event) {
            var position, normValue, distance, closestHandle, index, allowed, offset, mouseOverHandle,
                that = this,
                o = this.options;

            if (o.disabled) {
                return false;
            }

            this.elementSize = {
                width: this.element.outerWidth(),
                height: this.element.outerHeight()
            };
            this.elementOffset = this.element.offset();

            position = { x: event.pageX, y: event.pageY };
            normValue = this._normValueFromMouse(position);
            distance = this._valueMax() - this._valueMin() + 1;
            this.handles.each(function (i) {
                var thisDistance = Math.abs(normValue - that.values(i));
                if ((distance > thisDistance) ||
                    (distance === thisDistance &&
                        (i === that._lastChangedValue || that.values(i) === o.min))) {
                    distance = thisDistance;
                    closestHandle = $(this);
                    index = i;
                }
            });

            allowed = this._start(event, index);
            if (allowed === false) {
                return false;
            }
            this._mouseSliding = true;

            this._handleIndex = index;

            closestHandle
                .addClass("ui-state-active")
                .focus();

            offset = closestHandle.offset();
            mouseOverHandle = !$(event.target).parents().addBack().is(".ui-slider-handle");
            this._clickOffset = mouseOverHandle ? { left: 0, top: 0 } : {
                left: event.pageX - offset.left - (closestHandle.width() / 2),
                top: event.pageY - offset.top -
                    (closestHandle.height() / 2) -
                    (parseInt(closestHandle.css("borderTopWidth"), 10) || 0) -
                    (parseInt(closestHandle.css("borderBottomWidth"), 10) || 0) +
                    (parseInt(closestHandle.css("marginTop"), 10) || 0)
            };

            if (!this.handles.hasClass("ui-state-hover")) {
                this._slide(event, index, normValue);
            }
            this._animateOff = true;
            return true;
        },

        _mouseStart: function () {
            return true;
        },

        _mouseDrag: function (event) {
            var position = { x: event.pageX, y: event.pageY },
                normValue = this._normValueFromMouse(position);

            this._slide(event, this._handleIndex, normValue);

            return false;
        },

        _mouseStop: function (event) {
            this.handles.removeClass("ui-state-active");
            this._mouseSliding = false;

            this._stop(event, this._handleIndex);
            this._change(event, this._handleIndex);

            this._handleIndex = null;
            this._clickOffset = null;
            this._animateOff = false;

            return false;
        },

        _detectOrientation: function () {
            this.orientation = (this.options.orientation === "vertical") ? "vertical" : "horizontal";
        },

        _normValueFromMouse: function (position) {
            var pixelTotal,
                pixelMouse,
                percentMouse,
                valueTotal,
                valueMouse;

            if (this.orientation === "horizontal") {
                pixelTotal = this.elementSize.width;
                pixelMouse = position.x - this.elementOffset.left - (this._clickOffset ? this._clickOffset.left : 0);
            } else {
                pixelTotal = this.elementSize.height;
                pixelMouse = position.y - this.elementOffset.top - (this._clickOffset ? this._clickOffset.top : 0);
            }

            percentMouse = (pixelMouse / pixelTotal);
            if (percentMouse > 1) {
                percentMouse = 1;
            }
            if (percentMouse < 0) {
                percentMouse = 0;
            }
            if (this.orientation === "vertical") {
                percentMouse = 1 - percentMouse;
            }

            valueTotal = this._valueMax() - this._valueMin();
            valueMouse = this._valueMin() + percentMouse * valueTotal;

            return this._trimAlignValue(valueMouse);
        },

        _start: function (event, index) {
            var uiHash = {
                handle: this.handles[index],
                value: this.value()
            };
            if (this.options.values && this.options.values.length) {
                uiHash.value = this.values(index);
                uiHash.values = this.values();
            }
            return this._trigger("start", event, uiHash);
        },

        _slide: function (event, index, newVal) {
            var otherVal,
                newValues,
                allowed;

            if (this.options.values && this.options.values.length) {
                otherVal = this.values(index ? 0 : 1);

                if ((this.options.values.length === 2 && this.options.range === true) &&
                    ((index === 0 && newVal > otherVal) || (index === 1 && newVal < otherVal))
                ) {
                    newVal = otherVal;
                }

                if (newVal !== this.values(index)) {
                    newValues = this.values();
                    newValues[index] = newVal;
                    // A slide can be canceled by returning false from the slide callback
                    allowed = this._trigger("slide", event, {
                        handle: this.handles[index],
                        value: newVal,
                        values: newValues
                    });
                    otherVal = this.values(index ? 0 : 1);
                    if (allowed !== false) {
                        this.values(index, newVal, true);
                    }
                }
            } else {
                if (newVal !== this.value()) {
                    // A slide can be canceled by returning false from the slide callback
                    allowed = this._trigger("slide", event, {
                        handle: this.handles[index],
                        value: newVal
                    });
                    if (allowed !== false) {
                        this.value(newVal);
                    }
                }
            }
        },

        _stop: function (event, index) {
            var uiHash = {
                handle: this.handles[index],
                value: this.value()
            };
            if (this.options.values && this.options.values.length) {
                uiHash.value = this.values(index);
                uiHash.values = this.values();
            }

            this._trigger("stop", event, uiHash);
        },

        _change: function (event, index) {
            if (!this._keySliding && !this._mouseSliding) {
                var uiHash = {
                    handle: this.handles[index],
                    value: this.value()
                };
                if (this.options.values && this.options.values.length) {
                    uiHash.value = this.values(index);
                    uiHash.values = this.values();
                }

                //store the last changed value index for reference when handles overlap
                this._lastChangedValue = index;

                this._trigger("change", event, uiHash);
            }
        },

        value: function (newValue) {
            if (arguments.length) {
                this.options.value = this._trimAlignValue(newValue);
                this._refreshValue();
                this._change(null, 0);
                return;
            }

            return this._value();
        },

        values: function (index, newValue) {
            var vals,
                newValues,
                i;

            if (arguments.length > 1) {
                this.options.values[index] = this._trimAlignValue(newValue);
                this._refreshValue();
                this._change(null, index);
                return;
            }

            if (arguments.length) {
                if ($.isArray(arguments[0])) {
                    vals = this.options.values;
                    newValues = arguments[0];
                    for (i = 0; i < vals.length; i += 1) {
                        vals[i] = this._trimAlignValue(newValues[i]);
                        this._change(null, i);
                    }
                    this._refreshValue();
                } else {
                    if (this.options.values && this.options.values.length) {
                        return this._values(index);
                    } else {
                        return this.value();
                    }
                }
            } else {
                return this._values();
            }
        },

        _setOption: function (key, value) {
            var i,
                valsLength = 0;

            if (key === "range" && this.options.range === true) {
                if (value === "min") {
                    this.options.value = this._values(0);
                    this.options.values = null;
                } else if (value === "max") {
                    this.options.value = this._values(this.options.values.length - 1);
                    this.options.values = null;
                }
            }

            if ($.isArray(this.options.values)) {
                valsLength = this.options.values.length;
            }

            $.Widget.prototype._setOption.apply(this, arguments);

            switch (key) {
                case "orientation":
                    this._detectOrientation();
                    this.element
                        .removeClass("ui-slider-horizontal ui-slider-vertical")
                        .addClass("ui-slider-" + this.orientation);
                    this._refreshValue();
                    break;
                case "value":
                    this._animateOff = true;
                    this._refreshValue();
                    this._change(null, 0);
                    this._animateOff = false;
                    break;
                case "values":
                    this._animateOff = true;
                    this._refreshValue();
                    for (i = 0; i < valsLength; i += 1) {
                        this._change(null, i);
                    }
                    this._animateOff = false;
                    break;
                case "min":
                case "max":
                    this._animateOff = true;
                    this._refreshValue();
                    this._animateOff = false;
                    break;
                case "range":
                    this._animateOff = true;
                    this._refresh();
                    this._animateOff = false;
                    break;
            }
        },

        //internal value getter
        // _value() returns value trimmed by min and max, aligned by step
        _value: function () {
            var val = this.options.value;
            val = this._trimAlignValue(val);

            return val;
        },

        //internal values getter
        // _values() returns array of values trimmed by min and max, aligned by step
        // _values( index ) returns single value trimmed by min and max, aligned by step
        _values: function (index) {
            var val,
                vals,
                i;

            if (arguments.length) {
                val = this.options.values[index];
                val = this._trimAlignValue(val);

                return val;
            } else if (this.options.values && this.options.values.length) {
                // .slice() creates a copy of the array
                // this copy gets trimmed by min and max and then returned
                vals = this.options.values.slice();
                for (i = 0; i < vals.length; i += 1) {
                    vals[i] = this._trimAlignValue(vals[i]);
                }

                return vals;
            } else {
                return [];
            }
        },

        // returns the step-aligned value that val is closest to, between (inclusive) min and max
        _trimAlignValue: function (val) {
            if (val <= this._valueMin()) {
                return this._valueMin();
            }
            if (val >= this._valueMax()) {
                return this._valueMax();
            }
            var step = (this.options.step > 0) ? this.options.step : 1,
                valModStep = (val - this._valueMin()) % step,
                alignValue = val - valModStep;

            if (Math.abs(valModStep) * 2 >= step) {
                alignValue += (valModStep > 0) ? step : (-step);
            }

            // Since JavaScript has problems with large floats, round
            // the final value to 5 digits after the decimal point (see #4124)
            return parseFloat(alignValue.toFixed(5));
        },

        _valueMin: function () {
            return this.options.min;
        },

        _valueMax: function () {
            return this.options.max;
        },

        _refreshValue: function () {
            var lastValPercent, valPercent, value, valueMin, valueMax,
                oRange = this.options.range,
                o = this.options,
                that = this,
                animate = (!this._animateOff) ? o.animate : false,
                _set = {};

            if (this.options.values && this.options.values.length) {
                this.handles.each(function (i) {
                    valPercent = (that.values(i) - that._valueMin()) / (that._valueMax() - that._valueMin()) * 100;
                    _set[that.orientation === "horizontal" ? "left" : "bottom"] = valPercent + "%";
                    $(this).stop(1, 1)[animate ? "animate" : "css"](_set, o.animate);
                    if (that.options.range === true) {
                        if (that.orientation === "horizontal") {
                            if (i === 0) {
                                that.range.stop(1, 1)[animate ? "animate" : "css"]({ left: valPercent + "%" }, o.animate);
                            }
                            if (i === 1) {
                                that.range[animate ? "animate" : "css"]({ width: (valPercent - lastValPercent) + "%" }, { queue: false, duration: o.animate });
                            }
                        } else {
                            if (i === 0) {
                                that.range.stop(1, 1)[animate ? "animate" : "css"]({ bottom: (valPercent) + "%" }, o.animate);
                            }
                            if (i === 1) {
                                that.range[animate ? "animate" : "css"]({ height: (valPercent - lastValPercent) + "%" }, { queue: false, duration: o.animate });
                            }
                        }
                    }
                    lastValPercent = valPercent;
                });
            } else {
                value = this.value();
                valueMin = this._valueMin();
                valueMax = this._valueMax();
                valPercent = (valueMax !== valueMin) ?
                    (value - valueMin) / (valueMax - valueMin) * 100 :
                    0;
                _set[this.orientation === "horizontal" ? "left" : "bottom"] = valPercent + "%";
                this.handle.stop(1, 1)[animate ? "animate" : "css"](_set, o.animate);

                if (oRange === "min" && this.orientation === "horizontal") {
                    this.range.stop(1, 1)[animate ? "animate" : "css"]({ width: valPercent + "%" }, o.animate);
                }
                if (oRange === "max" && this.orientation === "horizontal") {
                    this.range[animate ? "animate" : "css"]({ width: (100 - valPercent) + "%" }, { queue: false, duration: o.animate });
                }
                if (oRange === "min" && this.orientation === "vertical") {
                    this.range.stop(1, 1)[animate ? "animate" : "css"]({ height: valPercent + "%" }, o.animate);
                }
                if (oRange === "max" && this.orientation === "vertical") {
                    this.range[animate ? "animate" : "css"]({ height: (100 - valPercent) + "%" }, { queue: false, duration: o.animate });
                }
            }
        },

        _handleEvents: {
            keydown: function (event) {
                /*jshint maxcomplexity:25*/
                var allowed, curVal, newVal, step,
                    index = $(event.target).data("ui-slider-handle-index");

                switch (event.keyCode) {
                    case $.ui.keyCode.HOME:
                    case $.ui.keyCode.END:
                    case $.ui.keyCode.PAGE_UP:
                    case $.ui.keyCode.PAGE_DOWN:
                    case $.ui.keyCode.UP:
                    case $.ui.keyCode.RIGHT:
                    case $.ui.keyCode.DOWN:
                    case $.ui.keyCode.LEFT:
                        event.preventDefault();
                        if (!this._keySliding) {
                            this._keySliding = true;
                            $(event.target).addClass("ui-state-active");
                            allowed = this._start(event, index);
                            if (allowed === false) {
                                return;
                            }
                        }
                        break;
                }

                step = this.options.step;
                if (this.options.values && this.options.values.length) {
                    curVal = newVal = this.values(index);
                } else {
                    curVal = newVal = this.value();
                }

                switch (event.keyCode) {
                    case $.ui.keyCode.HOME:
                        newVal = this._valueMin();
                        break;
                    case $.ui.keyCode.END:
                        newVal = this._valueMax();
                        break;
                    case $.ui.keyCode.PAGE_UP:
                        newVal = this._trimAlignValue(curVal + ((this._valueMax() - this._valueMin()) / numPages));
                        break;
                    case $.ui.keyCode.PAGE_DOWN:
                        newVal = this._trimAlignValue(curVal - ((this._valueMax() - this._valueMin()) / numPages));
                        break;
                    case $.ui.keyCode.UP:
                    case $.ui.keyCode.RIGHT:
                        if (curVal === this._valueMax()) {
                            return;
                        }
                        newVal = this._trimAlignValue(curVal + step);
                        break;
                    case $.ui.keyCode.DOWN:
                    case $.ui.keyCode.LEFT:
                        if (curVal === this._valueMin()) {
                            return;
                        }
                        newVal = this._trimAlignValue(curVal - step);
                        break;
                }

                this._slide(event, index, newVal);
            },
            click: function (event) {
                event.preventDefault();
            },
            keyup: function (event) {
                var index = $(event.target).data("ui-slider-handle-index");

                if (this._keySliding) {
                    this._keySliding = false;
                    this._stop(event, index);
                    this._change(event, index);
                    $(event.target).removeClass("ui-state-active");
                }
            }
        }

    });

}(jQuery));

(function ($) {

    function modifier(fn) {
        return function () {
            var previous = this.element.val();
            fn.apply(this, arguments);
            this._refresh();
            if (previous !== this.element.val()) {
                this._trigger("change");
            }
        };
    }

    $.widget("ui.spinner", {
        version: "1.10.2",
        defaultElement: "<input>",
        widgetEventPrefix: "spin",
        options: {
            culture: null,
            icons: {
                down: "ui-icon-triangle-1-s",
                up: "ui-icon-triangle-1-n"
            },
            incremental: true,
            max: null,
            min: null,
            numberFormat: null,
            page: 10,
            step: 1,

            change: null,
            spin: null,
            start: null,
            stop: null
        },

        _create: function () {
            // handle string values that need to be parsed
            this._setOption("max", this.options.max);
            this._setOption("min", this.options.min);
            this._setOption("step", this.options.step);

            // format the value, but don't constrain
            this._value(this.element.val(), true);

            this._draw();
            this._on(this._events);
            this._refresh();

            // turning off autocomplete prevents the browser from remembering the
            // value when navigating through history, so we re-enable autocomplete
            // if the page is unloaded before the widget is destroyed. #7790
            this._on(this.window, {
                beforeunload: function () {
                    this.element.removeAttr("autocomplete");
                }
            });
        },

        _getCreateOptions: function () {
            var options = {},
                element = this.element;

            $.each(["min", "max", "step"], function (i, option) {
                var value = element.attr(option);
                if (value !== undefined && value.length) {
                    options[option] = value;
                }
            });

            return options;
        },

        _events: {
            keydown: function (event) {
                if (this._start(event) && this._keydown(event)) {
                    event.preventDefault();
                }
            },
            keyup: "_stop",
            focus: function () {
                this.previous = this.element.val();
            },
            blur: function (event) {
                if (this.cancelBlur) {
                    delete this.cancelBlur;
                    return;
                }

                this._stop();
                this._refresh();
                if (this.previous !== this.element.val()) {
                    this._trigger("change", event);
                }
            },
            mousewheel: function (event, delta) {
                if (!delta) {
                    return;
                }
                if (!this.spinning && !this._start(event)) {
                    return false;
                }

                this._spin((delta > 0 ? 1 : -1) * this.options.step, event);
                clearTimeout(this.mousewheelTimer);
                this.mousewheelTimer = this._delay(function () {
                    if (this.spinning) {
                        this._stop(event);
                    }
                }, 100);
                event.preventDefault();
            },
            "mousedown .ui-spinner-button": function (event) {
                var previous;

                // We never want the buttons to have focus; whenever the user is
                // interacting with the spinner, the focus should be on the input.
                // If the input is focused then this.previous is properly set from
                // when the input first received focus. If the input is not focused
                // then we need to set this.previous based on the value before spinning.
                previous = this.element[0] === this.document[0].activeElement ?
                    this.previous : this.element.val();
                function checkFocus() {
                    var isActive = this.element[0] === this.document[0].activeElement;
                    if (!isActive) {
                        this.element.focus();
                        this.previous = previous;
                        // support: IE
                        // IE sets focus asynchronously, so we need to check if focus
                        // moved off of the input because the user clicked on the button.
                        this._delay(function () {
                            this.previous = previous;
                        });
                    }
                }

                // ensure focus is on (or stays on) the text field
                event.preventDefault();
                checkFocus.call(this);

                // support: IE
                // IE doesn't prevent moving focus even with event.preventDefault()
                // so we set a flag to know when we should ignore the blur event
                // and check (again) if focus moved off of the input.
                this.cancelBlur = true;
                this._delay(function () {
                    delete this.cancelBlur;
                    checkFocus.call(this);
                });

                if (this._start(event) === false) {
                    return;
                }

                this._repeat(null, $(event.currentTarget).hasClass("ui-spinner-up") ? 1 : -1, event);
            },
            "mouseup .ui-spinner-button": "_stop",
            "mouseenter .ui-spinner-button": function (event) {
                // button will add ui-state-active if mouse was down while mouseleave and kept down
                if (!$(event.currentTarget).hasClass("ui-state-active")) {
                    return;
                }

                if (this._start(event) === false) {
                    return false;
                }
                this._repeat(null, $(event.currentTarget).hasClass("ui-spinner-up") ? 1 : -1, event);
            },
            // TODO: do we really want to consider this a stop?
            // shouldn't we just stop the repeater and wait until mouseup before
            // we trigger the stop event?
            "mouseleave .ui-spinner-button": "_stop"
        },

        _draw: function () {
            var uiSpinner = this.uiSpinner = this.element
                .addClass("ui-spinner-input")
                .attr("autocomplete", "off")
                .wrap(this._uiSpinnerHtml())
                .parent()
                // add buttons
                .append(this._buttonHtml());

            this.element.attr("role", "spinbutton");

            // button bindings
            this.buttons = uiSpinner.find(".ui-spinner-button")
                .attr("tabIndex", -1)
                .button()
                .removeClass("ui-corner-all");

            // IE 6 doesn't understand height: 50% for the buttons
            // unless the wrapper has an explicit height
            if (this.buttons.height() > Math.ceil(uiSpinner.height() * 0.5) &&
                uiSpinner.height() > 0) {
                uiSpinner.height(uiSpinner.height());
            }

            // disable spinner if element was already disabled
            if (this.options.disabled) {
                this.disable();
            }
        },

        _keydown: function (event) {
            var options = this.options,
                keyCode = $.ui.keyCode;

            switch (event.keyCode) {
                case keyCode.UP:
                    this._repeat(null, 1, event);
                    return true;
                case keyCode.DOWN:
                    this._repeat(null, -1, event);
                    return true;
                case keyCode.PAGE_UP:
                    this._repeat(null, options.page, event);
                    return true;
                case keyCode.PAGE_DOWN:
                    this._repeat(null, -options.page, event);
                    return true;
            }

            return false;
        },

        _uiSpinnerHtml: function () {
            return "<span class='ui-spinner ui-widget ui-widget-content ui-corner-all'></span>";
        },

        _buttonHtml: function () {
            return "" +
                "<a class='ui-spinner-button ui-spinner-up ui-corner-tr'>" +
                "<span class='ui-icon " + this.options.icons.up + "'>&#9650;</span>" +
                "</a>" +
                "<a class='ui-spinner-button ui-spinner-down ui-corner-br'>" +
                "<span class='ui-icon " + this.options.icons.down + "'>&#9660;</span>" +
                "</a>";
        },

        _start: function (event) {
            if (!this.spinning && this._trigger("start", event) === false) {
                return false;
            }

            if (!this.counter) {
                this.counter = 1;
            }
            this.spinning = true;
            return true;
        },

        _repeat: function (i, steps, event) {
            i = i || 500;

            clearTimeout(this.timer);
            this.timer = this._delay(function () {
                this._repeat(40, steps, event);
            }, i);

            this._spin(steps * this.options.step, event);
        },

        _spin: function (step, event) {
            var value = this.value() || 0;

            if (!this.counter) {
                this.counter = 1;
            }

            value = this._adjustValue(value + step * this._increment(this.counter));

            if (!this.spinning || this._trigger("spin", event, { value: value }) !== false) {
                this._value(value);
                this.counter++;
            }
        },

        _increment: function (i) {
            var incremental = this.options.incremental;

            if (incremental) {
                return $.isFunction(incremental) ?
                    incremental(i) :
                    Math.floor(i * i * i / 50000 - i * i / 500 + 17 * i / 200 + 1);
            }

            return 1;
        },

        _precision: function () {
            var precision = this._precisionOf(this.options.step);
            if (this.options.min !== null) {
                precision = Math.max(precision, this._precisionOf(this.options.min));
            }
            return precision;
        },

        _precisionOf: function (num) {
            var str = num.toString(),
                decimal = str.indexOf(".");
            return decimal === -1 ? 0 : str.length - decimal - 1;
        },

        _adjustValue: function (value) {
            var base, aboveMin,
                options = this.options;

            // make sure we're at a valid step
            // - find out where we are relative to the base (min or 0)
            base = options.min !== null ? options.min : 0;
            aboveMin = value - base;
            // - round to the nearest step
            aboveMin = Math.round(aboveMin / options.step) * options.step;
            // - rounding is based on 0, so adjust back to our base
            value = base + aboveMin;

            // fix precision from bad JS floating point math
            value = parseFloat(value.toFixed(this._precision()));

            // clamp the value
            if (options.max !== null && value > options.max) {
                return options.max;
            }
            if (options.min !== null && value < options.min) {
                return options.min;
            }

            return value;
        },

        _stop: function (event) {
            if (!this.spinning) {
                return;
            }

            clearTimeout(this.timer);
            clearTimeout(this.mousewheelTimer);
            this.counter = 0;
            this.spinning = false;
            this._trigger("stop", event);
        },

        _setOption: function (key, value) {
            if (key === "culture" || key === "numberFormat") {
                var prevValue = this._parse(this.element.val());
                this.options[key] = value;
                this.element.val(this._format(prevValue));
                return;
            }

            if (key === "max" || key === "min" || key === "step") {
                if (typeof value === "string") {
                    value = this._parse(value);
                }
            }
            if (key === "icons") {
                this.buttons.first().find(".ui-icon")
                    .removeClass(this.options.icons.up)
                    .addClass(value.up);
                this.buttons.last().find(".ui-icon")
                    .removeClass(this.options.icons.down)
                    .addClass(value.down);
            }

            this._super(key, value);

            if (key === "disabled") {
                if (value) {
                    this.element.prop("disabled", true);
                    this.buttons.button("disable");
                } else {
                    this.element.prop("disabled", false);
                    this.buttons.button("enable");
                }
            }
        },

        _setOptions: modifier(function (options) {
            this._super(options);
            this._value(this.element.val());
        }),

        _parse: function (val) {
            if (typeof val === "string" && val !== "") {
                val = window.Globalize && this.options.numberFormat ?
                    Globalize.parseFloat(val, 10, this.options.culture) : +val;
            }
            return val === "" || isNaN(val) ? null : val;
        },

        _format: function (value) {
            if (value === "") {
                return "";
            }
            return window.Globalize && this.options.numberFormat ?
                Globalize.format(value, this.options.numberFormat, this.options.culture) :
                value;
        },

        _refresh: function () {
            this.element.attr({
                "aria-valuemin": this.options.min,
                "aria-valuemax": this.options.max,
                // TODO: what should we do with values that can't be parsed?
                "aria-valuenow": this._parse(this.element.val())
            });
        },

        // update the value without triggering change
        _value: function (value, allowAny) {
            var parsed;
            if (value !== "") {
                parsed = this._parse(value);
                if (parsed !== null) {
                    if (!allowAny) {
                        parsed = this._adjustValue(parsed);
                    }
                    value = this._format(parsed);
                }
            }
            this.element.val(value);
            this._refresh();
        },

        _destroy: function () {
            this.element
                .removeClass("ui-spinner-input")
                .prop("disabled", false)
                .removeAttr("autocomplete")
                .removeAttr("role")
                .removeAttr("aria-valuemin")
                .removeAttr("aria-valuemax")
                .removeAttr("aria-valuenow");
            this.uiSpinner.replaceWith(this.element);
        },

        stepUp: modifier(function (steps) {
            this._stepUp(steps);
        }),
        _stepUp: function (steps) {
            if (this._start()) {
                this._spin((steps || 1) * this.options.step);
                this._stop();
            }
        },

        stepDown: modifier(function (steps) {
            this._stepDown(steps);
        }),
        _stepDown: function (steps) {
            if (this._start()) {
                this._spin((steps || 1) * -this.options.step);
                this._stop();
            }
        },

        pageUp: modifier(function (pages) {
            this._stepUp((pages || 1) * this.options.page);
        }),

        pageDown: modifier(function (pages) {
            this._stepDown((pages || 1) * this.options.page);
        }),

        value: function (newVal) {
            if (!arguments.length) {
                return this._parse(this.element.val());
            }
            modifier(this._value).call(this, newVal);
        },

        widget: function () {
            return this.uiSpinner;
        }
    });

}(jQuery));

(function ($, undefined) {

    var tabId = 0,
        rhash = /#.*$/;

    function getNextTabId() {
        return ++tabId;
    }

    function isLocal(anchor) {
        return anchor.hash.length > 1 &&
            decodeURIComponent(anchor.href.replace(rhash, "")) ===
            decodeURIComponent(location.href.replace(rhash, ""));
    }

    $.widget("ui.tabs", {
        version: "1.10.2",
        delay: 300,
        options: {
            active: null,
            collapsible: false,
            event: "click",
            heightStyle: "content",
            hide: null,
            show: null,

            // callbacks
            activate: null,
            beforeActivate: null,
            beforeLoad: null,
            load: null
        },

        _create: function () {
            var that = this,
                options = this.options;

            this.running = false;

            this.element
                .addClass("ui-tabs ui-widget ui-widget-content ui-corner-all")
                .toggleClass("ui-tabs-collapsible", options.collapsible)
                // Prevent users from focusing disabled tabs via click
                .delegate(".ui-tabs-nav > li", "mousedown" + this.eventNamespace, function (event) {
                    if ($(this).is(".ui-state-disabled")) {
                        event.preventDefault();
                    }
                })
                // support: IE <9
                // Preventing the default action in mousedown doesn't prevent IE
                // from focusing the element, so if the anchor gets focused, blur.
                // We don't have to worry about focusing the previously focused
                // element since clicking on a non-focusable element should focus
                // the body anyway.
                .delegate(".ui-tabs-anchor", "focus" + this.eventNamespace, function () {
                    if ($(this).closest("li").is(".ui-state-disabled")) {
                        this.blur();
                    }
                });

            this._processTabs();
            options.active = this._initialActive();

            // Take disabling tabs via class attribute from HTML
            // into account and update option properly.
            if ($.isArray(options.disabled)) {
                options.disabled = $.unique(options.disabled.concat(
                    $.map(this.tabs.filter(".ui-state-disabled"), function (li) {
                        return that.tabs.index(li);
                    })
                )).sort();
            }

            // check for length avoids error when initializing empty list
            if (this.options.active !== false && this.anchors.length) {
                this.active = this._findActive(options.active);
            } else {
                this.active = $();
            }

            this._refresh();

            if (this.active.length) {
                this.load(options.active);
            }
        },

        _initialActive: function () {
            var active = this.options.active,
                collapsible = this.options.collapsible,
                locationHash = location.hash.substring(1);

            if (active === null) {
                // check the fragment identifier in the URL
                if (locationHash) {
                    this.tabs.each(function (i, tab) {
                        if ($(tab).attr("aria-controls") === locationHash) {
                            active = i;
                            return false;
                        }
                    });
                }

                // check for a tab marked active via a class
                if (active === null) {
                    active = this.tabs.index(this.tabs.filter(".ui-tabs-active"));
                }

                // no active tab, set to false
                if (active === null || active === -1) {
                    active = this.tabs.length ? 0 : false;
                }
            }

            // handle numbers: negative, out of range
            if (active !== false) {
                active = this.tabs.index(this.tabs.eq(active));
                if (active === -1) {
                    active = collapsible ? false : 0;
                }
            }

            // don't allow collapsible: false and active: false
            if (!collapsible && active === false && this.anchors.length) {
                active = 0;
            }

            return active;
        },

        _getCreateEventData: function () {
            return {
                tab: this.active,
                panel: !this.active.length ? $() : this._getPanelForTab(this.active)
            };
        },

        _tabKeydown: function (event) {
            /*jshint maxcomplexity:15*/
            var focusedTab = $(this.document[0].activeElement).closest("li"),
                selectedIndex = this.tabs.index(focusedTab),
                goingForward = true;

            if (this._handlePageNav(event)) {
                return;
            }

            switch (event.keyCode) {
                case $.ui.keyCode.RIGHT:
                case $.ui.keyCode.DOWN:
                    selectedIndex++;
                    break;
                case $.ui.keyCode.UP:
                case $.ui.keyCode.LEFT:
                    goingForward = false;
                    selectedIndex--;
                    break;
                case $.ui.keyCode.END:
                    selectedIndex = this.anchors.length - 1;
                    break;
                case $.ui.keyCode.HOME:
                    selectedIndex = 0;
                    break;
                case $.ui.keyCode.SPACE:
                    // Activate only, no collapsing
                    event.preventDefault();
                    clearTimeout(this.activating);
                    this._activate(selectedIndex);
                    return;
                case $.ui.keyCode.ENTER:
                    // Toggle (cancel delayed activation, allow collapsing)
                    event.preventDefault();
                    clearTimeout(this.activating);
                    // Determine if we should collapse or activate
                    this._activate(selectedIndex === this.options.active ? false : selectedIndex);
                    return;
                default:
                    return;
            }

            // Focus the appropriate tab, based on which key was pressed
            event.preventDefault();
            clearTimeout(this.activating);
            selectedIndex = this._focusNextTab(selectedIndex, goingForward);

            // Navigating with control key will prevent automatic activation
            if (!event.ctrlKey) {
                // Update aria-selected immediately so that AT think the tab is already selected.
                // Otherwise AT may confuse the user by stating that they need to activate the tab,
                // but the tab will already be activated by the time the announcement finishes.
                focusedTab.attr("aria-selected", "false");
                this.tabs.eq(selectedIndex).attr("aria-selected", "true");

                this.activating = this._delay(function () {
                    this.option("active", selectedIndex);
                }, this.delay);
            }
        },

        _panelKeydown: function (event) {
            if (this._handlePageNav(event)) {
                return;
            }

            // Ctrl+up moves focus to the current tab
            if (event.ctrlKey && event.keyCode === $.ui.keyCode.UP) {
                event.preventDefault();
                this.active.focus();
            }
        },

        // Alt+page up/down moves focus to the previous/next tab (and activates)
        _handlePageNav: function (event) {
            if (event.altKey && event.keyCode === $.ui.keyCode.PAGE_UP) {
                this._activate(this._focusNextTab(this.options.active - 1, false));
                return true;
            }
            if (event.altKey && event.keyCode === $.ui.keyCode.PAGE_DOWN) {
                this._activate(this._focusNextTab(this.options.active + 1, true));
                return true;
            }
        },

        _findNextTab: function (index, goingForward) {
            var lastTabIndex = this.tabs.length - 1;

            function constrain() {
                if (index > lastTabIndex) {
                    index = 0;
                }
                if (index < 0) {
                    index = lastTabIndex;
                }
                return index;
            }

            while ($.inArray(constrain(), this.options.disabled) !== -1) {
                index = goingForward ? index + 1 : index - 1;
            }

            return index;
        },

        _focusNextTab: function (index, goingForward) {
            index = this._findNextTab(index, goingForward);
            this.tabs.eq(index).focus();
            return index;
        },

        _setOption: function (key, value) {
            if (key === "active") {
                // _activate() will handle invalid values and update this.options
                this._activate(value);
                return;
            }

            if (key === "disabled") {
                // don't use the widget factory's disabled handling
                this._setupDisabled(value);
                return;
            }

            this._super(key, value);

            if (key === "collapsible") {
                this.element.toggleClass("ui-tabs-collapsible", value);
                // Setting collapsible: false while collapsed; open first panel
                if (!value && this.options.active === false) {
                    this._activate(0);
                }
            }

            if (key === "event") {
                this._setupEvents(value);
            }

            if (key === "heightStyle") {
                this._setupHeightStyle(value);
            }
        },

        _tabId: function (tab) {
            return tab.attr("aria-controls") || "ui-tabs-" + getNextTabId();
        },

        _sanitizeSelector: function (hash) {
            return hash ? hash.replace(/[!"$%&'()*+,.\/:;<=>?@\[\]\^`{|}~]/g, "\\$&") : "";
        },

        refresh: function () {
            var options = this.options,
                lis = this.tablist.children(":has(a[href])");

            // get disabled tabs from class attribute from HTML
            // this will get converted to a boolean if needed in _refresh()
            options.disabled = $.map(lis.filter(".ui-state-disabled"), function (tab) {
                return lis.index(tab);
            });

            this._processTabs();

            // was collapsed or no tabs
            if (options.active === false || !this.anchors.length) {
                options.active = false;
                this.active = $();
                // was active, but active tab is gone
            } else if (this.active.length && !$.contains(this.tablist[0], this.active[0])) {
                // all remaining tabs are disabled
                if (this.tabs.length === options.disabled.length) {
                    options.active = false;
                    this.active = $();
                    // activate previous tab
                } else {
                    this._activate(this._findNextTab(Math.max(0, options.active - 1), false));
                }
                // was active, active tab still exists
            } else {
                // make sure active index is correct
                options.active = this.tabs.index(this.active);
            }

            this._refresh();
        },

        _refresh: function () {
            this._setupDisabled(this.options.disabled);
            this._setupEvents(this.options.event);
            this._setupHeightStyle(this.options.heightStyle);

            this.tabs.not(this.active).attr({
                "aria-selected": "false",
                tabIndex: -1
            });
            this.panels.not(this._getPanelForTab(this.active))
                .hide()
                .attr({
                    "aria-expanded": "false",
                    "aria-hidden": "true"
                });

            // Make sure one tab is in the tab order
            if (!this.active.length) {
                this.tabs.eq(0).attr("tabIndex", 0);
            } else {
                this.active
                    .addClass("ui-tabs-active ui-state-active")
                    .attr({
                        "aria-selected": "true",
                        tabIndex: 0
                    });
                this._getPanelForTab(this.active)
                    .show()
                    .attr({
                        "aria-expanded": "true",
                        "aria-hidden": "false"
                    });
            }
        },

        _processTabs: function () {
            var that = this;

            this.tablist = this._getList()
                .addClass("ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all")
                .attr("role", "tablist");

            this.tabs = this.tablist.find("> li:has(a[href])")
                .addClass("ui-state-default ui-corner-top")
                .attr({
                    role: "tab",
                    tabIndex: -1
                });

            this.anchors = this.tabs.map(function () {
                return $("a", this)[0];
            })
                .addClass("ui-tabs-anchor")
                .attr({
                    role: "presentation",
                    tabIndex: -1
                });

            this.panels = $();

            this.anchors.each(function (i, anchor) {
                var selector, panel, panelId,
                    anchorId = $(anchor).uniqueId().attr("id"),
                    tab = $(anchor).closest("li"),
                    originalAriaControls = tab.attr("aria-controls");

                // inline tab
                if (isLocal(anchor)) {
                    selector = anchor.hash;
                    panel = that.element.find(that._sanitizeSelector(selector));
                    // remote tab
                } else {
                    panelId = that._tabId(tab);
                    selector = "#" + panelId;
                    panel = that.element.find(selector);
                    if (!panel.length) {
                        panel = that._createPanel(panelId);
                        panel.insertAfter(that.panels[i - 1] || that.tablist);
                    }
                    panel.attr("aria-live", "polite");
                }

                if (panel.length) {
                    that.panels = that.panels.add(panel);
                }
                if (originalAriaControls) {
                    tab.data("ui-tabs-aria-controls", originalAriaControls);
                }
                tab.attr({
                    "aria-controls": selector.substring(1),
                    "aria-labelledby": anchorId
                });
                panel.attr("aria-labelledby", anchorId);
            });

            this.panels
                .addClass("ui-tabs-panel ui-widget-content ui-corner-bottom")
                .attr("role", "tabpanel");
        },

        // allow overriding how to find the list for rare usage scenarios (#7715)
        _getList: function () {
            return this.element.find("ol,ul").eq(0);
        },

        _createPanel: function (id) {
            return $("<div>")
                .attr("id", id)
                .addClass("ui-tabs-panel ui-widget-content ui-corner-bottom")
                .data("ui-tabs-destroy", true);
        },

        _setupDisabled: function (disabled) {
            if ($.isArray(disabled)) {
                if (!disabled.length) {
                    disabled = false;
                } else if (disabled.length === this.anchors.length) {
                    disabled = true;
                }
            }

            // disable tabs
            for (var i = 0, li; (li = this.tabs[i]); i++) {
                if (disabled === true || $.inArray(i, disabled) !== -1) {
                    $(li)
                        .addClass("ui-state-disabled")
                        .attr("aria-disabled", "true");
                } else {
                    $(li)
                        .removeClass("ui-state-disabled")
                        .removeAttr("aria-disabled");
                }
            }

            this.options.disabled = disabled;
        },

        _setupEvents: function (event) {
            var events = {
                click: function (event) {
                    event.preventDefault();
                }
            };
            if (event) {
                $.each(event.split(" "), function (index, eventName) {
                    events[eventName] = "_eventHandler";
                });
            }

            this._off(this.anchors.add(this.tabs).add(this.panels));
            this._on(this.anchors, events);
            this._on(this.tabs, { keydown: "_tabKeydown" });
            this._on(this.panels, { keydown: "_panelKeydown" });

            this._focusable(this.tabs);
            this._hoverable(this.tabs);
        },

        _setupHeightStyle: function (heightStyle) {
            var maxHeight,
                parent = this.element.parent();

            if (heightStyle === "fill") {
                maxHeight = parent.height();
                maxHeight -= this.element.outerHeight() - this.element.height();

                this.element.siblings(":visible").each(function () {
                    var elem = $(this),
                        position = elem.css("position");

                    if (position === "absolute" || position === "fixed") {
                        return;
                    }
                    maxHeight -= elem.outerHeight(true);
                });

                this.element.children().not(this.panels).each(function () {
                    maxHeight -= $(this).outerHeight(true);
                });

                this.panels.each(function () {
                    $(this).height(Math.max(0, maxHeight -
                        $(this).innerHeight() + $(this).height()));
                })
                    .css("overflow", "auto");
            } else if (heightStyle === "auto") {
                maxHeight = 0;
                this.panels.each(function () {
                    maxHeight = Math.max(maxHeight, $(this).height("").height());
                }).height(maxHeight);
            }
        },

        _eventHandler: function (event) {
            var options = this.options,
                active = this.active,
                anchor = $(event.currentTarget),
                tab = anchor.closest("li"),
                clickedIsActive = tab[0] === active[0],
                collapsing = clickedIsActive && options.collapsible,
                toShow = collapsing ? $() : this._getPanelForTab(tab),
                toHide = !active.length ? $() : this._getPanelForTab(active),
                eventData = {
                    oldTab: active,
                    oldPanel: toHide,
                    newTab: collapsing ? $() : tab,
                    newPanel: toShow
                };

            event.preventDefault();

            if (tab.hasClass("ui-state-disabled") ||
                // tab is already loading
                tab.hasClass("ui-tabs-loading") ||
                // can't switch durning an animation
                this.running ||
                // click on active header, but not collapsible
                (clickedIsActive && !options.collapsible) ||
                // allow canceling activation
                (this._trigger("beforeActivate", event, eventData) === false)) {
                return;
            }

            options.active = collapsing ? false : this.tabs.index(tab);

            this.active = clickedIsActive ? $() : tab;
            if (this.xhr) {
                this.xhr.abort();
            }

            if (!toHide.length && !toShow.length) {
                $.error("jQuery UI Tabs: Mismatching fragment identifier.");
            }

            if (toShow.length) {
                this.load(this.tabs.index(tab), event);
            }
            this._toggle(event, eventData);
        },

        // handles show/hide for selecting tabs
        _toggle: function (event, eventData) {
            var that = this,
                toShow = eventData.newPanel,
                toHide = eventData.oldPanel;

            this.running = true;

            function complete() {
                that.running = false;
                that._trigger("activate", event, eventData);
            }

            function show() {
                eventData.newTab.closest("li").addClass("ui-tabs-active ui-state-active");

                if (toShow.length && that.options.show) {
                    that._show(toShow, that.options.show, complete);
                } else {
                    toShow.show();
                    complete();
                }
            }

            // start out by hiding, then showing, then completing
            if (toHide.length && this.options.hide) {
                this._hide(toHide, this.options.hide, function () {
                    eventData.oldTab.closest("li").removeClass("ui-tabs-active ui-state-active");
                    show();
                });
            } else {
                eventData.oldTab.closest("li").removeClass("ui-tabs-active ui-state-active");
                toHide.hide();
                show();
            }

            toHide.attr({
                "aria-expanded": "false",
                "aria-hidden": "true"
            });
            eventData.oldTab.attr("aria-selected", "false");
            // If we're switching tabs, remove the old tab from the tab order.
            // If we're opening from collapsed state, remove the previous tab from the tab order.
            // If we're collapsing, then keep the collapsing tab in the tab order.
            if (toShow.length && toHide.length) {
                eventData.oldTab.attr("tabIndex", -1);
            } else if (toShow.length) {
                this.tabs.filter(function () {
                    return $(this).attr("tabIndex") === 0;
                })
                    .attr("tabIndex", -1);
            }

            toShow.attr({
                "aria-expanded": "true",
                "aria-hidden": "false"
            });
            eventData.newTab.attr({
                "aria-selected": "true",
                tabIndex: 0
            });
        },

        _activate: function (index) {
            var anchor,
                active = this._findActive(index);

            // trying to activate the already active panel
            if (active[0] === this.active[0]) {
                return;
            }

            // trying to collapse, simulate a click on the current active header
            if (!active.length) {
                active = this.active;
            }

            anchor = active.find(".ui-tabs-anchor")[0];
            this._eventHandler({
                target: anchor,
                currentTarget: anchor,
                preventDefault: $.noop
            });
        },

        _findActive: function (index) {
            return index === false ? $() : this.tabs.eq(index);
        },

        _getIndex: function (index) {
            // meta-function to give users option to provide a href string instead of a numerical index.
            if (typeof index === "string") {
                index = this.anchors.index(this.anchors.filter("[href$='" + index + "']"));
            }

            return index;
        },

        _destroy: function () {
            if (this.xhr) {
                this.xhr.abort();
            }

            this.element.removeClass("ui-tabs ui-widget ui-widget-content ui-corner-all ui-tabs-collapsible");

            this.tablist
                .removeClass("ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all")
                .removeAttr("role");

            this.anchors
                .removeClass("ui-tabs-anchor")
                .removeAttr("role")
                .removeAttr("tabIndex")
                .removeUniqueId();

            this.tabs.add(this.panels).each(function () {
                if ($.data(this, "ui-tabs-destroy")) {
                    $(this).remove();
                } else {
                    $(this)
                        .removeClass("ui-state-default ui-state-active ui-state-disabled " +
                        "ui-corner-top ui-corner-bottom ui-widget-content ui-tabs-active ui-tabs-panel")
                        .removeAttr("tabIndex")
                        .removeAttr("aria-live")
                        .removeAttr("aria-busy")
                        .removeAttr("aria-selected")
                        .removeAttr("aria-labelledby")
                        .removeAttr("aria-hidden")
                        .removeAttr("aria-expanded")
                        .removeAttr("role");
                }
            });

            this.tabs.each(function () {
                var li = $(this),
                    prev = li.data("ui-tabs-aria-controls");
                if (prev) {
                    li
                        .attr("aria-controls", prev)
                        .removeData("ui-tabs-aria-controls");
                } else {
                    li.removeAttr("aria-controls");
                }
            });

            this.panels.show();

            if (this.options.heightStyle !== "content") {
                this.panels.css("height", "");
            }
        },

        enable: function (index) {
            var disabled = this.options.disabled;
            if (disabled === false) {
                return;
            }

            if (index === undefined) {
                disabled = false;
            } else {
                index = this._getIndex(index);
                if ($.isArray(disabled)) {
                    disabled = $.map(disabled, function (num) {
                        return num !== index ? num : null;
                    });
                } else {
                    disabled = $.map(this.tabs, function (li, num) {
                        return num !== index ? num : null;
                    });
                }
            }
            this._setupDisabled(disabled);
        },

        disable: function (index) {
            var disabled = this.options.disabled;
            if (disabled === true) {
                return;
            }

            if (index === undefined) {
                disabled = true;
            } else {
                index = this._getIndex(index);
                if ($.inArray(index, disabled) !== -1) {
                    return;
                }
                if ($.isArray(disabled)) {
                    disabled = $.merge([index], disabled).sort();
                } else {
                    disabled = [index];
                }
            }
            this._setupDisabled(disabled);
        },

        load: function (index, event) {
            index = this._getIndex(index);
            var that = this,
                tab = this.tabs.eq(index),
                anchor = tab.find(".ui-tabs-anchor"),
                panel = this._getPanelForTab(tab),
                eventData = {
                    tab: tab,
                    panel: panel
                };

            // not remote
            if (isLocal(anchor[0])) {
                return;
            }

            this.xhr = $.ajax(this._ajaxSettings(anchor, event, eventData));

            // support: jQuery <1.8
            // jQuery <1.8 returns false if the request is canceled in beforeSend,
            // but as of 1.8, $.ajax() always returns a jqXHR object.
            if (this.xhr && this.xhr.statusText !== "canceled") {
                tab.addClass("ui-tabs-loading");
                panel.attr("aria-busy", "true");

                this.xhr
                    .success(function (response) {
                        // support: jQuery <1.8
                        // http://bugs.jquery.com/ticket/11778
                        setTimeout(function () {
                            panel.html(response);
                            that._trigger("load", event, eventData);
                        }, 1);
                    })
                    .complete(function (jqXHR, status) {
                        // support: jQuery <1.8
                        // http://bugs.jquery.com/ticket/11778
                        setTimeout(function () {
                            if (status === "abort") {
                                that.panels.stop(false, true);
                            }

                            tab.removeClass("ui-tabs-loading");
                            panel.removeAttr("aria-busy");

                            if (jqXHR === that.xhr) {
                                delete that.xhr;
                            }
                        }, 1);
                    });
            }
        },

        _ajaxSettings: function (anchor, event, eventData) {
            var that = this;
            return {
                url: anchor.attr("href"),
                beforeSend: function (jqXHR, settings) {
                    return that._trigger("beforeLoad", event,
                        $.extend({ jqXHR: jqXHR, ajaxSettings: settings }, eventData));
                }
            };
        },

        _getPanelForTab: function (tab) {
            var id = $(tab).attr("aria-controls");
            return this.element.find(this._sanitizeSelector("#" + id));
        }
    });

})(jQuery);

(function ($) {

    var increments = 0;

    function addDescribedBy(elem, id) {
        var describedby = (elem.attr("aria-describedby") || "").split(/\s+/);
        describedby.push(id);
        elem
            .data("ui-tooltip-id", id)
            .attr("aria-describedby", $.trim(describedby.join(" ")));
    }

    function removeDescribedBy(elem) {
        var id = elem.data("ui-tooltip-id"),
            describedby = (elem.attr("aria-describedby") || "").split(/\s+/),
            index = $.inArray(id, describedby);
        if (index !== -1) {
            describedby.splice(index, 1);
        }

        elem.removeData("ui-tooltip-id");
        describedby = $.trim(describedby.join(" "));
        if (describedby) {
            elem.attr("aria-describedby", describedby);
        } else {
            elem.removeAttr("aria-describedby");
        }
    }

    $.widget("ui.tooltip", {
        version: "1.10.2",
        options: {
            content: function () {
                // support: IE<9, Opera in jQuery <1.7
                // .text() can't accept undefined, so coerce to a string
                var title = $(this).attr("title") || "";
                // Escape title, since we're going from an attribute to raw HTML
                return $("<a>").text(title).html();
            },
            hide: true,
            // Disabled elements have inconsistent behavior across browsers (#8661)
            items: "[title]:not([disabled])",
            position: {
                my: "left top+15",
                at: "left bottom",
                collision: "flipfit flip"
            },
            show: true,
            tooltipClass: null,
            track: false,

            // callbacks
            close: null,
            open: null
        },

        _create: function () {
            this._on({
                mouseover: "open",
                focusin: "open"
            });

            // IDs of generated tooltips, needed for destroy
            this.tooltips = {};
            // IDs of parent tooltips where we removed the title attribute
            this.parents = {};

            if (this.options.disabled) {
                this._disable();
            }
        },

        _setOption: function (key, value) {
            var that = this;

            if (key === "disabled") {
                this[value ? "_disable" : "_enable"]();
                this.options[key] = value;
                // disable element style changes
                return;
            }

            this._super(key, value);

            if (key === "content") {
                $.each(this.tooltips, function (id, element) {
                    that._updateContent(element);
                });
            }
        },

        _disable: function () {
            var that = this;

            // close open tooltips
            $.each(this.tooltips, function (id, element) {
                var event = $.Event("blur");
                event.target = event.currentTarget = element[0];
                that.close(event, true);
            });

            // remove title attributes to prevent native tooltips
            this.element.find(this.options.items).addBack().each(function () {
                var element = $(this);
                if (element.is("[title]")) {
                    element
                        .data("ui-tooltip-title", element.attr("title"))
                        .attr("title", "");
                }
            });
        },

        _enable: function () {
            // restore title attributes
            this.element.find(this.options.items).addBack().each(function () {
                var element = $(this);
                if (element.data("ui-tooltip-title")) {
                    element.attr("title", element.data("ui-tooltip-title"));
                }
            });
        },

        open: function (event) {
            var that = this,
                target = $(event ? event.target : this.element)
                    // we need closest here due to mouseover bubbling,
                    // but always pointing at the same event target
                    .closest(this.options.items);

            // No element to show a tooltip for or the tooltip is already open
            if (!target.length || target.data("ui-tooltip-id")) {
                return;
            }

            if (target.attr("title")) {
                target.data("ui-tooltip-title", target.attr("title"));
            }

            target.data("ui-tooltip-open", true);

            // kill parent tooltips, custom or native, for hover
            if (event && event.type === "mouseover") {
                target.parents().each(function () {
                    var parent = $(this),
                        blurEvent;
                    if (parent.data("ui-tooltip-open")) {
                        blurEvent = $.Event("blur");
                        blurEvent.target = blurEvent.currentTarget = this;
                        that.close(blurEvent, true);
                    }
                    if (parent.attr("title")) {
                        parent.uniqueId();
                        that.parents[this.id] = {
                            element: this,
                            title: parent.attr("title")
                        };
                        parent.attr("title", "");
                    }
                });
            }

            this._updateContent(target, event);
        },

        _updateContent: function (target, event) {
            var content,
                contentOption = this.options.content,
                that = this,
                eventType = event ? event.type : null;

            if (typeof contentOption === "string") {
                return this._open(event, target, contentOption);
            }

            content = contentOption.call(target[0], function (response) {
                // ignore async response if tooltip was closed already
                if (!target.data("ui-tooltip-open")) {
                    return;
                }
                // IE may instantly serve a cached response for ajax requests
                // delay this call to _open so the other call to _open runs first
                that._delay(function () {
                    // jQuery creates a special event for focusin when it doesn't
                    // exist natively. To improve performance, the native event
                    // object is reused and the type is changed. Therefore, we can't
                    // rely on the type being correct after the event finished
                    // bubbling, so we set it back to the previous value. (#8740)
                    if (event) {
                        event.type = eventType;
                    }
                    this._open(event, target, response);
                });
            });
            if (content) {
                this._open(event, target, content);
            }
        },

        _open: function (event, target, content) {
            var tooltip, events, delayedShow,
                positionOption = $.extend({}, this.options.position);

            if (!content) {
                return;
            }

            // Content can be updated multiple times. If the tooltip already
            // exists, then just update the content and bail.
            tooltip = this._find(target);
            if (tooltip.length) {
                tooltip.find(".ui-tooltip-content").html(content);
                return;
            }

            // if we have a title, clear it to prevent the native tooltip
            // we have to check first to avoid defining a title if none exists
            // (we don't want to cause an element to start matching [title])
            //
            // We use removeAttr only for key events, to allow IE to export the correct
            // accessible attributes. For mouse events, set to empty string to avoid
            // native tooltip showing up (happens only when removing inside mouseover).
            if (target.is("[title]")) {
                if (event && event.type === "mouseover") {
                    target.attr("title", "");
                } else {
                    target.removeAttr("title");
                }
            }

            tooltip = this._tooltip(target);
            addDescribedBy(target, tooltip.attr("id"));
            tooltip.find(".ui-tooltip-content").html(content);

            function position(event) {
                positionOption.of = event;
                if (tooltip.is(":hidden")) {
                    return;
                }
                tooltip.position(positionOption);
            }
            if (this.options.track && event && /^mouse/.test(event.type)) {
                this._on(this.document, {
                    mousemove: position
                });
                // trigger once to override element-relative positioning
                position(event);
            } else {
                tooltip.position($.extend({
                    of: target
                }, this.options.position));
            }

            tooltip.hide();

            this._show(tooltip, this.options.show);
            // Handle tracking tooltips that are shown with a delay (#8644). As soon
            // as the tooltip is visible, position the tooltip using the most recent
            // event.
            if (this.options.show && this.options.show.delay) {
                delayedShow = this.delayedShow = setInterval(function () {
                    if (tooltip.is(":visible")) {
                        position(positionOption.of);
                        clearInterval(delayedShow);
                    }
                }, $.fx.interval);
            }

            this._trigger("open", event, { tooltip: tooltip });

            events = {
                keyup: function (event) {
                    if (event.keyCode === $.ui.keyCode.ESCAPE) {
                        var fakeEvent = $.Event(event);
                        fakeEvent.currentTarget = target[0];
                        this.close(fakeEvent, true);
                    }
                },
                remove: function () {
                    this._removeTooltip(tooltip);
                }
            };
            if (!event || event.type === "mouseover") {
                events.mouseleave = "close";
            }
            if (!event || event.type === "focusin") {
                events.focusout = "close";
            }
            this._on(true, target, events);
        },

        close: function (event) {
            var that = this,
                target = $(event ? event.currentTarget : this.element),
                tooltip = this._find(target);

            // disabling closes the tooltip, so we need to track when we're closing
            // to avoid an infinite loop in case the tooltip becomes disabled on close
            if (this.closing) {
                return;
            }

            // Clear the interval for delayed tracking tooltips
            clearInterval(this.delayedShow);

            // only set title if we had one before (see comment in _open())
            if (target.data("ui-tooltip-title")) {
                target.attr("title", target.data("ui-tooltip-title"));
            }

            removeDescribedBy(target);

            tooltip.stop(true);
            this._hide(tooltip, this.options.hide, function () {
                that._removeTooltip($(this));
            });

            target.removeData("ui-tooltip-open");
            this._off(target, "mouseleave focusout keyup");
            // Remove 'remove' binding only on delegated targets
            if (target[0] !== this.element[0]) {
                this._off(target, "remove");
            }
            this._off(this.document, "mousemove");

            if (event && event.type === "mouseleave") {
                $.each(this.parents, function (id, parent) {
                    $(parent.element).attr("title", parent.title);
                    delete that.parents[id];
                });
            }

            this.closing = true;
            this._trigger("close", event, { tooltip: tooltip });
            this.closing = false;
        },

        _tooltip: function (element) {
            var id = "ui-tooltip-" + increments++,
                tooltip = $("<div>")
                    .attr({
                        id: id,
                        role: "tooltip"
                    })
                    .addClass("ui-tooltip ui-widget ui-corner-all ui-widget-content " +
                    (this.options.tooltipClass || ""));
            $("<div>")
                .addClass("ui-tooltip-content")
                .appendTo(tooltip);
            tooltip.appendTo(this.document[0].body);
            this.tooltips[id] = element;
            return tooltip;
        },

        _find: function (target) {
            var id = target.data("ui-tooltip-id");
            return id ? $("#" + id) : $();
        },

        _removeTooltip: function (tooltip) {
            tooltip.remove();
            delete this.tooltips[tooltip.attr("id")];
        },

        _destroy: function () {
            var that = this;

            // close open tooltips
            $.each(this.tooltips, function (id, element) {
                // Delegate to close method to handle common cleanup
                var event = $.Event("blur");
                event.target = event.currentTarget = element[0];
                that.close(event, true);

                // Remove immediately; destroying an open tooltip doesn't use the
                // hide animation
                $("#" + id).remove();

                // Restore the title
                if (element.data("ui-tooltip-title")) {
                    element.attr("title", element.data("ui-tooltip-title"));
                    element.removeData("ui-tooltip-title");
                }
            });
        }
    });

}(jQuery));
;
/**
 * Copyright (c) 2007-2014 Ariel Flesler - aflesler<a>gmail<d>com | http://flesler.blogspot.com
 * Licensed under MIT
 * @author Ariel Flesler
 * @version 1.4.11
 */
; (function (a) { if (typeof define === 'function' && define.amd) { define(['jquery'], a) } else { a(jQuery) } }(function ($) { var j = $.scrollTo = function (a, b, c) { return $(window).scrollTo(a, b, c) }; j.defaults = { axis: 'xy', duration: parseFloat($.fn.jquery) >= 1.3 ? 0 : 1, limit: true }; j.window = function (a) { return $(window)._scrollable() }; $.fn._scrollable = function () { return this.map(function () { var a = this, isWin = !a.nodeName || $.inArray(a.nodeName.toLowerCase(), ['iframe', '#document', 'html', 'body']) != -1; if (!isWin) return a; var b = (a.contentWindow || a).document || a.ownerDocument || a; return /webkit/i.test(navigator.userAgent) || b.compatMode == 'BackCompat' ? b.body : b.documentElement }) }; $.fn.scrollTo = function (f, g, h) { if (typeof g == 'object') { h = g; g = 0 } if (typeof h == 'function') h = { onAfter: h }; if (f == 'max') f = 9e9; h = $.extend({}, j.defaults, h); g = g || h.duration; h.queue = h.queue && h.axis.length > 1; if (h.queue) g /= 2; h.offset = both(h.offset); h.over = both(h.over); return this._scrollable().each(function () { if (f == null) return; var d = this, $elem = $(d), targ = f, toff, attr = {}, win = $elem.is('html,body'); switch (typeof targ) { case 'number': case 'string': if (/^([+-]=?)?\d+(\.\d+)?(px|%)?$/.test(targ)) { targ = both(targ); break } targ = $(targ, this); if (!targ.length) return; case 'object': if (targ.is || targ.style) toff = (targ = $(targ)).offset() }var e = $.isFunction(h.offset) && h.offset(d, targ) || h.offset; $.each(h.axis.split(''), function (i, a) { var b = a == 'x' ? 'Left' : 'Top', pos = b.toLowerCase(), key = 'scroll' + b, old = d[key], max = j.max(d, a); if (toff) { attr[key] = toff[pos] + (win ? 0 : old - $elem.offset()[pos]); if (h.margin) { attr[key] -= parseInt(targ.css('margin' + b)) || 0; attr[key] -= parseInt(targ.css('border' + b + 'Width')) || 0 } attr[key] += e[pos] || 0; if (h.over[pos]) attr[key] += targ[a == 'x' ? 'width' : 'height']() * h.over[pos] } else { var c = targ[pos]; attr[key] = c.slice && c.slice(-1) == '%' ? parseFloat(c) / 100 * max : c } if (h.limit && /^\d+$/.test(attr[key])) attr[key] = attr[key] <= 0 ? 0 : Math.min(attr[key], max); if (!i && h.queue) { if (old != attr[key]) animate(h.onAfterFirst); delete attr[key] } }); animate(h.onAfter); function animate(a) { $elem.animate(attr, g, h.easing, a && function () { a.call(this, targ, h) }) } }).end() }; j.max = function (a, b) { var c = b == 'x' ? 'Width' : 'Height', scroll = 'scroll' + c; if (!$(a).is('html,body')) return a[scroll] - $(a)[c.toLowerCase()](); var d = 'client' + c, html = a.ownerDocument.documentElement, body = a.ownerDocument.body; return Math.max(html[scroll], body[scroll]) - Math.min(html[d], body[d]) }; function both(a) { return $.isFunction(a) || typeof a == 'object' ? a : { top: a, left: a } }; return j }));
;
/* ============================================================
 * bootstrap-dropdown.js v2.3.1
 * http://twitter.github.com/bootstrap/javascript.html#dropdowns
 * ============================================================
 * Copyright 2012 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ============================================================ */


!function ($) {

    "use strict"; // jshint ;_;


    /* DROPDOWN CLASS DEFINITION
     * ========================= */

    var toggle = '[data-toggle=dropdown]'
        , Dropdown = function (element) {
            var $el = $(element).on('click.dropdown.data-api', this.toggle)
            $('html').on('click.dropdown.data-api', function () {
                $el.parent().removeClass('open')
            })
        }

    Dropdown.prototype = {

        constructor: Dropdown

        , toggle: function (e) {
            var $this = $(this)
                , $parent
                , isActive

            if ($this.is('.disabled, :disabled')) return

            $parent = getParent($this)

            isActive = $parent.hasClass('open')

            clearMenus()

            if (!isActive) {
                $parent.toggleClass('open')
            }

            $this.focus()

            return false
        }

        , keydown: function (e) {
            var $this
                , $items
                , $active
                , $parent
                , isActive
                , index

            if (!/(38|40|27)/.test(e.keyCode)) return

            $this = $(this)

            e.preventDefault()
            e.stopPropagation()

            if ($this.is('.disabled, :disabled')) return

            $parent = getParent($this)

            isActive = $parent.hasClass('open')

            if (!isActive || (isActive && e.keyCode == 27)) {
                if (e.which == 27) $parent.find(toggle).focus()
                return $this.click()
            }

            $items = $('[role=menu] li:not(.divider):visible a', $parent)

            if (!$items.length) return

            index = $items.index($items.filter(':focus'))

            if (e.keyCode == 38 && index > 0) index--                                        // up
            if (e.keyCode == 40 && index < $items.length - 1) index++                        // down
            if (!~index) index = 0

            $items
                .eq(index)
                .focus()
        }

    }

    function clearMenus() {
        $(toggle).each(function () {
            getParent($(this)).removeClass('open')
        })
    }

    function getParent($this) {
        var selector = $this.attr('data-target')
            , $parent

        if (!selector) {
            selector = $this.attr('href')
            selector = selector && /#/.test(selector) && selector.replace(/.*(?=#[^\s]*$)/, '') //strip for ie7
        }

        $parent = selector && $(selector)

        if (!$parent || !$parent.length) $parent = $this.parent()

        return $parent
    }


    /* DROPDOWN PLUGIN DEFINITION
     * ========================== */

    var old = $.fn.dropdown

    $.fn.dropdown = function (option) {
        return this.each(function () {
            var $this = $(this)
                , data = $this.data('dropdown')
            if (!data) $this.data('dropdown', (data = new Dropdown(this)))
            if (typeof option == 'string') data[option].call($this)
        })
    }

    $.fn.dropdown.Constructor = Dropdown


    /* DROPDOWN NO CONFLICT
     * ==================== */

    $.fn.dropdown.noConflict = function () {
        $.fn.dropdown = old
        return this
    }


    /* APPLY TO STANDARD DROPDOWN ELEMENTS
     * =================================== */

    $(document)
        .on('click.dropdown.data-api', clearMenus)
        .on('click.dropdown.data-api', '.dropdown form', function (e) { e.stopPropagation() })
        .on('click.dropdown-menu', function (e) { e.stopPropagation() })
        .on('click.dropdown.data-api', toggle, Dropdown.prototype.toggle)
        .on('keydown.dropdown.data-api', toggle + ', [role=menu]', Dropdown.prototype.keydown)

}(window.jQuery);
;
/* =========================================================
 * bootstrap-modal.js v2.3.1
 * http://twitter.github.com/bootstrap/javascript.html#modals
 * =========================================================
 * Copyright 2012 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ========================================================= */


!function ($) {

    "use strict"; // jshint ;_;


    /* MODAL CLASS DEFINITION
     * ====================== */

    var Modal = function (element, options) {
        this.options = options
        this.$element = $(element)
            .delegate('[data-dismiss="modal"]', 'click.dismiss.modal', $.proxy(this.hide, this))
        this.options.remote && this.$element.find('.modal-body').load(this.options.remote)
    }

    Modal.prototype = {

        constructor: Modal

        , toggle: function () {
            return this[!this.isShown ? 'show' : 'hide']()
        }

        , show: function () {
            var that = this
                , e = $.Event('show')

            this.$element.trigger(e)

            if (this.isShown || e.isDefaultPrevented()) return

            this.isShown = true

            this.escape()

            this.backdrop(function () {
                var transition = $.support.transition && that.$element.hasClass('fade')

                if (!that.$element.parent().length) {
                    that.$element.appendTo(document.body) //don't move modals dom position
                }

                that.$element.show()

                if (transition) {
                    that.$element[0].offsetWidth // force reflow
                }

                that.$element
                    .addClass('in')
                    .attr('aria-hidden', false)

                that.enforceFocus()

                transition ?
                    that.$element.one($.support.transition.end, function () { that.$element.focus().trigger('shown') }) :
                    that.$element.focus().trigger('shown')

            })
        }

        , hide: function (e) {
            e && e.preventDefault()

            var that = this

            e = $.Event('hide')

            this.$element.trigger(e)

            if (!this.isShown || e.isDefaultPrevented()) return

            this.isShown = false

            this.escape()

            $(document).off('focusin.modal')

            this.$element
                .removeClass('in')
                .attr('aria-hidden', true)

            $.support.transition && this.$element.hasClass('fade') ?
                this.hideWithTransition() :
                this.hideModal()
        }

        , enforceFocus: function () {
            var that = this
            $(document).on('focusin.modal', function (e) {
                if (that.$element[0] !== e.target && !that.$element.has(e.target).length) {
                    that.$element.focus()
                }
            })
        }

        , escape: function () {
            var that = this
            if (this.isShown && this.options.keyboard) {
                this.$element.on('keyup.dismiss.modal', function (e) {
                    e.which == 27 && that.hide()
                })
            } else if (!this.isShown) {
                this.$element.off('keyup.dismiss.modal')
            }
        }

        , hideWithTransition: function () {
            var that = this
                , timeout = setTimeout(function () {
                    that.$element.off($.support.transition.end)
                    that.hideModal()
                }, 500)

            this.$element.one($.support.transition.end, function () {
                clearTimeout(timeout)
                that.hideModal()
            })
        }

        , hideModal: function () {
            var that = this
            this.$element.hide()
            this.backdrop(function () {
                that.removeBackdrop()
                that.$element.trigger('hidden')
            })
        }

        , removeBackdrop: function () {
            this.$backdrop && this.$backdrop.remove()
            this.$backdrop = null
        }

        , backdrop: function (callback) {
            var that = this
                , animate = this.$element.hasClass('fade') ? 'fade' : ''

            if (this.isShown && this.options.backdrop) {
                var doAnimate = $.support.transition && animate

                this.$backdrop = $('<div class="modal-backdrop ' + animate + '" />')
                    .appendTo(document.body)

                this.$backdrop.click(
                    this.options.backdrop == 'static' ?
                        $.proxy(this.$element[0].focus, this.$element[0])
                        : $.proxy(this.hide, this)
                )

                if (doAnimate) this.$backdrop[0].offsetWidth // force reflow

                this.$backdrop.addClass('in')

                if (!callback) return

                doAnimate ?
                    this.$backdrop.one($.support.transition.end, callback) :
                    callback()

            } else if (!this.isShown && this.$backdrop) {
                this.$backdrop.removeClass('in')

                $.support.transition && this.$element.hasClass('fade') ?
                    this.$backdrop.one($.support.transition.end, callback) :
                    callback()

            } else if (callback) {
                callback()
            }
        }
    }


    /* MODAL PLUGIN DEFINITION
     * ======================= */

    var old = $.fn.modal

    $.fn.modal = function (option) {
        return this.each(function () {
            var $this = $(this)
                , data = $this.data('modal')
                , options = $.extend({}, $.fn.modal.defaults, $this.data(), typeof option == 'object' && option)
            if (!data) $this.data('modal', (data = new Modal(this, options)))
            if (typeof option == 'string') data[option]()
            else if (options.show) data.show()
        })
    }

    $.fn.modal.defaults = {
        backdrop: true
        , keyboard: true
        , show: true
    }

    $.fn.modal.Constructor = Modal


    /* MODAL NO CONFLICT
     * ================= */

    $.fn.modal.noConflict = function () {
        $.fn.modal = old
        return this
    }


    /* MODAL DATA-API
     * ============== */

    $(document).on('click.modal.data-api', '[data-toggle="modal"]', function (e) {
        var $this = $(this)
            , href = $this.attr('href')
            , $target = $($this.attr('data-target') || (href && href.replace(/.*(?=#[^\s]+$)/, ''))) //strip for ie7
            , option = $target.data('modal') ? 'toggle' : $.extend({ remote: !/#/.test(href) && href }, $target.data(), $this.data())

        e.preventDefault()

        $target
            .modal(option)
            .one('hide', function () {
                $this.focus()
            })
    })

}(window.jQuery);
;
/* ===========================================================
 * bootstrap-tooltip.js v2.3.1
 * http://twitter.github.com/bootstrap/javascript.html#tooltips
 * Inspired by the original jQuery.tipsy by Jason Frame
 * ===========================================================
 * Copyright 2012 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ========================================================== */


!function ($) {

    "use strict"; // jshint ;_;


    /* TOOLTIP PUBLIC CLASS DEFINITION
     * =============================== */

    var Tooltip = function (element, options) {
        this.init('tooltip', element, options)
    }

    Tooltip.prototype = {

        constructor: Tooltip

        , init: function (type, element, options) {
            var eventIn
                , eventOut
                , triggers
                , trigger
                , i

            this.type = type
            this.$element = $(element)
            this.options = this.getOptions(options)
            this.enabled = true

            triggers = this.options.trigger.split(' ')

            for (i = triggers.length; i--;) {
                trigger = triggers[i]
                if (trigger == 'click') {
                    this.$element.on('click.' + this.type, this.options.selector, $.proxy(this.toggle, this))
                } else if (trigger != 'manual') {
                    eventIn = trigger == 'hover' ? 'mouseenter' : 'focus'
                    eventOut = trigger == 'hover' ? 'mouseleave' : 'blur'
                    this.$element.on(eventIn + '.' + this.type, this.options.selector, $.proxy(this.enter, this))
                    this.$element.on(eventOut + '.' + this.type, this.options.selector, $.proxy(this.leave, this))
                }
            }

            this.options.selector ?
                (this._options = $.extend({}, this.options, { trigger: 'manual', selector: '' })) :
                this.fixTitle()
        }

        , getOptions: function (options) {
            options = $.extend({}, $.fn[this.type].defaults, this.$element.data(), options)

            if (options.delay && typeof options.delay == 'number') {
                options.delay = {
                    show: options.delay
                    , hide: options.delay
                }
            }

            return options
        }

        , enter: function (e) {
            var defaults = $.fn[this.type].defaults
                , options = {}
                , self

            this._options && $.each(this._options, function (key, value) {
                if (defaults[key] != value) options[key] = value
            }, this)

            self = $(e.currentTarget)[this.type](options).data(this.type)

            if (!self.options.delay || !self.options.delay.show) return self.show()

            clearTimeout(this.timeout)
            self.hoverState = 'in'
            this.timeout = setTimeout(function () {
                if (self.hoverState == 'in') self.show()
            }, self.options.delay.show)
        }

        , leave: function (e) {
            var self = $(e.currentTarget)[this.type](this._options).data(this.type)

            if (this.timeout) clearTimeout(this.timeout)
            if (!self.options.delay || !self.options.delay.hide) return self.hide()

            self.hoverState = 'out'
            this.timeout = setTimeout(function () {
                if (self.hoverState == 'out') self.hide()
            }, self.options.delay.hide)
        }

        , show: function () {
            var $tip
                , pos
                , actualWidth
                , actualHeight
                , placement
                , tp
                , e = $.Event('show')

            if (this.hasContent() && this.enabled) {
                this.$element.trigger(e)
                if (e.isDefaultPrevented()) return
                $tip = this.tip()
                this.setContent()

                if (this.options.animation) {
                    $tip.addClass('fade')
                }

                placement = typeof this.options.placement == 'function' ?
                    this.options.placement.call(this, $tip[0], this.$element[0]) :
                    this.options.placement

                $tip
                    .detach()
                    .css({ top: 0, left: 0, display: 'block' })

                this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element)

                pos = this.getPosition()

                actualWidth = $tip[0].offsetWidth
                actualHeight = $tip[0].offsetHeight

                switch (placement) {
                    case 'bottom':
                        tp = { top: pos.top + pos.height, left: pos.left + pos.width / 2 - actualWidth / 2 }
                        break
                    case 'top':
                        tp = { top: pos.top - actualHeight, left: pos.left + pos.width / 2 - actualWidth / 2 }
                        break
                    case 'left':
                        tp = { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth }
                        break
                    case 'right':
                        tp = { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width }
                        break
                }

                this.applyPlacement(tp, placement)
                this.$element.trigger('shown')
            }
        }

        , applyPlacement: function (offset, placement) {
            var $tip = this.tip()
                , width = $tip[0].offsetWidth
                , height = $tip[0].offsetHeight
                , actualWidth
                , actualHeight
                , delta
                , replace

            $tip
                .offset(offset)
                .addClass(placement)
                .addClass('in')

            actualWidth = $tip[0].offsetWidth
            actualHeight = $tip[0].offsetHeight

            if (placement == 'top' && actualHeight != height) {
                offset.top = offset.top + height - actualHeight
                replace = true
            }

            if (placement == 'bottom' || placement == 'top') {
                delta = 0

                if (offset.left < 0) {
                    delta = offset.left * -2
                    offset.left = 0
                    $tip.offset(offset)
                    actualWidth = $tip[0].offsetWidth
                    actualHeight = $tip[0].offsetHeight
                }

                this.replaceArrow(delta - width + actualWidth, actualWidth, 'left')
            } else {
                this.replaceArrow(actualHeight - height, actualHeight, 'top')
            }

            if (replace) $tip.offset(offset)
        }

        , replaceArrow: function (delta, dimension, position) {
            this
                .arrow()
                .css(position, delta ? (50 * (1 - delta / dimension) + "%") : '')
        }

        , setContent: function () {
            var $tip = this.tip()
                , title = this.getTitle()

            $tip.find('.tooltip-inner')[this.options.html ? 'html' : 'text'](title)
            $tip.removeClass('fade in top bottom left right')
        }

        , hide: function () {
            var that = this
                , $tip = this.tip()
                , e = $.Event('hide')

            this.$element.trigger(e)
            if (e.isDefaultPrevented()) return

            $tip.removeClass('in')

            function removeWithAnimation() {
                var timeout = setTimeout(function () {
                    $tip.off($.support.transition.end).detach()
                }, 500)

                $tip.one($.support.transition.end, function () {
                    clearTimeout(timeout)
                    $tip.detach()
                })
            }

            $.support.transition && this.$tip.hasClass('fade') ?
                removeWithAnimation() :
                $tip.detach()

            this.$element.trigger('hidden')

            return this
        }

        , fixTitle: function () {
            var $e = this.$element
            if ($e.attr('title') || typeof ($e.attr('data-original-title')) != 'string') {
                $e.attr('data-original-title', $e.attr('title') || '').attr('title', '')
            }
        }

        , hasContent: function () {
            return this.getTitle()
        }

        , getPosition: function () {
            var el = this.$element[0]
            return $.extend({}, (typeof el.getBoundingClientRect == 'function') ? el.getBoundingClientRect() : {
                width: el.offsetWidth
                , height: el.offsetHeight
            }, this.$element.offset())
        }

        , getTitle: function () {
            var title
                , $e = this.$element
                , o = this.options

            title = $e.attr('data-original-title')
                || (typeof o.title == 'function' ? o.title.call($e[0]) : o.title)

            return title
        }

        , tip: function () {
            return this.$tip = this.$tip || $(this.options.template)
        }

        , arrow: function () {
            return this.$arrow = this.$arrow || this.tip().find(".tooltip-arrow")
        }

        , validate: function () {
            if (!this.$element[0].parentNode) {
                this.hide()
                this.$element = null
                this.options = null
            }
        }

        , enable: function () {
            this.enabled = true
        }

        , disable: function () {
            this.enabled = false
        }

        , toggleEnabled: function () {
            this.enabled = !this.enabled
        }

        , toggle: function (e) {
            var self = e ? $(e.currentTarget)[this.type](this._options).data(this.type) : this
            self.tip().hasClass('in') ? self.hide() : self.show()
        }

        , destroy: function () {
            this.hide().$element.off('.' + this.type).removeData(this.type)
        }

    }


    /* TOOLTIP PLUGIN DEFINITION
     * ========================= */

    var old = $.fn.tooltip

    $.fn.tooltip = function (option) {
        return this.each(function () {
            var $this = $(this)
                , data = $this.data('tooltip')
                , options = typeof option == 'object' && option
            if (!data) $this.data('tooltip', (data = new Tooltip(this, options)))
            if (typeof option == 'string') data[option]()
        })
    }

    $.fn.tooltip.Constructor = Tooltip

    $.fn.tooltip.defaults = {
        animation: true
        , placement: 'top'
        , selector: false
        , template: '<div class="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>'
        , trigger: 'hover focus'
        , title: ''
        , delay: 0
        , html: false
        , container: false
    }


    /* TOOLTIP NO CONFLICT
     * =================== */

    $.fn.tooltip.noConflict = function () {
        $.fn.tooltip = old
        return this
    }

}(window.jQuery);
;
/* ===========================================================
 * bootstrap-popover.js v2.3.1
 * http://twitter.github.com/bootstrap/javascript.html#popovers
 * ===========================================================
 * Copyright 2012 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =========================================================== */


!function ($) {

    "use strict"; // jshint ;_;


    /* POPOVER PUBLIC CLASS DEFINITION
     * =============================== */

    var Popover = function (element, options) {
        this.init('popover', element, options)
    }


    /* NOTE: POPOVER EXTENDS BOOTSTRAP-TOOLTIP.js
       ========================================== */

    Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype, {

        constructor: Popover

        , setContent: function () {
            var $tip = this.tip()
                , title = this.getTitle()
                , content = this.getContent()

            $tip.find('.popover-title')[this.options.html ? 'html' : 'text'](title)
            $tip.find('.popover-content')[this.options.html ? 'html' : 'text'](content)

            $tip.removeClass('fade top bottom left right in')
        }

        , hasContent: function () {
            return this.getTitle() || this.getContent()
        }

        , getContent: function () {
            var content
                , $e = this.$element
                , o = this.options

            content = (typeof o.content == 'function' ? o.content.call($e[0]) : o.content)
                || $e.attr('data-content')

            return content
        }

        , tip: function () {
            if (!this.$tip) {
                this.$tip = $(this.options.template)
            }
            return this.$tip
        }

        , destroy: function () {
            this.hide().$element.off('.' + this.type).removeData(this.type)
        }

    })


    /* POPOVER PLUGIN DEFINITION
     * ======================= */

    var old = $.fn.popover

    $.fn.popover = function (option) {
        return this.each(function () {
            var $this = $(this)
                , data = $this.data('popover')
                , options = typeof option == 'object' && option
            if (!data) $this.data('popover', (data = new Popover(this, options)))
            if (typeof option == 'string') data[option]()
        })
    }

    $.fn.popover.Constructor = Popover

    $.fn.popover.defaults = $.extend({}, $.fn.tooltip.defaults, {
        placement: 'right'
        , trigger: 'click'
        , content: ''
        , template: '<div class="popover"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'
    })


    /* POPOVER NO CONFLICT
     * =================== */

    $.fn.popover.noConflict = function () {
        $.fn.popover = old
        return this
    }

}(window.jQuery);
;
// http://paulirish.com/2011/requestanimationframe-for-smart-animating/
// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating

// requestAnimationFrame polyfill by Erik MÃ¶ller. fixes from Paul Irish and Tino Zijdel

// MIT license

(function () {
    var lastTime = 0;
    var vendors = ['ms', 'moz', 'webkit', 'o'];
    for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
        window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
        window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame']
            || window[vendors[x] + 'CancelRequestAnimationFrame'];
    }

    if (!window.requestAnimationFrame)
        window.requestAnimationFrame = function (callback, element) {
            var currTime = new Date().getTime();
            var timeToCall = Math.max(0, 16 - (currTime - lastTime));
            var id = window.setTimeout(function () { callback(currTime + timeToCall); },
                timeToCall);
            lastTime = currTime + timeToCall;
            return id;
        };

    if (!window.cancelAnimationFrame)
        window.cancelAnimationFrame = function (id) {
            clearTimeout(id);
        };
}());
;
(function ($) {
    var monthNames = ['January', 'February', 'March', 'April', 'May', 'June',
        'July', 'August', 'September', 'October', 'November', 'December'];

    function getToday() {
        var date = new Date();
        return new Date(date.getFullYear(), date.getMonth(), date.getDate());
    }

    function areDatesEqual(date1, date2) {
        return String(date1) == String(date2);
    }

    function daysInMonth(year, month) {
        if (year instanceof Date) return daysInMonth(year.getFullYear(), year.getMonth());
        if (month == 1) {
            var leapYear = (year % 4 == 0) &&
                (!(year % 100 == 0) || (year % 400 == 0));
            return leapYear ? 29 : 28;
        } else if (month == 3 || month == 5 || month == 8 || month == 10) {
            return 30;
        } else {
            return 31;
        }
    }

    function dayAfter(date) {
        var year = date.getFullYear();
        var month = date.getMonth();
        var day = date.getDate();
        var lastDay = daysInMonth(date);
        return (day == lastDay) ?
            ((month == 11) ?
                new Date(year + 1, 0, 1) :
                new Date(year, month + 1, 1)
            ) :
            new Date(year, month, day + 1);
    }

    function dayBefore(date) {
        var year = date.getFullYear();
        var month = date.getMonth();
        var day = date.getDate();
        return (day == 1) ?
            ((month == 0) ?
                new Date(year - 1, 11, daysInMonth(year - 1, 11)) :
                new Date(year, month - 1, daysInMonth(year, month - 1))
            ) :
            new Date(year, month, day - 1);
    }

    function monthAfter(year, month) {
        return (month == 11) ?
            new Date(year + 1, 0, 1) :
            new Date(year, month + 1, 1);
    }

    function formatDate(date, options) {
        options = options || {};
        options.separator = options.separator || '/';

        var s;
        if (options.usa) {
            s = (date.getMonth() + 1) + options.separator + date.getDate()
        } else {
            s = date.getDate() + options.separator + (date.getMonth() + 1)
        }
        return s + options.separator + date.getFullYear();
    }

    function parseDate(date, options) {
        options = options || {};

        var a, day, month, year;
        a = date.split(/\D/);

        if (options.usa) {
            month = a.shift();
            day = a.shift();
        } else {
            day = a.shift();
            month = a.shift();
        }
        year = a.shift();

        return new Date(month + '/' + day + '/' + year);
    }

    function formatTime(hour, minute, options) {
        var printMinute = minute;
        if (minute < 10) printMinute = '0' + minute;

        if (options.isoTime) {
            var printHour = hour
            if (printHour < 10) printHour = '0' + hour;
            return printHour + ':' + printMinute;
        } else {
            var printHour = hour % 12;
            if (printHour == 0) printHour = 12;

            if (options.meridiemUpperCase) {
                var half = (hour < 12) ? 'AM' : 'PM';
                if (hour == 24) half = 'AM';
            } else {
                var half = (hour < 12) ? 'am' : 'pm';
                if (hour == 24) half = 'am';
            }

            if (minute === 0) {
                if (hour === 0) {
                    return 'Start of day';
                } else if (hour === 24) {
                    return 'End of day';
                }
            }

            return printHour + ':' + printMinute + half;
        }
    }

    function parseTime(text) {
        if (text === 'End of day') {
            return {
                hour: 24,
                minute: 0
            };
        } else if (text === 'Start of day') {
            return {
                hour: 0,
                minute: 0
            };
        }
        var match = match = /(\d+)\s*[:\-\.,]\s*(\d+)\s*(am|pm)?/i.exec(text);
        if (match && match.length >= 3) {
            var hour = Number(match[1]);
            var minute = Number(match[2])
            if (hour == 12 && match[3]) hour -= 12;
            if (match[3] && match[3].toLowerCase() == 'pm') hour += 12;
            return {
                hour: hour,
                minute: minute
            };
        } else {
            return null;
        }
    }

    function timeToMinutes(time) {
        return time && (time.hour * 60 + time.minute);
    }

    /**
     * Generates calendar header, with month name, << and >> controls, and
     * initials for days of the week.
     */
    function renderCalendarHeader(element, year, month, options) {
        //Prepare thead element
        var thead = $('<thead />');
        var titleRow = $('<tr />').appendTo(thead);

        //Generate << (back a month) link
        $('<th />').addClass('monthCell').append(
            $('<a href="javascript:;">&laquo;</a>')
                .addClass('prevMonth')
                .mousedown(function (e) {
                    renderCalendarPage(element,
                        month == 0 ? (year - 1) : year,
                        month == 0 ? 11 : (month - 1), options
                    );
                    e.preventDefault();
                })
        ).appendTo(titleRow);

        //Generate month title
        $('<th />').addClass('monthCell').attr('colSpan', 5).append(
            $('<a href="javascript:;">' + monthNames[month] + ' ' +
                year + '</a>').addClass('monthName')
        ).appendTo(titleRow);

        //Generate >> (forward a month) link
        $('<th />').addClass('monthCell').append(
            $('<a href="javascript:;">&raquo;</a>')
                .addClass('nextMonth')
                .mousedown(function () {
                    renderCalendarPage(element,
                        month == 11 ? (year + 1) : year,
                        month == 11 ? 0 : (month + 1), options
                    );
                })
        ).appendTo(titleRow);

        //Generate weekday initials row
        var dayNames = $('<tr />').appendTo(thead);
        $.each(String('SMTWTFS').split(''), function (k, v) {
            $('<td />').addClass('dayName').append(v).appendTo(dayNames);
        });

        return thead;
    }

    function renderCalendarPage(element, year, month, options) {
        options = options || {};

        var today = getToday();

        var date = new Date(year, month, 1);

        //Wind end date forward to saturday week after month
        var endDate = monthAfter(year, month);
        var ff = 6 - endDate.getDay();
        if (ff < 6) ff += 7;
        for (var i = 0; i < ff; i++) endDate = dayAfter(endDate);

        var table = $('<table />');
        renderCalendarHeader(element, year, month, options).appendTo(table);

        var tbody = $('<tbody />').appendTo(table);
        var row = $('<tr />');

        //Rewind date to monday week before month
        var rewind = date.getDay() + 7;
        for (var i = 0; i < rewind; i++) date = dayBefore(date);

        while (date <= endDate) {
            var td = $('<td />')
                .addClass('day')
                .append(
                $('<a href="javascript:;">' +
                    date.getDate() + '</a>'
                ).click((function () {
                    var thisDate = date;

                    return function () {
                        if (options && options.selectDate) {
                            options.selectDate(thisDate);
                        }
                    }
                }()))
                )
                .appendTo(row);

            var isToday = areDatesEqual(date, today);
            var isSelected = options.selected &&
                areDatesEqual(options.selected, date);

            if (isToday) td.addClass('today');
            if (isSelected) td.addClass('selected');
            if (isToday && isSelected) td.addClass('today_selected');
            if (date.getMonth() != month) td.addClass('nonMonth');

            dow = date.getDay();
            if (dow == 6) {
                tbody.append(row);
                row = $('<tr />');
            }
            date = dayAfter(date);
        }
        if (row.children().length) {
            tbody.append(row);
        } else {
            row.remove();
        }

        element.empty().append(table);
    }

    function renderTimeSelect(element, options) {
        var minTime = timeToMinutes(options.minTime);
        var maxTime = timeToMinutes(options.maxTime);
        var defaultTime = timeToMinutes(options.defaultTime);
        var selection = options.selection && timeToMinutes(parseTime(options.selection));

        //Round selection to nearest time interval so that it matches a list item
        selection = selection && (
            (
                Math.floor((selection - minTime) / options.timeInterval) *
                options.timeInterval
            ) + minTime
        );

        var scrollTo;   //Element to scroll the dropdown box to when shown
        var ul = $('<ul />');
        var lastOptionTime;
        if (options.showDuration) {
            lastOptionTime = maxTime + options.timeInterval;
        } else {
            lastOptionTime = maxTime;
        }


        for (var time = minTime; time <= lastOptionTime; time += options.timeInterval) {
            (function (time) {
                var hour = Math.floor(time / 60);
                var minute = time % 60;
                var timeText = formatTime(hour, minute, options);
                var fullText = timeText;
                if (options.showDuration) {
                    var duration = time - minTime;
                    if (duration < 60) {
                        fullText += ' (' + duration + ' mins)';
                    } else if (duration == 60) {
                        fullText += ' (1 hr)';
                    } else {
                        //Round partial hours to 1 decimal place
                        fullText += ' (' + (Math.round(duration / 60.0 * 10.0) / 10.0) + ' hrs)';
                    }
                }
                var li = $('<li />').append(
                    $('<a href="javascript:;">' + fullText + '</a>')
                        .click(function () {
                            if (options && options.selectTime) {
                                options.selectTime(timeText);
                            }
                        }).mousemove(function () {
                            $('li.selected', ul).removeClass('selected');
                        })
                ).appendTo(ul);

                //Set to scroll to the default hour, unless already set
                if (!scrollTo && time == defaultTime) scrollTo = li;

                if (selection == time) {
                    //Highlight selected item
                    li.addClass('selected');

                    //Set to scroll to the selected hour
                    //
                    //This is set even if scrollTo is already set, since
                    //scrolling to selected hour is more important than
                    //scrolling to default hour
                    scrollTo = li;
                }
            })(time);
        }
        if (scrollTo) {
            //Set timeout of zero so code runs immediately after any calling
            //functions are finished (this is needed, since box hasn't been
            //added to the DOM yet)
            setTimeout(function () {
                //Scroll the dropdown box so that scrollTo item is in
                //the middle
                element[0].scrollTop =
                    scrollTo[0].offsetTop - scrollTo.height() * 2;
            }, 0);
        }
        element.empty().append(ul);
    }

    $.fn.calendricalDate = function (options) {
        options = options || {};
        options.padding = options.padding || 4;

        return this.each(function () {
            var element = $(this);
            var div;
            var within = false;

            element.bind('focus click', function () {
                if (div) return;
                var offset = element.position();
                var padding = element.css('padding-left');
                div = $('<div />')
                    .addClass('calendricalDatePopup')
                    .mouseenter(function () { within = true; })
                    .mouseleave(function () { within = false; })
                    .mousedown(function (e) {
                        e.preventDefault();
                    })
                    .css({
                        position: 'absolute',
                        left: offset.left,
                        top: offset.top + element.height() +
                            options.padding * 2
                    });
                element.after(div);

                var selected = parseDate(element.val(), options);
                if (!selected.getFullYear()) selected = getToday();

                renderCalendarPage(
                    div,
                    selected.getFullYear(),
                    selected.getMonth(), {
                        selected: selected,
                        selectDate: function (date) {
                            within = false;
                            element.val(formatDate(date, options)).change();
                            div.remove();
                            div = null;
                            if (options.endDate) {
                                var endDate = parseDate(
                                    options.endDate.val(), options
                                );
                                if (endDate >= selected) {
                                    options.endDate.val(formatDate(
                                        new Date(
                                            date.getTime() +
                                            endDate.getTime() -
                                            selected.getTime()
                                        ),
                                        options.usa,
                                        options.separator
                                    ));
                                }
                            }
                        }
                    }
                );
            }).blur(function () {
                if (within) {
                    if (div) element.focus();
                    return;
                }
                if (!div) return;
                div.remove();
                div = null;
            });
        });
    };

    $.fn.calendricalDateRange = function (options) {
        if (this.length >= 2) {
            $(this[0]).calendricalDate($.extend({
                endDate: $(this[1])
            }, options));
            $(this[1]).calendricalDate(options);
        }
        return this;
    };

    $.fn.calendricalTime = function (options) {
        options = options || {};
        options.timeInterval = options.timeInterval || 30;
        options.padding = options.padding || 4;

        return this.each(function () {
            var element = $(this);
            var div;
            var within = false;

            element.attr('autocomplete', 'off');
            element.bind('focus click', function () {
                if (div) return;

                var offset = element.position();
                div = $('<div />')
                    .addClass('calendricalTimePopup')
                    .mouseenter(function () { within = true; })
                    .mouseleave(function () { within = false; })
                    .mousedown(function (e) {
                        e.preventDefault();
                    })
                    .css({
                        position: 'absolute',
                        left: offset.left,
                        top: offset.top + element.height() +
                            options.padding * 2
                    });

                element.after(div);
                var renderOptions = {
                    selection: element.val(),
                    selectTime: function (time) {
                        within = false;
                        element.val(time).change();
                        div.remove();
                        div = null;
                    },
                    isoTime: options.isoTime || false,
                    meridiemUpperCase: options.meridiemUpperCase || false,
                    defaultTime: options.defaultTime || { hour: 8, minute: 0 },
                    minTime: options.minTime || { hour: 0, minute: 0 },
                    maxTime: options.maxTime || { hour: 23, minute: 59 },
                    timeInterval: options.timeInterval || 30
                };

                if (options.startTime) {
                    var startTime = parseTime(options.startTime.val());
                    //Don't display duration if part of a datetime range,
                    //and start and end times are on different days
                    if (options.startDate && options.endDate && !areDatesEqual(parseDate(options.startDate.val(), options), parseDate(options.endDate.val(), options))) {
                        startTime = null;
                    }
                    if (startTime) {
                        renderOptions.minTime = startTime;
                        renderOptions.defaultTime = startTime;
                        renderOptions.showDuration = true;
                        div.addClass('calendricalEndTimePopup');
                    }
                }

                renderTimeSelect(div, renderOptions);
            }).blur(function () {
                if (within) {
                    if (div) element.focus();
                    return;
                }
                if (!div) return;
                div.remove();
                div = null;
            });
        });
    },

        $.fn.calendricalTimeRange = function (options) {
            if (this.length >= 2) {
                $(this[0]).calendricalTime(options);
                $(this[1]).calendricalTime($.extend({
                    startTime: $(this[0])
                }, options));
            }
            return this;
        };

    $.fn.calendricalDateTimeRange = function (options) {
        if (this.length >= 4) {
            $(this[0]).calendricalDate($.extend({
                endDate: $(this[2])
            }, options));
            $(this[1]).calendricalTime(options);
            $(this[2]).calendricalDate(options);
            $(this[3]).calendricalTime($.extend({
                startTime: $(this[1]),
                startDate: $(this[0]),
                endDate: $(this[2])
            }, options));
        }
        return this;
    };
})(jQuery);
;
/*! noUiSlider - 7.0.10 - 2014-12-27 14:50:46 */

/*jslint browser: true */
/*jslint white: true */

(function ($) {

    'use strict';


    // Removes duplicates from an array.
    function unique(array) {
        return $.grep(array, function (el, index) {
            return index === $.inArray(el, array);
        });
    }

    // Round a value to the closest 'to'.
    function closest(value, to) {
        return Math.round(value / to) * to;
    }

    // Checks whether a value is numerical.
    function isNumeric(a) {
        return typeof a === 'number' && !isNaN(a) && isFinite(a);
    }

    // Rounds a number to 7 supported decimals.
    function accurateNumber(number) {
        var p = Math.pow(10, 7);
        return Number((Math.round(number * p) / p).toFixed(7));
    }

    // Sets a class and removes it after [duration] ms.
    function addClassFor(element, className, duration) {
        element.addClass(className);
        setTimeout(function () {
            element.removeClass(className);
        }, duration);
    }

    // Limits a value to 0 - 100
    function limit(a) {
        return Math.max(Math.min(a, 100), 0);
    }

    // Wraps a variable as an array, if it isn't one yet.
    function asArray(a) {
        return $.isArray(a) ? a : [a];
    }

    // Counts decimals
    function countDecimals(numStr) {
        var pieces = numStr.split(".");
        return pieces.length > 1 ? pieces[1].length : 0;
    }


    var
        // Cache the document selector;
        /** @const */
        doc = $(document),
        // Make a backup of the original jQuery/Zepto .val() method.
        /** @const */
        $val = $.fn.val,
        // Namespace for binding and unbinding slider events;
        /** @const */
        namespace = '.nui',
        // Determine the events to bind. IE11 implements pointerEvents without
        // a prefix, which breaks compatibility with the IE10 implementation.
        /** @const */
        actions = window.navigator.pointerEnabled ? {
            start: 'pointerdown',
            move: 'pointermove',
            end: 'pointerup'
        } : window.navigator.msPointerEnabled ? {
            start: 'MSPointerDown',
            move: 'MSPointerMove',
            end: 'MSPointerUp'
        } : {
                    start: 'mousedown touchstart',
                    move: 'mousemove touchmove',
                    end: 'mouseup touchend'
                },
        // Re-usable list of classes;
        /** @const */
        Classes = [
/*  0 */  'noUi-target'
/*  1 */, 'noUi-base'
/*  2 */, 'noUi-origin'
/*  3 */, 'noUi-handle'
/*  4 */, 'noUi-horizontal'
/*  5 */, 'noUi-vertical'
/*  6 */, 'noUi-background'
/*  7 */, 'noUi-connect'
/*  8 */, 'noUi-ltr'
/*  9 */, 'noUi-rtl'
/* 10 */, 'noUi-dragable'
/* 11 */, ''
/* 12 */, 'noUi-state-drag'
/* 13 */, ''
/* 14 */, 'noUi-state-tap'
/* 15 */, 'noUi-active'
/* 16 */, ''
/* 17 */, 'noUi-stacking'
        ];


    // Value calculation

    // Determine the size of a sub-range in relation to a full range.
    function subRangeRatio(pa, pb) {
        return (100 / (pb - pa));
    }

    // (percentage) How many percent is this value of this range?
    function fromPercentage(range, value) {
        return (value * 100) / (range[1] - range[0]);
    }

    // (percentage) Where is this value on this range?
    function toPercentage(range, value) {
        return fromPercentage(range, range[0] < 0 ?
            value + Math.abs(range[0]) :
            value - range[0]);
    }

    // (value) How much is this percentage on this range?
    function isPercentage(range, value) {
        return ((value * (range[1] - range[0])) / 100) + range[0];
    }


    // Range conversion

    function getJ(value, arr) {

        var j = 1;

        while (value >= arr[j]) {
            j += 1;
        }

        return j;
    }

    // (percentage) Input a value, find where, on a scale of 0-100, it applies.
    function toStepping(xVal, xPct, value) {

        if (value >= xVal.slice(-1)[0]) {
            return 100;
        }

        var j = getJ(value, xVal), va, vb, pa, pb;

        va = xVal[j - 1];
        vb = xVal[j];
        pa = xPct[j - 1];
        pb = xPct[j];

        return pa + (toPercentage([va, vb], value) / subRangeRatio(pa, pb));
    }

    // (value) Input a percentage, find where it is on the specified range.
    function fromStepping(xVal, xPct, value) {

        // There is no range group that fits 100
        if (value >= 100) {
            return xVal.slice(-1)[0];
        }

        var j = getJ(value, xPct), va, vb, pa, pb;

        va = xVal[j - 1];
        vb = xVal[j];
        pa = xPct[j - 1];
        pb = xPct[j];

        return isPercentage([va, vb], (value - pa) * subRangeRatio(pa, pb));
    }

    // (percentage) Get the step that applies at a certain value.
    function getStep(xPct, xSteps, snap, value) {

        if (value === 100) {
            return value;
        }

        var j = getJ(value, xPct), a, b;

        // If 'snap' is set, steps are used as fixed points on the slider.
        if (snap) {

            a = xPct[j - 1];
            b = xPct[j];

            // Find the closest position, a or b.
            if ((value - a) > ((b - a) / 2)) {
                return b;
            }

            return a;
        }

        if (!xSteps[j - 1]) {
            return value;
        }

        return xPct[j - 1] + closest(
            value - xPct[j - 1],
            xSteps[j - 1]
        );
    }


    // Entry parsing

    function handleEntryPoint(index, value, that) {

        var percentage;

        // Wrap numerical input in an array.
        if (typeof value === "number") {
            value = [value];
        }

        // Reject any invalid input, by testing whether value is an array.
        if (Object.prototype.toString.call(value) !== '[object Array]') {
            throw new Error("noUiSlider: 'range' contains invalid value.");
        }

        // Covert min/max syntax to 0 and 100.
        if (index === 'min') {
            percentage = 0;
        } else if (index === 'max') {
            percentage = 100;
        } else {
            percentage = parseFloat(index);
        }

        // Check for correct input.
        if (!isNumeric(percentage) || !isNumeric(value[0])) {
            throw new Error("noUiSlider: 'range' value isn't numeric.");
        }

        // Store values.
        that.xPct.push(percentage);
        that.xVal.push(value[0]);

        // NaN will evaluate to false too, but to keep
        // logging clear, set step explicitly. Make sure
        // not to override the 'step' setting with false.
        if (!percentage) {
            if (!isNaN(value[1])) {
                that.xSteps[0] = value[1];
            }
        } else {
            that.xSteps.push(isNaN(value[1]) ? false : value[1]);
        }
    }

    function handleStepPoint(i, n, that) {

        // Ignore 'false' stepping.
        if (!n) {
            return true;
        }

        // Factor to range ratio
        that.xSteps[i] = fromPercentage([
            that.xVal[i]
            , that.xVal[i + 1]
        ], n) / subRangeRatio(
            that.xPct[i],
            that.xPct[i + 1]);
    }


    // Interface

    // The interface to Spectrum handles all direction-based
    // conversions, so the above values are unaware.

    function Spectrum(entry, snap, direction, singleStep) {

        this.xPct = [];
        this.xVal = [];
        this.xSteps = [singleStep || false];
        this.xNumSteps = [false];

        this.snap = snap;
        this.direction = direction;

        var index, ordered = [ /* [0, 'min'], [1, '50%'], [2, 'max'] */];

        // Map the object keys to an array.
        for (index in entry) {
            if (entry.hasOwnProperty(index)) {
                ordered.push([entry[index], index]);
            }
        }

        // Sort all entries by value (numeric sort).
        ordered.sort(function (a, b) { return a[0] - b[0]; });

        // Convert all entries to subranges.
        for (index = 0; index < ordered.length; index++) {
            handleEntryPoint(ordered[index][1], ordered[index][0], this);
        }

        // Store the actual step values.
        // xSteps is sorted in the same order as xPct and xVal.
        this.xNumSteps = this.xSteps.slice(0);

        // Convert all numeric steps to the percentage of the subrange they represent.
        for (index = 0; index < this.xNumSteps.length; index++) {
            handleStepPoint(index, this.xNumSteps[index], this);
        }
    }

    Spectrum.prototype.getMargin = function (value) {
        return this.xPct.length === 2 ? fromPercentage(this.xVal, value) : false;
    };

    Spectrum.prototype.toStepping = function (value) {

        value = toStepping(this.xVal, this.xPct, value);

        // Invert the value if this is a right-to-left slider.
        if (this.direction) {
            value = 100 - value;
        }

        return value;
    };

    Spectrum.prototype.fromStepping = function (value) {

        // Invert the value if this is a right-to-left slider.
        if (this.direction) {
            value = 100 - value;
        }

        return accurateNumber(fromStepping(this.xVal, this.xPct, value));
    };

    Spectrum.prototype.getStep = function (value) {

        // Find the proper step for rtl sliders by search in inverse direction.
        // Fixes issue #262.
        if (this.direction) {
            value = 100 - value;
        }

        value = getStep(this.xPct, this.xSteps, this.snap, value);

        if (this.direction) {
            value = 100 - value;
        }

        return value;
    };

    Spectrum.prototype.getApplicableStep = function (value) {

        // If the value is 100%, return the negative step twice.
        var j = getJ(value, this.xPct), offset = value === 100 ? 2 : 1;
        return [this.xNumSteps[j - 2], this.xVal[j - offset], this.xNumSteps[j - offset]];
    };

    // Outside testing
    Spectrum.prototype.convert = function (value) {
        return this.getStep(this.toStepping(value));
    };

    /*	Every input option is tested and parsed. This'll prevent
        endless validation in internal methods. These tests are
        structured with an item for every option available. An
        option can be marked as required by setting the 'r' flag.
        The testing function is provided with three arguments:
            - The provided value for the option;
            - A reference to the options object;
            - The name for the option;
    
        The testing function returns false when an error is detected,
        or true when everything is OK. It can also modify the option
        object, to make sure all values can be correctly looped elsewhere. */

    /** @const */
    var defaultFormatter = {
        'to': function (value) {
            return value.toFixed(2);
        }, 'from': Number
    };

    function testStep(parsed, entry) {

        if (!isNumeric(entry)) {
            throw new Error("noUiSlider: 'step' is not numeric.");
        }

        // The step option can still be used to set stepping
        // for linear sliders. Overwritten if set in 'range'.
        parsed.singleStep = entry;
    }

    function testRange(parsed, entry) {

        // Filter incorrect input.
        if (typeof entry !== 'object' || $.isArray(entry)) {
            throw new Error("noUiSlider: 'range' is not an object.");
        }

        // Catch missing start or end.
        if (entry.min === undefined || entry.max === undefined) {
            throw new Error("noUiSlider: Missing 'min' or 'max' in 'range'.");
        }

        parsed.spectrum = new Spectrum(entry, parsed.snap, parsed.dir, parsed.singleStep);
    }

    function testStart(parsed, entry) {

        entry = asArray(entry);

        // Validate input. Values aren't tested, as the public .val method
        // will always provide a valid location.
        if (!$.isArray(entry) || !entry.length || entry.length > 2) {
            throw new Error("noUiSlider: 'start' option is incorrect.");
        }

        // Store the number of handles.
        parsed.handles = entry.length;

        // When the slider is initialized, the .val method will
        // be called with the start options.
        parsed.start = entry;
    }

    function testSnap(parsed, entry) {

        // Enforce 100% stepping within subranges.
        parsed.snap = entry;

        if (typeof entry !== 'boolean') {
            throw new Error("noUiSlider: 'snap' option must be a boolean.");
        }
    }

    function testAnimate(parsed, entry) {

        // Enforce 100% stepping within subranges.
        parsed.animate = entry;

        if (typeof entry !== 'boolean') {
            throw new Error("noUiSlider: 'animate' option must be a boolean.");
        }
    }

    function testConnect(parsed, entry) {

        if (entry === 'lower' && parsed.handles === 1) {
            parsed.connect = 1;
        } else if (entry === 'upper' && parsed.handles === 1) {
            parsed.connect = 2;
        } else if (entry === true && parsed.handles === 2) {
            parsed.connect = 3;
        } else if (entry === false) {
            parsed.connect = 0;
        } else {
            throw new Error("noUiSlider: 'connect' option doesn't match handle count.");
        }
    }

    function testOrientation(parsed, entry) {

        // Set orientation to an a numerical value for easy
        // array selection.
        switch (entry) {
            case 'horizontal':
                parsed.ort = 0;
                break;
            case 'vertical':
                parsed.ort = 1;
                break;
            default:
                throw new Error("noUiSlider: 'orientation' option is invalid.");
        }
    }

    function testMargin(parsed, entry) {

        if (!isNumeric(entry)) {
            throw new Error("noUiSlider: 'margin' option must be numeric.");
        }

        parsed.margin = parsed.spectrum.getMargin(entry);

        if (!parsed.margin) {
            throw new Error("noUiSlider: 'margin' option is only supported on linear sliders.");
        }
    }

    function testLimit(parsed, entry) {

        if (!isNumeric(entry)) {
            throw new Error("noUiSlider: 'limit' option must be numeric.");
        }

        parsed.limit = parsed.spectrum.getMargin(entry);

        if (!parsed.limit) {
            throw new Error("noUiSlider: 'limit' option is only supported on linear sliders.");
        }
    }

    function testDirection(parsed, entry) {

        // Set direction as a numerical value for easy parsing.
        // Invert connection for RTL sliders, so that the proper
        // handles get the connect/background classes.
        switch (entry) {
            case 'ltr':
                parsed.dir = 0;
                break;
            case 'rtl':
                parsed.dir = 1;
                parsed.connect = [0, 2, 1, 3][parsed.connect];
                break;
            default:
                throw new Error("noUiSlider: 'direction' option was not recognized.");
        }
    }

    function testBehaviour(parsed, entry) {

        // Make sure the input is a string.
        if (typeof entry !== 'string') {
            throw new Error("noUiSlider: 'behaviour' must be a string containing options.");
        }

        // Check if the string contains any keywords.
        // None are required.
        var tap = entry.indexOf('tap') >= 0,
            drag = entry.indexOf('drag') >= 0,
            fixed = entry.indexOf('fixed') >= 0,
            snap = entry.indexOf('snap') >= 0;

        parsed.events = {
            tap: tap || snap,
            drag: drag,
            fixed: fixed,
            snap: snap
        };
    }

    function testFormat(parsed, entry) {

        parsed.format = entry;

        // Any object with a to and from method is supported.
        if (typeof entry.to === 'function' && typeof entry.from === 'function') {
            return true;
        }

        throw new Error("noUiSlider: 'format' requires 'to' and 'from' methods.");
    }

    // Test all developer settings and parse to assumption-safe values.
    function testOptions(options) {

        var parsed = {
            margin: 0,
            limit: 0,
            animate: true,
            format: defaultFormatter
        }, tests;

        // Tests are executed in the order they are presented here.
        tests = {
            'step': { r: false, t: testStep },
            'start': { r: true, t: testStart },
            'connect': { r: true, t: testConnect },
            'direction': { r: true, t: testDirection },
            'snap': { r: false, t: testSnap },
            'animate': { r: false, t: testAnimate },
            'range': { r: true, t: testRange },
            'orientation': { r: false, t: testOrientation },
            'margin': { r: false, t: testMargin },
            'limit': { r: false, t: testLimit },
            'behaviour': { r: true, t: testBehaviour },
            'format': { r: false, t: testFormat }
        };

        // Set defaults where applicable.
        options = $.extend({
            'connect': false,
            'direction': 'ltr',
            'behaviour': 'tap',
            'orientation': 'horizontal'
        }, options);

        // Run all options through a testing mechanism to ensure correct
        // input. It should be noted that options might get modified to
        // be handled properly. E.g. wrapping integers in arrays.
        $.each(tests, function (name, test) {

            // If the option isn't set, but it is required, throw an error.
            if (options[name] === undefined) {

                if (test.r) {
                    throw new Error("noUiSlider: '" + name + "' is required.");
                }

                return true;
            }

            test.t(parsed, options[name]);
        });

        // Pre-define the styles.
        parsed.style = parsed.ort ? 'top' : 'left';

        return parsed;
    }

    // Class handling

    // Delimit proposed values for handle positions.
    function getPositions(a, b, delimit) {

        // Add movement to current position.
        var c = a + b[0], d = a + b[1];

        // Only alter the other position on drag,
        // not on standard sliding.
        if (delimit) {
            if (c < 0) {
                d += Math.abs(c);
            }
            if (d > 100) {
                c -= (d - 100);
            }

            // Limit values to 0 and 100.
            return [limit(c), limit(d)];
        }

        return [c, d];
    }


    // Event handling

    // Provide a clean event with standardized offset values.
    function fixEvent(e) {

        // Prevent scrolling and panning on touch events, while
        // attempting to slide. The tap event also depends on this.
        e.preventDefault();

        // Filter the event to register the type, which can be
        // touch, mouse or pointer. Offset changes need to be
        // made on an event specific basis.
        var touch = e.type.indexOf('touch') === 0
            , mouse = e.type.indexOf('mouse') === 0
            , pointer = e.type.indexOf('pointer') === 0
            , x, y, event = e;

        // IE10 implemented pointer events with a prefix;
        if (e.type.indexOf('MSPointer') === 0) {
            pointer = true;
        }

        // Get the originalEvent, if the event has been wrapped
        // by jQuery. Zepto doesn't wrap the event.
        if (e.originalEvent) {
            e = e.originalEvent;
        }

        if (touch) {
            // noUiSlider supports one movement at a time,
            // so we can select the first 'changedTouch'.
            x = e.changedTouches[0].pageX;
            y = e.changedTouches[0].pageY;
        }

        if (mouse || pointer) {

            // Polyfill the pageXOffset and pageYOffset
            // variables for IE7 and IE8;
            if (!pointer && window.pageXOffset === undefined) {
                window.pageXOffset = document.documentElement.scrollLeft;
                window.pageYOffset = document.documentElement.scrollTop;
            }

            x = e.clientX + window.pageXOffset;
            y = e.clientY + window.pageYOffset;
        }

        event.points = [x, y];
        event.cursor = mouse;

        return event;
    }


    // DOM additions

    // Append a handle to the base.
    function addHandle(direction, index) {

        var handle = $('<div><div/></div>').addClass(Classes[2]),
            additions = ['-lower', '-upper'];

        if (direction) {
            additions.reverse();
        }

        handle.children().addClass(
            Classes[3] + " " + Classes[3] + additions[index]
        );

        return handle;
    }

    // Add the proper connection classes.
    function addConnection(connect, target, handles) {

        // Apply the required connection classes to the elements
        // that need them. Some classes are made up for several
        // segments listed in the class list, to allow easy
        // renaming and provide a minor compression benefit.
        switch (connect) {
            case 1: target.addClass(Classes[7]);
                handles[0].addClass(Classes[6]);
                break;
            case 3: handles[1].addClass(Classes[6]);
            /* falls through */
            case 2: handles[0].addClass(Classes[7]);
            /* falls through */
            case 0: target.addClass(Classes[6]);
                break;
        }
    }

    // Add handles to the slider base.
    function addHandles(nrHandles, direction, base) {

        var index, handles = [];

        // Append handles.
        for (index = 0; index < nrHandles; index += 1) {

            // Keep a list of all added handles.
            handles.push(addHandle(direction, index).appendTo(base));
        }

        return handles;
    }

    // Initialize a single slider.
    function addSlider(direction, orientation, target) {

        // Apply classes and data to the target.
        target.addClass([
            Classes[0],
            Classes[8 + direction],
            Classes[4 + orientation]
        ].join(' '));

        return $('<div/>').appendTo(target).addClass(Classes[1]);
    }

    function closure(target, options, originalOptions) {

        // Internal variables

        // All variables local to 'closure' are marked $.
        var $Target = $(target),
            $Locations = [-1, -1],
            $Base,
            $Handles,
            $Spectrum = options.spectrum,
            $Values = [],
            // libLink. For rtl sliders, 'lower' and 'upper' should not be inverted
            // for one-handle sliders, so trim 'upper' it that case.
            triggerPos = ['lower', 'upper'].slice(0, options.handles);

        // Invert the libLink connection for rtl sliders.
        if (options.dir) {
            triggerPos.reverse();
        }

        // Helpers

        // Shorthand for base dimensions.
        function baseSize() {
            return $Base[['width', 'height'][options.ort]]();
        }

        // External event handling
        function fireEvents(events) {

            // Use the external api to get the values.
            // Wrap the values in an array, as .trigger takes
            // only one additional argument.
            var index, values = [$Target.val()];

            for (index = 0; index < events.length; index += 1) {
                $Target.trigger(events[index], values);
            }
        }

        // Returns the input array, respecting the slider direction configuration.
        function inSliderOrder(values) {

            // If only one handle is used, return a single value.
            if (values.length === 1) {
                return values[0];
            }

            if (options.dir) {
                return values.reverse();
            }

            return values;
        }

        // libLink integration

        // Create a new function which calls .val on input change.
        function createChangeHandler(trigger) {
            return function (ignore, value) {
                // Determine which array position to 'null' based on 'trigger'.
                $Target.val([trigger ? null : value, trigger ? value : null], true);
            };
        }

        // Called by libLink when it wants a set of links updated.
        function linkUpdate(flag) {

            var trigger = $.inArray(flag, triggerPos);

            // The API might not have been set yet.
            if ($Target[0].linkAPI && $Target[0].linkAPI[flag]) {
                $Target[0].linkAPI[flag].change(
                    $Values[trigger],
                    $Handles[trigger].children(),
                    $Target
                );
            }
        }

        // Called by libLink to append an element to the slider.
        function linkConfirm(flag, element) {

            // Find the trigger for the passed flag.
            var trigger = $.inArray(flag, triggerPos);

            // If set, append the element to the handle it belongs to.
            if (element) {
                element.appendTo($Handles[trigger].children());
            }

            // The public API is reversed for rtl sliders, so the changeHandler
            // should not be aware of the inverted trigger positions.
            // On rtl slider with one handle, 'lower' should be used.
            if (options.dir && options.handles > 1) {
                trigger = trigger === 1 ? 0 : 1;
            }

            return createChangeHandler(trigger);
        }

        // Place elements back on the slider.
        function reAppendLink() {

            var i, flag;

            // The API keeps a list of elements: we can re-append them on rebuild.
            for (i = 0; i < triggerPos.length; i += 1) {
                if (this.linkAPI && this.linkAPI[(flag = triggerPos[i])]) {
                    this.linkAPI[flag].reconfirm(flag);
                }
            }
        }

        target.LinkUpdate = linkUpdate;
        target.LinkConfirm = linkConfirm;
        target.LinkDefaultFormatter = options.format;
        target.LinkDefaultFlag = 'lower';

        target.reappend = reAppendLink;


        // Handler for attaching events trough a proxy.
        function attach(events, element, callback, data) {

            // This function can be used to 'filter' events to the slider.

            // Add the noUiSlider namespace to all events.
            events = events.replace(/\s/g, namespace + ' ') + namespace;

            // Bind a closure on the target.
            return element.on(events, function (e) {

                // jQuery and Zepto (1) handle unset attributes differently,
                // but always falsy; #208
                if (!!$Target.attr('disabled')) {
                    return false;
                }

                // Stop if an active 'tap' transition is taking place.
                if ($Target.hasClass(Classes[14])) {
                    return false;
                }

                e = fixEvent(e);
                e.calcPoint = e.points[options.ort];

                // Call the event handler with the event [ and additional data ].
                callback(e, data);
            });
        }

        // Handle movement on document for handle and range drag.
        function move(event, data) {

            var handles = data.handles || $Handles, positions, state = false,
                proposal = ((event.calcPoint - data.start) * 100) / baseSize(),
                h = handles[0][0] !== $Handles[0][0] ? 1 : 0;

            // Calculate relative positions for the handles.
            positions = getPositions(proposal, data.positions, handles.length > 1);

            state = setHandle(handles[0], positions[h], handles.length === 1);

            if (handles.length > 1) {
                state = setHandle(handles[1], positions[h ? 0 : 1], false) || state;
            }

            // Fire the 'slide' event if any handle moved.
            if (state) {
                fireEvents(['slide']);
            }
        }

        // Unbind move events on document, call callbacks.
        function end(event) {

            // The handle is no longer active, so remove the class.
            $('.' + Classes[15]).removeClass(Classes[15]);

            // Remove cursor styles and text-selection events bound to the body.
            if (event.cursor) {
                $('body').css('cursor', '').off(namespace);
            }

            // Unbind the move and end events, which are added on 'start'.
            doc.off(namespace);

            // Remove dragging class.
            $Target.removeClass(Classes[12]);

            // Fire the change and set events.
            fireEvents(['set', 'change']);
        }

        // Bind move events on document.
        function start(event, data) {

            // Mark the handle as 'active' so it can be styled.
            if (data.handles.length === 1) {
                data.handles[0].children().addClass(Classes[15]);
            }

            // A drag should never propagate up to the 'tap' event.
            event.stopPropagation();

            // Attach the move event.
            attach(actions.move, doc, move, {
                start: event.calcPoint,
                handles: data.handles,
                positions: [
                    $Locations[0],
                    $Locations[$Handles.length - 1]
                ]
            });

            // Unbind all movement when the drag ends.
            attach(actions.end, doc, end, null);

            // Text selection isn't an issue on touch devices,
            // so adding cursor styles can be skipped.
            if (event.cursor) {

                // Prevent the 'I' cursor and extend the range-drag cursor.
                $('body').css('cursor', $(event.target).css('cursor'));

                // Mark the target with a dragging state.
                if ($Handles.length > 1) {
                    $Target.addClass(Classes[12]);
                }

                // Prevent text selection when dragging the handles.
                $('body').on('selectstart' + namespace, false);
            }
        }

        // Move closest handle to tapped location.
        function tap(event) {

            var location = event.calcPoint, total = 0, to;

            // The tap event shouldn't propagate up and cause 'edge' to run.
            event.stopPropagation();

            // Add up the handle offsets.
            $.each($Handles, function () {
                total += this.offset()[options.style];
            });

            // Find the handle closest to the tapped position.
            total = (location < total / 2 || $Handles.length === 1) ? 0 : 1;

            location -= $Base.offset()[options.style];

            // Calculate the new position.
            to = (location * 100) / baseSize();

            if (!options.events.snap) {
                // Flag the slider as it is now in a transitional state.
                // Transition takes 300 ms, so re-enable the slider afterwards.
                addClassFor($Target, Classes[14], 300);
            }

            // Find the closest handle and calculate the tapped point.
            // The set handle to the new position.
            setHandle($Handles[total], to);

            fireEvents(['slide', 'set', 'change']);

            if (options.events.snap) {
                start(event, { handles: [$Handles[total]] });
            }
        }

        // Attach events to several slider parts.
        function events(behaviour) {

            var i, drag;

            // Attach the standard drag event to the handles.
            if (!behaviour.fixed) {

                for (i = 0; i < $Handles.length; i += 1) {

                    // These events are only bound to the visual handle
                    // element, not the 'real' origin element.
                    attach(actions.start, $Handles[i].children(), start, {
                        handles: [$Handles[i]]
                    });
                }
            }

            // Attach the tap event to the slider base.
            if (behaviour.tap) {

                attach(actions.start, $Base, tap, {
                    handles: $Handles
                });
            }

            // Make the range dragable.
            if (behaviour.drag) {

                drag = $Base.find('.' + Classes[7]).addClass(Classes[10]);

                // When the range is fixed, the entire range can
                // be dragged by the handles. The handle in the first
                // origin will propagate the start event upward,
                // but it needs to be bound manually on the other.
                if (behaviour.fixed) {
                    drag = drag.add($Base.children().not(drag).children());
                }

                attach(actions.start, drag, start, {
                    handles: $Handles
                });
            }
        }


        // Test suggested values and apply margin, step.
        function setHandle(handle, to, noLimitOption) {

            var trigger = handle[0] !== $Handles[0][0] ? 1 : 0,
                lowerMargin = $Locations[0] + options.margin,
                upperMargin = $Locations[1] - options.margin,
                lowerLimit = $Locations[0] + options.limit,
                upperLimit = $Locations[1] - options.limit;

            // For sliders with multiple handles,
            // limit movement to the other handle.
            // Apply the margin option by adding it to the handle positions.
            if ($Handles.length > 1) {
                to = trigger ? Math.max(to, lowerMargin) : Math.min(to, upperMargin);
            }

            // The limit option has the opposite effect, limiting handles to a
            // maximum distance from another. Limit must be > 0, as otherwise
            // handles would be unmoveable. 'noLimitOption' is set to 'false'
            // for the .val() method, except for pass 4/4.
            if (noLimitOption !== false && options.limit && $Handles.length > 1) {
                to = trigger ? Math.min(to, lowerLimit) : Math.max(to, upperLimit);
            }

            // Handle the step option.
            to = $Spectrum.getStep(to);

            // Limit to 0/100 for .val input, trim anything beyond 7 digits, as
            // JavaScript has some issues in its floating point implementation.
            to = limit(parseFloat(to.toFixed(7)));

            // Return false if handle can't move.
            if (to === $Locations[trigger]) {
                return false;
            }

            // Set the handle to the new position.
            handle.css(options.style, to + '%');

            // Force proper handle stacking
            if (handle.is(':first-child')) {
                handle.toggleClass(Classes[17], to > 50);
            }

            // Update locations.
            $Locations[trigger] = to;

            // Convert the value to the slider stepping/range.
            $Values[trigger] = $Spectrum.fromStepping(to);

            linkUpdate(triggerPos[trigger]);

            return true;
        }

        // Loop values from value method and apply them.
        function setValues(count, values) {

            var i, trigger, to;

            // With the limit option, we'll need another limiting pass.
            if (options.limit) {
                count += 1;
            }

            // If there are multiple handles to be set run the setting
            // mechanism twice for the first handle, to make sure it
            // can be bounced of the second one properly.
            for (i = 0; i < count; i += 1) {

                trigger = i % 2;

                // Get the current argument from the array.
                to = values[trigger];

                // Setting with null indicates an 'ignore'.
                // Inputting 'false' is invalid.
                if (to !== null && to !== false) {

                    // If a formatted number was passed, attemt to decode it.
                    if (typeof to === 'number') {
                        to = String(to);
                    }

                    to = options.format.from(to);

                    // Request an update for all links if the value was invalid.
                    // Do so too if setting the handle fails.
                    if (to === false || isNaN(to) || setHandle($Handles[trigger], $Spectrum.toStepping(to), i === (3 - options.dir)) === false) {

                        linkUpdate(triggerPos[trigger]);
                    }
                }
            }
        }

        // Set the slider value.
        function valueSet(input) {

            // LibLink: don't accept new values when currently emitting changes.
            if ($Target[0].LinkIsEmitting) {
                return this;
            }

            var count, values = asArray(input);

            // The RTL settings is implemented by reversing the front-end,
            // internal mechanisms are the same.
            if (options.dir && options.handles > 1) {
                values.reverse();
            }

            // Animation is optional.
            // Make sure the initial values where set before using animated
            // placement. (no report, unit testing);
            if (options.animate && $Locations[0] !== -1) {
                addClassFor($Target, Classes[14], 300);
            }

            // Determine how often to set the handles.
            count = $Handles.length > 1 ? 3 : 1;

            if (values.length === 1) {
                count = 1;
            }

            setValues(count, values);

            // Fire the 'set' event. As of noUiSlider 7,
            // this is no longer optional.
            fireEvents(['set']);

            return this;
        }

        // Get the slider value.
        function valueGet() {

            var i, retour = [];

            // Get the value from all handles.
            for (i = 0; i < options.handles; i += 1) {
                retour[i] = options.format.to($Values[i]);
            }

            return inSliderOrder(retour);
        }

        // Destroy the slider and unbind all events.
        function destroyTarget() {

            // Unbind events on the slider, remove all classes and child elements.
            $(this).off(namespace)
                .removeClass(Classes.join(' '))
                .empty();

            delete this.LinkUpdate;
            delete this.LinkConfirm;
            delete this.LinkDefaultFormatter;
            delete this.LinkDefaultFlag;
            delete this.reappend;
            delete this.vGet;
            delete this.vSet;
            delete this.getCurrentStep;
            delete this.getInfo;
            delete this.destroy;

            // Return the original options from the closure.
            return originalOptions;
        }

        // Get the current step size for the slider.
        function getCurrentStep() {

            // Check all locations, map them to their stepping point.
            // Get the step point, then find it in the input list.
            var retour = $.map($Locations, function (location, index) {

                var step = $Spectrum.getApplicableStep(location),

                    // As per #391, the comparison for the decrement step can have some rounding issues.
                    // Round the value to the precision used in the step.
                    stepDecimals = countDecimals(String(step[2])),

                    // Get the current numeric value
                    value = $Values[index],

                    // To move the slider 'one step up', the current step value needs to be added.
                    // Use null if we are at the maximum slider value.
                    increment = location === 100 ? null : step[2],

                    // Going 'one step down' might put the slider in a different sub-range, so we
                    // need to switch between the current or the previous step.
                    prev = Number((value - step[2]).toFixed(stepDecimals)),

                    // If the value fits the step, return the current step value. Otherwise, use the
                    // previous step. Return null if the slider is at its minimum value.
                    decrement = location === 0 ? null : (prev >= step[1]) ? step[2] : (step[0] || false);

                return [[decrement, increment]];
            });

            // Return values in the proper order.
            return inSliderOrder(retour);
        }

        // Get the original set of options.
        function getOriginalOptions() {
            return originalOptions;
        }


        // Initialize slider

        // Throw an error if the slider was already initialized.
        if ($Target.hasClass(Classes[0])) {
            throw new Error('Slider was already initialized.');
        }

        // Create the base element, initialise HTML and set classes.
        // Add handles and links.
        $Base = addSlider(options.dir, options.ort, $Target);
        $Handles = addHandles(options.handles, options.dir, $Base);

        // Set the connect classes.
        addConnection(options.connect, $Target, $Handles);

        // Attach user events.
        events(options.events);

        // Methods

        target.vSet = valueSet;
        target.vGet = valueGet;
        target.destroy = destroyTarget;

        target.getCurrentStep = getCurrentStep;
        target.getOriginalOptions = getOriginalOptions;

        target.getInfo = function () {
            return [
                $Spectrum,
                options.style,
                options.ort
            ];
        };

        // Use the public value method to set the start values.
        $Target.val(options.start);

    }


    // Run the standard initializer
    function initialize(originalOptions) {

        // Test the options once, not for every slider.
        var options = testOptions(originalOptions, this);

        // Loop all items, and provide a new closed-scope environment.
        return this.each(function () {
            closure(this, options, originalOptions);
        });
    }

    // Destroy the slider, then re-enter initialization.
    function rebuild(options) {

        return this.each(function () {

            // The rebuild flag can be used if the slider wasn't initialized yet.
            if (!this.destroy) {
                $(this).noUiSlider(options);
                return;
            }

            // Get the current values from the slider,
            // including the initialization options.
            var values = $(this).val(), originalOptions = this.destroy(),

                // Extend the previous options with the newly provided ones.
                newOptions = $.extend({}, originalOptions, options);

            // Run the standard initializer.
            $(this).noUiSlider(newOptions);

            // Place Link elements back.
            this.reappend();

            // If the start option hasn't changed,
            // reset the previous values.
            if (originalOptions.start === newOptions.start) {
                $(this).val(values);
            }
        });
    }

    // Access the internal getting and setting methods based on argument count.
    function value() {
        return this[0][!arguments.length ? 'vGet' : 'vSet'].apply(this[0], arguments);
    }

    // Override the .val() method. Test every element. Is it a slider? Go to
    // the slider value handling. No? Use the standard method.
    // Note how $.fn.val expects 'this' to be an instance of $. For convenience,
    // the above 'value' function does too.
    $.fn.val = function (arg) {

        // this === instanceof $

        function valMethod(a) {
            return a.hasClass(Classes[0]) ? value : $val;
        }

        // If no value is passed, this is 'get'.
        if (!arguments.length) {
            var first = $(this[0]);
            return valMethod(first).call(first);
        }

        var isFunction = $.isFunction(arg);

        // Return the set so it remains chainable. Make sure not to break
        // jQuery's .val(function( index, value ){}) signature.
        return this.each(function (i) {

            var val = arg, $t = $(this);

            if (isFunction) {
                val = arg.call(this, i, $t.val());
            }

            valMethod($t).call($t, val);
        });
    };

    // Extend jQuery/Zepto with the noUiSlider method.
    $.fn.noUiSlider = function (options, rebuildFlag) {

        switch (options) {
            case 'step': return this[0].getCurrentStep();
            case 'options': return this[0].getOriginalOptions();
        }

        return (rebuildFlag ? rebuild : initialize).call(this, options);
    };

}(window.jQuery || window.Zepto));
;
//fgnass.github.com/spin.js#v2.0.1
!function (a, b) { "object" == typeof exports ? module.exports = b() : "function" == typeof define && define.amd ? define(b) : a.Spinner = b() }(this, function () { "use strict"; function a(a, b) { var c, d = document.createElement(a || "div"); for (c in b) d[c] = b[c]; return d } function b(a) { for (var b = 1, c = arguments.length; c > b; b++)a.appendChild(arguments[b]); return a } function c(a, b, c, d) { var e = ["opacity", b, ~~(100 * a), c, d].join("-"), f = .01 + c / d * 100, g = Math.max(1 - (1 - a) / b * (100 - f), a), h = j.substring(0, j.indexOf("Animation")).toLowerCase(), i = h && "-" + h + "-" || ""; return l[e] || (m.insertRule("@" + i + "keyframes " + e + "{0%{opacity:" + g + "}" + f + "%{opacity:" + a + "}" + (f + .01) + "%{opacity:1}" + (f + b) % 100 + "%{opacity:" + a + "}100%{opacity:" + g + "}}", m.cssRules.length), l[e] = 1), e } function d(a, b) { var c, d, e = a.style; for (b = b.charAt(0).toUpperCase() + b.slice(1), d = 0; d < k.length; d++)if (c = k[d] + b, void 0 !== e[c]) return c; return void 0 !== e[b] ? b : void 0 } function e(a, b) { for (var c in b) a.style[d(a, c) || c] = b[c]; return a } function f(a) { for (var b = 1; b < arguments.length; b++) { var c = arguments[b]; for (var d in c) void 0 === a[d] && (a[d] = c[d]) } return a } function g(a, b) { return "string" == typeof a ? a : a[b % a.length] } function h(a) { this.opts = f(a || {}, h.defaults, n) } function i() { function c(b, c) { return a("<" + b + ' xmlns="urn:schemas-microsoft.com:vml" class="spin-vml">', c) } m.addRule(".spin-vml", "behavior:url(#default#VML)"), h.prototype.lines = function (a, d) { function f() { return e(c("group", { coordsize: k + " " + k, coordorigin: -j + " " + -j }), { width: k, height: k }) } function h(a, h, i) { b(m, b(e(f(), { rotation: 360 / d.lines * a + "deg", left: ~~h }), b(e(c("roundrect", { arcsize: d.corners }), { width: j, height: d.width, left: d.radius, top: -d.width >> 1, filter: i }), c("fill", { color: g(d.color, a), opacity: d.opacity }), c("stroke", { opacity: 0 })))) } var i, j = d.length + d.width, k = 2 * j, l = 2 * -(d.width + d.length) + "px", m = e(f(), { position: "absolute", top: l, left: l }); if (d.shadow) for (i = 1; i <= d.lines; i++)h(i, -2, "progid:DXImageTransform.Microsoft.Blur(pixelradius=2,makeshadow=1,shadowopacity=.3)"); for (i = 1; i <= d.lines; i++)h(i); return b(a, m) }, h.prototype.opacity = function (a, b, c, d) { var e = a.firstChild; d = d.shadow && d.lines || 0, e && b + d < e.childNodes.length && (e = e.childNodes[b + d], e = e && e.firstChild, e = e && e.firstChild, e && (e.opacity = c)) } } var j, k = ["webkit", "Moz", "ms", "O"], l = {}, m = function () { var c = a("style", { type: "text/css" }); return b(document.getElementsByTagName("head")[0], c), c.sheet || c.styleSheet }(), n = { lines: 12, length: 7, width: 5, radius: 10, rotate: 0, corners: 1, color: "#000", direction: 1, speed: 1, trail: 100, opacity: .25, fps: 20, zIndex: 2e9, className: "spinner", top: "50%", left: "50%", position: "absolute" }; h.defaults = {}, f(h.prototype, { spin: function (b) { this.stop(); { var c = this, d = c.opts, f = c.el = e(a(0, { className: d.className }), { position: d.position, width: 0, zIndex: d.zIndex }); d.radius + d.length + d.width } if (e(f, { left: d.left, top: d.top }), b && b.insertBefore(f, b.firstChild || null), f.setAttribute("role", "progressbar"), c.lines(f, c.opts), !j) { var g, h = 0, i = (d.lines - 1) * (1 - d.direction) / 2, k = d.fps, l = k / d.speed, m = (1 - d.opacity) / (l * d.trail / 100), n = l / d.lines; !function o() { h++; for (var a = 0; a < d.lines; a++)g = Math.max(1 - (h + (d.lines - a) * n) % l * m, d.opacity), c.opacity(f, a * d.direction + i, g, d); c.timeout = c.el && setTimeout(o, ~~(1e3 / k)) }() } return c }, stop: function () { var a = this.el; return a && (clearTimeout(this.timeout), a.parentNode && a.parentNode.removeChild(a), this.el = void 0), this }, lines: function (d, f) { function h(b, c) { return e(a(), { position: "absolute", width: f.length + f.width + "px", height: f.width + "px", background: b, boxShadow: c, transformOrigin: "left", transform: "rotate(" + ~~(360 / f.lines * k + f.rotate) + "deg) translate(" + f.radius + "px,0)", borderRadius: (f.corners * f.width >> 1) + "px" }) } for (var i, k = 0, l = (f.lines - 1) * (1 - f.direction) / 2; k < f.lines; k++)i = e(a(), { position: "absolute", top: 1 + ~(f.width / 2) + "px", transform: f.hwaccel ? "translate3d(0,0,0)" : "", opacity: f.opacity, animation: j && c(f.opacity, f.trail, l + k * f.direction, f.lines) + " " + 1 / f.speed + "s linear infinite" }), f.shadow && b(i, e(h("#000", "0 0 4px #000"), { top: "2px" })), b(d, b(i, h(g(f.color, k), "0 0 1px rgba(0,0,0,.1)"))); return d }, opacity: function (a, b, c) { b < a.childNodes.length && (a.childNodes[b].style.opacity = c) } }); var o = e(a("group"), { behavior: "url(#default#VML)" }); return !d(o, "transform") && o.adj ? i() : j = d(o, "animation"), h });
;
// Chosen, a Select Box Enhancer for jQuery and Protoype
// by Patrick Filler for Harvest, http://getharvest.com
//
// Version 0.9.14
// Full source at https://github.com/harvesthq/chosen
// Copyright (c) 2011 Harvest http://getharvest.com

// MIT License, https://github.com/harvesthq/chosen/blob/master/LICENSE.md
// This file is generated by `cake build`, do not edit it by hand.
(function () {
    var SelectParser;

    SelectParser = (function () {

        function SelectParser() {
            this.options_index = 0;
            this.parsed = [];
        }

        SelectParser.prototype.add_node = function (child) {
            if (child.nodeName.toUpperCase() === "OPTGROUP") {
                return this.add_group(child);
            } else {
                return this.add_option(child);
            }
        };

        SelectParser.prototype.add_group = function (group) {
            var group_position, option, _i, _len, _ref, _results;
            group_position = this.parsed.length;
            this.parsed.push({
                array_index: group_position,
                group: true,
                label: group.label,
                children: 0,
                disabled: group.disabled
            });
            _ref = group.childNodes;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                option = _ref[_i];
                _results.push(this.add_option(option, group_position, group.disabled));
            }
            return _results;
        };

        SelectParser.prototype.add_option = function (option, group_position, group_disabled) {
            if (option.nodeName.toUpperCase() === "OPTION") {
                if (option.text !== "") {
                    if (group_position != null) {
                        this.parsed[group_position].children += 1;
                    }
                    this.parsed.push({
                        array_index: this.parsed.length,
                        options_index: this.options_index,
                        value: option.value,
                        text: option.text,
                        html: option.innerHTML,
                        selected: option.selected,
                        disabled: group_disabled === true ? group_disabled : option.disabled,
                        group_array_index: group_position,
                        classes: option.className,
                        style: option.style.cssText
                    });
                } else {
                    this.parsed.push({
                        array_index: this.parsed.length,
                        options_index: this.options_index,
                        empty: true
                    });
                }
                return this.options_index += 1;
            }
        };

        return SelectParser;

    })();

    SelectParser.select_to_array = function (select) {
        var child, parser, _i, _len, _ref;
        parser = new SelectParser();
        _ref = select.childNodes;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            child = _ref[_i];
            parser.add_node(child);
        }
        return parser.parsed;
    };

    this.SelectParser = SelectParser;

}).call(this);

/*
Chosen source: generate output using 'cake build'
Copyright (c) 2011 by Harvest
*/


(function () {
    var AbstractChosen, root;

    root = this;

    AbstractChosen = (function () {

        function AbstractChosen(form_field, options) {
            this.form_field = form_field;
            this.options = options != null ? options : {};
            if (!AbstractChosen.browser_is_supported()) {
                return;
            }
            this.is_multiple = this.form_field.multiple;
            this.set_default_text();
            this.set_default_values();
            this.setup();
            this.set_up_html();
            this.register_observers();
            this.finish_setup();
        }

        AbstractChosen.prototype.set_default_values = function () {
            var _this = this;
            this.click_test_action = function (evt) {
                return _this.test_active_click(evt);
            };
            this.activate_action = function (evt) {
                return _this.activate_field(evt);
            };
            this.active_field = false;
            this.mouse_on_container = false;
            this.results_showing = false;
            this.result_highlighted = null;
            this.result_single_selected = null;
            this.allow_single_deselect = (this.options.allow_single_deselect != null) && (this.form_field.options[0] != null) && this.form_field.options[0].text === "" ? this.options.allow_single_deselect : false;
            this.disable_search_threshold = this.options.disable_search_threshold || 0;
            this.disable_search = this.options.disable_search || false;
            this.enable_split_word_search = this.options.enable_split_word_search != null ? this.options.enable_split_word_search : true;
            this.search_contains = this.options.search_contains || false;
            this.choices = 0;
            this.single_backstroke_delete = this.options.single_backstroke_delete || false;
            this.max_selected_options = this.options.max_selected_options || Infinity;
            return this.inherit_select_classes = this.options.inherit_select_classes || false;
        };

        AbstractChosen.prototype.set_default_text = function () {
            if (this.form_field.getAttribute("data-placeholder")) {
                this.default_text = this.form_field.getAttribute("data-placeholder");
            } else if (this.is_multiple) {
                this.default_text = this.options.placeholder_text_multiple || this.options.placeholder_text || AbstractChosen.default_multiple_text;
            } else {
                this.default_text = this.options.placeholder_text_single || this.options.placeholder_text || AbstractChosen.default_single_text;
            }
            return this.results_none_found = this.form_field.getAttribute("data-no_results_text") || this.options.no_results_text || AbstractChosen.default_no_result_text;
        };

        AbstractChosen.prototype.mouse_enter = function () {
            return this.mouse_on_container = true;
        };

        AbstractChosen.prototype.mouse_leave = function () {
            return this.mouse_on_container = false;
        };

        AbstractChosen.prototype.input_focus = function (evt) {
            var _this = this;
            if (this.is_multiple) {
                if (!this.active_field) {
                    return setTimeout((function () {
                        return _this.container_mousedown();
                    }), 50);
                }
            } else {
                if (!this.active_field) {
                    return this.activate_field();
                }
            }
        };

        AbstractChosen.prototype.input_blur = function (evt) {
            var _this = this;
            if (!this.mouse_on_container) {
                this.active_field = false;
                return setTimeout((function () {
                    return _this.blur_test();
                }), 100);
            }
        };

        AbstractChosen.prototype.result_add_option = function (option) {
            var classes, style;
            if (!option.disabled) {
                option.dom_id = this.container_id + "_o_" + option.array_index;
                classes = option.selected && this.is_multiple ? [] : ["active-result"];
                if (option.selected) {
                    classes.push("result-selected");
                }
                if (option.group_array_index != null) {
                    classes.push("group-option");
                }
                if (option.classes !== "") {
                    classes.push(option.classes);
                }
                style = option.style.cssText !== "" ? " style=\"" + option.style + "\"" : "";
                return '<li id="' + option.dom_id + '" class="' + classes.join(' ') + '"' + style + '>' + option.html + '</li>';
            } else {
                return "";
            }
        };

        AbstractChosen.prototype.results_update_field = function () {
            this.set_default_text();
            if (!this.is_multiple) {
                this.results_reset_cleanup();
            }
            this.result_clear_highlight();
            this.result_single_selected = null;
            return this.results_build();
        };

        AbstractChosen.prototype.results_toggle = function () {
            if (this.results_showing) {
                return this.results_hide();
            } else {
                return this.results_show();
            }
        };

        AbstractChosen.prototype.results_search = function (evt) {
            if (this.results_showing) {
                return this.winnow_results();
            } else {
                return this.results_show();
            }
        };

        AbstractChosen.prototype.choices_click = function (evt) {
            evt.preventDefault();
            if (!this.results_showing) {
                return this.results_show();
            }
        };

        AbstractChosen.prototype.keyup_checker = function (evt) {
            var stroke, _ref;
            stroke = (_ref = evt.which) != null ? _ref : evt.keyCode;
            this.search_field_scale();
            switch (stroke) {
                case 8:
                    if (this.is_multiple && this.backstroke_length < 1 && this.choices > 0) {
                        return this.keydown_backstroke();
                    } else if (!this.pending_backstroke) {
                        this.result_clear_highlight();
                        return this.results_search();
                    }
                    break;
                case 13:
                    evt.preventDefault();
                    if (this.results_showing) {
                        return this.result_select(evt);
                    }
                    break;
                case 27:
                    if (this.results_showing) {
                        this.results_hide();
                    }
                    return true;
                case 9:
                case 38:
                case 40:
                case 16:
                case 91:
                case 17:
                    break;
                default:
                    return this.results_search();
            }
        };

        AbstractChosen.prototype.generate_field_id = function () {
            var new_id;
            new_id = this.generate_random_id();
            this.form_field.id = new_id;
            return new_id;
        };

        AbstractChosen.prototype.generate_random_char = function () {
            var chars, newchar, rand;
            chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
            rand = Math.floor(Math.random() * chars.length);
            return newchar = chars.substring(rand, rand + 1);
        };

        AbstractChosen.prototype.container_width = function () {
            var width;
            if (this.options.width != null) {
                return this.options.width;
            }
            width = window.getComputedStyle != null ? parseFloat(window.getComputedStyle(this.form_field).getPropertyValue('width')) : (typeof jQuery !== "undefined" && jQuery !== null) && (this.form_field_jq != null) ? this.form_field_jq.outerWidth() : this.form_field.getWidth();
            return width + "px";
        };

        AbstractChosen.browser_is_supported = function () {
            var _ref;
            if (window.navigator.appName === "Microsoft Internet Explorer") {
                return (null !== (_ref = document.documentMode) && _ref >= 8);
            }
            return true;
        };

        AbstractChosen.default_multiple_text = "Select Some Options";

        AbstractChosen.default_single_text = "Select an Option";

        AbstractChosen.default_no_result_text = "No results match";

        return AbstractChosen;

    })();

    root.AbstractChosen = AbstractChosen;

}).call(this);

/*
Chosen source: generate output using 'cake build'
Copyright (c) 2011 by Harvest
*/


(function () {
    var $, Chosen, root,
        __hasProp = {}.hasOwnProperty,
        __extends = function (child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

    root = this;

    $ = jQuery;

    $.fn.extend({
        chosen: function (options) {
            if (!AbstractChosen.browser_is_supported()) {
                return this;
            }
            return this.each(function (input_field) {
                var $this;
                $this = $(this);
                if (!$this.hasClass("chzn-done")) {
                    return $this.data('chosen', new Chosen(this, options));
                }
            });
        }
    });

    Chosen = (function (_super) {

        __extends(Chosen, _super);

        function Chosen() {
            return Chosen.__super__.constructor.apply(this, arguments);
        }

        Chosen.prototype.setup = function () {
            this.form_field_jq = $(this.form_field);
            this.current_selectedIndex = this.form_field.selectedIndex;
            return this.is_rtl = this.form_field_jq.hasClass("chzn-rtl");
        };

        Chosen.prototype.finish_setup = function () {
            return this.form_field_jq.addClass("chzn-done");
        };

        Chosen.prototype.set_up_html = function () {
            var container_classes, container_props;
            this.container_id = this.form_field.id.length ? this.form_field.id.replace(/[^\w]/g, '_') : this.generate_field_id();
            this.container_id += "_chzn";
            container_classes = ["chzn-container"];
            container_classes.push("chzn-container-" + (this.is_multiple ? "multi" : "single"));
            if (this.inherit_select_classes && this.form_field.className) {
                container_classes.push(this.form_field.className);
            }
            if (this.is_rtl) {
                container_classes.push("chzn-rtl");
            }
            container_props = {
                'id': this.container_id,
                'class': container_classes.join(' '),
                'style': "width: " + (this.container_width()) + ";",
                'title': this.form_field.title
            };
            this.container = $("<div />", container_props);
            if (this.is_multiple) {
                this.container.html('<ul class="chzn-choices"><li class="search-field"><input type="text" value="' + this.default_text + '" class="default" autocomplete="off" style="width:25px;" /></li></ul><div class="chzn-drop"><ul class="chzn-results"></ul></div>');
            } else {
                this.container.html('<a href="javascript:void(0)" class="chzn-single chzn-default" tabindex="-1"><span>' + this.default_text + '</span><div><b></b></div></a><div class="chzn-drop"><div class="chzn-search"><input type="text" autocomplete="off" /></div><ul class="chzn-results"></ul></div>');
            }
            this.form_field_jq.hide().after(this.container);
            this.dropdown = this.container.find('div.chzn-drop').first();
            this.search_field = this.container.find('input').first();
            this.search_results = this.container.find('ul.chzn-results').first();
            this.search_field_scale();
            this.search_no_results = this.container.find('li.no-results').first();
            if (this.is_multiple) {
                this.search_choices = this.container.find('ul.chzn-choices').first();
                this.search_container = this.container.find('li.search-field').first();
            } else {
                this.search_container = this.container.find('div.chzn-search').first();
                this.selected_item = this.container.find('.chzn-single').first();
            }
            this.results_build();
            this.set_tab_index();
            this.set_label_behavior();
            return this.form_field_jq.trigger("liszt:ready", {
                chosen: this
            });
        };

        Chosen.prototype.register_observers = function () {
            var _this = this;
            this.container.mousedown(function (evt) {
                _this.container_mousedown(evt);
            });
            this.container.mouseup(function (evt) {
                _this.container_mouseup(evt);
            });
            this.container.mouseenter(function (evt) {
                _this.mouse_enter(evt);
            });
            this.container.mouseleave(function (evt) {
                _this.mouse_leave(evt);
            });
            this.search_results.mouseup(function (evt) {
                _this.search_results_mouseup(evt);
            });
            this.search_results.mouseover(function (evt) {
                _this.search_results_mouseover(evt);
            });
            this.search_results.mouseout(function (evt) {
                _this.search_results_mouseout(evt);
            });
            this.search_results.bind('mousewheel DOMMouseScroll', function (evt) {
                _this.search_results_mousewheel(evt);
            });
            this.form_field_jq.bind("liszt:updated", function (evt) {
                _this.results_update_field(evt);
            });
            this.form_field_jq.bind("liszt:activate", function (evt) {
                _this.activate_field(evt);
            });
            this.form_field_jq.bind("liszt:open", function (evt) {
                _this.container_mousedown(evt);
            });
            this.search_field.blur(function (evt) {
                _this.input_blur(evt);
            });
            this.search_field.keyup(function (evt) {
                _this.keyup_checker(evt);
            });
            this.search_field.keydown(function (evt) {
                _this.keydown_checker(evt);
            });
            this.search_field.focus(function (evt) {
                _this.input_focus(evt);
            });
            if (this.is_multiple) {
                return this.search_choices.click(function (evt) {
                    _this.choices_click(evt);
                });
            } else {
                return this.container.click(function (evt) {
                    evt.preventDefault();
                });
            }
        };

        Chosen.prototype.search_field_disabled = function () {
            this.is_disabled = this.form_field_jq[0].disabled;
            if (this.is_disabled) {
                this.container.addClass('chzn-disabled');
                this.search_field[0].disabled = true;
                if (!this.is_multiple) {
                    this.selected_item.unbind("focus", this.activate_action);
                }
                return this.close_field();
            } else {
                this.container.removeClass('chzn-disabled');
                this.search_field[0].disabled = false;
                if (!this.is_multiple) {
                    return this.selected_item.bind("focus", this.activate_action);
                }
            }
        };

        Chosen.prototype.container_mousedown = function (evt) {
            if (!this.is_disabled) {
                if (evt && evt.type === "mousedown" && !this.results_showing) {
                    evt.preventDefault();
                }
                if (!((evt != null) && ($(evt.target)).hasClass("search-choice-close"))) {
                    if (!this.active_field) {
                        if (this.is_multiple) {
                            this.search_field.val("");
                        }
                        $(document).click(this.click_test_action);
                        this.results_show();
                    } else if (!this.is_multiple && evt && (($(evt.target)[0] === this.selected_item[0]) || $(evt.target).parents("a.chzn-single").length)) {
                        evt.preventDefault();
                        this.results_toggle();
                    }
                    return this.activate_field();
                }
            }
        };

        Chosen.prototype.container_mouseup = function (evt) {
            if (evt.target.nodeName === "ABBR" && !this.is_disabled) {
                return this.results_reset(evt);
            }
        };

        Chosen.prototype.search_results_mousewheel = function (evt) {
            var delta, _ref, _ref1;
            delta = -((_ref = evt.originalEvent) != null ? _ref.wheelDelta : void 0) || ((_ref1 = evt.originialEvent) != null ? _ref1.detail : void 0);
            if (delta != null) {
                evt.preventDefault();
                if (evt.type === 'DOMMouseScroll') {
                    delta = delta * 40;
                }
                return this.search_results.scrollTop(delta + this.search_results.scrollTop());
            }
        };

        Chosen.prototype.blur_test = function (evt) {
            if (!this.active_field && this.container.hasClass("chzn-container-active")) {
                return this.close_field();
            }
        };

        Chosen.prototype.close_field = function () {
            $(document).unbind("click", this.click_test_action);
            this.active_field = false;
            this.results_hide();
            this.container.removeClass("chzn-container-active");
            this.winnow_results_clear();
            this.clear_backstroke();
            this.show_search_field_default();
            return this.search_field_scale();
        };

        Chosen.prototype.activate_field = function () {
            this.container.addClass("chzn-container-active");
            this.active_field = true;
            this.search_field.val(this.search_field.val());
            return this.search_field.focus();
        };

        Chosen.prototype.test_active_click = function (evt) {
            if ($(evt.target).parents('#' + this.container_id).length) {
                return this.active_field = true;
            } else {
                return this.close_field();
            }
        };

        Chosen.prototype.results_build = function () {
            var content, data, _i, _len, _ref;
            this.parsing = true;
            this.results_data = root.SelectParser.select_to_array(this.form_field);
            if (this.is_multiple && this.choices > 0) {
                this.search_choices.find("li.search-choice").remove();
                this.choices = 0;
            } else if (!this.is_multiple) {
                this.selected_item.addClass("chzn-default").find("span").text(this.default_text);
                if (this.disable_search || this.form_field.options.length <= this.disable_search_threshold) {
                    this.container.addClass("chzn-container-single-nosearch");
                } else {
                    this.container.removeClass("chzn-container-single-nosearch");
                }
            }
            content = '';
            _ref = this.results_data;
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                data = _ref[_i];
                if (data.group) {
                    content += this.result_add_group(data);
                } else if (!data.empty) {
                    content += this.result_add_option(data);
                    if (data.selected && this.is_multiple) {
                        this.choice_build(data);
                    } else if (data.selected && !this.is_multiple) {
                        this.selected_item.removeClass("chzn-default").find("span").text(data.text);
                        if (this.allow_single_deselect) {
                            this.single_deselect_control_build();
                        }
                    }
                }
            }
            this.search_field_disabled();
            this.show_search_field_default();
            this.search_field_scale();
            this.search_results.html(content);
            return this.parsing = false;
        };

        Chosen.prototype.result_add_group = function (group) {
            if (!group.disabled) {
                group.dom_id = this.container_id + "_g_" + group.array_index;
                return '<li id="' + group.dom_id + '" class="group-result">' + $("<div />").text(group.label).html() + '</li>';
            } else {
                return "";
            }
        };

        Chosen.prototype.result_do_highlight = function (el) {
            var high_bottom, high_top, maxHeight, visible_bottom, visible_top;
            if (el.length) {
                this.result_clear_highlight();
                this.result_highlight = el;
                this.result_highlight.addClass("highlighted");
                maxHeight = parseInt(this.search_results.css("maxHeight"), 10);
                visible_top = this.search_results.scrollTop();
                visible_bottom = maxHeight + visible_top;
                high_top = this.result_highlight.position().top + this.search_results.scrollTop();
                high_bottom = high_top + this.result_highlight.outerHeight();
                if (high_bottom >= visible_bottom) {
                    return this.search_results.scrollTop((high_bottom - maxHeight) > 0 ? high_bottom - maxHeight : 0);
                } else if (high_top < visible_top) {
                    return this.search_results.scrollTop(high_top);
                }
            }
        };

        Chosen.prototype.result_clear_highlight = function () {
            if (this.result_highlight) {
                this.result_highlight.removeClass("highlighted");
            }
            return this.result_highlight = null;
        };

        Chosen.prototype.results_show = function () {
            if (this.result_single_selected != null) {
                this.result_do_highlight(this.result_single_selected);
            } else if (this.is_multiple && this.max_selected_options <= this.choices) {
                this.form_field_jq.trigger("liszt:maxselected", {
                    chosen: this
                });
                return false;
            }
            this.container.addClass("chzn-with-drop");
            this.form_field_jq.trigger("liszt:showing_dropdown", {
                chosen: this
            });
            this.results_showing = true;
            this.search_field.focus();
            this.search_field.val(this.search_field.val());
            return this.winnow_results();
        };

        Chosen.prototype.results_hide = function () {
            this.result_clear_highlight();
            this.container.removeClass("chzn-with-drop");
            this.form_field_jq.trigger("liszt:hiding_dropdown", {
                chosen: this
            });
            return this.results_showing = false;
        };

        Chosen.prototype.set_tab_index = function (el) {
            var ti;
            if (this.form_field_jq.attr("tabindex")) {
                ti = this.form_field_jq.attr("tabindex");
                this.form_field_jq.attr("tabindex", -1);
                return this.search_field.attr("tabindex", ti);
            }
        };

        Chosen.prototype.set_label_behavior = function () {
            var _this = this;
            this.form_field_label = this.form_field_jq.parents("label");
            if (!this.form_field_label.length && this.form_field.id.length) {
                this.form_field_label = $("label[for=" + this.form_field.id + "]");
            }
            if (this.form_field_label.length > 0) {
                return this.form_field_label.click(function (evt) {
                    if (_this.is_multiple) {
                        return _this.container_mousedown(evt);
                    } else {
                        return _this.activate_field();
                    }
                });
            }
        };

        Chosen.prototype.show_search_field_default = function () {
            if (this.is_multiple && this.choices < 1 && !this.active_field) {
                this.search_field.val(this.default_text);
                return this.search_field.addClass("default");
            } else {
                this.search_field.val("");
                return this.search_field.removeClass("default");
            }
        };

        Chosen.prototype.search_results_mouseup = function (evt) {
            var target;
            target = $(evt.target).hasClass("active-result") ? $(evt.target) : $(evt.target).parents(".active-result").first();
            if (target.length) {
                this.result_highlight = target;
                this.result_select(evt);
                return this.search_field.focus();
            }
        };

        Chosen.prototype.search_results_mouseover = function (evt) {
            var target;
            target = $(evt.target).hasClass("active-result") ? $(evt.target) : $(evt.target).parents(".active-result").first();
            if (target) {
                return this.result_do_highlight(target);
            }
        };

        Chosen.prototype.search_results_mouseout = function (evt) {
            if ($(evt.target).hasClass("active-result" || $(evt.target).parents('.active-result').first())) {
                return this.result_clear_highlight();
            }
        };

        Chosen.prototype.choice_build = function (item) {
            var choice_id, html, link,
                _this = this;
            if (this.is_multiple && this.max_selected_options <= this.choices) {
                this.form_field_jq.trigger("liszt:maxselected", {
                    chosen: this
                });
                return false;
            }
            choice_id = this.container_id + "_c_" + item.array_index;
            this.choices += 1;
            if (item.disabled) {
                html = '<li class="search-choice search-choice-disabled" id="' + choice_id + '"><span>' + item.html + '</span></li>';
            } else {
                html = '<li class="search-choice" id="' + choice_id + '"><span>' + item.html + '</span><a href="javascript:void(0)" class="search-choice-close" rel="' + item.array_index + '"></a></li>';
            }
            this.search_container.before(html);
            link = $('#' + choice_id).find("a").first();
            return link.click(function (evt) {
                return _this.choice_destroy_link_click(evt);
            });
        };

        Chosen.prototype.choice_destroy_link_click = function (evt) {
            evt.preventDefault();
            evt.stopPropagation();
            if (!this.is_disabled) {
                return this.choice_destroy($(evt.target));
            }
        };

        Chosen.prototype.choice_destroy = function (link) {
            if (this.result_deselect(link.attr("rel"))) {
                this.choices -= 1;
                this.show_search_field_default();
                if (this.is_multiple && this.choices > 0 && this.search_field.val().length < 1) {
                    this.results_hide();
                }
                link.parents('li').first().remove();
                return this.search_field_scale();
            }
        };

        Chosen.prototype.results_reset = function () {
            this.form_field.options[0].selected = true;
            this.selected_item.find("span").text(this.default_text);
            if (!this.is_multiple) {
                this.selected_item.addClass("chzn-default");
            }
            this.show_search_field_default();
            this.results_reset_cleanup();
            this.form_field_jq.trigger("change");
            if (this.active_field) {
                return this.results_hide();
            }
        };

        Chosen.prototype.results_reset_cleanup = function () {
            this.current_selectedIndex = this.form_field.selectedIndex;
            return this.selected_item.find("abbr").remove();
        };

        Chosen.prototype.result_select = function (evt) {
            var high, high_id, item, position;
            if (this.result_highlight) {
                high = this.result_highlight;
                high_id = high.attr("id");
                this.result_clear_highlight();
                if (this.is_multiple) {
                    this.result_deactivate(high);
                } else {
                    this.search_results.find(".result-selected").removeClass("result-selected");
                    this.result_single_selected = high;
                    this.selected_item.removeClass("chzn-default");
                }
                high.addClass("result-selected");
                position = high_id.substr(high_id.lastIndexOf("_") + 1);
                item = this.results_data[position];
                item.selected = true;
                this.form_field.options[item.options_index].selected = true;
                if (this.is_multiple) {
                    this.choice_build(item);
                } else {
                    this.selected_item.find("span").first().text(item.text);
                    if (this.allow_single_deselect) {
                        this.single_deselect_control_build();
                    }
                }
                if (!((evt.metaKey || evt.ctrlKey) && this.is_multiple)) {
                    this.results_hide();
                }
                this.search_field.val("");
                if (this.is_multiple || this.form_field.selectedIndex !== this.current_selectedIndex) {
                    this.form_field_jq.trigger("change", {
                        'selected': this.form_field.options[item.options_index].value
                    });
                }
                this.current_selectedIndex = this.form_field.selectedIndex;
                return this.search_field_scale();
            }
        };

        Chosen.prototype.result_activate = function (el) {
            return el.addClass("active-result");
        };

        Chosen.prototype.result_deactivate = function (el) {
            return el.removeClass("active-result");
        };

        Chosen.prototype.result_deselect = function (pos) {
            var result, result_data;
            result_data = this.results_data[pos];
            if (!this.form_field.options[result_data.options_index].disabled) {
                result_data.selected = false;
                this.form_field.options[result_data.options_index].selected = false;
                result = $("#" + this.container_id + "_o_" + pos);
                result.removeClass("result-selected").addClass("active-result").show();
                this.result_clear_highlight();
                this.winnow_results();
                this.form_field_jq.trigger("change", {
                    deselected: this.form_field.options[result_data.options_index].value
                });
                this.search_field_scale();
                return true;
            } else {
                return false;
            }
        };

        Chosen.prototype.single_deselect_control_build = function () {
            if (this.allow_single_deselect && this.selected_item.find("abbr").length < 1) {
                return this.selected_item.find("span").first().after("<abbr class=\"search-choice-close\"></abbr>");
            }
        };

        Chosen.prototype.winnow_results = function () {
            var found, option, part, parts, regex, regexAnchor, result, result_id, results, searchText, startpos, text, zregex, _i, _j, _len, _len1, _ref;
            this.no_results_clear();
            results = 0;
            searchText = this.search_field.val() === this.default_text ? "" : $('<div/>').text($.trim(this.search_field.val())).html();
            regexAnchor = this.search_contains ? "" : "^";
            regex = new RegExp(regexAnchor + searchText.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"), 'i');
            zregex = new RegExp(searchText.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"), 'i');
            _ref = this.results_data;
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                option = _ref[_i];
                if (!option.disabled && !option.empty) {
                    if (option.group) {
                        $('#' + option.dom_id).css('display', 'none');
                    } else if (!(this.is_multiple && option.selected)) {
                        found = false;
                        result_id = option.dom_id;
                        result = $("#" + result_id);
                        if (regex.test(option.html)) {
                            found = true;
                            results += 1;
                        } else if (this.enable_split_word_search && (option.html.indexOf(" ") >= 0 || option.html.indexOf("[") === 0)) {
                            parts = option.html.replace(/\[|\]/g, "").split(/[\s\u200B]/);
                            if (parts.length) {
                                for (_j = 0, _len1 = parts.length; _j < _len1; _j++) {
                                    part = parts[_j];
                                    if (regex.test(part)) {
                                        found = true;
                                        results += 1;
                                    }
                                }
                            }
                        }
                        if (found) {
                            if (searchText.length) {
                                startpos = option.html.search(zregex);
                                text = option.html.substr(0, startpos + searchText.length) + '</em>' + option.html.substr(startpos + searchText.length);
                                text = text.substr(0, startpos) + '<em>' + text.substr(startpos);
                            } else {
                                text = option.html;
                            }
                            result.html(text);
                            this.result_activate(result);
                            if (option.group_array_index != null) {
                                $("#" + this.results_data[option.group_array_index].dom_id).css('display', 'list-item');
                            }
                        } else {
                            if (this.result_highlight && result_id === this.result_highlight.attr('id')) {
                                this.result_clear_highlight();
                            }
                            this.result_deactivate(result);
                        }
                    }
                }
            }
            if (results < 1 && searchText.length) {
                return this.no_results(searchText);
            } else {
                return this.winnow_results_set_highlight();
            }
        };

        Chosen.prototype.winnow_results_clear = function () {
            var li, lis, _i, _len, _results;
            this.search_field.val("");
            lis = this.search_results.find("li");
            _results = [];
            for (_i = 0, _len = lis.length; _i < _len; _i++) {
                li = lis[_i];
                li = $(li);
                if (li.hasClass("group-result")) {
                    _results.push(li.css('display', 'auto'));
                } else if (!this.is_multiple || !li.hasClass("result-selected")) {
                    _results.push(this.result_activate(li));
                } else {
                    _results.push(void 0);
                }
            }
            return _results;
        };

        Chosen.prototype.winnow_results_set_highlight = function () {
            var do_high, selected_results;
            if (!this.result_highlight) {
                selected_results = !this.is_multiple ? this.search_results.find(".result-selected.active-result") : [];
                do_high = selected_results.length ? selected_results.first() : this.search_results.find(".active-result").first();
                if (do_high != null) {
                    return this.result_do_highlight(do_high);
                }
            }
        };

        Chosen.prototype.no_results = function (terms) {
            var no_results_html;
            no_results_html = $('<li class="no-results">' + this.results_none_found + ' "<span></span>"</li>');
            no_results_html.find("span").first().html(terms);
            return this.search_results.append(no_results_html);
        };

        Chosen.prototype.no_results_clear = function () {
            return this.search_results.find(".no-results").remove();
        };

        Chosen.prototype.keydown_arrow = function () {
            var first_active, next_sib;
            if (!this.result_highlight) {
                first_active = this.search_results.find("li.active-result").first();
                if (first_active) {
                    this.result_do_highlight($(first_active));
                }
            } else if (this.results_showing) {
                next_sib = this.result_highlight.nextAll("li.active-result").first();
                if (next_sib) {
                    this.result_do_highlight(next_sib);
                }
            }
            if (!this.results_showing) {
                return this.results_show();
            }
        };

        Chosen.prototype.keyup_arrow = function () {
            var prev_sibs;
            if (!this.results_showing && !this.is_multiple) {
                return this.results_show();
            } else if (this.result_highlight) {
                prev_sibs = this.result_highlight.prevAll("li.active-result");
                if (prev_sibs.length) {
                    return this.result_do_highlight(prev_sibs.first());
                } else {
                    if (this.choices > 0) {
                        this.results_hide();
                    }
                    return this.result_clear_highlight();
                }
            }
        };

        Chosen.prototype.keydown_backstroke = function () {
            var next_available_destroy;
            if (this.pending_backstroke) {
                this.choice_destroy(this.pending_backstroke.find("a").first());
                return this.clear_backstroke();
            } else {
                next_available_destroy = this.search_container.siblings("li.search-choice").last();
                if (next_available_destroy.length && !next_available_destroy.hasClass("search-choice-disabled")) {
                    this.pending_backstroke = next_available_destroy;
                    if (this.single_backstroke_delete) {
                        return this.keydown_backstroke();
                    } else {
                        return this.pending_backstroke.addClass("search-choice-focus");
                    }
                }
            }
        };

        Chosen.prototype.clear_backstroke = function () {
            if (this.pending_backstroke) {
                this.pending_backstroke.removeClass("search-choice-focus");
            }
            return this.pending_backstroke = null;
        };

        Chosen.prototype.keydown_checker = function (evt) {
            var stroke, _ref;
            stroke = (_ref = evt.which) != null ? _ref : evt.keyCode;
            this.search_field_scale();
            if (stroke !== 8 && this.pending_backstroke) {
                this.clear_backstroke();
            }
            switch (stroke) {
                case 8:
                    this.backstroke_length = this.search_field.val().length;
                    break;
                case 9:
                    if (this.results_showing && !this.is_multiple) {
                        this.result_select(evt);
                    }
                    this.mouse_on_container = false;
                    break;
                case 13:
                    evt.preventDefault();
                    break;
                case 38:
                    evt.preventDefault();
                    this.keyup_arrow();
                    break;
                case 40:
                    this.keydown_arrow();
                    break;
            }
        };

        Chosen.prototype.search_field_scale = function () {
            var div, h, style, style_block, styles, w, _i, _len;
            if (this.is_multiple) {
                h = 0;
                w = 0;
                style_block = "position:absolute; left: -1000px; top: -1000px; display:none;";
                styles = ['font-size', 'font-style', 'font-weight', 'font-family', 'line-height', 'text-transform', 'letter-spacing'];
                for (_i = 0, _len = styles.length; _i < _len; _i++) {
                    style = styles[_i];
                    style_block += style + ":" + this.search_field.css(style) + ";";
                }
                div = $('<div />', {
                    'style': style_block
                });
                div.text(this.search_field.val());
                $('body').append(div);
                w = div.width() + 25;
                div.remove();
                if (!this.f_width) {
                    this.f_width = this.container.outerWidth();
                }
                if (w > this.f_width - 10) {
                    w = this.f_width - 10;
                }
                return this.search_field.css({
                    'width': w + 'px'
                });
            }
        };

        Chosen.prototype.generate_random_id = function () {
            var string;
            string = "sel" + this.generate_random_char() + this.generate_random_char() + this.generate_random_char();
            while ($("#" + string).length > 0) {
                string += this.generate_random_char();
            }
            return string;
        };

        return Chosen;

    })(AbstractChosen);

    root.Chosen = Chosen;

}).call(this);
;
//! moment.js
//! version : 2.8.3
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

(function (undefined) {
    /************************************
        Constants
    ************************************/

    var moment,
        VERSION = '2.8.3',
        // the global-scope this is NOT the global object in Node.js
        globalScope = typeof global !== 'undefined' ? global : this,
        oldGlobalMoment,
        round = Math.round,
        hasOwnProperty = Object.prototype.hasOwnProperty,
        i,

        YEAR = 0,
        MONTH = 1,
        DATE = 2,
        HOUR = 3,
        MINUTE = 4,
        SECOND = 5,
        MILLISECOND = 6,

        // internal storage for locale config files
        locales = {},

        // extra moment internal properties (plugins register props here)
        momentProperties = [],

        // check for nodeJS
        hasModule = (typeof module !== 'undefined' && module.exports),

        // ASP.NET json date format regex
        aspNetJsonRegex = /^\/?Date\((\-?\d+)/i,
        aspNetTimeSpanJsonRegex = /(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/,

        // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
        // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
        isoDurationRegex = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/,

        // format tokens
        formattingTokens = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Q|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,4}|X|zz?|ZZ?|.)/g,
        localFormattingTokens = /(\[[^\[]*\])|(\\)?(LT|LL?L?L?|l{1,4})/g,

        // parsing token regexes
        parseTokenOneOrTwoDigits = /\d\d?/, // 0 - 99
        parseTokenOneToThreeDigits = /\d{1,3}/, // 0 - 999
        parseTokenOneToFourDigits = /\d{1,4}/, // 0 - 9999
        parseTokenOneToSixDigits = /[+\-]?\d{1,6}/, // -999,999 - 999,999
        parseTokenDigits = /\d+/, // nonzero number of digits
        parseTokenWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i, // any word (or two) characters or numbers including two/three word month in arabic.
        parseTokenTimezone = /Z|[\+\-]\d\d:?\d\d/gi, // +00:00 -00:00 +0000 -0000 or Z
        parseTokenT = /T/i, // T (ISO separator)
        parseTokenTimestampMs = /[\+\-]?\d+(\.\d{1,3})?/, // 123456789 123456789.123
        parseTokenOrdinal = /\d{1,2}/,

        //strict parsing regexes
        parseTokenOneDigit = /\d/, // 0 - 9
        parseTokenTwoDigits = /\d\d/, // 00 - 99
        parseTokenThreeDigits = /\d{3}/, // 000 - 999
        parseTokenFourDigits = /\d{4}/, // 0000 - 9999
        parseTokenSixDigits = /[+-]?\d{6}/, // -999,999 - 999,999
        parseTokenSignedNumber = /[+-]?\d+/, // -inf - inf

        // iso 8601 regex
        // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
        isoRegex = /^\s*(?:[+-]\d{6}|\d{4})-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,

        isoFormat = 'YYYY-MM-DDTHH:mm:ssZ',

        isoDates = [
            ['YYYYYY-MM-DD', /[+-]\d{6}-\d{2}-\d{2}/],
            ['YYYY-MM-DD', /\d{4}-\d{2}-\d{2}/],
            ['GGGG-[W]WW-E', /\d{4}-W\d{2}-\d/],
            ['GGGG-[W]WW', /\d{4}-W\d{2}/],
            ['YYYY-DDD', /\d{4}-\d{3}/]
        ],

        // iso time formats and regexes
        isoTimes = [
            ['HH:mm:ss.SSSS', /(T| )\d\d:\d\d:\d\d\.\d+/],
            ['HH:mm:ss', /(T| )\d\d:\d\d:\d\d/],
            ['HH:mm', /(T| )\d\d:\d\d/],
            ['HH', /(T| )\d\d/]
        ],

        // timezone chunker '+10:00' > ['10', '00'] or '-1530' > ['-15', '30']
        parseTimezoneChunker = /([\+\-]|\d\d)/gi,

        // getter and setter names
        proxyGettersAndSetters = 'Date|Hours|Minutes|Seconds|Milliseconds'.split('|'),
        unitMillisecondFactors = {
            'Milliseconds': 1,
            'Seconds': 1e3,
            'Minutes': 6e4,
            'Hours': 36e5,
            'Days': 864e5,
            'Months': 2592e6,
            'Years': 31536e6
        },

        unitAliases = {
            ms: 'millisecond',
            s: 'second',
            m: 'minute',
            h: 'hour',
            d: 'day',
            D: 'date',
            w: 'week',
            W: 'isoWeek',
            M: 'month',
            Q: 'quarter',
            y: 'year',
            DDD: 'dayOfYear',
            e: 'weekday',
            E: 'isoWeekday',
            gg: 'weekYear',
            GG: 'isoWeekYear'
        },

        camelFunctions = {
            dayofyear: 'dayOfYear',
            isoweekday: 'isoWeekday',
            isoweek: 'isoWeek',
            weekyear: 'weekYear',
            isoweekyear: 'isoWeekYear'
        },

        // format function strings
        formatFunctions = {},

        // default relative time thresholds
        relativeTimeThresholds = {
            s: 45,  // seconds to minute
            m: 45,  // minutes to hour
            h: 22,  // hours to day
            d: 26,  // days to month
            M: 11   // months to year
        },

        // tokens to ordinalize and pad
        ordinalizeTokens = 'DDD w W M D d'.split(' '),
        paddedTokens = 'M D H h m s w W'.split(' '),

        formatTokenFunctions = {
            M: function () {
                return this.month() + 1;
            },
            MMM: function (format) {
                return this.localeData().monthsShort(this, format);
            },
            MMMM: function (format) {
                return this.localeData().months(this, format);
            },
            D: function () {
                return this.date();
            },
            DDD: function () {
                return this.dayOfYear();
            },
            d: function () {
                return this.day();
            },
            dd: function (format) {
                return this.localeData().weekdaysMin(this, format);
            },
            ddd: function (format) {
                return this.localeData().weekdaysShort(this, format);
            },
            dddd: function (format) {
                return this.localeData().weekdays(this, format);
            },
            w: function () {
                return this.week();
            },
            W: function () {
                return this.isoWeek();
            },
            YY: function () {
                return leftZeroFill(this.year() % 100, 2);
            },
            YYYY: function () {
                return leftZeroFill(this.year(), 4);
            },
            YYYYY: function () {
                return leftZeroFill(this.year(), 5);
            },
            YYYYYY: function () {
                var y = this.year(), sign = y >= 0 ? '+' : '-';
                return sign + leftZeroFill(Math.abs(y), 6);
            },
            gg: function () {
                return leftZeroFill(this.weekYear() % 100, 2);
            },
            gggg: function () {
                return leftZeroFill(this.weekYear(), 4);
            },
            ggggg: function () {
                return leftZeroFill(this.weekYear(), 5);
            },
            GG: function () {
                return leftZeroFill(this.isoWeekYear() % 100, 2);
            },
            GGGG: function () {
                return leftZeroFill(this.isoWeekYear(), 4);
            },
            GGGGG: function () {
                return leftZeroFill(this.isoWeekYear(), 5);
            },
            e: function () {
                return this.weekday();
            },
            E: function () {
                return this.isoWeekday();
            },
            a: function () {
                return this.localeData().meridiem(this.hours(), this.minutes(), true);
            },
            A: function () {
                return this.localeData().meridiem(this.hours(), this.minutes(), false);
            },
            H: function () {
                return this.hours();
            },
            h: function () {
                return this.hours() % 12 || 12;
            },
            m: function () {
                return this.minutes();
            },
            s: function () {
                return this.seconds();
            },
            S: function () {
                return toInt(this.milliseconds() / 100);
            },
            SS: function () {
                return leftZeroFill(toInt(this.milliseconds() / 10), 2);
            },
            SSS: function () {
                return leftZeroFill(this.milliseconds(), 3);
            },
            SSSS: function () {
                return leftZeroFill(this.milliseconds(), 3);
            },
            Z: function () {
                var a = -this.zone(),
                    b = '+';
                if (a < 0) {
                    a = -a;
                    b = '-';
                }
                return b + leftZeroFill(toInt(a / 60), 2) + ':' + leftZeroFill(toInt(a) % 60, 2);
            },
            ZZ: function () {
                var a = -this.zone(),
                    b = '+';
                if (a < 0) {
                    a = -a;
                    b = '-';
                }
                return b + leftZeroFill(toInt(a / 60), 2) + leftZeroFill(toInt(a) % 60, 2);
            },
            z: function () {
                return this.zoneAbbr();
            },
            zz: function () {
                return this.zoneName();
            },
            X: function () {
                return this.unix();
            },
            Q: function () {
                return this.quarter();
            }
        },

        deprecations = {},

        lists = ['months', 'monthsShort', 'weekdays', 'weekdaysShort', 'weekdaysMin'];

    // Pick the first defined of two or three arguments. dfl comes from
    // default.
    function dfl(a, b, c) {
        switch (arguments.length) {
            case 2: return a != null ? a : b;
            case 3: return a != null ? a : b != null ? b : c;
            default: throw new Error('Implement me');
        }
    }

    function hasOwnProp(a, b) {
        return hasOwnProperty.call(a, b);
    }

    function defaultParsingFlags() {
        // We need to deep clone this object, and es5 standard is not very
        // helpful.
        return {
            empty: false,
            unusedTokens: [],
            unusedInput: [],
            overflow: -2,
            charsLeftOver: 0,
            nullInput: false,
            invalidMonth: null,
            invalidFormat: false,
            userInvalidated: false,
            iso: false
        };
    }

    function printMsg(msg) {
        if (moment.suppressDeprecationWarnings === false &&
            typeof console !== 'undefined' && console.warn) {
            console.warn('Deprecation warning: ' + msg);
        }
    }

    function deprecate(msg, fn) {
        var firstTime = true;
        return extend(function () {
            if (firstTime) {
                printMsg(msg);
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }

    function deprecateSimple(name, msg) {
        if (!deprecations[name]) {
            printMsg(msg);
            deprecations[name] = true;
        }
    }

    function padToken(func, count) {
        return function (a) {
            return leftZeroFill(func.call(this, a), count);
        };
    }
    function ordinalizeToken(func, period) {
        return function (a) {
            return this.localeData().ordinal(func.call(this, a), period);
        };
    }

    while (ordinalizeTokens.length) {
        i = ordinalizeTokens.pop();
        formatTokenFunctions[i + 'o'] = ordinalizeToken(formatTokenFunctions[i], i);
    }
    while (paddedTokens.length) {
        i = paddedTokens.pop();
        formatTokenFunctions[i + i] = padToken(formatTokenFunctions[i], 2);
    }
    formatTokenFunctions.DDDD = padToken(formatTokenFunctions.DDD, 3);


    /************************************
        Constructors
    ************************************/

    function Locale() {
    }

    // Moment prototype object
    function Moment(config, skipOverflow) {
        if (skipOverflow !== false) {
            checkOverflow(config);
        }
        copyConfig(this, config);
        this._d = new Date(+config._d);
    }

    // Duration Constructor
    function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;

        // representation for dateAddRemove
        this._milliseconds = +milliseconds +
            seconds * 1e3 + // 1000
            minutes * 6e4 + // 1000 * 60
            hours * 36e5; // 1000 * 60 * 60
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days +
            weeks * 7;
        // It is impossible translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months +
            quarters * 3 +
            years * 12;

        this._data = {};

        this._locale = moment.localeData();

        this._bubble();
    }

    /************************************
        Helpers
    ************************************/


    function extend(a, b) {
        for (var i in b) {
            if (hasOwnProp(b, i)) {
                a[i] = b[i];
            }
        }

        if (hasOwnProp(b, 'toString')) {
            a.toString = b.toString;
        }

        if (hasOwnProp(b, 'valueOf')) {
            a.valueOf = b.valueOf;
        }

        return a;
    }

    function copyConfig(to, from) {
        var i, prop, val;

        if (typeof from._isAMomentObject !== 'undefined') {
            to._isAMomentObject = from._isAMomentObject;
        }
        if (typeof from._i !== 'undefined') {
            to._i = from._i;
        }
        if (typeof from._f !== 'undefined') {
            to._f = from._f;
        }
        if (typeof from._l !== 'undefined') {
            to._l = from._l;
        }
        if (typeof from._strict !== 'undefined') {
            to._strict = from._strict;
        }
        if (typeof from._tzm !== 'undefined') {
            to._tzm = from._tzm;
        }
        if (typeof from._isUTC !== 'undefined') {
            to._isUTC = from._isUTC;
        }
        if (typeof from._offset !== 'undefined') {
            to._offset = from._offset;
        }
        if (typeof from._pf !== 'undefined') {
            to._pf = from._pf;
        }
        if (typeof from._locale !== 'undefined') {
            to._locale = from._locale;
        }

        if (momentProperties.length > 0) {
            for (i in momentProperties) {
                prop = momentProperties[i];
                val = from[prop];
                if (typeof val !== 'undefined') {
                    to[prop] = val;
                }
            }
        }

        return to;
    }

    function absRound(number) {
        if (number < 0) {
            return Math.ceil(number);
        } else {
            return Math.floor(number);
        }
    }

    // left zero fill a number
    // see http://jsperf.com/left-zero-filling for performance comparison
    function leftZeroFill(number, targetLength, forceSign) {
        var output = '' + Math.abs(number),
            sign = number >= 0;

        while (output.length < targetLength) {
            output = '0' + output;
        }
        return (sign ? (forceSign ? '+' : '') : '-') + output;
    }

    function positiveMomentsDifference(base, other) {
        var res = { milliseconds: 0, months: 0 };

        res.months = other.month() - base.month() +
            (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, 'M').isAfter(other)) {
            --res.months;
        }

        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

        return res;
    }

    function momentsDifference(base, other) {
        var res;
        other = makeAs(other, base);
        if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
        } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
        }

        return res;
    }

    // TODO: remove 'name' arg after deprecation is removed
    function createAdder(direction, name) {
        return function (val, period) {
            var dur, tmp;
            //invert the arguments, but complain about it
            if (period !== null && !isNaN(+period)) {
                deprecateSimple(name, 'moment().' + name + '(period, number) is deprecated. Please use moment().' + name + '(number, period).');
                tmp = val; val = period; period = tmp;
            }

            val = typeof val === 'string' ? +val : val;
            dur = moment.duration(val, period);
            addOrSubtractDurationFromMoment(this, dur, direction);
            return this;
        };
    }

    function addOrSubtractDurationFromMoment(mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds,
            days = duration._days,
            months = duration._months;
        updateOffset = updateOffset == null ? true : updateOffset;

        if (milliseconds) {
            mom._d.setTime(+mom._d + milliseconds * isAdding);
        }
        if (days) {
            rawSetter(mom, 'Date', rawGetter(mom, 'Date') + days * isAdding);
        }
        if (months) {
            rawMonthSetter(mom, rawGetter(mom, 'Month') + months * isAdding);
        }
        if (updateOffset) {
            moment.updateOffset(mom, days || months);
        }
    }

    // check if is an array
    function isArray(input) {
        return Object.prototype.toString.call(input) === '[object Array]';
    }

    function isDate(input) {
        return Object.prototype.toString.call(input) === '[object Date]' ||
            input instanceof Date;
    }

    // compare two arrays, return the number of differences
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if ((dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    function normalizeUnits(units) {
        if (units) {
            var lowered = units.toLowerCase().replace(/(.)s$/, '$1');
            units = unitAliases[units] || camelFunctions[lowered] || lowered;
        }
        return units;
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;

        for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }

        return normalizedInput;
    }

    function makeList(field) {
        var count, setter;

        if (field.indexOf('week') === 0) {
            count = 7;
            setter = 'day';
        }
        else if (field.indexOf('month') === 0) {
            count = 12;
            setter = 'month';
        }
        else {
            return;
        }

        moment[field] = function (format, index) {
            var i, getter,
                method = moment._locale[field],
                results = [];

            if (typeof format === 'number') {
                index = format;
                format = undefined;
            }

            getter = function (i) {
                var m = moment().utc().set(setter, i);
                return method.call(moment._locale, m, format || '');
            };

            if (index != null) {
                return getter(index);
            }
            else {
                for (i = 0; i < count; i++) {
                    results.push(getter(i));
                }
                return results;
            }
        };
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            if (coercedNumber >= 0) {
                value = Math.floor(coercedNumber);
            } else {
                value = Math.ceil(coercedNumber);
            }
        }

        return value;
    }

    function daysInMonth(year, month) {
        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
    }

    function weeksInYear(year, dow, doy) {
        return weekOfYear(moment([year, 11, 31 + dow - doy]), dow, doy).week;
    }

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }

    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }

    function checkOverflow(m) {
        var overflow;
        if (m._a && m._pf.overflow === -2) {
            overflow =
                m._a[MONTH] < 0 || m._a[MONTH] > 11 ? MONTH :
                    m._a[DATE] < 1 || m._a[DATE] > daysInMonth(m._a[YEAR], m._a[MONTH]) ? DATE :
                        m._a[HOUR] < 0 || m._a[HOUR] > 23 ? HOUR :
                            m._a[MINUTE] < 0 || m._a[MINUTE] > 59 ? MINUTE :
                                m._a[SECOND] < 0 || m._a[SECOND] > 59 ? SECOND :
                                    m._a[MILLISECOND] < 0 || m._a[MILLISECOND] > 999 ? MILLISECOND :
                                        -1;

            if (m._pf._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }

            m._pf.overflow = overflow;
        }
    }

    function isValid(m) {
        if (m._isValid == null) {
            m._isValid = !isNaN(m._d.getTime()) &&
                m._pf.overflow < 0 &&
                !m._pf.empty &&
                !m._pf.invalidMonth &&
                !m._pf.nullInput &&
                !m._pf.invalidFormat &&
                !m._pf.userInvalidated;

            if (m._strict) {
                m._isValid = m._isValid &&
                    m._pf.charsLeftOver === 0 &&
                    m._pf.unusedTokens.length === 0;
            }
        }
        return m._isValid;
    }

    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }

    // pick the locale from the array
    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
    function chooseLocale(names) {
        var i = 0, j, next, locale, split;

        while (i < names.length) {
            split = normalizeLocale(names[i]).split('-');
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                locale = loadLocale(split.slice(0, j).join('-'));
                if (locale) {
                    return locale;
                }
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return null;
    }

    function loadLocale(name) {
        var oldLocale = null;
        if (!locales[name] && hasModule) {
            try {
                oldLocale = moment.locale();
                require('./locale/' + name);
                // because defineLocale currently also sets the global locale, we want to undo that for lazy loaded locales
                moment.locale(oldLocale);
            } catch (e) { }
        }
        return locales[name];
    }

    // Return a moment from input, that is local/utc/zone equivalent to model.
    function makeAs(input, model) {
        return model._isUTC ? moment(input).zone(model._offset || 0) :
            moment(input).local();
    }

    /************************************
        Locale
    ************************************/


    extend(Locale.prototype, {

        set: function (config) {
            var prop, i;
            for (i in config) {
                prop = config[i];
                if (typeof prop === 'function') {
                    this[i] = prop;
                } else {
                    this['_' + i] = prop;
                }
            }
        },

        _months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
        months: function (m) {
            return this._months[m.month()];
        },

        _monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        monthsShort: function (m) {
            return this._monthsShort[m.month()];
        },

        monthsParse: function (monthName) {
            var i, mom, regex;

            if (!this._monthsParse) {
                this._monthsParse = [];
            }

            for (i = 0; i < 12; i++) {
                // make the regex if we don't have it already
                if (!this._monthsParse[i]) {
                    mom = moment.utc([2000, i]);
                    regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                    this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
                }
                // test the regex
                if (this._monthsParse[i].test(monthName)) {
                    return i;
                }
            }
        },

        _weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        weekdays: function (m) {
            return this._weekdays[m.day()];
        },

        _weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysShort: function (m) {
            return this._weekdaysShort[m.day()];
        },

        _weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        weekdaysMin: function (m) {
            return this._weekdaysMin[m.day()];
        },

        weekdaysParse: function (weekdayName) {
            var i, mom, regex;

            if (!this._weekdaysParse) {
                this._weekdaysParse = [];
            }

            for (i = 0; i < 7; i++) {
                // make the regex if we don't have it already
                if (!this._weekdaysParse[i]) {
                    mom = moment([2000, 1]).day(i);
                    regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                    this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
                }
                // test the regex
                if (this._weekdaysParse[i].test(weekdayName)) {
                    return i;
                }
            }
        },

        _longDateFormat: {
            LT: 'h:mm A',
            L: 'MM/DD/YYYY',
            LL: 'MMMM D, YYYY',
            LLL: 'MMMM D, YYYY LT',
            LLLL: 'dddd, MMMM D, YYYY LT'
        },
        longDateFormat: function (key) {
            var output = this._longDateFormat[key];
            if (!output && this._longDateFormat[key.toUpperCase()]) {
                output = this._longDateFormat[key.toUpperCase()].replace(/MMMM|MM|DD|dddd/g, function (val) {
                    return val.slice(1);
                });
                this._longDateFormat[key] = output;
            }
            return output;
        },

        isPM: function (input) {
            // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
            // Using charAt should be more compatible.
            return ((input + '').toLowerCase().charAt(0) === 'p');
        },

        _meridiemParse: /[ap]\.?m?\.?/i,
        meridiem: function (hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? 'pm' : 'PM';
            } else {
                return isLower ? 'am' : 'AM';
            }
        },

        _calendar: {
            sameDay: '[Today at] LT',
            nextDay: '[Tomorrow at] LT',
            nextWeek: 'dddd [at] LT',
            lastDay: '[Yesterday at] LT',
            lastWeek: '[Last] dddd [at] LT',
            sameElse: 'L'
        },
        calendar: function (key, mom) {
            var output = this._calendar[key];
            return typeof output === 'function' ? output.apply(mom) : output;
        },

        _relativeTime: {
            future: 'in %s',
            past: '%s ago',
            s: 'a few seconds',
            m: 'a minute',
            mm: '%d minutes',
            h: 'an hour',
            hh: '%d hours',
            d: 'a day',
            dd: '%d days',
            M: 'a month',
            MM: '%d months',
            y: 'a year',
            yy: '%d years'
        },

        relativeTime: function (number, withoutSuffix, string, isFuture) {
            var output = this._relativeTime[string];
            return (typeof output === 'function') ?
                output(number, withoutSuffix, string, isFuture) :
                output.replace(/%d/i, number);
        },

        pastFuture: function (diff, output) {
            var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
            return typeof format === 'function' ? format(output) : format.replace(/%s/i, output);
        },

        ordinal: function (number) {
            return this._ordinal.replace('%d', number);
        },
        _ordinal: '%d',

        preparse: function (string) {
            return string;
        },

        postformat: function (string) {
            return string;
        },

        week: function (mom) {
            return weekOfYear(mom, this._week.dow, this._week.doy).week;
        },

        _week: {
            dow: 0, // Sunday is the first day of the week.
            doy: 6  // The week that contains Jan 1st is the first week of the year.
        },

        _invalidDate: 'Invalid date',
        invalidDate: function () {
            return this._invalidDate;
        }
    });

    /************************************
        Formatting
    ************************************/


    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, '');
        }
        return input.replace(/\\/g, '');
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function (mom) {
            var output = '';
            for (i = 0; i < length; i++) {
                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }

    // format date using native date object
    function formatMoment(m, format) {
        if (!m.isValid()) {
            return m.localeData().invalidDate();
        }

        format = expandFormat(format, m.localeData());

        if (!formatFunctions[format]) {
            formatFunctions[format] = makeFormatFunction(format);
        }

        return formatFunctions[format](m);
    }

    function expandFormat(format, locale) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }

        return format;
    }


    /************************************
        Parsing
    ************************************/


    // get the regex to find the next token
    function getParseRegexForToken(token, config) {
        var a, strict = config._strict;
        switch (token) {
            case 'Q':
                return parseTokenOneDigit;
            case 'DDDD':
                return parseTokenThreeDigits;
            case 'YYYY':
            case 'GGGG':
            case 'gggg':
                return strict ? parseTokenFourDigits : parseTokenOneToFourDigits;
            case 'Y':
            case 'G':
            case 'g':
                return parseTokenSignedNumber;
            case 'YYYYYY':
            case 'YYYYY':
            case 'GGGGG':
            case 'ggggg':
                return strict ? parseTokenSixDigits : parseTokenOneToSixDigits;
            case 'S':
                if (strict) {
                    return parseTokenOneDigit;
                }
            /* falls through */
            case 'SS':
                if (strict) {
                    return parseTokenTwoDigits;
                }
            /* falls through */
            case 'SSS':
                if (strict) {
                    return parseTokenThreeDigits;
                }
            /* falls through */
            case 'DDD':
                return parseTokenOneToThreeDigits;
            case 'MMM':
            case 'MMMM':
            case 'dd':
            case 'ddd':
            case 'dddd':
                return parseTokenWord;
            case 'a':
            case 'A':
                return config._locale._meridiemParse;
            case 'X':
                return parseTokenTimestampMs;
            case 'Z':
            case 'ZZ':
                return parseTokenTimezone;
            case 'T':
                return parseTokenT;
            case 'SSSS':
                return parseTokenDigits;
            case 'MM':
            case 'DD':
            case 'YY':
            case 'GG':
            case 'gg':
            case 'HH':
            case 'hh':
            case 'mm':
            case 'ss':
            case 'ww':
            case 'WW':
                return strict ? parseTokenTwoDigits : parseTokenOneOrTwoDigits;
            case 'M':
            case 'D':
            case 'd':
            case 'H':
            case 'h':
            case 'm':
            case 's':
            case 'w':
            case 'W':
            case 'e':
            case 'E':
                return parseTokenOneOrTwoDigits;
            case 'Do':
                return parseTokenOrdinal;
            default:
                a = new RegExp(regexpEscape(unescapeFormat(token.replace('\\', '')), 'i'));
                return a;
        }
    }

    function timezoneMinutesFromString(string) {
        string = string || '';
        var possibleTzMatches = (string.match(parseTokenTimezone) || []),
            tzChunk = possibleTzMatches[possibleTzMatches.length - 1] || [],
            parts = (tzChunk + '').match(parseTimezoneChunker) || ['-', 0, 0],
            minutes = +(parts[1] * 60) + toInt(parts[2]);

        return parts[0] === '+' ? -minutes : minutes;
    }

    // function to convert string input to date
    function addTimeToArrayFromToken(token, input, config) {
        var a, datePartArray = config._a;

        switch (token) {
            // QUARTER
            case 'Q':
                if (input != null) {
                    datePartArray[MONTH] = (toInt(input) - 1) * 3;
                }
                break;
            // MONTH
            case 'M': // fall through to MM
            case 'MM':
                if (input != null) {
                    datePartArray[MONTH] = toInt(input) - 1;
                }
                break;
            case 'MMM': // fall through to MMMM
            case 'MMMM':
                a = config._locale.monthsParse(input);
                // if we didn't find a month name, mark the date as invalid.
                if (a != null) {
                    datePartArray[MONTH] = a;
                } else {
                    config._pf.invalidMonth = input;
                }
                break;
            // DAY OF MONTH
            case 'D': // fall through to DD
            case 'DD':
                if (input != null) {
                    datePartArray[DATE] = toInt(input);
                }
                break;
            case 'Do':
                if (input != null) {
                    datePartArray[DATE] = toInt(parseInt(input, 10));
                }
                break;
            // DAY OF YEAR
            case 'DDD': // fall through to DDDD
            case 'DDDD':
                if (input != null) {
                    config._dayOfYear = toInt(input);
                }

                break;
            // YEAR
            case 'YY':
                datePartArray[YEAR] = moment.parseTwoDigitYear(input);
                break;
            case 'YYYY':
            case 'YYYYY':
            case 'YYYYYY':
                datePartArray[YEAR] = toInt(input);
                break;
            // AM / PM
            case 'a': // fall through to A
            case 'A':
                config._isPm = config._locale.isPM(input);
                break;
            // 24 HOUR
            case 'H': // fall through to hh
            case 'HH': // fall through to hh
            case 'h': // fall through to hh
            case 'hh':
                datePartArray[HOUR] = toInt(input);
                break;
            // MINUTE
            case 'm': // fall through to mm
            case 'mm':
                datePartArray[MINUTE] = toInt(input);
                break;
            // SECOND
            case 's': // fall through to ss
            case 'ss':
                datePartArray[SECOND] = toInt(input);
                break;
            // MILLISECOND
            case 'S':
            case 'SS':
            case 'SSS':
            case 'SSSS':
                datePartArray[MILLISECOND] = toInt(('0.' + input) * 1000);
                break;
            // UNIX TIMESTAMP WITH MS
            case 'X':
                config._d = new Date(parseFloat(input) * 1000);
                break;
            // TIMEZONE
            case 'Z': // fall through to ZZ
            case 'ZZ':
                config._useUTC = true;
                config._tzm = timezoneMinutesFromString(input);
                break;
            // WEEKDAY - human
            case 'dd':
            case 'ddd':
            case 'dddd':
                a = config._locale.weekdaysParse(input);
                // if we didn't get a weekday name, mark the date as invalid
                if (a != null) {
                    config._w = config._w || {};
                    config._w['d'] = a;
                } else {
                    config._pf.invalidWeekday = input;
                }
                break;
            // WEEK, WEEK DAY - numeric
            case 'w':
            case 'ww':
            case 'W':
            case 'WW':
            case 'd':
            case 'e':
            case 'E':
                token = token.substr(0, 1);
            /* falls through */
            case 'gggg':
            case 'GGGG':
            case 'GGGGG':
                token = token.substr(0, 2);
                if (input) {
                    config._w = config._w || {};
                    config._w[token] = toInt(input);
                }
                break;
            case 'gg':
            case 'GG':
                config._w = config._w || {};
                config._w[token] = moment.parseTwoDigitYear(input);
        }
    }

    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp;

        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;

            // TODO: We need to take the current isoWeekYear, but that depends on
            // how we interpret now (local, utc, fixed offset). So create
            // a now version of current config (take local/utc/offset flags, and
            // create now).
            weekYear = dfl(w.GG, config._a[YEAR], weekOfYear(moment(), 1, 4).year);
            week = dfl(w.W, 1);
            weekday = dfl(w.E, 1);
        } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;

            weekYear = dfl(w.gg, config._a[YEAR], weekOfYear(moment(), dow, doy).year);
            week = dfl(w.w, 1);

            if (w.d != null) {
                // weekday -- low day numbers are considered next week
                weekday = w.d;
                if (weekday < dow) {
                    ++week;
                }
            } else if (w.e != null) {
                // local weekday -- counting starts from begining of week
                weekday = w.e + dow;
            } else {
                // default to begining of week
                weekday = dow;
            }
        }
        temp = dayOfYearFromWeeks(weekYear, week, weekday, doy, dow);

        config._a[YEAR] = temp.year;
        config._dayOfYear = temp.dayOfYear;
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function dateFromConfig(config) {
        var i, date, input = [], currentDate, yearToUse;

        if (config._d) {
            return;
        }

        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear) {
            yearToUse = dfl(config._a[YEAR], currentDate[YEAR]);

            if (config._dayOfYear > daysInYear(yearToUse)) {
                config._pf._overflowDayOfYear = true;
            }

            date = makeUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
        }

        config._d = (config._useUTC ? makeUTCDate : makeDate).apply(null, input);
        // Apply timezone offset from input. The actual zone can be changed
        // with parseZone.
        if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() + config._tzm);
        }
    }

    function dateFromObject(config) {
        var normalizedInput;

        if (config._d) {
            return;
        }

        normalizedInput = normalizeObjectUnits(config._i);
        config._a = [
            normalizedInput.year,
            normalizedInput.month,
            normalizedInput.day,
            normalizedInput.hour,
            normalizedInput.minute,
            normalizedInput.second,
            normalizedInput.millisecond
        ];

        dateFromConfig(config);
    }

    function currentDateArray(config) {
        var now = new Date();
        if (config._useUTC) {
            return [
                now.getUTCFullYear(),
                now.getUTCMonth(),
                now.getUTCDate()
            ];
        } else {
            return [now.getFullYear(), now.getMonth(), now.getDate()];
        }
    }

    // date from string and format string
    function makeDateFromStringAndFormat(config) {
        if (config._f === moment.ISO_8601) {
            parseISO(config);
            return;
        }

        config._a = [];
        config._pf.empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var string = '' + config._i,
            i, parsedInput, tokens, token, skipped,
            stringLength = string.length,
            totalParsedInputLength = 0;

        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    config._pf.unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    config._pf.empty = false;
                }
                else {
                    config._pf.unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            }
            else if (config._strict && !parsedInput) {
                config._pf.unusedTokens.push(token);
            }
        }

        // add remaining unparsed input length to the string
        config._pf.charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            config._pf.unusedInput.push(string);
        }

        // handle am pm
        if (config._isPm && config._a[HOUR] < 12) {
            config._a[HOUR] += 12;
        }
        // if is 12 am, change hours to 0
        if (config._isPm === false && config._a[HOUR] === 12) {
            config._a[HOUR] = 0;
        }

        dateFromConfig(config);
        checkOverflow(config);
    }

    function unescapeFormat(s) {
        return s.replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        });
    }

    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function regexpEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    // date from string and array of format strings
    function makeDateFromStringAndArray(config) {
        var tempConfig,
            bestMoment,

            scoreToBeat,
            i,
            currentScore;

        if (config._f.length === 0) {
            config._pf.invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }

        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
                tempConfig._useUTC = config._useUTC;
            }
            tempConfig._pf = defaultParsingFlags();
            tempConfig._f = config._f[i];
            makeDateFromStringAndFormat(tempConfig);

            if (!isValid(tempConfig)) {
                continue;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += tempConfig._pf.charsLeftOver;

            //or tokens
            currentScore += tempConfig._pf.unusedTokens.length * 10;

            tempConfig._pf.score = currentScore;

            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
            }
        }

        extend(config, bestMoment || tempConfig);
    }

    // date from iso format
    function parseISO(config) {
        var i, l,
            string = config._i,
            match = isoRegex.exec(string);

        if (match) {
            config._pf.iso = true;
            for (i = 0, l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(string)) {
                    // match[5] should be 'T' or undefined
                    config._f = isoDates[i][0] + (match[6] || ' ');
                    break;
                }
            }
            for (i = 0, l = isoTimes.length; i < l; i++) {
                if (isoTimes[i][1].exec(string)) {
                    config._f += isoTimes[i][0];
                    break;
                }
            }
            if (string.match(parseTokenTimezone)) {
                config._f += 'Z';
            }
            makeDateFromStringAndFormat(config);
        } else {
            config._isValid = false;
        }
    }

    // date from iso format or fallback
    function makeDateFromString(config) {
        parseISO(config);
        if (config._isValid === false) {
            delete config._isValid;
            moment.createFromInputFallback(config);
        }
    }

    function map(arr, fn) {
        var res = [], i;
        for (i = 0; i < arr.length; ++i) {
            res.push(fn(arr[i], i));
        }
        return res;
    }

    function makeDateFromInput(config) {
        var input = config._i, matched;
        if (input === undefined) {
            config._d = new Date();
        } else if (isDate(input)) {
            config._d = new Date(+input);
        } else if ((matched = aspNetJsonRegex.exec(input)) !== null) {
            config._d = new Date(+matched[1]);
        } else if (typeof input === 'string') {
            makeDateFromString(config);
        } else if (isArray(input)) {
            config._a = map(input.slice(0), function (obj) {
                return parseInt(obj, 10);
            });
            dateFromConfig(config);
        } else if (typeof (input) === 'object') {
            dateFromObject(config);
        } else if (typeof (input) === 'number') {
            // from milliseconds
            config._d = new Date(input);
        } else {
            moment.createFromInputFallback(config);
        }
    }

    function makeDate(y, m, d, h, M, s, ms) {
        //can't just apply() to create a date:
        //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
        var date = new Date(y, m, d, h, M, s, ms);

        //the date constructor doesn't accept years < 1970
        if (y < 1970) {
            date.setFullYear(y);
        }
        return date;
    }

    function makeUTCDate(y) {
        var date = new Date(Date.UTC.apply(null, arguments));
        if (y < 1970) {
            date.setUTCFullYear(y);
        }
        return date;
    }

    function parseWeekday(input, locale) {
        if (typeof input === 'string') {
            if (!isNaN(input)) {
                input = parseInt(input, 10);
            }
            else {
                input = locale.weekdaysParse(input);
                if (typeof input !== 'number') {
                    return null;
                }
            }
        }
        return input;
    }

    /************************************
        Relative Time
    ************************************/


    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function relativeTime(posNegDuration, withoutSuffix, locale) {
        var duration = moment.duration(posNegDuration).abs(),
            seconds = round(duration.as('s')),
            minutes = round(duration.as('m')),
            hours = round(duration.as('h')),
            days = round(duration.as('d')),
            months = round(duration.as('M')),
            years = round(duration.as('y')),

            args = seconds < relativeTimeThresholds.s && ['s', seconds] ||
                minutes === 1 && ['m'] ||
                minutes < relativeTimeThresholds.m && ['mm', minutes] ||
                hours === 1 && ['h'] ||
                hours < relativeTimeThresholds.h && ['hh', hours] ||
                days === 1 && ['d'] ||
                days < relativeTimeThresholds.d && ['dd', days] ||
                months === 1 && ['M'] ||
                months < relativeTimeThresholds.M && ['MM', months] ||
                years === 1 && ['y'] || ['yy', years];

        args[2] = withoutSuffix;
        args[3] = +posNegDuration > 0;
        args[4] = locale;
        return substituteTimeAgo.apply({}, args);
    }


    /************************************
        Week of Year
    ************************************/


    // firstDayOfWeek       0 = sun, 6 = sat
    //                      the day of the week that starts the week
    //                      (usually sunday or monday)
    // firstDayOfWeekOfYear 0 = sun, 6 = sat
    //                      the first week is the week that contains the first
    //                      of this day of the week
    //                      (eg. ISO weeks use thursday (4))
    function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
        var end = firstDayOfWeekOfYear - firstDayOfWeek,
            daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(),
            adjustedMoment;


        if (daysToDayOfWeek > end) {
            daysToDayOfWeek -= 7;
        }

        if (daysToDayOfWeek < end - 7) {
            daysToDayOfWeek += 7;
        }

        adjustedMoment = moment(mom).add(daysToDayOfWeek, 'd');
        return {
            week: Math.ceil(adjustedMoment.dayOfYear() / 7),
            year: adjustedMoment.year()
        };
    }

    //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(year, week, weekday, firstDayOfWeekOfYear, firstDayOfWeek) {
        var d = makeUTCDate(year, 0, 1).getUTCDay(), daysToAdd, dayOfYear;

        d = d === 0 ? 7 : d;
        weekday = weekday != null ? weekday : firstDayOfWeek;
        daysToAdd = firstDayOfWeek - d + (d > firstDayOfWeekOfYear ? 7 : 0) - (d < firstDayOfWeek ? 7 : 0);
        dayOfYear = 7 * (week - 1) + (weekday - firstDayOfWeek) + daysToAdd + 1;

        return {
            year: dayOfYear > 0 ? year : year - 1,
            dayOfYear: dayOfYear > 0 ? dayOfYear : daysInYear(year - 1) + dayOfYear
        };
    }

    /************************************
        Top Level Functions
    ************************************/

    function makeMoment(config) {
        var input = config._i,
            format = config._f;

        config._locale = config._locale || moment.localeData(config._l);

        if (input === null || (format === undefined && input === '')) {
            return moment.invalid({ nullInput: true });
        }

        if (typeof input === 'string') {
            config._i = input = config._locale.preparse(input);
        }

        if (moment.isMoment(input)) {
            return new Moment(input, true);
        } else if (format) {
            if (isArray(format)) {
                makeDateFromStringAndArray(config);
            } else {
                makeDateFromStringAndFormat(config);
            }
        } else {
            makeDateFromInput(config);
        }

        return new Moment(config);
    }

    moment = function (input, format, locale, strict) {
        var c;

        if (typeof (locale) === 'boolean') {
            strict = locale;
            locale = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c = {};
        c._isAMomentObject = true;
        c._i = input;
        c._f = format;
        c._l = locale;
        c._strict = strict;
        c._isUTC = false;
        c._pf = defaultParsingFlags();

        return makeMoment(c);
    };

    moment.suppressDeprecationWarnings = false;

    moment.createFromInputFallback = deprecate(
        'moment construction falls back to js Date. This is ' +
        'discouraged and will be removed in upcoming major ' +
        'release. Please refer to ' +
        'https://github.com/moment/moment/issues/1407 for more info.',
        function (config) {
            config._d = new Date(config._i);
        }
    );

    // Pick a moment m from moments so that m[fn](other) is true for all
    // other. This relies on the function fn to be transitive.
    //
    // moments should either be an array of moment objects or an array, whose
    // first element is an array of moment objects.
    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
        }
        if (!moments.length) {
            return moment();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
            if (moments[i][fn](res)) {
                res = moments[i];
            }
        }
        return res;
    }

    moment.min = function () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isBefore', args);
    };

    moment.max = function () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isAfter', args);
    };

    // creating with utc
    moment.utc = function (input, format, locale, strict) {
        var c;

        if (typeof (locale) === 'boolean') {
            strict = locale;
            locale = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c = {};
        c._isAMomentObject = true;
        c._useUTC = true;
        c._isUTC = true;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;
        c._pf = defaultParsingFlags();

        return makeMoment(c).utc();
    };

    // creating with unix timestamp (in seconds)
    moment.unix = function (input) {
        return moment(input * 1000);
    };

    // duration
    moment.duration = function (input, key) {
        var duration = input,
            // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            parseIso,
            diffRes;

        if (moment.isDuration(input)) {
            duration = {
                ms: input._milliseconds,
                d: input._days,
                M: input._months
            };
        } else if (typeof input === 'number') {
            duration = {};
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        } else if (!!(match = aspNetTimeSpanJsonRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y: 0,
                d: toInt(match[DATE]) * sign,
                h: toInt(match[HOUR]) * sign,
                m: toInt(match[MINUTE]) * sign,
                s: toInt(match[SECOND]) * sign,
                ms: toInt(match[MILLISECOND]) * sign
            };
        } else if (!!(match = isoDurationRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            parseIso = function (inp) {
                // We'd normally use ~~inp for this, but unfortunately it also
                // converts floats to ints.
                // inp may be undefined, so careful calling replace on it.
                var res = inp && parseFloat(inp.replace(',', '.'));
                // apply sign while we're at it
                return (isNaN(res) ? 0 : res) * sign;
            };
            duration = {
                y: parseIso(match[2]),
                M: parseIso(match[3]),
                d: parseIso(match[4]),
                h: parseIso(match[5]),
                m: parseIso(match[6]),
                s: parseIso(match[7]),
                w: parseIso(match[8])
            };
        } else if (typeof duration === 'object' &&
            ('from' in duration || 'to' in duration)) {
            diffRes = momentsDifference(moment(duration.from), moment(duration.to));

            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
        }

        ret = new Duration(duration);

        if (moment.isDuration(input) && hasOwnProp(input, '_locale')) {
            ret._locale = input._locale;
        }

        return ret;
    };

    // version number
    moment.version = VERSION;

    // default format
    moment.defaultFormat = isoFormat;

    // constant that refers to the ISO standard
    moment.ISO_8601 = function () { };

    // Plugins that add properties should also add the key here (null value),
    // so we can properly clone ourselves.
    moment.momentProperties = momentProperties;

    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    moment.updateOffset = function () { };

    // This function allows you to set a threshold for relative time strings
    moment.relativeTimeThreshold = function (threshold, limit) {
        if (relativeTimeThresholds[threshold] === undefined) {
            return false;
        }
        if (limit === undefined) {
            return relativeTimeThresholds[threshold];
        }
        relativeTimeThresholds[threshold] = limit;
        return true;
    };

    moment.lang = deprecate(
        'moment.lang is deprecated. Use moment.locale instead.',
        function (key, value) {
            return moment.locale(key, value);
        }
    );

    // This function will load locale and then set the global locale.  If
    // no arguments are passed in, it will simply return the current global
    // locale key.
    moment.locale = function (key, values) {
        var data;
        if (key) {
            if (typeof (values) !== 'undefined') {
                data = moment.defineLocale(key, values);
            }
            else {
                data = moment.localeData(key);
            }

            if (data) {
                moment.duration._locale = moment._locale = data;
            }
        }

        return moment._locale._abbr;
    };

    moment.defineLocale = function (name, values) {
        if (values !== null) {
            values.abbr = name;
            if (!locales[name]) {
                locales[name] = new Locale();
            }
            locales[name].set(values);

            // backwards compat for now: also set the locale
            moment.locale(name);

            return locales[name];
        } else {
            // useful for testing
            delete locales[name];
            return null;
        }
    };

    moment.langData = deprecate(
        'moment.langData is deprecated. Use moment.localeData instead.',
        function (key) {
            return moment.localeData(key);
        }
    );

    // returns locale data
    moment.localeData = function (key) {
        var locale;

        if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
        }

        if (!key) {
            return moment._locale;
        }

        if (!isArray(key)) {
            //short-circuit everything else
            locale = loadLocale(key);
            if (locale) {
                return locale;
            }
            key = [key];
        }

        return chooseLocale(key);
    };

    // compare moment object
    moment.isMoment = function (obj) {
        return obj instanceof Moment ||
            (obj != null && hasOwnProp(obj, '_isAMomentObject'));
    };

    // for typechecking Duration objects
    moment.isDuration = function (obj) {
        return obj instanceof Duration;
    };

    for (i = lists.length - 1; i >= 0; --i) {
        makeList(lists[i]);
    }

    moment.normalizeUnits = function (units) {
        return normalizeUnits(units);
    };

    moment.invalid = function (flags) {
        var m = moment.utc(NaN);
        if (flags != null) {
            extend(m._pf, flags);
        }
        else {
            m._pf.userInvalidated = true;
        }

        return m;
    };

    moment.parseZone = function () {
        return moment.apply(null, arguments).parseZone();
    };

    moment.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    };

    /************************************
        Moment Prototype
    ************************************/


    extend(moment.fn = Moment.prototype, {

        clone: function () {
            return moment(this);
        },

        valueOf: function () {
            return +this._d + ((this._offset || 0) * 60000);
        },

        unix: function () {
            return Math.floor(+this / 1000);
        },

        toString: function () {
            return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
        },

        toDate: function () {
            return this._offset ? new Date(+this) : this._d;
        },

        toISOString: function () {
            var m = moment(this).utc();
            if (0 < m.year() && m.year() <= 9999) {
                return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
            } else {
                return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
            }
        },

        toArray: function () {
            var m = this;
            return [
                m.year(),
                m.month(),
                m.date(),
                m.hours(),
                m.minutes(),
                m.seconds(),
                m.milliseconds()
            ];
        },

        isValid: function () {
            return isValid(this);
        },

        isDSTShifted: function () {
            if (this._a) {
                return this.isValid() && compareArrays(this._a, (this._isUTC ? moment.utc(this._a) : moment(this._a)).toArray()) > 0;
            }

            return false;
        },

        parsingFlags: function () {
            return extend({}, this._pf);
        },

        invalidAt: function () {
            return this._pf.overflow;
        },

        utc: function (keepLocalTime) {
            return this.zone(0, keepLocalTime);
        },

        local: function (keepLocalTime) {
            if (this._isUTC) {
                this.zone(0, keepLocalTime);
                this._isUTC = false;

                if (keepLocalTime) {
                    this.add(this._dateTzOffset(), 'm');
                }
            }
            return this;
        },

        format: function (inputString) {
            var output = formatMoment(this, inputString || moment.defaultFormat);
            return this.localeData().postformat(output);
        },

        add: createAdder(1, 'add'),

        subtract: createAdder(-1, 'subtract'),

        diff: function (input, units, asFloat) {
            var that = makeAs(input, this),
                zoneDiff = (this.zone() - that.zone()) * 6e4,
                diff, output, daysAdjust;

            units = normalizeUnits(units);

            if (units === 'year' || units === 'month') {
                // average number of days in the months in the given dates
                diff = (this.daysInMonth() + that.daysInMonth()) * 432e5; // 24 * 60 * 60 * 1000 / 2
                // difference in months
                output = ((this.year() - that.year()) * 12) + (this.month() - that.month());
                // adjust by taking difference in days, average number of days
                // and dst in the given months.
                daysAdjust = (this - moment(this).startOf('month')) -
                    (that - moment(that).startOf('month'));
                // same as above but with zones, to negate all dst
                daysAdjust -= ((this.zone() - moment(this).startOf('month').zone()) -
                    (that.zone() - moment(that).startOf('month').zone())) * 6e4;
                output += daysAdjust / diff;
                if (units === 'year') {
                    output = output / 12;
                }
            } else {
                diff = (this - that);
                output = units === 'second' ? diff / 1e3 : // 1000
                    units === 'minute' ? diff / 6e4 : // 1000 * 60
                        units === 'hour' ? diff / 36e5 : // 1000 * 60 * 60
                            units === 'day' ? (diff - zoneDiff) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
                                units === 'week' ? (diff - zoneDiff) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
                                    diff;
            }
            return asFloat ? output : absRound(output);
        },

        from: function (time, withoutSuffix) {
            return moment.duration({ to: this, from: time }).locale(this.locale()).humanize(!withoutSuffix);
        },

        fromNow: function (withoutSuffix) {
            return this.from(moment(), withoutSuffix);
        },

        calendar: function (time) {
            // We want to compare the start of today, vs this.
            // Getting start-of-today depends on whether we're zone'd or not.
            var now = time || moment(),
                sod = makeAs(now, this).startOf('day'),
                diff = this.diff(sod, 'days', true),
                format = diff < -6 ? 'sameElse' :
                    diff < -1 ? 'lastWeek' :
                        diff < 0 ? 'lastDay' :
                            diff < 1 ? 'sameDay' :
                                diff < 2 ? 'nextDay' :
                                    diff < 7 ? 'nextWeek' : 'sameElse';
            return this.format(this.localeData().calendar(format, this));
        },

        isLeapYear: function () {
            return isLeapYear(this.year());
        },

        isDST: function () {
            return (this.zone() < this.clone().month(0).zone() ||
                this.zone() < this.clone().month(5).zone());
        },

        day: function (input) {
            var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
            if (input != null) {
                input = parseWeekday(input, this.localeData());
                return this.add(input - day, 'd');
            } else {
                return day;
            }
        },

        month: makeAccessor('Month', true),

        startOf: function (units) {
            units = normalizeUnits(units);
            // the following switch intentionally omits break keywords
            // to utilize falling through the cases.
            switch (units) {
                case 'year':
                    this.month(0);
                /* falls through */
                case 'quarter':
                case 'month':
                    this.date(1);
                /* falls through */
                case 'week':
                case 'isoWeek':
                case 'day':
                    this.hours(0);
                /* falls through */
                case 'hour':
                    this.minutes(0);
                /* falls through */
                case 'minute':
                    this.seconds(0);
                /* falls through */
                case 'second':
                    this.milliseconds(0);
                /* falls through */
            }

            // weeks are a special case
            if (units === 'week') {
                this.weekday(0);
            } else if (units === 'isoWeek') {
                this.isoWeekday(1);
            }

            // quarters are also special
            if (units === 'quarter') {
                this.month(Math.floor(this.month() / 3) * 3);
            }

            return this;
        },

        endOf: function (units) {
            units = normalizeUnits(units);
            return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
        },

        isAfter: function (input, units) {
            units = normalizeUnits(typeof units !== 'undefined' ? units : 'millisecond');
            if (units === 'millisecond') {
                input = moment.isMoment(input) ? input : moment(input);
                return +this > +input;
            } else {
                return +this.clone().startOf(units) > +moment(input).startOf(units);
            }
        },

        isBefore: function (input, units) {
            units = normalizeUnits(typeof units !== 'undefined' ? units : 'millisecond');
            if (units === 'millisecond') {
                input = moment.isMoment(input) ? input : moment(input);
                return +this < +input;
            } else {
                return +this.clone().startOf(units) < +moment(input).startOf(units);
            }
        },

        isSame: function (input, units) {
            units = normalizeUnits(units || 'millisecond');
            if (units === 'millisecond') {
                input = moment.isMoment(input) ? input : moment(input);
                return +this === +input;
            } else {
                return +this.clone().startOf(units) === +makeAs(input, this).startOf(units);
            }
        },

        min: deprecate(
            'moment().min is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548',
            function (other) {
                other = moment.apply(null, arguments);
                return other < this ? this : other;
            }
        ),

        max: deprecate(
            'moment().max is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548',
            function (other) {
                other = moment.apply(null, arguments);
                return other > this ? this : other;
            }
        ),

        // keepLocalTime = true means only change the timezone, without
        // affecting the local hour. So 5:31:26 +0300 --[zone(2, true)]-->
        // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist int zone
        // +0200, so we adjust the time as needed, to be valid.
        //
        // Keeping the time actually adds/subtracts (one hour)
        // from the actual represented time. That is why we call updateOffset
        // a second time. In case it wants us to change the offset again
        // _changeInProgress == true case, then we have to adjust, because
        // there is no such time in the given timezone.
        zone: function (input, keepLocalTime) {
            var offset = this._offset || 0,
                localAdjust;
            if (input != null) {
                if (typeof input === 'string') {
                    input = timezoneMinutesFromString(input);
                }
                if (Math.abs(input) < 16) {
                    input = input * 60;
                }
                if (!this._isUTC && keepLocalTime) {
                    localAdjust = this._dateTzOffset();
                }
                this._offset = input;
                this._isUTC = true;
                if (localAdjust != null) {
                    this.subtract(localAdjust, 'm');
                }
                if (offset !== input) {
                    if (!keepLocalTime || this._changeInProgress) {
                        addOrSubtractDurationFromMoment(this,
                            moment.duration(offset - input, 'm'), 1, false);
                    } else if (!this._changeInProgress) {
                        this._changeInProgress = true;
                        moment.updateOffset(this, true);
                        this._changeInProgress = null;
                    }
                }
            } else {
                return this._isUTC ? offset : this._dateTzOffset();
            }
            return this;
        },

        zoneAbbr: function () {
            return this._isUTC ? 'UTC' : '';
        },

        zoneName: function () {
            return this._isUTC ? 'Coordinated Universal Time' : '';
        },

        parseZone: function () {
            if (this._tzm) {
                this.zone(this._tzm);
            } else if (typeof this._i === 'string') {
                this.zone(this._i);
            }
            return this;
        },

        hasAlignedHourOffset: function (input) {
            if (!input) {
                input = 0;
            }
            else {
                input = moment(input).zone();
            }

            return (this.zone() - input) % 60 === 0;
        },

        daysInMonth: function () {
            return daysInMonth(this.year(), this.month());
        },

        dayOfYear: function (input) {
            var dayOfYear = round((moment(this).startOf('day') - moment(this).startOf('year')) / 864e5) + 1;
            return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
        },

        quarter: function (input) {
            return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
        },

        weekYear: function (input) {
            var year = weekOfYear(this, this.localeData()._week.dow, this.localeData()._week.doy).year;
            return input == null ? year : this.add((input - year), 'y');
        },

        isoWeekYear: function (input) {
            var year = weekOfYear(this, 1, 4).year;
            return input == null ? year : this.add((input - year), 'y');
        },

        week: function (input) {
            var week = this.localeData().week(this);
            return input == null ? week : this.add((input - week) * 7, 'd');
        },

        isoWeek: function (input) {
            var week = weekOfYear(this, 1, 4).week;
            return input == null ? week : this.add((input - week) * 7, 'd');
        },

        weekday: function (input) {
            var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
            return input == null ? weekday : this.add(input - weekday, 'd');
        },

        isoWeekday: function (input) {
            // behaves the same as moment#day except
            // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
            // as a setter, sunday should belong to the previous week.
            return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
        },

        isoWeeksInYear: function () {
            return weeksInYear(this.year(), 1, 4);
        },

        weeksInYear: function () {
            var weekInfo = this.localeData()._week;
            return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
        },

        get: function (units) {
            units = normalizeUnits(units);
            return this[units]();
        },

        set: function (units, value) {
            units = normalizeUnits(units);
            if (typeof this[units] === 'function') {
                this[units](value);
            }
            return this;
        },

        // If passed a locale key, it will set the locale for this
        // instance.  Otherwise, it will return the locale configuration
        // variables for this instance.
        locale: function (key) {
            var newLocaleData;

            if (key === undefined) {
                return this._locale._abbr;
            } else {
                newLocaleData = moment.localeData(key);
                if (newLocaleData != null) {
                    this._locale = newLocaleData;
                }
                return this;
            }
        },

        lang: deprecate(
            'moment().lang() is deprecated. Use moment().localeData() instead.',
            function (key) {
                if (key === undefined) {
                    return this.localeData();
                } else {
                    return this.locale(key);
                }
            }
        ),

        localeData: function () {
            return this._locale;
        },

        _dateTzOffset: function () {
            // On Firefox.24 Date#getTimezoneOffset returns a floating point.
            // https://github.com/moment/moment/pull/1871
            return Math.round(this._d.getTimezoneOffset() / 15) * 15;
        }
    });

    function rawMonthSetter(mom, value) {
        var dayOfMonth;

        // TODO: Move this out of here!
        if (typeof value === 'string') {
            value = mom.localeData().monthsParse(value);
            // TODO: Another silent failure?
            if (typeof value !== 'number') {
                return mom;
            }
        }

        dayOfMonth = Math.min(mom.date(),
            daysInMonth(mom.year(), value));
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
        return mom;
    }

    function rawGetter(mom, unit) {
        return mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]();
    }

    function rawSetter(mom, unit, value) {
        if (unit === 'Month') {
            return rawMonthSetter(mom, value);
        } else {
            return mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
        }
    }

    function makeAccessor(unit, keepTime) {
        return function (value) {
            if (value != null) {
                rawSetter(this, unit, value);
                moment.updateOffset(this, keepTime);
                return this;
            } else {
                return rawGetter(this, unit);
            }
        };
    }

    moment.fn.millisecond = moment.fn.milliseconds = makeAccessor('Milliseconds', false);
    moment.fn.second = moment.fn.seconds = makeAccessor('Seconds', false);
    moment.fn.minute = moment.fn.minutes = makeAccessor('Minutes', false);
    // Setting the hour should keep the time, because the user explicitly
    // specified which hour he wants. So trying to maintain the same hour (in
    // a new timezone) makes sense. Adding/subtracting hours does not follow
    // this rule.
    moment.fn.hour = moment.fn.hours = makeAccessor('Hours', true);
    // moment.fn.month is defined separately
    moment.fn.date = makeAccessor('Date', true);
    moment.fn.dates = deprecate('dates accessor is deprecated. Use date instead.', makeAccessor('Date', true));
    moment.fn.year = makeAccessor('FullYear', true);
    moment.fn.years = deprecate('years accessor is deprecated. Use year instead.', makeAccessor('FullYear', true));

    // add plural methods
    moment.fn.days = moment.fn.day;
    moment.fn.months = moment.fn.month;
    moment.fn.weeks = moment.fn.week;
    moment.fn.isoWeeks = moment.fn.isoWeek;
    moment.fn.quarters = moment.fn.quarter;

    // add aliased format methods
    moment.fn.toJSON = moment.fn.toISOString;

    /************************************
        Duration Prototype
    ************************************/


    function daysToYears(days) {
        // 400 years have 146097 days (taking into account leap year rules)
        return days * 400 / 146097;
    }

    function yearsToDays(years) {
        // years * 365 + absRound(years / 4) -
        //     absRound(years / 100) + absRound(years / 400);
        return years * 146097 / 400;
    }

    extend(moment.duration.fn = Duration.prototype, {

        _bubble: function () {
            var milliseconds = this._milliseconds,
                days = this._days,
                months = this._months,
                data = this._data,
                seconds, minutes, hours, years = 0;

            // The following code bubbles up values, see the tests for
            // examples of what that means.
            data.milliseconds = milliseconds % 1000;

            seconds = absRound(milliseconds / 1000);
            data.seconds = seconds % 60;

            minutes = absRound(seconds / 60);
            data.minutes = minutes % 60;

            hours = absRound(minutes / 60);
            data.hours = hours % 24;

            days += absRound(hours / 24);

            // Accurately convert days to years, assume start from year 0.
            years = absRound(daysToYears(days));
            days -= absRound(yearsToDays(years));

            // 30 days to a month
            // TODO (iskren): Use anchor date (like 1st Jan) to compute this.
            months += absRound(days / 30);
            days %= 30;

            // 12 months -> 1 year
            years += absRound(months / 12);
            months %= 12;

            data.days = days;
            data.months = months;
            data.years = years;
        },

        abs: function () {
            this._milliseconds = Math.abs(this._milliseconds);
            this._days = Math.abs(this._days);
            this._months = Math.abs(this._months);

            this._data.milliseconds = Math.abs(this._data.milliseconds);
            this._data.seconds = Math.abs(this._data.seconds);
            this._data.minutes = Math.abs(this._data.minutes);
            this._data.hours = Math.abs(this._data.hours);
            this._data.months = Math.abs(this._data.months);
            this._data.years = Math.abs(this._data.years);

            return this;
        },

        weeks: function () {
            return absRound(this.days() / 7);
        },

        valueOf: function () {
            return this._milliseconds +
                this._days * 864e5 +
                (this._months % 12) * 2592e6 +
                toInt(this._months / 12) * 31536e6;
        },

        humanize: function (withSuffix) {
            var output = relativeTime(this, !withSuffix, this.localeData());

            if (withSuffix) {
                output = this.localeData().pastFuture(+this, output);
            }

            return this.localeData().postformat(output);
        },

        add: function (input, val) {
            // supports only 2.0-style add(1, 's') or add(moment)
            var dur = moment.duration(input, val);

            this._milliseconds += dur._milliseconds;
            this._days += dur._days;
            this._months += dur._months;

            this._bubble();

            return this;
        },

        subtract: function (input, val) {
            var dur = moment.duration(input, val);

            this._milliseconds -= dur._milliseconds;
            this._days -= dur._days;
            this._months -= dur._months;

            this._bubble();

            return this;
        },

        get: function (units) {
            units = normalizeUnits(units);
            return this[units.toLowerCase() + 's']();
        },

        as: function (units) {
            var days, months;
            units = normalizeUnits(units);

            if (units === 'month' || units === 'year') {
                days = this._days + this._milliseconds / 864e5;
                months = this._months + daysToYears(days) * 12;
                return units === 'month' ? months : months / 12;
            } else {
                // handle milliseconds separately because of floating point math errors (issue #1867)
                days = this._days + yearsToDays(this._months / 12);
                switch (units) {
                    case 'week': return days / 7 + this._milliseconds / 6048e5;
                    case 'day': return days + this._milliseconds / 864e5;
                    case 'hour': return days * 24 + this._milliseconds / 36e5;
                    case 'minute': return days * 24 * 60 + this._milliseconds / 6e4;
                    case 'second': return days * 24 * 60 * 60 + this._milliseconds / 1000;
                    // Math.floor prevents floating point math errors here
                    case 'millisecond': return Math.floor(days * 24 * 60 * 60 * 1000) + this._milliseconds;
                    default: throw new Error('Unknown unit ' + units);
                }
            }
        },

        lang: moment.fn.lang,
        locale: moment.fn.locale,

        toIsoString: deprecate(
            'toIsoString() is deprecated. Please use toISOString() instead ' +
            '(notice the capitals)',
            function () {
                return this.toISOString();
            }
        ),

        toISOString: function () {
            // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
            var years = Math.abs(this.years()),
                months = Math.abs(this.months()),
                days = Math.abs(this.days()),
                hours = Math.abs(this.hours()),
                minutes = Math.abs(this.minutes()),
                seconds = Math.abs(this.seconds() + this.milliseconds() / 1000);

            if (!this.asSeconds()) {
                // this is the same as C#'s (Noda) and python (isodate)...
                // but not other JS (goog.date)
                return 'P0D';
            }

            return (this.asSeconds() < 0 ? '-' : '') +
                'P' +
                (years ? years + 'Y' : '') +
                (months ? months + 'M' : '') +
                (days ? days + 'D' : '') +
                ((hours || minutes || seconds) ? 'T' : '') +
                (hours ? hours + 'H' : '') +
                (minutes ? minutes + 'M' : '') +
                (seconds ? seconds + 'S' : '');
        },

        localeData: function () {
            return this._locale;
        }
    });

    moment.duration.fn.toString = moment.duration.fn.toISOString;

    function makeDurationGetter(name) {
        moment.duration.fn[name] = function () {
            return this._data[name];
        };
    }

    for (i in unitMillisecondFactors) {
        if (hasOwnProp(unitMillisecondFactors, i)) {
            makeDurationGetter(i.toLowerCase());
        }
    }

    moment.duration.fn.asMilliseconds = function () {
        return this.as('ms');
    };
    moment.duration.fn.asSeconds = function () {
        return this.as('s');
    };
    moment.duration.fn.asMinutes = function () {
        return this.as('m');
    };
    moment.duration.fn.asHours = function () {
        return this.as('h');
    };
    moment.duration.fn.asDays = function () {
        return this.as('d');
    };
    moment.duration.fn.asWeeks = function () {
        return this.as('weeks');
    };
    moment.duration.fn.asMonths = function () {
        return this.as('M');
    };
    moment.duration.fn.asYears = function () {
        return this.as('y');
    };

    /************************************
        Default Locale
    ************************************/


    // Set default locale, other locale will inherit from English.
    moment.locale('en', {
        ordinal: function (number) {
            var b = number % 10,
                output = (toInt(number % 100 / 10) === 1) ? 'th' :
                    (b === 1) ? 'st' :
                        (b === 2) ? 'nd' :
                            (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });

    /* EMBED_LOCALES */

    /************************************
        Exposing Moment
    ************************************/

    function makeGlobal(shouldDeprecate) {
        /*global ender:false */
        if (typeof ender !== 'undefined') {
            return;
        }
        oldGlobalMoment = globalScope.moment;
        if (shouldDeprecate) {
            globalScope.moment = deprecate(
                'Accessing Moment through the global scope is ' +
                'deprecated, and will be removed in an upcoming ' +
                'release.',
                moment);
        } else {
            globalScope.moment = moment;
        }
    }

    // CommonJS module is defined
    if (hasModule) {
        module.exports = moment;
    } else if (typeof define === 'function' && define.amd) {
        define('moment', function (require, exports, module) {
            if (module.config && module.config() && module.config().noGlobal === true) {
                // release the global variable
                globalScope.moment = oldGlobalMoment;
            }

            return moment;
        });
        makeGlobal(true);
    } else {
        makeGlobal();
    }
}).call(this);
;
/*
Copyright 2012 Igor Vaynberg

Version: 3.5.4 Timestamp: Sun Aug 30 13:30:32 EDT 2015

This software is licensed under the Apache License, Version 2.0 (the "Apache License") or the GNU
General Public License version 2 (the "GPL License"). You may choose either license to govern your
use of this software only upon the condition that you accept all of the terms of either the Apache
License or the GPL License.

You may obtain a copy of the Apache License and the GPL License at:

    http://www.apache.org/licenses/LICENSE-2.0
    http://www.gnu.org/licenses/gpl-2.0.html

Unless required by applicable law or agreed to in writing, software distributed under the
Apache License or the GPL License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
CONDITIONS OF ANY KIND, either express or implied. See the Apache License and the GPL License for
the specific language governing permissions and limitations under the Apache License and the GPL License.
*/
(function ($) {
    if (typeof $.fn.each2 == "undefined") {
        $.extend($.fn, {
            /*
            * 4-10 times faster .each replacement
            * use it carefully, as it overrides jQuery context of element on each iteration
            */
            each2: function (c) {
                var j = $([0]), i = -1, l = this.length;
                while (
                    ++i < l
                    && (j.context = j[0] = this[i])
                    && c.call(j[0], i, j) !== false //"this"=DOM, i=index, j=jQuery object
                );
                return this;
            }
        });
    }
})(jQuery);

(function ($, undefined) {
    "use strict";
    /*global document, window, jQuery, console */

    if (window.Select2 !== undefined) {
        return;
    }

    var AbstractSelect2, SingleSelect2, MultiSelect2, nextUid, sizer,
        lastMousePosition = { x: 0, y: 0 }, $document, scrollBarDimensions,

        KEY = {
            TAB: 9,
            ENTER: 13,
            ESC: 27,
            SPACE: 32,
            LEFT: 37,
            UP: 38,
            RIGHT: 39,
            DOWN: 40,
            SHIFT: 16,
            CTRL: 17,
            ALT: 18,
            PAGE_UP: 33,
            PAGE_DOWN: 34,
            HOME: 36,
            END: 35,
            BACKSPACE: 8,
            DELETE: 46,
            isArrow: function (k) {
                k = k.which ? k.which : k;
                switch (k) {
                    case KEY.LEFT:
                    case KEY.RIGHT:
                    case KEY.UP:
                    case KEY.DOWN:
                        return true;
                }
                return false;
            },
            isControl: function (e) {
                var k = e.which;
                switch (k) {
                    case KEY.SHIFT:
                    case KEY.CTRL:
                    case KEY.ALT:
                        return true;
                }

                if (e.metaKey) return true;

                return false;
            },
            isFunctionKey: function (k) {
                k = k.which ? k.which : k;
                return k >= 112 && k <= 123;
            }
        },
        MEASURE_SCROLLBAR_TEMPLATE = "<div class='select2-measure-scrollbar'></div>",

        DIACRITICS = { "\u24B6": "A", "\uFF21": "A", "\u00C0": "A", "\u00C1": "A", "\u00C2": "A", "\u1EA6": "A", "\u1EA4": "A", "\u1EAA": "A", "\u1EA8": "A", "\u00C3": "A", "\u0100": "A", "\u0102": "A", "\u1EB0": "A", "\u1EAE": "A", "\u1EB4": "A", "\u1EB2": "A", "\u0226": "A", "\u01E0": "A", "\u00C4": "A", "\u01DE": "A", "\u1EA2": "A", "\u00C5": "A", "\u01FA": "A", "\u01CD": "A", "\u0200": "A", "\u0202": "A", "\u1EA0": "A", "\u1EAC": "A", "\u1EB6": "A", "\u1E00": "A", "\u0104": "A", "\u023A": "A", "\u2C6F": "A", "\uA732": "AA", "\u00C6": "AE", "\u01FC": "AE", "\u01E2": "AE", "\uA734": "AO", "\uA736": "AU", "\uA738": "AV", "\uA73A": "AV", "\uA73C": "AY", "\u24B7": "B", "\uFF22": "B", "\u1E02": "B", "\u1E04": "B", "\u1E06": "B", "\u0243": "B", "\u0182": "B", "\u0181": "B", "\u24B8": "C", "\uFF23": "C", "\u0106": "C", "\u0108": "C", "\u010A": "C", "\u010C": "C", "\u00C7": "C", "\u1E08": "C", "\u0187": "C", "\u023B": "C", "\uA73E": "C", "\u24B9": "D", "\uFF24": "D", "\u1E0A": "D", "\u010E": "D", "\u1E0C": "D", "\u1E10": "D", "\u1E12": "D", "\u1E0E": "D", "\u0110": "D", "\u018B": "D", "\u018A": "D", "\u0189": "D", "\uA779": "D", "\u01F1": "DZ", "\u01C4": "DZ", "\u01F2": "Dz", "\u01C5": "Dz", "\u24BA": "E", "\uFF25": "E", "\u00C8": "E", "\u00C9": "E", "\u00CA": "E", "\u1EC0": "E", "\u1EBE": "E", "\u1EC4": "E", "\u1EC2": "E", "\u1EBC": "E", "\u0112": "E", "\u1E14": "E", "\u1E16": "E", "\u0114": "E", "\u0116": "E", "\u00CB": "E", "\u1EBA": "E", "\u011A": "E", "\u0204": "E", "\u0206": "E", "\u1EB8": "E", "\u1EC6": "E", "\u0228": "E", "\u1E1C": "E", "\u0118": "E", "\u1E18": "E", "\u1E1A": "E", "\u0190": "E", "\u018E": "E", "\u24BB": "F", "\uFF26": "F", "\u1E1E": "F", "\u0191": "F", "\uA77B": "F", "\u24BC": "G", "\uFF27": "G", "\u01F4": "G", "\u011C": "G", "\u1E20": "G", "\u011E": "G", "\u0120": "G", "\u01E6": "G", "\u0122": "G", "\u01E4": "G", "\u0193": "G", "\uA7A0": "G", "\uA77D": "G", "\uA77E": "G", "\u24BD": "H", "\uFF28": "H", "\u0124": "H", "\u1E22": "H", "\u1E26": "H", "\u021E": "H", "\u1E24": "H", "\u1E28": "H", "\u1E2A": "H", "\u0126": "H", "\u2C67": "H", "\u2C75": "H", "\uA78D": "H", "\u24BE": "I", "\uFF29": "I", "\u00CC": "I", "\u00CD": "I", "\u00CE": "I", "\u0128": "I", "\u012A": "I", "\u012C": "I", "\u0130": "I", "\u00CF": "I", "\u1E2E": "I", "\u1EC8": "I", "\u01CF": "I", "\u0208": "I", "\u020A": "I", "\u1ECA": "I", "\u012E": "I", "\u1E2C": "I", "\u0197": "I", "\u24BF": "J", "\uFF2A": "J", "\u0134": "J", "\u0248": "J", "\u24C0": "K", "\uFF2B": "K", "\u1E30": "K", "\u01E8": "K", "\u1E32": "K", "\u0136": "K", "\u1E34": "K", "\u0198": "K", "\u2C69": "K", "\uA740": "K", "\uA742": "K", "\uA744": "K", "\uA7A2": "K", "\u24C1": "L", "\uFF2C": "L", "\u013F": "L", "\u0139": "L", "\u013D": "L", "\u1E36": "L", "\u1E38": "L", "\u013B": "L", "\u1E3C": "L", "\u1E3A": "L", "\u0141": "L", "\u023D": "L", "\u2C62": "L", "\u2C60": "L", "\uA748": "L", "\uA746": "L", "\uA780": "L", "\u01C7": "LJ", "\u01C8": "Lj", "\u24C2": "M", "\uFF2D": "M", "\u1E3E": "M", "\u1E40": "M", "\u1E42": "M", "\u2C6E": "M", "\u019C": "M", "\u24C3": "N", "\uFF2E": "N", "\u01F8": "N", "\u0143": "N", "\u00D1": "N", "\u1E44": "N", "\u0147": "N", "\u1E46": "N", "\u0145": "N", "\u1E4A": "N", "\u1E48": "N", "\u0220": "N", "\u019D": "N", "\uA790": "N", "\uA7A4": "N", "\u01CA": "NJ", "\u01CB": "Nj", "\u24C4": "O", "\uFF2F": "O", "\u00D2": "O", "\u00D3": "O", "\u00D4": "O", "\u1ED2": "O", "\u1ED0": "O", "\u1ED6": "O", "\u1ED4": "O", "\u00D5": "O", "\u1E4C": "O", "\u022C": "O", "\u1E4E": "O", "\u014C": "O", "\u1E50": "O", "\u1E52": "O", "\u014E": "O", "\u022E": "O", "\u0230": "O", "\u00D6": "O", "\u022A": "O", "\u1ECE": "O", "\u0150": "O", "\u01D1": "O", "\u020C": "O", "\u020E": "O", "\u01A0": "O", "\u1EDC": "O", "\u1EDA": "O", "\u1EE0": "O", "\u1EDE": "O", "\u1EE2": "O", "\u1ECC": "O", "\u1ED8": "O", "\u01EA": "O", "\u01EC": "O", "\u00D8": "O", "\u01FE": "O", "\u0186": "O", "\u019F": "O", "\uA74A": "O", "\uA74C": "O", "\u01A2": "OI", "\uA74E": "OO", "\u0222": "OU", "\u24C5": "P", "\uFF30": "P", "\u1E54": "P", "\u1E56": "P", "\u01A4": "P", "\u2C63": "P", "\uA750": "P", "\uA752": "P", "\uA754": "P", "\u24C6": "Q", "\uFF31": "Q", "\uA756": "Q", "\uA758": "Q", "\u024A": "Q", "\u24C7": "R", "\uFF32": "R", "\u0154": "R", "\u1E58": "R", "\u0158": "R", "\u0210": "R", "\u0212": "R", "\u1E5A": "R", "\u1E5C": "R", "\u0156": "R", "\u1E5E": "R", "\u024C": "R", "\u2C64": "R", "\uA75A": "R", "\uA7A6": "R", "\uA782": "R", "\u24C8": "S", "\uFF33": "S", "\u1E9E": "S", "\u015A": "S", "\u1E64": "S", "\u015C": "S", "\u1E60": "S", "\u0160": "S", "\u1E66": "S", "\u1E62": "S", "\u1E68": "S", "\u0218": "S", "\u015E": "S", "\u2C7E": "S", "\uA7A8": "S", "\uA784": "S", "\u24C9": "T", "\uFF34": "T", "\u1E6A": "T", "\u0164": "T", "\u1E6C": "T", "\u021A": "T", "\u0162": "T", "\u1E70": "T", "\u1E6E": "T", "\u0166": "T", "\u01AC": "T", "\u01AE": "T", "\u023E": "T", "\uA786": "T", "\uA728": "TZ", "\u24CA": "U", "\uFF35": "U", "\u00D9": "U", "\u00DA": "U", "\u00DB": "U", "\u0168": "U", "\u1E78": "U", "\u016A": "U", "\u1E7A": "U", "\u016C": "U", "\u00DC": "U", "\u01DB": "U", "\u01D7": "U", "\u01D5": "U", "\u01D9": "U", "\u1EE6": "U", "\u016E": "U", "\u0170": "U", "\u01D3": "U", "\u0214": "U", "\u0216": "U", "\u01AF": "U", "\u1EEA": "U", "\u1EE8": "U", "\u1EEE": "U", "\u1EEC": "U", "\u1EF0": "U", "\u1EE4": "U", "\u1E72": "U", "\u0172": "U", "\u1E76": "U", "\u1E74": "U", "\u0244": "U", "\u24CB": "V", "\uFF36": "V", "\u1E7C": "V", "\u1E7E": "V", "\u01B2": "V", "\uA75E": "V", "\u0245": "V", "\uA760": "VY", "\u24CC": "W", "\uFF37": "W", "\u1E80": "W", "\u1E82": "W", "\u0174": "W", "\u1E86": "W", "\u1E84": "W", "\u1E88": "W", "\u2C72": "W", "\u24CD": "X", "\uFF38": "X", "\u1E8A": "X", "\u1E8C": "X", "\u24CE": "Y", "\uFF39": "Y", "\u1EF2": "Y", "\u00DD": "Y", "\u0176": "Y", "\u1EF8": "Y", "\u0232": "Y", "\u1E8E": "Y", "\u0178": "Y", "\u1EF6": "Y", "\u1EF4": "Y", "\u01B3": "Y", "\u024E": "Y", "\u1EFE": "Y", "\u24CF": "Z", "\uFF3A": "Z", "\u0179": "Z", "\u1E90": "Z", "\u017B": "Z", "\u017D": "Z", "\u1E92": "Z", "\u1E94": "Z", "\u01B5": "Z", "\u0224": "Z", "\u2C7F": "Z", "\u2C6B": "Z", "\uA762": "Z", "\u24D0": "a", "\uFF41": "a", "\u1E9A": "a", "\u00E0": "a", "\u00E1": "a", "\u00E2": "a", "\u1EA7": "a", "\u1EA5": "a", "\u1EAB": "a", "\u1EA9": "a", "\u00E3": "a", "\u0101": "a", "\u0103": "a", "\u1EB1": "a", "\u1EAF": "a", "\u1EB5": "a", "\u1EB3": "a", "\u0227": "a", "\u01E1": "a", "\u00E4": "a", "\u01DF": "a", "\u1EA3": "a", "\u00E5": "a", "\u01FB": "a", "\u01CE": "a", "\u0201": "a", "\u0203": "a", "\u1EA1": "a", "\u1EAD": "a", "\u1EB7": "a", "\u1E01": "a", "\u0105": "a", "\u2C65": "a", "\u0250": "a", "\uA733": "aa", "\u00E6": "ae", "\u01FD": "ae", "\u01E3": "ae", "\uA735": "ao", "\uA737": "au", "\uA739": "av", "\uA73B": "av", "\uA73D": "ay", "\u24D1": "b", "\uFF42": "b", "\u1E03": "b", "\u1E05": "b", "\u1E07": "b", "\u0180": "b", "\u0183": "b", "\u0253": "b", "\u24D2": "c", "\uFF43": "c", "\u0107": "c", "\u0109": "c", "\u010B": "c", "\u010D": "c", "\u00E7": "c", "\u1E09": "c", "\u0188": "c", "\u023C": "c", "\uA73F": "c", "\u2184": "c", "\u24D3": "d", "\uFF44": "d", "\u1E0B": "d", "\u010F": "d", "\u1E0D": "d", "\u1E11": "d", "\u1E13": "d", "\u1E0F": "d", "\u0111": "d", "\u018C": "d", "\u0256": "d", "\u0257": "d", "\uA77A": "d", "\u01F3": "dz", "\u01C6": "dz", "\u24D4": "e", "\uFF45": "e", "\u00E8": "e", "\u00E9": "e", "\u00EA": "e", "\u1EC1": "e", "\u1EBF": "e", "\u1EC5": "e", "\u1EC3": "e", "\u1EBD": "e", "\u0113": "e", "\u1E15": "e", "\u1E17": "e", "\u0115": "e", "\u0117": "e", "\u00EB": "e", "\u1EBB": "e", "\u011B": "e", "\u0205": "e", "\u0207": "e", "\u1EB9": "e", "\u1EC7": "e", "\u0229": "e", "\u1E1D": "e", "\u0119": "e", "\u1E19": "e", "\u1E1B": "e", "\u0247": "e", "\u025B": "e", "\u01DD": "e", "\u24D5": "f", "\uFF46": "f", "\u1E1F": "f", "\u0192": "f", "\uA77C": "f", "\u24D6": "g", "\uFF47": "g", "\u01F5": "g", "\u011D": "g", "\u1E21": "g", "\u011F": "g", "\u0121": "g", "\u01E7": "g", "\u0123": "g", "\u01E5": "g", "\u0260": "g", "\uA7A1": "g", "\u1D79": "g", "\uA77F": "g", "\u24D7": "h", "\uFF48": "h", "\u0125": "h", "\u1E23": "h", "\u1E27": "h", "\u021F": "h", "\u1E25": "h", "\u1E29": "h", "\u1E2B": "h", "\u1E96": "h", "\u0127": "h", "\u2C68": "h", "\u2C76": "h", "\u0265": "h", "\u0195": "hv", "\u24D8": "i", "\uFF49": "i", "\u00EC": "i", "\u00ED": "i", "\u00EE": "i", "\u0129": "i", "\u012B": "i", "\u012D": "i", "\u00EF": "i", "\u1E2F": "i", "\u1EC9": "i", "\u01D0": "i", "\u0209": "i", "\u020B": "i", "\u1ECB": "i", "\u012F": "i", "\u1E2D": "i", "\u0268": "i", "\u0131": "i", "\u24D9": "j", "\uFF4A": "j", "\u0135": "j", "\u01F0": "j", "\u0249": "j", "\u24DA": "k", "\uFF4B": "k", "\u1E31": "k", "\u01E9": "k", "\u1E33": "k", "\u0137": "k", "\u1E35": "k", "\u0199": "k", "\u2C6A": "k", "\uA741": "k", "\uA743": "k", "\uA745": "k", "\uA7A3": "k", "\u24DB": "l", "\uFF4C": "l", "\u0140": "l", "\u013A": "l", "\u013E": "l", "\u1E37": "l", "\u1E39": "l", "\u013C": "l", "\u1E3D": "l", "\u1E3B": "l", "\u017F": "l", "\u0142": "l", "\u019A": "l", "\u026B": "l", "\u2C61": "l", "\uA749": "l", "\uA781": "l", "\uA747": "l", "\u01C9": "lj", "\u24DC": "m", "\uFF4D": "m", "\u1E3F": "m", "\u1E41": "m", "\u1E43": "m", "\u0271": "m", "\u026F": "m", "\u24DD": "n", "\uFF4E": "n", "\u01F9": "n", "\u0144": "n", "\u00F1": "n", "\u1E45": "n", "\u0148": "n", "\u1E47": "n", "\u0146": "n", "\u1E4B": "n", "\u1E49": "n", "\u019E": "n", "\u0272": "n", "\u0149": "n", "\uA791": "n", "\uA7A5": "n", "\u01CC": "nj", "\u24DE": "o", "\uFF4F": "o", "\u00F2": "o", "\u00F3": "o", "\u00F4": "o", "\u1ED3": "o", "\u1ED1": "o", "\u1ED7": "o", "\u1ED5": "o", "\u00F5": "o", "\u1E4D": "o", "\u022D": "o", "\u1E4F": "o", "\u014D": "o", "\u1E51": "o", "\u1E53": "o", "\u014F": "o", "\u022F": "o", "\u0231": "o", "\u00F6": "o", "\u022B": "o", "\u1ECF": "o", "\u0151": "o", "\u01D2": "o", "\u020D": "o", "\u020F": "o", "\u01A1": "o", "\u1EDD": "o", "\u1EDB": "o", "\u1EE1": "o", "\u1EDF": "o", "\u1EE3": "o", "\u1ECD": "o", "\u1ED9": "o", "\u01EB": "o", "\u01ED": "o", "\u00F8": "o", "\u01FF": "o", "\u0254": "o", "\uA74B": "o", "\uA74D": "o", "\u0275": "o", "\u01A3": "oi", "\u0223": "ou", "\uA74F": "oo", "\u24DF": "p", "\uFF50": "p", "\u1E55": "p", "\u1E57": "p", "\u01A5": "p", "\u1D7D": "p", "\uA751": "p", "\uA753": "p", "\uA755": "p", "\u24E0": "q", "\uFF51": "q", "\u024B": "q", "\uA757": "q", "\uA759": "q", "\u24E1": "r", "\uFF52": "r", "\u0155": "r", "\u1E59": "r", "\u0159": "r", "\u0211": "r", "\u0213": "r", "\u1E5B": "r", "\u1E5D": "r", "\u0157": "r", "\u1E5F": "r", "\u024D": "r", "\u027D": "r", "\uA75B": "r", "\uA7A7": "r", "\uA783": "r", "\u24E2": "s", "\uFF53": "s", "\u00DF": "s", "\u015B": "s", "\u1E65": "s", "\u015D": "s", "\u1E61": "s", "\u0161": "s", "\u1E67": "s", "\u1E63": "s", "\u1E69": "s", "\u0219": "s", "\u015F": "s", "\u023F": "s", "\uA7A9": "s", "\uA785": "s", "\u1E9B": "s", "\u24E3": "t", "\uFF54": "t", "\u1E6B": "t", "\u1E97": "t", "\u0165": "t", "\u1E6D": "t", "\u021B": "t", "\u0163": "t", "\u1E71": "t", "\u1E6F": "t", "\u0167": "t", "\u01AD": "t", "\u0288": "t", "\u2C66": "t", "\uA787": "t", "\uA729": "tz", "\u24E4": "u", "\uFF55": "u", "\u00F9": "u", "\u00FA": "u", "\u00FB": "u", "\u0169": "u", "\u1E79": "u", "\u016B": "u", "\u1E7B": "u", "\u016D": "u", "\u00FC": "u", "\u01DC": "u", "\u01D8": "u", "\u01D6": "u", "\u01DA": "u", "\u1EE7": "u", "\u016F": "u", "\u0171": "u", "\u01D4": "u", "\u0215": "u", "\u0217": "u", "\u01B0": "u", "\u1EEB": "u", "\u1EE9": "u", "\u1EEF": "u", "\u1EED": "u", "\u1EF1": "u", "\u1EE5": "u", "\u1E73": "u", "\u0173": "u", "\u1E77": "u", "\u1E75": "u", "\u0289": "u", "\u24E5": "v", "\uFF56": "v", "\u1E7D": "v", "\u1E7F": "v", "\u028B": "v", "\uA75F": "v", "\u028C": "v", "\uA761": "vy", "\u24E6": "w", "\uFF57": "w", "\u1E81": "w", "\u1E83": "w", "\u0175": "w", "\u1E87": "w", "\u1E85": "w", "\u1E98": "w", "\u1E89": "w", "\u2C73": "w", "\u24E7": "x", "\uFF58": "x", "\u1E8B": "x", "\u1E8D": "x", "\u24E8": "y", "\uFF59": "y", "\u1EF3": "y", "\u00FD": "y", "\u0177": "y", "\u1EF9": "y", "\u0233": "y", "\u1E8F": "y", "\u00FF": "y", "\u1EF7": "y", "\u1E99": "y", "\u1EF5": "y", "\u01B4": "y", "\u024F": "y", "\u1EFF": "y", "\u24E9": "z", "\uFF5A": "z", "\u017A": "z", "\u1E91": "z", "\u017C": "z", "\u017E": "z", "\u1E93": "z", "\u1E95": "z", "\u01B6": "z", "\u0225": "z", "\u0240": "z", "\u2C6C": "z", "\uA763": "z", "\u0386": "\u0391", "\u0388": "\u0395", "\u0389": "\u0397", "\u038A": "\u0399", "\u03AA": "\u0399", "\u038C": "\u039F", "\u038E": "\u03A5", "\u03AB": "\u03A5", "\u038F": "\u03A9", "\u03AC": "\u03B1", "\u03AD": "\u03B5", "\u03AE": "\u03B7", "\u03AF": "\u03B9", "\u03CA": "\u03B9", "\u0390": "\u03B9", "\u03CC": "\u03BF", "\u03CD": "\u03C5", "\u03CB": "\u03C5", "\u03B0": "\u03C5", "\u03C9": "\u03C9", "\u03C2": "\u03C3" };

    $document = $(document);

    nextUid = (function () { var counter = 1; return function () { return counter++; }; }());


    function reinsertElement(element) {
        var placeholder = $(document.createTextNode(''));

        element.before(placeholder);
        placeholder.before(element);
        placeholder.remove();
    }

    function stripDiacritics(str) {
        // Used 'uni range + named function' from http://jsperf.com/diacritics/18
        function match(a) {
            return DIACRITICS[a] || a;
        }

        return str.replace(/[^\u0000-\u007E]/g, match);
    }

    function indexOf(value, array) {
        var i = 0, l = array.length;
        for (; i < l; i = i + 1) {
            if (equal(value, array[i])) return i;
        }
        return -1;
    }

    function measureScrollbar() {
        var $template = $(MEASURE_SCROLLBAR_TEMPLATE);
        $template.appendTo(document.body);

        var dim = {
            width: $template.width() - $template[0].clientWidth,
            height: $template.height() - $template[0].clientHeight
        };
        $template.remove();

        return dim;
    }

    /**
     * Compares equality of a and b
     * @param a
     * @param b
     */
    function equal(a, b) {
        if (a === b) return true;
        if (a === undefined || b === undefined) return false;
        if (a === null || b === null) return false;
        // Check whether 'a' or 'b' is a string (primitive or object).
        // The concatenation of an empty string (+'') converts its argument to a string's primitive.
        if (a.constructor === String) return a + '' === b + ''; // a+'' - in case 'a' is a String object
        if (b.constructor === String) return b + '' === a + ''; // b+'' - in case 'b' is a String object
        return false;
    }

    /**
     * Splits the string into an array of values, transforming each value. An empty array is returned for nulls or empty
     * strings
     * @param string
     * @param separator
     */
    function splitVal(string, separator, transform) {
        var val, i, l;
        if (string === null || string.length < 1) return [];
        val = string.split(separator);
        for (i = 0, l = val.length; i < l; i = i + 1) val[i] = transform(val[i]);
        return val;
    }

    function getSideBorderPadding(element) {
        return element.outerWidth(false) - element.width();
    }

    function installKeyUpChangeEvent(element) {
        var key = "keyup-change-value";
        element.on("keydown", function () {
            if ($.data(element, key) === undefined) {
                $.data(element, key, element.val());
            }
        });
        element.on("keyup", function () {
            var val = $.data(element, key);
            if (val !== undefined && element.val() !== val) {
                $.removeData(element, key);
                element.trigger("keyup-change");
            }
        });
    }


    /**
     * filters mouse events so an event is fired only if the mouse moved.
     *
     * filters out mouse events that occur when mouse is stationary but
     * the elements under the pointer are scrolled.
     */
    function installFilteredMouseMove(element) {
        element.on("mousemove", function (e) {
            var lastpos = lastMousePosition;
            if (lastpos === undefined || lastpos.x !== e.pageX || lastpos.y !== e.pageY) {
                $(e.target).trigger("mousemove-filtered", e);
            }
        });
    }

    /**
     * Debounces a function. Returns a function that calls the original fn function only if no invocations have been made
     * within the last quietMillis milliseconds.
     *
     * @param quietMillis number of milliseconds to wait before invoking fn
     * @param fn function to be debounced
     * @param ctx object to be used as this reference within fn
     * @return debounced version of fn
     */
    function debounce(quietMillis, fn, ctx) {
        ctx = ctx || undefined;
        var timeout;
        return function () {
            var args = arguments;
            window.clearTimeout(timeout);
            timeout = window.setTimeout(function () {
                fn.apply(ctx, args);
            }, quietMillis);
        };
    }

    function installDebouncedScroll(threshold, element) {
        var notify = debounce(threshold, function (e) { element.trigger("scroll-debounced", e); });
        element.on("scroll", function (e) {
            if (indexOf(e.target, element.get()) >= 0) notify(e);
        });
    }

    function focus($el) {
        if ($el[0] === document.activeElement) return;

        /* set the focus in a 0 timeout - that way the focus is set after the processing
            of the current event has finished - which seems like the only reliable way
            to set focus */
        window.setTimeout(function () {
            var el = $el[0], pos = $el.val().length, range;

            $el.focus();

            /* make sure el received focus so we do not error out when trying to manipulate the caret.
                sometimes modals or others listeners may steal it after its set */
            var isVisible = (el.offsetWidth > 0 || el.offsetHeight > 0);
            if (isVisible && el === document.activeElement) {

                /* after the focus is set move the caret to the end, necessary when we val()
                    just before setting focus */
                if (el.setSelectionRange) {
                    el.setSelectionRange(pos, pos);
                }
                else if (el.createTextRange) {
                    range = el.createTextRange();
                    range.collapse(false);
                    range.select();
                }
            }
        }, 0);
    }

    function getCursorInfo(el) {
        el = $(el)[0];
        var offset = 0;
        var length = 0;
        if ('selectionStart' in el) {
            offset = el.selectionStart;
            length = el.selectionEnd - offset;
        } else if ('selection' in document) {
            el.focus();
            var sel = document.selection.createRange();
            length = document.selection.createRange().text.length;
            sel.moveStart('character', -el.value.length);
            offset = sel.text.length - length;
        }
        return { offset: offset, length: length };
    }

    function killEvent(event) {
        event.preventDefault();
        event.stopPropagation();
    }
    function killEventImmediately(event) {
        event.preventDefault();
        event.stopImmediatePropagation();
    }

    function measureTextWidth(e) {
        if (!sizer) {
            var style = e[0].currentStyle || window.getComputedStyle(e[0], null);
            sizer = $(document.createElement("div")).css({
                position: "absolute",
                left: "-10000px",
                top: "-10000px",
                display: "none",
                fontSize: style.fontSize,
                fontFamily: style.fontFamily,
                fontStyle: style.fontStyle,
                fontWeight: style.fontWeight,
                letterSpacing: style.letterSpacing,
                textTransform: style.textTransform,
                whiteSpace: "nowrap"
            });
            sizer.attr("class", "select2-sizer");
            $(document.body).append(sizer);
        }
        sizer.text(e.val());
        return sizer.width();
    }

    function syncCssClasses(dest, src, adapter) {
        var classes, replacements = [], adapted;

        classes = $.trim(dest.attr("class"));

        if (classes) {
            classes = '' + classes; // for IE which returns object

            $(classes.split(/\s+/)).each2(function () {
                if (this.indexOf("select2-") === 0) {
                    replacements.push(this);
                }
            });
        }

        classes = $.trim(src.attr("class"));

        if (classes) {
            classes = '' + classes; // for IE which returns object

            $(classes.split(/\s+/)).each2(function () {
                if (this.indexOf("select2-") !== 0) {
                    adapted = adapter(this);

                    if (adapted) {
                        replacements.push(adapted);
                    }
                }
            });
        }

        dest.attr("class", replacements.join(" "));
    }


    function markMatch(text, term, markup, escapeMarkup) {
        var match = stripDiacritics(text.toUpperCase()).indexOf(stripDiacritics(term.toUpperCase())),
            tl = term.length;

        if (match < 0) {
            markup.push(escapeMarkup(text));
            return;
        }

        markup.push(escapeMarkup(text.substring(0, match)));
        markup.push("<span class='select2-match'>");
        markup.push(escapeMarkup(text.substring(match, match + tl)));
        markup.push("</span>");
        markup.push(escapeMarkup(text.substring(match + tl, text.length)));
    }

    function defaultEscapeMarkup(markup) {
        var replace_map = {
            '\\': '&#92;',
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#39;',
            "/": '&#47;'
        };

        return String(markup).replace(/[&<>"'\/\\]/g, function (match) {
            return replace_map[match];
        });
    }

    /**
     * Produces an ajax-based query function
     *
     * @param options object containing configuration parameters
     * @param options.params parameter map for the transport ajax call, can contain such options as cache, jsonpCallback, etc. see $.ajax
     * @param options.transport function that will be used to execute the ajax request. must be compatible with parameters supported by $.ajax
     * @param options.url url for the data
     * @param options.data a function(searchTerm, pageNumber, context) that should return an object containing query string parameters for the above url.
     * @param options.dataType request data type: ajax, jsonp, other datatypes supported by jQuery's $.ajax function or the transport function if specified
     * @param options.quietMillis (optional) milliseconds to wait before making the ajaxRequest, helps debounce the ajax function if invoked too often
     * @param options.results a function(remoteData, pageNumber, query) that converts data returned form the remote request to the format expected by Select2.
     *      The expected format is an object containing the following keys:
     *      results array of objects that will be used as choices
     *      more (optional) boolean indicating whether there are more results available
     *      Example: {results:[{id:1, text:'Red'},{id:2, text:'Blue'}], more:true}
     */
    function ajax(options) {
        var timeout, // current scheduled but not yet executed request
            handler = null,
            quietMillis = options.quietMillis || 100,
            ajaxUrl = options.url,
            self = this;

        return function (query) {
            window.clearTimeout(timeout);
            timeout = window.setTimeout(function () {
                var data = options.data, // ajax data function
                    url = ajaxUrl, // ajax url string or function
                    transport = options.transport || $.fn.select2.ajaxDefaults.transport,
                    // deprecated - to be removed in 4.0  - use params instead
                    deprecated = {
                        type: options.type || 'GET', // set type of request (GET or POST)
                        cache: options.cache || false,
                        jsonpCallback: options.jsonpCallback || undefined,
                        dataType: options.dataType || "json"
                    },
                    params = $.extend({}, $.fn.select2.ajaxDefaults.params, deprecated);

                data = data ? data.call(self, query.term, query.page, query.context) : null;
                url = (typeof url === 'function') ? url.call(self, query.term, query.page, query.context) : url;

                if (handler && typeof handler.abort === "function") { handler.abort(); }

                if (options.params) {
                    if ($.isFunction(options.params)) {
                        $.extend(params, options.params.call(self));
                    } else {
                        $.extend(params, options.params);
                    }
                }

                $.extend(params, {
                    url: url,
                    dataType: options.dataType,
                    data: data,
                    success: function (data) {
                        // TODO - replace query.page with query so users have access to term, page, etc.
                        // added query as third paramter to keep backwards compatibility
                        var results = options.results(data, query.page, query);
                        query.callback(results);
                    },
                    error: function (jqXHR, textStatus, errorThrown) {
                        var results = {
                            hasError: true,
                            jqXHR: jqXHR,
                            textStatus: textStatus,
                            errorThrown: errorThrown
                        };

                        query.callback(results);
                    }
                });
                handler = transport.call(self, params);
            }, quietMillis);
        };
    }

    /**
     * Produces a query function that works with a local array
     *
     * @param options object containing configuration parameters. The options parameter can either be an array or an
     * object.
     *
     * If the array form is used it is assumed that it contains objects with 'id' and 'text' keys.
     *
     * If the object form is used it is assumed that it contains 'data' and 'text' keys. The 'data' key should contain
     * an array of objects that will be used as choices. These objects must contain at least an 'id' key. The 'text'
     * key can either be a String in which case it is expected that each element in the 'data' array has a key with the
     * value of 'text' which will be used to match choices. Alternatively, text can be a function(item) that can extract
     * the text.
     */
    function local(options) {
        var data = options, // data elements
            dataText,
            tmp,
            text = function (item) { return "" + item.text; }; // function used to retrieve the text portion of a data item that is matched against the search

        if ($.isArray(data)) {
            tmp = data;
            data = { results: tmp };
        }

        if ($.isFunction(data) === false) {
            tmp = data;
            data = function () { return tmp; };
        }

        var dataItem = data();
        if (dataItem.text) {
            text = dataItem.text;
            // if text is not a function we assume it to be a key name
            if (!$.isFunction(text)) {
                dataText = dataItem.text; // we need to store this in a separate variable because in the next step data gets reset and data.text is no longer available
                text = function (item) { return item[dataText]; };
            }
        }

        return function (query) {
            var t = query.term, filtered = { results: [] }, process;
            if (t === "") {
                query.callback(data());
                return;
            }

            process = function (datum, collection) {
                var group, attr;
                datum = datum[0];
                if (datum.children) {
                    group = {};
                    for (attr in datum) {
                        if (datum.hasOwnProperty(attr)) group[attr] = datum[attr];
                    }
                    group.children = [];
                    $(datum.children).each2(function (i, childDatum) { process(childDatum, group.children); });
                    if (group.children.length || query.matcher(t, text(group), datum)) {
                        collection.push(group);
                    }
                } else {
                    if (query.matcher(t, text(datum), datum)) {
                        collection.push(datum);
                    }
                }
            };

            $(data().results).each2(function (i, datum) { process(datum, filtered.results); });
            query.callback(filtered);
        };
    }

    // TODO javadoc
    function tags(data) {
        var isFunc = $.isFunction(data);
        return function (query) {
            var t = query.term, filtered = { results: [] };
            var result = isFunc ? data(query) : data;
            if ($.isArray(result)) {
                $(result).each(function () {
                    var isObject = this.text !== undefined,
                        text = isObject ? this.text : this;
                    if (t === "" || query.matcher(t, text)) {
                        filtered.results.push(isObject ? this : { id: this, text: this });
                    }
                });
                query.callback(filtered);
            }
        };
    }

    /**
     * Checks if the formatter function should be used.
     *
     * Throws an error if it is not a function. Returns true if it should be used,
     * false if no formatting should be performed.
     *
     * @param formatter
     */
    function checkFormatter(formatter, formatterName) {
        if ($.isFunction(formatter)) return true;
        if (!formatter) return false;
        if (typeof (formatter) === 'string') return true;
        throw new Error(formatterName + " must be a string, function, or falsy value");
    }

    /**
     * Returns a given value
     * If given a function, returns its output
     *
     * @param val string|function
     * @param context value of "this" to be passed to function
     * @returns {*}
     */
    function evaluate(val, context) {
        if ($.isFunction(val)) {
            var args = Array.prototype.slice.call(arguments, 2);
            return val.apply(context, args);
        }
        return val;
    }

    function countResults(results) {
        var count = 0;
        $.each(results, function (i, item) {
            if (item.children) {
                count += countResults(item.children);
            } else {
                count++;
            }
        });
        return count;
    }

    /**
     * Default tokenizer. This function uses breaks the input on substring match of any string from the
     * opts.tokenSeparators array and uses opts.createSearchChoice to create the choice object. Both of those
     * two options have to be defined in order for the tokenizer to work.
     *
     * @param input text user has typed so far or pasted into the search field
     * @param selection currently selected choices
     * @param selectCallback function(choice) callback tho add the choice to selection
     * @param opts select2's opts
     * @return undefined/null to leave the current input unchanged, or a string to change the input to the returned value
     */
    function defaultTokenizer(input, selection, selectCallback, opts) {
        var original = input, // store the original so we can compare and know if we need to tell the search to update its text
            dupe = false, // check for whether a token we extracted represents a duplicate selected choice
            token, // token
            index, // position at which the separator was found
            i, l, // looping variables
            separator; // the matched separator

        if (!opts.createSearchChoice || !opts.tokenSeparators || opts.tokenSeparators.length < 1) return undefined;

        while (true) {
            index = -1;

            for (i = 0, l = opts.tokenSeparators.length; i < l; i++) {
                separator = opts.tokenSeparators[i];
                index = input.indexOf(separator);
                if (index >= 0) break;
            }

            if (index < 0) break; // did not find any token separator in the input string, bail

            token = input.substring(0, index);
            input = input.substring(index + separator.length);

            if (token.length > 0) {
                token = opts.createSearchChoice.call(this, token, selection);
                if (token !== undefined && token !== null && opts.id(token) !== undefined && opts.id(token) !== null) {
                    dupe = false;
                    for (i = 0, l = selection.length; i < l; i++) {
                        if (equal(opts.id(token), opts.id(selection[i]))) {
                            dupe = true; break;
                        }
                    }

                    if (!dupe) selectCallback(token);
                }
            }
        }

        if (original !== input) return input;
    }

    function cleanupJQueryElements() {
        var self = this;

        $.each(arguments, function (i, element) {
            self[element].remove();
            self[element] = null;
        });
    }

    /**
     * Creates a new class
     *
     * @param superClass
     * @param methods
     */
    function clazz(SuperClass, methods) {
        var constructor = function () { };
        constructor.prototype = new SuperClass;
        constructor.prototype.constructor = constructor;
        constructor.prototype.parent = SuperClass.prototype;
        constructor.prototype = $.extend(constructor.prototype, methods);
        return constructor;
    }

    AbstractSelect2 = clazz(Object, {

        // abstract
        bind: function (func) {
            var self = this;
            return function () {
                func.apply(self, arguments);
            };
        },

        // abstract
        init: function (opts) {
            var results, search, resultsSelector = ".select2-results";

            // prepare options
            this.opts = opts = this.prepareOpts(opts);

            this.id = opts.id;

            // destroy if called on an existing component
            if (opts.element.data("select2") !== undefined &&
                opts.element.data("select2") !== null) {
                opts.element.data("select2").destroy();
            }

            this.container = this.createContainer();

            this.liveRegion = $('.select2-hidden-accessible');
            if (this.liveRegion.length == 0) {
                this.liveRegion = $("<span>", {
                    role: "status",
                    "aria-live": "polite"
                })
                    .addClass("select2-hidden-accessible")
                    .appendTo(document.body);
            }

            this.containerId = "s2id_" + (opts.element.attr("id") || "autogen" + nextUid());
            this.containerEventName = this.containerId
                .replace(/([.])/g, '_')
                .replace(/([;&,\-\.\+\*\~':"\!\^#$%@\[\]\(\)=>\|])/g, '\\$1');
            this.container.attr("id", this.containerId);

            this.container.attr("title", opts.element.attr("title"));

            this.body = $(document.body);

            syncCssClasses(this.container, this.opts.element, this.opts.adaptContainerCssClass);

            this.container.attr("style", opts.element.attr("style"));
            this.container.css(evaluate(opts.containerCss, this.opts.element));
            this.container.addClass(evaluate(opts.containerCssClass, this.opts.element));

            this.elementTabIndex = this.opts.element.attr("tabindex");

            // swap container for the element
            this.opts.element
                .data("select2", this)
                .attr("tabindex", "-1")
                .before(this.container)
                .on("click.select2", killEvent); // do not leak click events

            this.container.data("select2", this);

            this.dropdown = this.container.find(".select2-drop");

            syncCssClasses(this.dropdown, this.opts.element, this.opts.adaptDropdownCssClass);

            this.dropdown.addClass(evaluate(opts.dropdownCssClass, this.opts.element));
            this.dropdown.data("select2", this);
            this.dropdown.on("click", killEvent);

            this.results = results = this.container.find(resultsSelector);
            this.search = search = this.container.find("input.select2-input");

            this.queryCount = 0;
            this.resultsPage = 0;
            this.context = null;

            // initialize the container
            this.initContainer();

            this.container.on("click", killEvent);

            installFilteredMouseMove(this.results);

            this.dropdown.on("mousemove-filtered", resultsSelector, this.bind(this.highlightUnderEvent));
            this.dropdown.on("touchstart touchmove touchend", resultsSelector, this.bind(function (event) {
                this._touchEvent = true;
                this.highlightUnderEvent(event);
            }));
            this.dropdown.on("touchmove", resultsSelector, this.bind(this.touchMoved));
            this.dropdown.on("touchstart touchend", resultsSelector, this.bind(this.clearTouchMoved));

            // Waiting for a click event on touch devices to select option and hide dropdown
            // otherwise click will be triggered on an underlying element
            this.dropdown.on('click', this.bind(function (event) {
                if (this._touchEvent) {
                    this._touchEvent = false;
                    this.selectHighlighted();
                }
            }));

            installDebouncedScroll(80, this.results);
            this.dropdown.on("scroll-debounced", resultsSelector, this.bind(this.loadMoreIfNeeded));

            // do not propagate change event from the search field out of the component
            $(this.container).on("change", ".select2-input", function (e) { e.stopPropagation(); });
            $(this.dropdown).on("change", ".select2-input", function (e) { e.stopPropagation(); });

            // if jquery.mousewheel plugin is installed we can prevent out-of-bounds scrolling of results via mousewheel
            if ($.fn.mousewheel) {
                results.mousewheel(function (e, delta, deltaX, deltaY) {
                    var top = results.scrollTop();
                    if (deltaY > 0 && top - deltaY <= 0) {
                        results.scrollTop(0);
                        killEvent(e);
                    } else if (deltaY < 0 && results.get(0).scrollHeight - results.scrollTop() + deltaY <= results.height()) {
                        results.scrollTop(results.get(0).scrollHeight - results.height());
                        killEvent(e);
                    }
                });
            }

            installKeyUpChangeEvent(search);
            search.on("keyup-change input paste", this.bind(this.updateResults));
            search.on("focus", function () { search.addClass("select2-focused"); });
            search.on("blur", function () { search.removeClass("select2-focused"); });

            this.dropdown.on("mouseup", resultsSelector, this.bind(function (e) {
                if ($(e.target).closest(".select2-result-selectable").length > 0) {
                    this.highlightUnderEvent(e);
                    this.selectHighlighted(e);
                }
            }));

            // trap all mouse events from leaving the dropdown. sometimes there may be a modal that is listening
            // for mouse events outside of itself so it can close itself. since the dropdown is now outside the select2's
            // dom it will trigger the popup close, which is not what we want
            // focusin can cause focus wars between modals and select2 since the dropdown is outside the modal.
            this.dropdown.on("click mouseup mousedown touchstart touchend focusin", function (e) { e.stopPropagation(); });

            this.lastSearchTerm = undefined;

            if ($.isFunction(this.opts.initSelection)) {
                // initialize selection based on the current value of the source element
                this.initSelection();

                // if the user has provided a function that can set selection based on the value of the source element
                // we monitor the change event on the element and trigger it, allowing for two way synchronization
                this.monitorSource();
            }

            if (opts.maximumInputLength !== null) {
                this.search.attr("maxlength", opts.maximumInputLength);
            }

            var disabled = opts.element.prop("disabled");
            if (disabled === undefined) disabled = false;
            this.enable(!disabled);

            var readonly = opts.element.prop("readonly");
            if (readonly === undefined) readonly = false;
            this.readonly(readonly);

            // Calculate size of scrollbar
            scrollBarDimensions = scrollBarDimensions || measureScrollbar();

            this.autofocus = opts.element.prop("autofocus");
            opts.element.prop("autofocus", false);
            if (this.autofocus) this.focus();

            this.search.attr("placeholder", opts.searchInputPlaceholder);
        },

        // abstract
        destroy: function () {
            var element = this.opts.element, select2 = element.data("select2"), self = this;

            this.close();

            if (element.length && element[0].detachEvent && self._sync) {
                element.each(function () {
                    if (self._sync) {
                        this.detachEvent("onpropertychange", self._sync);
                    }
                });
            }
            if (this.propertyObserver) {
                this.propertyObserver.disconnect();
                this.propertyObserver = null;
            }
            this._sync = null;

            if (select2 !== undefined) {
                select2.container.remove();
                select2.liveRegion.remove();
                select2.dropdown.remove();
                element.removeData("select2")
                    .off(".select2");
                if (!element.is("input[type='hidden']")) {
                    element
                        .show()
                        .prop("autofocus", this.autofocus || false);
                    if (this.elementTabIndex) {
                        element.attr({ tabindex: this.elementTabIndex });
                    } else {
                        element.removeAttr("tabindex");
                    }
                    element.show();
                } else {
                    element.css("display", "");
                }
            }

            cleanupJQueryElements.call(this,
                "container",
                "liveRegion",
                "dropdown",
                "results",
                "search"
            );
        },

        // abstract
        optionToData: function (element) {
            if (element.is("option")) {
                return {
                    id: element.prop("value"),
                    text: element.text(),
                    element: element.get(),
                    css: element.attr("class"),
                    disabled: element.prop("disabled"),
                    locked: equal(element.attr("locked"), "locked") || equal(element.data("locked"), true)
                };
            } else if (element.is("optgroup")) {
                return {
                    text: element.attr("label"),
                    children: [],
                    element: element.get(),
                    css: element.attr("class")
                };
            }
        },

        // abstract
        prepareOpts: function (opts) {
            var element, select, idKey, ajaxUrl, self = this;

            element = opts.element;

            if (element.get(0).tagName.toLowerCase() === "select") {
                this.select = select = opts.element;
            }

            if (select) {
                // these options are not allowed when attached to a select because they are picked up off the element itself
                $.each(["id", "multiple", "ajax", "query", "createSearchChoice", "initSelection", "data", "tags"], function () {
                    if (this in opts) {
                        throw new Error("Option '" + this + "' is not allowed for Select2 when attached to a <select> element.");
                    }
                });
            }

            opts.debug = opts.debug || $.fn.select2.defaults.debug;

            // Warnings for options renamed/removed in Select2 4.0.0
            // Only when it's enabled through debug mode
            if (opts.debug && console && console.warn) {
                // id was removed
                if (opts.id != null) {
                    console.warn(
                        'Select2: The `id` option has been removed in Select2 4.0.0, ' +
                        'consider renaming your `id` property or mapping the property before your data makes it to Select2. ' +
                        'You can read more at https://select2.github.io/announcements-4.0.html#changed-id'
                    );
                }

                // text was removed
                if (opts.text != null) {
                    console.warn(
                        'Select2: The `text` option has been removed in Select2 4.0.0, ' +
                        'consider renaming your `text` property or mapping the property before your data makes it to Select2. ' +
                        'You can read more at https://select2.github.io/announcements-4.0.html#changed-id'
                    );
                }

                // sortResults was renamed to results
                if (opts.sortResults != null) {
                    console.warn(
                        'Select2: the `sortResults` option has been renamed to `sorter` in Select2 4.0.0. '
                    );
                }

                // selectOnBlur was renamed to selectOnClose
                if (opts.selectOnBlur != null) {
                    console.warn(
                        'Select2: The `selectOnBlur` option has been renamed to `selectOnClose` in Select2 4.0.0.'
                    );
                }

                // ajax.results was renamed to ajax.processResults
                if (opts.ajax != null && opts.ajax.results != null) {
                    console.warn(
                        'Select2: The `ajax.results` option has been renamed to `ajax.processResults` in Select2 4.0.0.'
                    );
                }

                // format* options were renamed to language.*
                if (opts.formatNoResults != null) {
                    console.warn(
                        'Select2: The `formatNoResults` option has been renamed to `language.noResults` in Select2 4.0.0.'
                    );
                }
                if (opts.formatSearching != null) {
                    console.warn(
                        'Select2: The `formatSearching` option has been renamed to `language.searching` in Select2 4.0.0.'
                    );
                }
                if (opts.formatInputTooShort != null) {
                    console.warn(
                        'Select2: The `formatInputTooShort` option has been renamed to `language.inputTooShort` in Select2 4.0.0.'
                    );
                }
                if (opts.formatInputTooLong != null) {
                    console.warn(
                        'Select2: The `formatInputTooLong` option has been renamed to `language.inputTooLong` in Select2 4.0.0.'
                    );
                }
                if (opts.formatLoading != null) {
                    console.warn(
                        'Select2: The `formatLoading` option has been renamed to `language.loadingMore` in Select2 4.0.0.'
                    );
                }
                if (opts.formatSelectionTooBig != null) {
                    console.warn(
                        'Select2: The `formatSelectionTooBig` option has been renamed to `language.maximumSelected` in Select2 4.0.0.'
                    );
                }

                if (opts.element.data('select2Tags')) {
                    console.warn(
                        'Select2: The `data-select2-tags` attribute has been renamed to `data-tags` in Select2 4.0.0.'
                    );
                }
            }

            // Aliasing options renamed in Select2 4.0.0

            // data-select2-tags -> data-tags
            if (opts.element.data('tags') != null) {
                var elemTags = opts.element.data('tags');

                // data-tags should actually be a boolean
                if (!$.isArray(elemTags)) {
                    elemTags = [];
                }

                opts.element.data('select2Tags', elemTags);
            }

            // sortResults -> sorter
            if (opts.sorter != null) {
                opts.sortResults = opts.sorter;
            }

            // selectOnBlur -> selectOnClose
            if (opts.selectOnClose != null) {
                opts.selectOnBlur = opts.selectOnClose;
            }

            // ajax.results -> ajax.processResults
            if (opts.ajax != null) {
                if ($.isFunction(opts.ajax.processResults)) {
                    opts.ajax.results = opts.ajax.processResults;
                }
            }

            // Formatters/language options
            if (opts.language != null) {
                var lang = opts.language;

                // formatNoMatches -> language.noMatches
                if ($.isFunction(lang.noMatches)) {
                    opts.formatNoMatches = lang.noMatches;
                }

                // formatSearching -> language.searching
                if ($.isFunction(lang.searching)) {
                    opts.formatSearching = lang.searching;
                }

                // formatInputTooShort -> language.inputTooShort
                if ($.isFunction(lang.inputTooShort)) {
                    opts.formatInputTooShort = lang.inputTooShort;
                }

                // formatInputTooLong -> language.inputTooLong
                if ($.isFunction(lang.inputTooLong)) {
                    opts.formatInputTooLong = lang.inputTooLong;
                }

                // formatLoading -> language.loadingMore
                if ($.isFunction(lang.loadingMore)) {
                    opts.formatLoading = lang.loadingMore;
                }

                // formatSelectionTooBig -> language.maximumSelected
                if ($.isFunction(lang.maximumSelected)) {
                    opts.formatSelectionTooBig = lang.maximumSelected;
                }
            }

            opts = $.extend({}, {
                populateResults: function (container, results, query) {
                    var populate, id = this.opts.id, liveRegion = this.liveRegion;

                    populate = function (results, container, depth) {

                        var i, l, result, selectable, disabled, compound, node, label, innerContainer, formatted;

                        results = opts.sortResults(results, container, query);

                        // collect the created nodes for bulk append
                        var nodes = [];
                        for (i = 0, l = results.length; i < l; i = i + 1) {

                            result = results[i];

                            disabled = (result.disabled === true);
                            selectable = (!disabled) && (id(result) !== undefined);

                            compound = result.children && result.children.length > 0;

                            node = $("<li></li>");
                            node.addClass("select2-results-dept-" + depth);
                            node.addClass("select2-result");
                            node.addClass(selectable ? "select2-result-selectable" : "select2-result-unselectable");
                            if (disabled) { node.addClass("select2-disabled"); }
                            if (compound) { node.addClass("select2-result-with-children"); }
                            node.addClass(self.opts.formatResultCssClass(result));
                            node.attr("role", "presentation");

                            label = $(document.createElement("div"));
                            label.addClass("select2-result-label");
                            label.attr("id", "select2-result-label-" + nextUid());
                            label.attr("role", "option");

                            formatted = opts.formatResult(result, label, query, self.opts.escapeMarkup);
                            if (formatted !== undefined) {
                                label.html(formatted);
                                node.append(label);
                            }


                            if (compound) {
                                innerContainer = $("<ul></ul>");
                                innerContainer.addClass("select2-result-sub");
                                populate(result.children, innerContainer, depth + 1);
                                node.append(innerContainer);
                            }

                            node.data("select2-data", result);
                            nodes.push(node[0]);
                        }

                        // bulk append the created nodes
                        container.append(nodes);
                        liveRegion.text(opts.formatMatches(results.length));
                    };

                    populate(results, container, 0);
                }
            }, $.fn.select2.defaults, opts);

            if (typeof (opts.id) !== "function") {
                idKey = opts.id;
                opts.id = function (e) { return e[idKey]; };
            }

            if ($.isArray(opts.element.data("select2Tags"))) {
                if ("tags" in opts) {
                    throw "tags specified as both an attribute 'data-select2-tags' and in options of Select2 " + opts.element.attr("id");
                }
                opts.tags = opts.element.data("select2Tags");
            }

            if (select) {
                opts.query = this.bind(function (query) {
                    var data = { results: [], more: false },
                        term = query.term,
                        children, placeholderOption, process;

                    process = function (element, collection) {
                        var group;
                        if (element.is("option")) {
                            if (query.matcher(term, element.text(), element)) {
                                collection.push(self.optionToData(element));
                            }
                        } else if (element.is("optgroup")) {
                            group = self.optionToData(element);
                            element.children().each2(function (i, elm) { process(elm, group.children); });
                            if (group.children.length > 0) {
                                collection.push(group);
                            }
                        }
                    };

                    children = element.children();

                    // ignore the placeholder option if there is one
                    if (this.getPlaceholder() !== undefined && children.length > 0) {
                        placeholderOption = this.getPlaceholderOption();
                        if (placeholderOption) {
                            children = children.not(placeholderOption);
                        }
                    }

                    children.each2(function (i, elm) { process(elm, data.results); });

                    query.callback(data);
                });
                // this is needed because inside val() we construct choices from options and their id is hardcoded
                opts.id = function (e) { return e.id; };
            } else {
                if (!("query" in opts)) {
                    if ("ajax" in opts) {
                        ajaxUrl = opts.element.data("ajax-url");
                        if (ajaxUrl && ajaxUrl.length > 0) {
                            opts.ajax.url = ajaxUrl;
                        }
                        opts.query = ajax.call(opts.element, opts.ajax);
                    } else if ("data" in opts) {
                        opts.query = local(opts.data);
                    } else if ("tags" in opts) {
                        opts.query = tags(opts.tags);
                        if (opts.createSearchChoice === undefined) {
                            opts.createSearchChoice = function (term) { return { id: $.trim(term), text: $.trim(term) }; };
                        }
                        if (opts.initSelection === undefined) {
                            opts.initSelection = function (element, callback) {
                                var data = [];
                                $(splitVal(element.val(), opts.separator, opts.transformVal)).each(function () {
                                    var obj = { id: this, text: this },
                                        tags = opts.tags;
                                    if ($.isFunction(tags)) tags = tags();
                                    $(tags).each(function () { if (equal(this.id, obj.id)) { obj = this; return false; } });
                                    data.push(obj);
                                });

                                callback(data);
                            };
                        }
                    }
                }
            }
            if (typeof (opts.query) !== "function") {
                throw "query function not defined for Select2 " + opts.element.attr("id");
            }

            if (opts.createSearchChoicePosition === 'top') {
                opts.createSearchChoicePosition = function (list, item) { list.unshift(item); };
            }
            else if (opts.createSearchChoicePosition === 'bottom') {
                opts.createSearchChoicePosition = function (list, item) { list.push(item); };
            }
            else if (typeof (opts.createSearchChoicePosition) !== "function") {
                throw "invalid createSearchChoicePosition option must be 'top', 'bottom' or a custom function";
            }

            return opts;
        },

        /**
         * Monitor the original element for changes and update select2 accordingly
         */
        // abstract
        monitorSource: function () {
            var el = this.opts.element, observer, self = this;

            el.on("change.select2", this.bind(function (e) {
                if (this.opts.element.data("select2-change-triggered") !== true) {
                    this.initSelection();
                }
            }));

            this._sync = this.bind(function () {

                // sync enabled state
                var disabled = el.prop("disabled");
                if (disabled === undefined) disabled = false;
                this.enable(!disabled);

                var readonly = el.prop("readonly");
                if (readonly === undefined) readonly = false;
                this.readonly(readonly);

                if (this.container) {
                    syncCssClasses(this.container, this.opts.element, this.opts.adaptContainerCssClass);
                    this.container.addClass(evaluate(this.opts.containerCssClass, this.opts.element));
                }

                if (this.dropdown) {
                    syncCssClasses(this.dropdown, this.opts.element, this.opts.adaptDropdownCssClass);
                    this.dropdown.addClass(evaluate(this.opts.dropdownCssClass, this.opts.element));
                }

            });

            // IE8-10 (IE9/10 won't fire propertyChange via attachEventListener)
            if (el.length && el[0].attachEvent) {
                el.each(function () {
                    this.attachEvent("onpropertychange", self._sync);
                });
            }

            // safari, chrome, firefox, IE11
            observer = window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver;
            if (observer !== undefined) {
                if (this.propertyObserver) { delete this.propertyObserver; this.propertyObserver = null; }
                this.propertyObserver = new observer(function (mutations) {
                    $.each(mutations, self._sync);
                });
                this.propertyObserver.observe(el.get(0), { attributes: true, subtree: false });
            }
        },

        // abstract
        triggerSelect: function (data) {
            var evt = $.Event("select2-selecting", { val: this.id(data), object: data, choice: data });
            this.opts.element.trigger(evt);
            return !evt.isDefaultPrevented();
        },

        /**
         * Triggers the change event on the source element
         */
        // abstract
        triggerChange: function (details) {

            details = details || {};
            details = $.extend({}, details, { type: "change", val: this.val() });
            // prevents recursive triggering
            this.opts.element.data("select2-change-triggered", true);
            this.opts.element.trigger(details);
            this.opts.element.data("select2-change-triggered", false);

            // some validation frameworks ignore the change event and listen instead to keyup, click for selects
            // so here we trigger the click event manually
            this.opts.element.click();

            // ValidationEngine ignores the change event and listens instead to blur
            // so here we trigger the blur event manually if so desired
            if (this.opts.blurOnChange)
                this.opts.element.blur();
        },

        //abstract
        isInterfaceEnabled: function () {
            return this.enabledInterface === true;
        },

        // abstract
        enableInterface: function () {
            var enabled = this._enabled && !this._readonly,
                disabled = !enabled;

            if (enabled === this.enabledInterface) return false;

            this.container.toggleClass("select2-container-disabled", disabled);
            this.close();
            this.enabledInterface = enabled;

            return true;
        },

        // abstract
        enable: function (enabled) {
            if (enabled === undefined) enabled = true;
            if (this._enabled === enabled) return;
            this._enabled = enabled;

            this.opts.element.prop("disabled", !enabled);
            this.enableInterface();
        },

        // abstract
        disable: function () {
            this.enable(false);
        },

        // abstract
        readonly: function (enabled) {
            if (enabled === undefined) enabled = false;
            if (this._readonly === enabled) return;
            this._readonly = enabled;

            this.opts.element.prop("readonly", enabled);
            this.enableInterface();
        },

        // abstract
        opened: function () {
            return (this.container) ? this.container.hasClass("select2-dropdown-open") : false;
        },

        // abstract
        positionDropdown: function () {
            var $dropdown = this.dropdown,
                container = this.container,
                offset = container.offset(),
                height = container.outerHeight(false),
                width = container.outerWidth(false),
                dropHeight = $dropdown.outerHeight(false),
                $window = $(window),
                windowWidth = $window.width(),
                windowHeight = $window.height(),
                viewPortRight = $window.scrollLeft() + windowWidth,
                viewportBottom = $window.scrollTop() + windowHeight,
                dropTop = offset.top + height,
                dropLeft = offset.left,
                enoughRoomBelow = dropTop + dropHeight <= viewportBottom,
                enoughRoomAbove = (offset.top - dropHeight) >= $window.scrollTop(),
                dropWidth = $dropdown.outerWidth(false),
                enoughRoomOnRight = function () {
                    return dropLeft + dropWidth <= viewPortRight;
                },
                enoughRoomOnLeft = function () {
                    return offset.left + viewPortRight + container.outerWidth(false) > dropWidth;
                },
                aboveNow = $dropdown.hasClass("select2-drop-above"),
                bodyOffset,
                above,
                changeDirection,
                css,
                resultsListNode;

            // always prefer the current above/below alignment, unless there is not enough room
            if (aboveNow) {
                above = true;
                if (!enoughRoomAbove && enoughRoomBelow) {
                    changeDirection = true;
                    above = false;
                }
            } else {
                above = false;
                if (!enoughRoomBelow && enoughRoomAbove) {
                    changeDirection = true;
                    above = true;
                }
            }

            //if we are changing direction we need to get positions when dropdown is hidden;
            if (changeDirection) {
                $dropdown.hide();
                offset = this.container.offset();
                height = this.container.outerHeight(false);
                width = this.container.outerWidth(false);
                dropHeight = $dropdown.outerHeight(false);
                viewPortRight = $window.scrollLeft() + windowWidth;
                viewportBottom = $window.scrollTop() + windowHeight;
                dropTop = offset.top + height;
                dropLeft = offset.left;
                dropWidth = $dropdown.outerWidth(false);
                $dropdown.show();

                // fix so the cursor does not move to the left within the search-textbox in IE
                this.focusSearch();
            }

            if (this.opts.dropdownAutoWidth) {
                resultsListNode = $('.select2-results', $dropdown)[0];
                $dropdown.addClass('select2-drop-auto-width');
                $dropdown.css('width', '');
                // Add scrollbar width to dropdown if vertical scrollbar is present
                dropWidth = $dropdown.outerWidth(false) + (resultsListNode.scrollHeight === resultsListNode.clientHeight ? 0 : scrollBarDimensions.width);
                dropWidth > width ? width = dropWidth : dropWidth = width;
                dropHeight = $dropdown.outerHeight(false);
            }
            else {
                this.container.removeClass('select2-drop-auto-width');
            }

            //console.log("below/ droptop:", dropTop, "dropHeight", dropHeight, "sum", (dropTop+dropHeight)+" viewport bottom", viewportBottom, "enough?", enoughRoomBelow);
            //console.log("above/ offset.top", offset.top, "dropHeight", dropHeight, "top", (offset.top-dropHeight), "scrollTop", this.body.scrollTop(), "enough?", enoughRoomAbove);

            // fix positioning when body has an offset and is not position: static
            if (this.body.css('position') !== 'static') {
                bodyOffset = this.body.offset();
                dropTop -= bodyOffset.top;
                dropLeft -= bodyOffset.left;
            }

            if (!enoughRoomOnRight() && enoughRoomOnLeft()) {
                dropLeft = offset.left + this.container.outerWidth(false) - dropWidth;
            }

            css = {
                left: dropLeft,
                width: width
            };

            if (above) {
                this.container.addClass("select2-drop-above");
                $dropdown.addClass("select2-drop-above");
                dropHeight = $dropdown.outerHeight(false);
                css.top = offset.top - dropHeight;
                css.bottom = 'auto';
            }
            else {
                css.top = dropTop;
                css.bottom = 'auto';
                this.container.removeClass("select2-drop-above");
                $dropdown.removeClass("select2-drop-above");
            }
            css = $.extend(css, evaluate(this.opts.dropdownCss, this.opts.element));

            $dropdown.css(css);
        },

        // abstract
        shouldOpen: function () {
            var event;

            if (this.opened()) return false;

            if (this._enabled === false || this._readonly === true) return false;

            event = $.Event("select2-opening");
            this.opts.element.trigger(event);
            return !event.isDefaultPrevented();
        },

        // abstract
        clearDropdownAlignmentPreference: function () {
            // clear the classes used to figure out the preference of where the dropdown should be opened
            this.container.removeClass("select2-drop-above");
            this.dropdown.removeClass("select2-drop-above");
        },

        /**
         * Opens the dropdown
         *
         * @return {Boolean} whether or not dropdown was opened. This method will return false if, for example,
         * the dropdown is already open, or if the 'open' event listener on the element called preventDefault().
         */
        // abstract
        open: function () {

            if (!this.shouldOpen()) return false;

            this.opening();

            // Only bind the document mousemove when the dropdown is visible
            $document.on("mousemove.select2Event", function (e) {
                lastMousePosition.x = e.pageX;
                lastMousePosition.y = e.pageY;
            });

            return true;
        },

        /**
         * Performs the opening of the dropdown
         */
        // abstract
        opening: function () {
            var cid = this.containerEventName,
                scroll = "scroll." + cid,
                resize = "resize." + cid,
                orient = "orientationchange." + cid,
                mask;

            this.container.addClass("select2-dropdown-open").addClass("select2-container-active");

            this.clearDropdownAlignmentPreference();

            if (this.dropdown[0] !== this.body.children().last()[0]) {
                this.dropdown.detach().appendTo(this.body);
            }

            // create the dropdown mask if doesn't already exist
            mask = $("#select2-drop-mask");
            if (mask.length === 0) {
                mask = $(document.createElement("div"));
                mask.attr("id", "select2-drop-mask").attr("class", "select2-drop-mask");
                mask.hide();
                mask.appendTo(this.body);
                mask.on("mousedown touchstart click", function (e) {
                    // Prevent IE from generating a click event on the body
                    reinsertElement(mask);

                    var dropdown = $("#select2-drop"), self;
                    if (dropdown.length > 0) {
                        self = dropdown.data("select2");
                        if (self.opts.selectOnBlur) {
                            self.selectHighlighted({ noFocus: true });
                        }
                        self.close();
                        e.preventDefault();
                        e.stopPropagation();
                    }
                });
            }

            // ensure the mask is always right before the dropdown
            if (this.dropdown.prev()[0] !== mask[0]) {
                this.dropdown.before(mask);
            }

            // move the global id to the correct dropdown
            $("#select2-drop").removeAttr("id");
            this.dropdown.attr("id", "select2-drop");

            // show the elements
            mask.show();

            this.positionDropdown();
            this.dropdown.show();
            this.positionDropdown();

            this.dropdown.addClass("select2-drop-active");

            // attach listeners to events that can change the position of the container and thus require
            // the position of the dropdown to be updated as well so it does not come unglued from the container
            var that = this;
            this.container.parents().add(window).each(function () {
                $(this).on(resize + " " + scroll + " " + orient, function (e) {
                    if (that.opened()) that.positionDropdown();
                });
            });


        },

        // abstract
        close: function () {
            if (!this.opened()) return;

            var cid = this.containerEventName,
                scroll = "scroll." + cid,
                resize = "resize." + cid,
                orient = "orientationchange." + cid;

            // unbind event listeners
            this.container.parents().add(window).each(function () { $(this).off(scroll).off(resize).off(orient); });

            this.clearDropdownAlignmentPreference();

            $("#select2-drop-mask").hide();
            this.dropdown.removeAttr("id"); // only the active dropdown has the select2-drop id
            this.dropdown.hide();
            this.container.removeClass("select2-dropdown-open").removeClass("select2-container-active");
            this.results.empty();

            // Now that the dropdown is closed, unbind the global document mousemove event
            $document.off("mousemove.select2Event");

            this.clearSearch();
            this.search.removeClass("select2-active");

            // Remove the aria active descendant for highlighted element
            this.search.removeAttr("aria-activedescendant");
            this.opts.element.trigger($.Event("select2-close"));
        },

        /**
         * Opens control, sets input value, and updates results.
         */
        // abstract
        externalSearch: function (term) {
            this.open();
            this.search.val(term);
            this.updateResults(false);
        },

        // abstract
        clearSearch: function () {

        },

        /**
         * @return {Boolean} Whether or not search value was changed.
         * @private
         */
        prefillNextSearchTerm: function () {
            // initializes search's value with nextSearchTerm (if defined by user)
            // ignore nextSearchTerm if the dropdown is opened by the user pressing a letter
            if (this.search.val() !== "") {
                return false;
            }

            var nextSearchTerm = this.opts.nextSearchTerm(this.data(), this.lastSearchTerm);
            if (nextSearchTerm !== undefined) {
                this.search.val(nextSearchTerm);
                this.search.select();
                return true;
            }

            return false;
        },

        //abstract
        getMaximumSelectionSize: function () {
            return evaluate(this.opts.maximumSelectionSize, this.opts.element);
        },

        // abstract
        ensureHighlightVisible: function () {
            var results = this.results, children, index, child, hb, rb, y, more, topOffset;

            index = this.highlight();

            if (index < 0) return;

            if (index == 0) {

                // if the first element is highlighted scroll all the way to the top,
                // that way any unselectable headers above it will also be scrolled
                // into view

                results.scrollTop(0);
                return;
            }

            children = this.findHighlightableChoices().find('.select2-result-label');

            child = $(children[index]);

            topOffset = (child.offset() || {}).top || 0;

            hb = topOffset + child.outerHeight(true);

            // if this is the last child lets also make sure select2-more-results is visible
            if (index === children.length - 1) {
                more = results.find("li.select2-more-results");
                if (more.length > 0) {
                    hb = more.offset().top + more.outerHeight(true);
                }
            }

            rb = results.offset().top + results.outerHeight(false);
            if (hb > rb) {
                results.scrollTop(results.scrollTop() + (hb - rb));
            }
            y = topOffset - results.offset().top;

            // make sure the top of the element is visible
            if (y < 0 && child.css('display') != 'none') {
                results.scrollTop(results.scrollTop() + y); // y is negative
            }
        },

        // abstract
        findHighlightableChoices: function () {
            return this.results.find(".select2-result-selectable:not(.select2-disabled):not(.select2-selected)");
        },

        // abstract
        moveHighlight: function (delta) {
            var choices = this.findHighlightableChoices(),
                index = this.highlight();

            while (index > -1 && index < choices.length) {
                index += delta;
                var choice = $(choices[index]);
                if (choice.hasClass("select2-result-selectable") && !choice.hasClass("select2-disabled") && !choice.hasClass("select2-selected")) {
                    this.highlight(index);
                    break;
                }
            }
        },

        // abstract
        highlight: function (index) {
            var choices = this.findHighlightableChoices(),
                choice,
                data;

            if (arguments.length === 0) {
                return indexOf(choices.filter(".select2-highlighted")[0], choices.get());
            }

            if (index >= choices.length) index = choices.length - 1;
            if (index < 0) index = 0;

            this.removeHighlight();

            choice = $(choices[index]);
            choice.addClass("select2-highlighted");

            // ensure assistive technology can determine the active choice
            this.search.attr("aria-activedescendant", choice.find(".select2-result-label").attr("id"));

            this.ensureHighlightVisible();

            this.liveRegion.text(choice.text());

            data = choice.data("select2-data");
            if (data) {
                this.opts.element.trigger({ type: "select2-highlight", val: this.id(data), choice: data });
            }
        },

        removeHighlight: function () {
            this.results.find(".select2-highlighted").removeClass("select2-highlighted");
        },

        touchMoved: function () {
            this._touchMoved = true;
        },

        clearTouchMoved: function () {
            this._touchMoved = false;
        },

        // abstract
        countSelectableResults: function () {
            return this.findHighlightableChoices().length;
        },

        // abstract
        highlightUnderEvent: function (event) {
            var el = $(event.target).closest(".select2-result-selectable");
            if (el.length > 0 && !el.is(".select2-highlighted")) {
                var choices = this.findHighlightableChoices();
                this.highlight(choices.index(el));
            } else if (el.length == 0) {
                // if we are over an unselectable item remove all highlights
                this.removeHighlight();
            }
        },

        // abstract
        loadMoreIfNeeded: function () {
            var results = this.results,
                more = results.find("li.select2-more-results"),
                below, // pixels the element is below the scroll fold, below==0 is when the element is starting to be visible
                page = this.resultsPage + 1,
                self = this,
                term = this.search.val(),
                context = this.context;

            if (more.length === 0) return;
            below = more.offset().top - results.offset().top - results.height();

            if (below <= this.opts.loadMorePadding) {
                more.addClass("select2-active");
                this.opts.query({
                    element: this.opts.element,
                    term: term,
                    page: page,
                    context: context,
                    matcher: this.opts.matcher,
                    callback: this.bind(function (data) {

                        // ignore a response if the select2 has been closed before it was received
                        if (!self.opened()) return;


                        self.opts.populateResults.call(this, results, data.results, { term: term, page: page, context: context });
                        self.postprocessResults(data, false, false);

                        if (data.more === true) {
                            more.detach().appendTo(results).html(self.opts.escapeMarkup(evaluate(self.opts.formatLoadMore, self.opts.element, page + 1)));
                            window.setTimeout(function () { self.loadMoreIfNeeded(); }, 10);
                        } else {
                            more.remove();
                        }
                        self.positionDropdown();
                        self.resultsPage = page;
                        self.context = data.context;
                        this.opts.element.trigger({ type: "select2-loaded", items: data });
                    })
                });
            }
        },

        /**
         * Default tokenizer function which does nothing
         */
        tokenize: function () {

        },

        /**
         * @param initial whether or not this is the call to this method right after the dropdown has been opened
         */
        // abstract
        updateResults: function (initial) {
            var search = this.search,
                results = this.results,
                opts = this.opts,
                data,
                self = this,
                input,
                term = search.val(),
                lastTerm = $.data(this.container, "select2-last-term"),
                // sequence number used to drop out-of-order responses
                queryNumber;

            // prevent duplicate queries against the same term
            if (initial !== true && lastTerm && equal(term, lastTerm)) return;

            $.data(this.container, "select2-last-term", term);

            // if the search is currently hidden we do not alter the results
            if (initial !== true && (this.showSearchInput === false || !this.opened())) {
                return;
            }

            function postRender() {
                search.removeClass("select2-active");
                self.positionDropdown();
                if (results.find('.select2-no-results,.select2-selection-limit,.select2-searching').length) {
                    self.liveRegion.text(results.text());
                }
                else {
                    self.liveRegion.text(self.opts.formatMatches(results.find('.select2-result-selectable:not(".select2-selected")').length));
                }
            }

            function render(html) {
                results.html(html);
                postRender();
            }

            queryNumber = ++this.queryCount;

            var maxSelSize = this.getMaximumSelectionSize();
            if (maxSelSize >= 1) {
                data = this.data();
                if ($.isArray(data) && data.length >= maxSelSize && checkFormatter(opts.formatSelectionTooBig, "formatSelectionTooBig")) {
                    render("<li class='select2-selection-limit'>" + evaluate(opts.formatSelectionTooBig, opts.element, maxSelSize) + "</li>");
                    return;
                }
            }

            if (search.val().length < opts.minimumInputLength) {
                if (checkFormatter(opts.formatInputTooShort, "formatInputTooShort")) {
                    render("<li class='select2-no-results'>" + evaluate(opts.formatInputTooShort, opts.element, search.val(), opts.minimumInputLength) + "</li>");
                } else {
                    render("");
                }
                if (initial && this.showSearch) this.showSearch(true);
                return;
            }

            if (opts.maximumInputLength && search.val().length > opts.maximumInputLength) {
                if (checkFormatter(opts.formatInputTooLong, "formatInputTooLong")) {
                    render("<li class='select2-no-results'>" + evaluate(opts.formatInputTooLong, opts.element, search.val(), opts.maximumInputLength) + "</li>");
                } else {
                    render("");
                }
                return;
            }

            if (opts.formatSearching && this.findHighlightableChoices().length === 0) {
                render("<li class='select2-searching'>" + evaluate(opts.formatSearching, opts.element) + "</li>");
            }

            search.addClass("select2-active");

            this.removeHighlight();

            // give the tokenizer a chance to pre-process the input
            input = this.tokenize();
            if (input != undefined && input != null) {
                search.val(input);
            }

            this.resultsPage = 1;

            opts.query({
                element: opts.element,
                term: search.val(),
                page: this.resultsPage,
                context: null,
                matcher: opts.matcher,
                callback: this.bind(function (data) {
                    var def; // default choice

                    // ignore old responses
                    if (queryNumber != this.queryCount) {
                        return;
                    }

                    // ignore a response if the select2 has been closed before it was received
                    if (!this.opened()) {
                        this.search.removeClass("select2-active");
                        return;
                    }

                    // handle ajax error
                    if (data.hasError !== undefined && checkFormatter(opts.formatAjaxError, "formatAjaxError")) {
                        render("<li class='select2-ajax-error'>" + evaluate(opts.formatAjaxError, opts.element, data.jqXHR, data.textStatus, data.errorThrown) + "</li>");
                        return;
                    }

                    // save context, if any
                    this.context = (data.context === undefined) ? null : data.context;
                    // create a default choice and prepend it to the list
                    if (this.opts.createSearchChoice && search.val() !== "") {
                        def = this.opts.createSearchChoice.call(self, search.val(), data.results);
                        if (def !== undefined && def !== null && self.id(def) !== undefined && self.id(def) !== null) {
                            if ($(data.results).filter(
                                function () {
                                    return equal(self.id(this), self.id(def));
                                }).length === 0) {
                                this.opts.createSearchChoicePosition(data.results, def);
                            }
                        }
                    }

                    if (data.results.length === 0 && checkFormatter(opts.formatNoMatches, "formatNoMatches")) {
                        render("<li class='select2-no-results'>" + evaluate(opts.formatNoMatches, opts.element, search.val()) + "</li>");
                        if (this.showSearch) {
                            this.showSearch(search.val());
                        }
                        return;
                    }

                    results.empty();
                    self.opts.populateResults.call(this, results, data.results, { term: search.val(), page: this.resultsPage, context: null });

                    if (data.more === true && checkFormatter(opts.formatLoadMore, "formatLoadMore")) {
                        results.append("<li class='select2-more-results'>" + opts.escapeMarkup(evaluate(opts.formatLoadMore, opts.element, this.resultsPage)) + "</li>");
                        window.setTimeout(function () { self.loadMoreIfNeeded(); }, 10);
                    }

                    this.postprocessResults(data, initial);

                    postRender();

                    this.opts.element.trigger({ type: "select2-loaded", items: data });
                })
            });
        },

        // abstract
        cancel: function () {
            this.close();
        },

        // abstract
        blur: function () {
            // if selectOnBlur == true, select the currently highlighted option
            if (this.opts.selectOnBlur)
                this.selectHighlighted({ noFocus: true });

            this.close();
            this.container.removeClass("select2-container-active");
            // synonymous to .is(':focus'), which is available in jquery >= 1.6
            if (this.search[0] === document.activeElement) { this.search.blur(); }
            this.clearSearch();
            this.selection.find(".select2-search-choice-focus").removeClass("select2-search-choice-focus");
        },

        // abstract
        focusSearch: function () {
            focus(this.search);
        },

        // abstract
        selectHighlighted: function (options) {
            if (this._touchMoved) {
                this.clearTouchMoved();
                return;
            }
            var index = this.highlight(),
                highlighted = this.results.find(".select2-highlighted"),
                data = highlighted.closest('.select2-result').data("select2-data");

            if (data) {
                this.highlight(index);
                this.onSelect(data, options);
            } else if (options && options.noFocus) {
                this.close();
            }
        },

        // abstract
        getPlaceholder: function () {
            var placeholderOption;
            return this.opts.element.attr("placeholder") ||
                this.opts.element.attr("data-placeholder") || // jquery 1.4 compat
                this.opts.element.data("placeholder") ||
                this.opts.placeholder ||
                ((placeholderOption = this.getPlaceholderOption()) !== undefined ? placeholderOption.text() : undefined);
        },

        // abstract
        getPlaceholderOption: function () {
            if (this.select) {
                var firstOption = this.select.children('option').first();
                if (this.opts.placeholderOption !== undefined) {
                    //Determine the placeholder option based on the specified placeholderOption setting
                    return (this.opts.placeholderOption === "first" && firstOption) ||
                        (typeof this.opts.placeholderOption === "function" && this.opts.placeholderOption(this.select));
                } else if ($.trim(firstOption.text()) === "" && firstOption.val() === "") {
                    //No explicit placeholder option specified, use the first if it's blank
                    return firstOption;
                }
            }
        },

        /**
         * Get the desired width for the container element.  This is
         * derived first from option `width` passed to select2, then
         * the inline 'style' on the original element, and finally
         * falls back to the jQuery calculated element width.
         */
        // abstract
        initContainerWidth: function () {
            function resolveContainerWidth() {
                var style, attrs, matches, i, l, attr;

                if (this.opts.width === "off") {
                    return null;
                } else if (this.opts.width === "element") {
                    return this.opts.element.outerWidth(false) === 0 ? 'auto' : this.opts.element.outerWidth(false) + 'px';
                } else if (this.opts.width === "copy" || this.opts.width === "resolve") {
                    // check if there is inline style on the element that contains width
                    style = this.opts.element.attr('style');
                    if (typeof (style) === "string") {
                        attrs = style.split(';');
                        for (i = 0, l = attrs.length; i < l; i = i + 1) {
                            attr = attrs[i].replace(/\s/g, '');
                            matches = attr.match(/^width:(([-+]?([0-9]*\.)?[0-9]+)(px|em|ex|%|in|cm|mm|pt|pc))/i);
                            if (matches !== null && matches.length >= 1)
                                return matches[1];
                        }
                    }

                    if (this.opts.width === "resolve") {
                        // next check if css('width') can resolve a width that is percent based, this is sometimes possible
                        // when attached to input type=hidden or elements hidden via css
                        style = this.opts.element.css('width');
                        if (style.indexOf("%") > 0) return style;

                        // finally, fallback on the calculated width of the element
                        return (this.opts.element.outerWidth(false) === 0 ? 'auto' : this.opts.element.outerWidth(false) + 'px');
                    }

                    return null;
                } else if ($.isFunction(this.opts.width)) {
                    return this.opts.width();
                } else {
                    return this.opts.width;
                }
            };

            var width = resolveContainerWidth.call(this);
            if (width !== null) {
                this.container.css("width", width);
            }
        }
    });

    SingleSelect2 = clazz(AbstractSelect2, {

        // single

        createContainer: function () {
            var container = $(document.createElement("div")).attr({
                "class": "select2-container"
            }).html([
                "<a href='javascript:void(0)' class='select2-choice' tabindex='-1'>",
                "   <span class='select2-chosen'>&#160;</span><abbr class='select2-search-choice-close'></abbr>",
                "   <span class='select2-arrow' role='presentation'><b role='presentation'></b></span>",
                "</a>",
                "<label for='' class='select2-offscreen'></label>",
                "<input class='select2-focusser select2-offscreen' type='text' aria-haspopup='true' role='button' />",
                "<div class='select2-drop select2-display-none'>",
                "   <div class='select2-search'>",
                "       <label for='' class='select2-offscreen'></label>",
                "       <input type='text' autocomplete='off' autocorrect='off' autocapitalize='off' spellcheck='false' class='select2-input' role='combobox' aria-expanded='true'",
                "       aria-autocomplete='list' />",
                "   </div>",
                "   <ul class='select2-results' role='listbox'>",
                "   </ul>",
                "</div>"].join(""));
            return container;
        },

        // single
        enableInterface: function () {
            if (this.parent.enableInterface.apply(this, arguments)) {
                this.focusser.prop("disabled", !this.isInterfaceEnabled());
            }
        },

        // single
        opening: function () {
            var el, range, len;

            if (this.opts.minimumResultsForSearch >= 0) {
                this.showSearch(true);
            }

            this.parent.opening.apply(this, arguments);

            if (this.showSearchInput !== false) {
                // IE appends focusser.val() at the end of field :/ so we manually insert it at the beginning using a range
                // all other browsers handle this just fine

                this.search.val(this.focusser.val());
            }
            if (this.opts.shouldFocusInput(this)) {
                this.search.focus();
                // move the cursor to the end after focussing, otherwise it will be at the beginning and
                // new text will appear *before* focusser.val()
                el = this.search.get(0);
                if (el.createTextRange) {
                    range = el.createTextRange();
                    range.collapse(false);
                    range.select();
                } else if (el.setSelectionRange) {
                    len = this.search.val().length;
                    el.setSelectionRange(len, len);
                }
            }

            this.prefillNextSearchTerm();

            this.focusser.prop("disabled", true).val("");
            this.updateResults(true);
            this.opts.element.trigger($.Event("select2-open"));
        },

        // single
        close: function () {
            if (!this.opened()) return;
            this.parent.close.apply(this, arguments);

            this.focusser.prop("disabled", false);

            if (this.opts.shouldFocusInput(this)) {
                this.focusser.focus();
            }
        },

        // single
        focus: function () {
            if (this.opened()) {
                this.close();
            } else {
                this.focusser.prop("disabled", false);
                if (this.opts.shouldFocusInput(this)) {
                    this.focusser.focus();
                }
            }
        },

        // single
        isFocused: function () {
            return this.container.hasClass("select2-container-active");
        },

        // single
        cancel: function () {
            this.parent.cancel.apply(this, arguments);
            this.focusser.prop("disabled", false);

            if (this.opts.shouldFocusInput(this)) {
                this.focusser.focus();
            }
        },

        // single
        destroy: function () {
            $("label[for='" + this.focusser.attr('id') + "']")
                .attr('for', this.opts.element.attr("id"));
            this.parent.destroy.apply(this, arguments);

            cleanupJQueryElements.call(this,
                "selection",
                "focusser"
            );
        },

        // single
        initContainer: function () {

            var selection,
                container = this.container,
                dropdown = this.dropdown,
                idSuffix = nextUid(),
                elementLabel;

            if (this.opts.minimumResultsForSearch < 0) {
                this.showSearch(false);
            } else {
                this.showSearch(true);
            }

            this.selection = selection = container.find(".select2-choice");

            this.focusser = container.find(".select2-focusser");

            // add aria associations
            selection.find(".select2-chosen").attr("id", "select2-chosen-" + idSuffix);
            this.focusser.attr("aria-labelledby", "select2-chosen-" + idSuffix);
            this.results.attr("id", "select2-results-" + idSuffix);
            this.search.attr("aria-owns", "select2-results-" + idSuffix);

            // rewrite labels from original element to focusser
            this.focusser.attr("id", "s2id_autogen" + idSuffix);

            elementLabel = $("label[for='" + this.opts.element.attr("id") + "']");
            this.opts.element.on('focus.select2', this.bind(function () { this.focus(); }));

            this.focusser.prev()
                .text(elementLabel.text())
                .attr('for', this.focusser.attr('id'));

            // Ensure the original element retains an accessible name
            var originalTitle = this.opts.element.attr("title");
            this.opts.element.attr("title", (originalTitle || elementLabel.text()));

            this.focusser.attr("tabindex", this.elementTabIndex);

            // write label for search field using the label from the focusser element
            this.search.attr("id", this.focusser.attr('id') + '_search');

            this.search.prev()
                .text($("label[for='" + this.focusser.attr('id') + "']").text())
                .attr('for', this.search.attr('id'));

            this.search.on("keydown", this.bind(function (e) {
                if (!this.isInterfaceEnabled()) return;

                // filter 229 keyCodes (input method editor is processing key input)
                if (229 == e.keyCode) return;

                if (e.which === KEY.PAGE_UP || e.which === KEY.PAGE_DOWN) {
                    // prevent the page from scrolling
                    killEvent(e);
                    return;
                }

                switch (e.which) {
                    case KEY.UP:
                    case KEY.DOWN:
                        this.moveHighlight((e.which === KEY.UP) ? -1 : 1);
                        killEvent(e);
                        return;
                    case KEY.ENTER:
                        this.selectHighlighted();
                        killEvent(e);
                        return;
                    case KEY.TAB:
                        this.selectHighlighted({ noFocus: true });
                        return;
                    case KEY.ESC:
                        this.cancel(e);
                        killEvent(e);
                        return;
                }
            }));

            this.search.on("blur", this.bind(function (e) {
                // a workaround for chrome to keep the search field focussed when the scroll bar is used to scroll the dropdown.
                // without this the search field loses focus which is annoying
                if (document.activeElement === this.body.get(0)) {
                    window.setTimeout(this.bind(function () {
                        if (this.opened() && this.results && this.results.length > 1) {
                            this.search.focus();
                        }
                    }), 0);
                }
            }));

            this.focusser.on("keydown", this.bind(function (e) {
                if (!this.isInterfaceEnabled()) return;

                if (e.which === KEY.TAB || KEY.isControl(e) || KEY.isFunctionKey(e) || e.which === KEY.ESC) {
                    return;
                }

                if (this.opts.openOnEnter === false && e.which === KEY.ENTER) {
                    killEvent(e);
                    return;
                }

                if (e.which == KEY.DOWN || e.which == KEY.UP
                    || (e.which == KEY.ENTER && this.opts.openOnEnter)) {

                    if (e.altKey || e.ctrlKey || e.shiftKey || e.metaKey) return;

                    this.open();
                    killEvent(e);
                    return;
                }

                if (e.which == KEY.DELETE || e.which == KEY.BACKSPACE) {
                    if (this.opts.allowClear) {
                        this.clear();
                    }
                    killEvent(e);
                    return;
                }
            }));


            installKeyUpChangeEvent(this.focusser);
            this.focusser.on("keyup-change input", this.bind(function (e) {
                if (this.opts.minimumResultsForSearch >= 0) {
                    e.stopPropagation();
                    if (this.opened()) return;
                    this.open();
                }
            }));

            selection.on("mousedown touchstart", "abbr", this.bind(function (e) {
                if (!this.isInterfaceEnabled()) {
                    return;
                }

                this.clear();
                killEventImmediately(e);
                this.close();

                if (this.selection) {
                    this.selection.focus();
                }
            }));

            selection.on("mousedown touchstart", this.bind(function (e) {
                // Prevent IE from generating a click event on the body
                reinsertElement(selection);

                if (!this.container.hasClass("select2-container-active")) {
                    this.opts.element.trigger($.Event("select2-focus"));
                }

                if (this.opened()) {
                    this.close();
                } else if (this.isInterfaceEnabled()) {
                    this.open();
                }

                killEvent(e);
            }));

            dropdown.on("mousedown touchstart", this.bind(function () {
                if (this.opts.shouldFocusInput(this)) {
                    this.search.focus();
                }
            }));

            selection.on("focus", this.bind(function (e) {
                killEvent(e);
            }));

            this.focusser.on("focus", this.bind(function () {
                if (!this.container.hasClass("select2-container-active")) {
                    this.opts.element.trigger($.Event("select2-focus"));
                }
                this.container.addClass("select2-container-active");
            })).on("blur", this.bind(function () {
                if (!this.opened()) {
                    this.container.removeClass("select2-container-active");
                    this.opts.element.trigger($.Event("select2-blur"));
                }
            }));
            this.search.on("focus", this.bind(function () {
                if (!this.container.hasClass("select2-container-active")) {
                    this.opts.element.trigger($.Event("select2-focus"));
                }
                this.container.addClass("select2-container-active");
            }));

            this.initContainerWidth();
            this.opts.element.hide();
            this.setPlaceholder();

        },

        // single
        clear: function (triggerChange) {
            var data = this.selection.data("select2-data");
            if (data) { // guard against queued quick consecutive clicks
                var evt = $.Event("select2-clearing");
                this.opts.element.trigger(evt);
                if (evt.isDefaultPrevented()) {
                    return;
                }
                var placeholderOption = this.getPlaceholderOption();
                this.opts.element.val(placeholderOption ? placeholderOption.val() : "");
                this.selection.find(".select2-chosen").empty();
                this.selection.removeData("select2-data");
                this.setPlaceholder();

                if (triggerChange !== false) {
                    this.opts.element.trigger({ type: "select2-removed", val: this.id(data), choice: data });
                    this.triggerChange({ removed: data });
                }
            }
        },

        /**
         * Sets selection based on source element's value
         */
        // single
        initSelection: function () {
            var selected;
            if (this.isPlaceholderOptionSelected()) {
                this.updateSelection(null);
                this.close();
                this.setPlaceholder();
            } else {
                var self = this;
                this.opts.initSelection.call(null, this.opts.element, function (selected) {
                    if (selected !== undefined && selected !== null) {
                        self.updateSelection(selected);
                        self.close();
                        self.setPlaceholder();
                        self.lastSearchTerm = self.search.val();
                    }
                });
            }
        },

        isPlaceholderOptionSelected: function () {
            var placeholderOption;
            if (this.getPlaceholder() === undefined) return false; // no placeholder specified so no option should be considered
            return ((placeholderOption = this.getPlaceholderOption()) !== undefined && placeholderOption.prop("selected"))
                || (this.opts.element.val() === "")
                || (this.opts.element.val() === undefined)
                || (this.opts.element.val() === null);
        },

        // single
        prepareOpts: function () {
            var opts = this.parent.prepareOpts.apply(this, arguments),
                self = this;

            if (opts.element.get(0).tagName.toLowerCase() === "select") {
                // install the selection initializer
                opts.initSelection = function (element, callback) {
                    var selected = element.find("option").filter(function () { return this.selected && !this.disabled });
                    // a single select box always has a value, no need to null check 'selected'
                    callback(self.optionToData(selected));
                };
            } else if ("data" in opts) {
                // install default initSelection when applied to hidden input and data is local
                opts.initSelection = opts.initSelection || function (element, callback) {
                    var id = element.val();
                    //search in data by id, storing the actual matching item
                    var match = null;
                    opts.query({
                        matcher: function (term, text, el) {
                            var is_match = equal(id, opts.id(el));
                            if (is_match) {
                                match = el;
                            }
                            return is_match;
                        },
                        callback: !$.isFunction(callback) ? $.noop : function () {
                            callback(match);
                        }
                    });
                };
            }

            return opts;
        },

        // single
        getPlaceholder: function () {
            // if a placeholder is specified on a single select without a valid placeholder option ignore it
            if (this.select) {
                if (this.getPlaceholderOption() === undefined) {
                    return undefined;
                }
            }

            return this.parent.getPlaceholder.apply(this, arguments);
        },

        // single
        setPlaceholder: function () {
            var placeholder = this.getPlaceholder();

            if (this.isPlaceholderOptionSelected() && placeholder !== undefined) {

                // check for a placeholder option if attached to a select
                if (this.select && this.getPlaceholderOption() === undefined) return;

                this.selection.find(".select2-chosen").html(this.opts.escapeMarkup(placeholder));

                this.selection.addClass("select2-default");

                this.container.removeClass("select2-allowclear");
            }
        },

        // single
        postprocessResults: function (data, initial, noHighlightUpdate) {
            var selected = 0, self = this, showSearchInput = true;

            // find the selected element in the result list

            this.findHighlightableChoices().each2(function (i, elm) {
                if (equal(self.id(elm.data("select2-data")), self.opts.element.val())) {
                    selected = i;
                    return false;
                }
            });

            // and highlight it
            if (noHighlightUpdate !== false) {
                if (initial === true && selected >= 0) {
                    this.highlight(selected);
                } else {
                    this.highlight(0);
                }
            }

            // hide the search box if this is the first we got the results and there are enough of them for search

            if (initial === true) {
                var min = this.opts.minimumResultsForSearch;
                if (min >= 0) {
                    this.showSearch(countResults(data.results) >= min);
                }
            }
        },

        // single
        showSearch: function (showSearchInput) {
            if (this.showSearchInput === showSearchInput) return;

            this.showSearchInput = showSearchInput;

            this.dropdown.find(".select2-search").toggleClass("select2-search-hidden", !showSearchInput);
            this.dropdown.find(".select2-search").toggleClass("select2-offscreen", !showSearchInput);
            //add "select2-with-searchbox" to the container if search box is shown
            $(this.dropdown, this.container).toggleClass("select2-with-searchbox", showSearchInput);
        },

        // single
        onSelect: function (data, options) {

            if (!this.triggerSelect(data)) { return; }

            var old = this.opts.element.val(),
                oldData = this.data();

            this.opts.element.val(this.id(data));
            this.updateSelection(data);

            this.opts.element.trigger({ type: "select2-selected", val: this.id(data), choice: data });

            this.lastSearchTerm = this.search.val();
            this.close();

            if ((!options || !options.noFocus) && this.opts.shouldFocusInput(this)) {
                this.focusser.focus();
            }

            if (!equal(old, this.id(data))) {
                this.triggerChange({ added: data, removed: oldData });
            }
        },

        // single
        updateSelection: function (data) {

            var container = this.selection.find(".select2-chosen"), formatted, cssClass;

            this.selection.data("select2-data", data);

            container.empty();
            if (data !== null) {
                formatted = this.opts.formatSelection(data, container, this.opts.escapeMarkup);
            }
            if (formatted !== undefined) {
                container.append(formatted);
            }
            cssClass = this.opts.formatSelectionCssClass(data, container);
            if (cssClass !== undefined) {
                container.addClass(cssClass);
            }

            this.selection.removeClass("select2-default");

            if (this.opts.allowClear && this.getPlaceholder() !== undefined) {
                this.container.addClass("select2-allowclear");
            }
        },

        // single
        val: function () {
            var val,
                triggerChange = false,
                data = null,
                self = this,
                oldData = this.data();

            if (arguments.length === 0) {
                return this.opts.element.val();
            }

            val = arguments[0];

            if (arguments.length > 1) {
                triggerChange = arguments[1];

                if (this.opts.debug && console && console.warn) {
                    console.warn(
                        'Select2: The second option to `select2("val")` is not supported in Select2 4.0.0. ' +
                        'The `change` event will always be triggered in 4.0.0.'
                    );
                }
            }

            if (this.select) {
                if (this.opts.debug && console && console.warn) {
                    console.warn(
                        'Select2: Setting the value on a <select> using `select2("val")` is no longer supported in 4.0.0. ' +
                        'You can use the `.val(newValue).trigger("change")` method provided by jQuery instead.'
                    );
                }

                this.select
                    .val(val)
                    .find("option").filter(function () { return this.selected }).each2(function (i, elm) {
                        data = self.optionToData(elm);
                        return false;
                    });
                this.updateSelection(data);
                this.setPlaceholder();
                if (triggerChange) {
                    this.triggerChange({ added: data, removed: oldData });
                }
            } else {
                // val is an id. !val is true for [undefined,null,'',0] - 0 is legal
                if (!val && val !== 0) {
                    this.clear(triggerChange);
                    return;
                }
                if (this.opts.initSelection === undefined) {
                    throw new Error("cannot call val() if initSelection() is not defined");
                }
                this.opts.element.val(val);
                this.opts.initSelection(this.opts.element, function (data) {
                    self.opts.element.val(!data ? "" : self.id(data));
                    self.updateSelection(data);
                    self.setPlaceholder();
                    if (triggerChange) {
                        self.triggerChange({ added: data, removed: oldData });
                    }
                });
            }
        },

        // single
        clearSearch: function () {
            this.search.val("");
            this.focusser.val("");
        },

        // single
        data: function (value) {
            var data,
                triggerChange = false;

            if (arguments.length === 0) {
                data = this.selection.data("select2-data");
                if (data == undefined) data = null;
                return data;
            } else {
                if (this.opts.debug && console && console.warn) {
                    console.warn(
                        'Select2: The `select2("data")` method can no longer set selected values in 4.0.0, ' +
                        'consider using the `.val()` method instead.'
                    );
                }

                if (arguments.length > 1) {
                    triggerChange = arguments[1];
                }
                if (!value) {
                    this.clear(triggerChange);
                } else {
                    data = this.data();
                    this.opts.element.val(!value ? "" : this.id(value));
                    this.updateSelection(value);
                    if (triggerChange) {
                        this.triggerChange({ added: value, removed: data });
                    }
                }
            }
        }
    });

    MultiSelect2 = clazz(AbstractSelect2, {

        // multi
        createContainer: function () {
            var container = $(document.createElement("div")).attr({
                "class": "select2-container select2-container-multi"
            }).html([
                "<ul class='select2-choices'>",
                "  <li class='select2-search-field'>",
                "    <label for='' class='select2-offscreen'></label>",
                "    <input type='text' autocomplete='off' autocorrect='off' autocapitalize='off' spellcheck='false' class='select2-input'>",
                "  </li>",
                "</ul>",
                "<div class='select2-drop select2-drop-multi select2-display-none'>",
                "   <ul class='select2-results'>",
                "   </ul>",
                "</div>"].join(""));
            return container;
        },

        // multi
        prepareOpts: function () {
            var opts = this.parent.prepareOpts.apply(this, arguments),
                self = this;

            // TODO validate placeholder is a string if specified
            if (opts.element.get(0).tagName.toLowerCase() === "select") {
                // install the selection initializer
                opts.initSelection = function (element, callback) {

                    var data = [];

                    element.find("option").filter(function () { return this.selected && !this.disabled }).each2(function (i, elm) {
                        data.push(self.optionToData(elm));
                    });
                    callback(data);
                };
            } else if ("data" in opts) {
                // install default initSelection when applied to hidden input and data is local
                opts.initSelection = opts.initSelection || function (element, callback) {
                    var ids = splitVal(element.val(), opts.separator, opts.transformVal);
                    //search in data by array of ids, storing matching items in a list
                    var matches = [];
                    opts.query({
                        matcher: function (term, text, el) {
                            var is_match = $.grep(ids, function (id) {
                                return equal(id, opts.id(el));
                            }).length;
                            if (is_match) {
                                matches.push(el);
                            }
                            return is_match;
                        },
                        callback: !$.isFunction(callback) ? $.noop : function () {
                            // reorder matches based on the order they appear in the ids array because right now
                            // they are in the order in which they appear in data array
                            var ordered = [];
                            for (var i = 0; i < ids.length; i++) {
                                var id = ids[i];
                                for (var j = 0; j < matches.length; j++) {
                                    var match = matches[j];
                                    if (equal(id, opts.id(match))) {
                                        ordered.push(match);
                                        matches.splice(j, 1);
                                        break;
                                    }
                                }
                            }
                            callback(ordered);
                        }
                    });
                };
            }

            return opts;
        },

        // multi
        selectChoice: function (choice) {

            var selected = this.container.find(".select2-search-choice-focus");
            if (selected.length && choice && choice[0] == selected[0]) {

            } else {
                if (selected.length) {
                    this.opts.element.trigger("choice-deselected", selected);
                }
                selected.removeClass("select2-search-choice-focus");
                if (choice && choice.length) {
                    this.close();
                    choice.addClass("select2-search-choice-focus");
                    this.opts.element.trigger("choice-selected", choice);
                }
            }
        },

        // multi
        destroy: function () {
            $("label[for='" + this.search.attr('id') + "']")
                .attr('for', this.opts.element.attr("id"));
            this.parent.destroy.apply(this, arguments);

            cleanupJQueryElements.call(this,
                "searchContainer",
                "selection"
            );
        },

        // multi
        initContainer: function () {

            var selector = ".select2-choices", selection;

            this.searchContainer = this.container.find(".select2-search-field");
            this.selection = selection = this.container.find(selector);

            var _this = this;
            this.selection.on("click", ".select2-container:not(.select2-container-disabled) .select2-search-choice:not(.select2-locked)", function (e) {
                _this.search[0].focus();
                _this.selectChoice($(this));
            });

            // rewrite labels from original element to focusser
            this.search.attr("id", "s2id_autogen" + nextUid());

            this.search.prev()
                .text($("label[for='" + this.opts.element.attr("id") + "']").text())
                .attr('for', this.search.attr('id'));
            this.opts.element.on('focus.select2', this.bind(function () { this.focus(); }));

            this.search.on("input paste", this.bind(function () {
                if (this.search.attr('placeholder') && this.search.val().length == 0) return;
                if (!this.isInterfaceEnabled()) return;
                if (!this.opened()) {
                    this.open();
                }
            }));

            this.search.attr("tabindex", this.elementTabIndex);

            this.keydowns = 0;
            this.search.on("keydown", this.bind(function (e) {
                if (!this.isInterfaceEnabled()) return;

                ++this.keydowns;
                var selected = selection.find(".select2-search-choice-focus");
                var prev = selected.prev(".select2-search-choice:not(.select2-locked)");
                var next = selected.next(".select2-search-choice:not(.select2-locked)");
                var pos = getCursorInfo(this.search);

                if (selected.length &&
                    (e.which == KEY.LEFT || e.which == KEY.RIGHT || e.which == KEY.BACKSPACE || e.which == KEY.DELETE || e.which == KEY.ENTER)) {
                    var selectedChoice = selected;
                    if (e.which == KEY.LEFT && prev.length) {
                        selectedChoice = prev;
                    }
                    else if (e.which == KEY.RIGHT) {
                        selectedChoice = next.length ? next : null;
                    }
                    else if (e.which === KEY.BACKSPACE) {
                        if (this.unselect(selected.first())) {
                            this.search.width(10);
                            selectedChoice = prev.length ? prev : next;
                        }
                    } else if (e.which == KEY.DELETE) {
                        if (this.unselect(selected.first())) {
                            this.search.width(10);
                            selectedChoice = next.length ? next : null;
                        }
                    } else if (e.which == KEY.ENTER) {
                        selectedChoice = null;
                    }

                    this.selectChoice(selectedChoice);
                    killEvent(e);
                    if (!selectedChoice || !selectedChoice.length) {
                        this.open();
                    }
                    return;
                } else if (((e.which === KEY.BACKSPACE && this.keydowns == 1)
                    || e.which == KEY.LEFT) && (pos.offset == 0 && !pos.length)) {

                    this.selectChoice(selection.find(".select2-search-choice:not(.select2-locked)").last());
                    killEvent(e);
                    return;
                } else {
                    this.selectChoice(null);
                }

                if (this.opened()) {
                    switch (e.which) {
                        case KEY.UP:
                        case KEY.DOWN:
                            this.moveHighlight((e.which === KEY.UP) ? -1 : 1);
                            killEvent(e);
                            return;
                        case KEY.ENTER:
                            this.selectHighlighted();
                            killEvent(e);
                            return;
                        case KEY.TAB:
                            this.selectHighlighted({ noFocus: true });
                            this.close();
                            return;
                        case KEY.ESC:
                            this.cancel(e);
                            killEvent(e);
                            return;
                    }
                }

                if (e.which === KEY.TAB || KEY.isControl(e) || KEY.isFunctionKey(e)
                    || e.which === KEY.BACKSPACE || e.which === KEY.ESC) {
                    return;
                }

                if (e.which === KEY.ENTER) {
                    if (this.opts.openOnEnter === false) {
                        return;
                    } else if (e.altKey || e.ctrlKey || e.shiftKey || e.metaKey) {
                        return;
                    }
                }

                this.open();

                if (e.which === KEY.PAGE_UP || e.which === KEY.PAGE_DOWN) {
                    // prevent the page from scrolling
                    killEvent(e);
                }

                if (e.which === KEY.ENTER) {
                    // prevent form from being submitted
                    killEvent(e);
                }

            }));

            this.search.on("keyup", this.bind(function (e) {
                this.keydowns = 0;
                this.resizeSearch();
            })
            );

            this.search.on("blur", this.bind(function (e) {
                this.container.removeClass("select2-container-active");
                this.search.removeClass("select2-focused");
                this.selectChoice(null);
                if (!this.opened()) this.clearSearch();
                e.stopImmediatePropagation();
                this.opts.element.trigger($.Event("select2-blur"));
            }));

            this.container.on("click", selector, this.bind(function (e) {
                if (!this.isInterfaceEnabled()) return;
                if ($(e.target).closest(".select2-search-choice").length > 0) {
                    // clicked inside a select2 search choice, do not open
                    return;
                }
                this.selectChoice(null);
                this.clearPlaceholder();
                if (!this.container.hasClass("select2-container-active")) {
                    this.opts.element.trigger($.Event("select2-focus"));
                }
                this.open();
                this.focusSearch();
                e.preventDefault();
            }));

            this.container.on("focus", selector, this.bind(function () {
                if (!this.isInterfaceEnabled()) return;
                if (!this.container.hasClass("select2-container-active")) {
                    this.opts.element.trigger($.Event("select2-focus"));
                }
                this.container.addClass("select2-container-active");
                this.dropdown.addClass("select2-drop-active");
                this.clearPlaceholder();
            }));

            this.initContainerWidth();
            this.opts.element.hide();

            // set the placeholder if necessary
            this.clearSearch();
        },

        // multi
        enableInterface: function () {
            if (this.parent.enableInterface.apply(this, arguments)) {
                this.search.prop("disabled", !this.isInterfaceEnabled());
            }
        },

        // multi
        initSelection: function () {
            var data;
            if (this.opts.element.val() === "" && this.opts.element.text() === "") {
                this.updateSelection([]);
                this.close();
                // set the placeholder if necessary
                this.clearSearch();
            }
            if (this.select || this.opts.element.val() !== "") {
                var self = this;
                this.opts.initSelection.call(null, this.opts.element, function (data) {
                    if (data !== undefined && data !== null) {
                        self.updateSelection(data);
                        self.close();
                        // set the placeholder if necessary
                        self.clearSearch();
                    }
                });
            }
        },

        // multi
        clearSearch: function () {
            var placeholder = this.getPlaceholder(),
                maxWidth = this.getMaxSearchWidth();

            if (placeholder !== undefined && this.getVal().length === 0 && this.search.hasClass("select2-focused") === false) {
                this.search.val(placeholder).addClass("select2-default");
                // stretch the search box to full width of the container so as much of the placeholder is visible as possible
                // we could call this.resizeSearch(), but we do not because that requires a sizer and we do not want to create one so early because of a firefox bug, see #944
                this.search.width(maxWidth > 0 ? maxWidth : this.container.css("width"));
            } else {
                this.search.val("").width(10);
            }
        },

        // multi
        clearPlaceholder: function () {
            if (this.search.hasClass("select2-default")) {
                this.search.val("").removeClass("select2-default");
            }
        },

        // multi
        opening: function () {
            this.clearPlaceholder(); // should be done before super so placeholder is not used to search
            this.resizeSearch();

            this.parent.opening.apply(this, arguments);

            this.focusSearch();

            this.prefillNextSearchTerm();
            this.updateResults(true);

            if (this.opts.shouldFocusInput(this)) {
                this.search.focus();
            }
            this.opts.element.trigger($.Event("select2-open"));
        },

        // multi
        close: function () {
            if (!this.opened()) return;
            this.parent.close.apply(this, arguments);
        },

        // multi
        focus: function () {
            this.close();
            this.search.focus();
        },

        // multi
        isFocused: function () {
            return this.search.hasClass("select2-focused");
        },

        // multi
        updateSelection: function (data) {
            var ids = {}, filtered = [], self = this;

            // filter out duplicates
            $(data).each(function () {
                if (!(self.id(this) in ids)) {
                    ids[self.id(this)] = 0;
                    filtered.push(this);
                }
            });

            this.selection.find(".select2-search-choice").remove();
            this.addSelectedChoice(filtered);
            self.postprocessResults();
        },

        // multi
        tokenize: function () {
            var input = this.search.val();
            input = this.opts.tokenizer.call(this, input, this.data(), this.bind(this.onSelect), this.opts);
            if (input != null && input != undefined) {
                this.search.val(input);
                if (input.length > 0) {
                    this.open();
                }
            }

        },

        // multi
        onSelect: function (data, options) {

            if (!this.triggerSelect(data) || data.text === "") { return; }

            this.addSelectedChoice(data);

            this.opts.element.trigger({ type: "selected", val: this.id(data), choice: data });

            // keep track of the search's value before it gets cleared
            this.lastSearchTerm = this.search.val();

            this.clearSearch();
            this.updateResults();

            if (this.select || !this.opts.closeOnSelect) this.postprocessResults(data, false, this.opts.closeOnSelect === true);

            if (this.opts.closeOnSelect) {
                this.close();
                this.search.width(10);
            } else {
                if (this.countSelectableResults() > 0) {
                    this.search.width(10);
                    this.resizeSearch();
                    if (this.getMaximumSelectionSize() > 0 && this.val().length >= this.getMaximumSelectionSize()) {
                        // if we reached max selection size repaint the results so choices
                        // are replaced with the max selection reached message
                        this.updateResults(true);
                    } else {
                        // initializes search's value with nextSearchTerm and update search result
                        if (this.prefillNextSearchTerm()) {
                            this.updateResults();
                        }
                    }
                    this.positionDropdown();
                } else {
                    // if nothing left to select close
                    this.close();
                    this.search.width(10);
                }
            }

            // since its not possible to select an element that has already been
            // added we do not need to check if this is a new element before firing change
            this.triggerChange({ added: data });

            if (!options || !options.noFocus)
                this.focusSearch();
        },

        // multi
        cancel: function () {
            this.close();
            this.focusSearch();
        },

        addSelectedChoice: function (data) {
            var val = this.getVal(), self = this;
            $(data).each(function () {
                val.push(self.createChoice(this));
            });
            this.setVal(val);
        },

        createChoice: function (data) {
            var enableChoice = !data.locked,
                enabledItem = $(
                    "<li class='select2-search-choice'>" +
                    "    <div></div>" +
                    "    <a href='#' class='select2-search-choice-close' tabindex='-1'></a>" +
                    "</li>"),
                disabledItem = $(
                    "<li class='select2-search-choice select2-locked'>" +
                    "<div></div>" +
                    "</li>");
            var choice = enableChoice ? enabledItem : disabledItem,
                id = this.id(data),
                formatted,
                cssClass;

            formatted = this.opts.formatSelection(data, choice.find("div"), this.opts.escapeMarkup);
            if (formatted != undefined) {
                choice.find("div").replaceWith($("<div></div>").html(formatted));
            }
            cssClass = this.opts.formatSelectionCssClass(data, choice.find("div"));
            if (cssClass != undefined) {
                choice.addClass(cssClass);
            }

            if (enableChoice) {
                choice.find(".select2-search-choice-close")
                    .on("mousedown", killEvent)
                    .on("click dblclick", this.bind(function (e) {
                        if (!this.isInterfaceEnabled()) return;

                        this.unselect($(e.target));
                        this.selection.find(".select2-search-choice-focus").removeClass("select2-search-choice-focus");
                        killEvent(e);
                        this.close();
                        this.focusSearch();
                    })).on("focus", this.bind(function () {
                        if (!this.isInterfaceEnabled()) return;
                        this.container.addClass("select2-container-active");
                        this.dropdown.addClass("select2-drop-active");
                    }));
            }

            choice.data("select2-data", data);
            choice.insertBefore(this.searchContainer);

            return id;
        },

        // multi
        unselect: function (selected) {
            var val = this.getVal(),
                data,
                index;
            selected = selected.closest(".select2-search-choice");

            if (selected.length === 0) {
                throw "Invalid argument: " + selected + ". Must be .select2-search-choice";
            }

            data = selected.data("select2-data");

            if (!data) {
                // prevent a race condition when the 'x' is clicked really fast repeatedly the event can be queued
                // and invoked on an element already removed
                return;
            }

            var evt = $.Event("select2-removing");
            evt.val = this.id(data);
            evt.choice = data;
            this.opts.element.trigger(evt);

            if (evt.isDefaultPrevented()) {
                return false;
            }

            while ((index = indexOf(this.id(data), val)) >= 0) {
                val.splice(index, 1);
                this.setVal(val);
                if (this.select) this.postprocessResults();
            }

            selected.remove();

            this.opts.element.trigger({ type: "select2-removed", val: this.id(data), choice: data });
            this.triggerChange({ removed: data });

            return true;
        },

        // multi
        postprocessResults: function (data, initial, noHighlightUpdate) {
            var val = this.getVal(),
                choices = this.results.find(".select2-result"),
                compound = this.results.find(".select2-result-with-children"),
                self = this;

            choices.each2(function (i, choice) {
                var id = self.id(choice.data("select2-data"));
                if (indexOf(id, val) >= 0) {
                    choice.addClass("select2-selected");
                    // mark all children of the selected parent as selected
                    choice.find(".select2-result-selectable").addClass("select2-selected");
                }
            });

            compound.each2(function (i, choice) {
                // hide an optgroup if it doesn't have any selectable children
                if (!choice.is('.select2-result-selectable')
                    && choice.find(".select2-result-selectable:not(.select2-selected)").length === 0) {
                    choice.addClass("select2-selected");
                }
            });

            if (this.highlight() == -1 && noHighlightUpdate !== false && this.opts.closeOnSelect === true) {
                self.highlight(0);
            }

            //If all results are chosen render formatNoMatches
            if (!this.opts.createSearchChoice && !choices.filter('.select2-result:not(.select2-selected)').length > 0) {
                if (!data || data && !data.more && this.results.find(".select2-no-results").length === 0) {
                    if (checkFormatter(self.opts.formatNoMatches, "formatNoMatches")) {
                        this.results.append("<li class='select2-no-results'>" + evaluate(self.opts.formatNoMatches, self.opts.element, self.search.val()) + "</li>");
                    }
                }
            }

        },

        // multi
        getMaxSearchWidth: function () {
            return this.selection.width() - getSideBorderPadding(this.search);
        },

        // multi
        resizeSearch: function () {
            var minimumWidth, left, maxWidth, containerLeft, searchWidth,
                sideBorderPadding = getSideBorderPadding(this.search);

            minimumWidth = measureTextWidth(this.search) + 10;

            left = this.search.offset().left;

            maxWidth = this.selection.width();
            containerLeft = this.selection.offset().left;

            searchWidth = maxWidth - (left - containerLeft) - sideBorderPadding;

            if (searchWidth < minimumWidth) {
                searchWidth = maxWidth - sideBorderPadding;
            }

            if (searchWidth < 40) {
                searchWidth = maxWidth - sideBorderPadding;
            }

            if (searchWidth <= 0) {
                searchWidth = minimumWidth;
            }

            this.search.width(Math.floor(searchWidth));
        },

        // multi
        getVal: function () {
            var val;
            if (this.select) {
                val = this.select.val();
                return val === null ? [] : val;
            } else {
                val = this.opts.element.val();
                return splitVal(val, this.opts.separator, this.opts.transformVal);
            }
        },

        // multi
        setVal: function (val) {
            if (this.select) {
                this.select.val(val);
            } else {
                var unique = [], valMap = {};
                // filter out duplicates
                $(val).each(function () {
                    if (!(this in valMap)) {
                        unique.push(this);
                        valMap[this] = 0;
                    }
                });
                this.opts.element.val(unique.length === 0 ? "" : unique.join(this.opts.separator));
            }
        },

        // multi
        buildChangeDetails: function (old, current) {
            var current = current.slice(0),
                old = old.slice(0);

            // remove intersection from each array
            for (var i = 0; i < current.length; i++) {
                for (var j = 0; j < old.length; j++) {
                    if (equal(this.opts.id(current[i]), this.opts.id(old[j]))) {
                        current.splice(i, 1);
                        i--;
                        old.splice(j, 1);
                        break;
                    }
                }
            }

            return { added: current, removed: old };
        },


        // multi
        val: function (val, triggerChange) {
            var oldData, self = this;

            if (arguments.length === 0) {
                return this.getVal();
            }

            oldData = this.data();
            if (!oldData.length) oldData = [];

            // val is an id. !val is true for [undefined,null,'',0] - 0 is legal
            if (!val && val !== 0) {
                this.opts.element.val("");
                this.updateSelection([]);
                this.clearSearch();
                if (triggerChange) {
                    this.triggerChange({ added: this.data(), removed: oldData });
                }
                return;
            }

            // val is a list of ids
            this.setVal(val);

            if (this.select) {
                this.opts.initSelection(this.select, this.bind(this.updateSelection));
                if (triggerChange) {
                    this.triggerChange(this.buildChangeDetails(oldData, this.data()));
                }
            } else {
                if (this.opts.initSelection === undefined) {
                    throw new Error("val() cannot be called if initSelection() is not defined");
                }

                this.opts.initSelection(this.opts.element, function (data) {
                    var ids = $.map(data, self.id);
                    self.setVal(ids);
                    self.updateSelection(data);
                    self.clearSearch();
                    if (triggerChange) {
                        self.triggerChange(self.buildChangeDetails(oldData, self.data()));
                    }
                });
            }
            this.clearSearch();
        },

        // multi
        onSortStart: function () {
            if (this.select) {
                throw new Error("Sorting of elements is not supported when attached to <select>. Attach to <input type='hidden'/> instead.");
            }

            // collapse search field into 0 width so its container can be collapsed as well
            this.search.width(0);
            // hide the container
            this.searchContainer.hide();
        },

        // multi
        onSortEnd: function () {

            var val = [], self = this;

            // show search and move it to the end of the list
            this.searchContainer.show();
            // make sure the search container is the last item in the list
            this.searchContainer.appendTo(this.searchContainer.parent());
            // since we collapsed the width in dragStarted, we resize it here
            this.resizeSearch();

            // update selection
            this.selection.find(".select2-search-choice").each(function () {
                val.push(self.opts.id($(this).data("select2-data")));
            });
            this.setVal(val);
            this.triggerChange();
        },

        // multi
        data: function (values, triggerChange) {
            var self = this, ids, old;
            if (arguments.length === 0) {
                return this.selection
                    .children(".select2-search-choice")
                    .map(function () { return $(this).data("select2-data"); })
                    .get();
            } else {
                old = this.data();
                if (!values) { values = []; }
                ids = $.map(values, function (e) { return self.opts.id(e); });
                this.setVal(ids);
                this.updateSelection(values);
                this.clearSearch();
                if (triggerChange) {
                    this.triggerChange(this.buildChangeDetails(old, this.data()));
                }
            }
        }
    });

    $.fn.select2 = function () {

        var args = Array.prototype.slice.call(arguments, 0),
            opts,
            select2,
            method, value, multiple,
            allowedMethods = ["val", "destroy", "opened", "open", "close", "focus", "isFocused", "container", "dropdown", "onSortStart", "onSortEnd", "enable", "disable", "readonly", "positionDropdown", "data", "search"],
            valueMethods = ["opened", "isFocused", "container", "dropdown"],
            propertyMethods = ["val", "data"],
            methodsMap = { search: "externalSearch" };

        this.each(function () {
            if (args.length === 0 || typeof (args[0]) === "object") {
                opts = args.length === 0 ? {} : $.extend({}, args[0]);
                opts.element = $(this);

                if (opts.element.get(0).tagName.toLowerCase() === "select") {
                    multiple = opts.element.prop("multiple");
                } else {
                    multiple = opts.multiple || false;
                    if ("tags" in opts) { opts.multiple = multiple = true; }
                }

                select2 = multiple ? new window.Select2["class"].multi() : new window.Select2["class"].single();
                select2.init(opts);
            } else if (typeof (args[0]) === "string") {

                if (indexOf(args[0], allowedMethods) < 0) {
                    throw "Unknown method: " + args[0];
                }

                value = undefined;
                select2 = $(this).data("select2");
                if (select2 === undefined) return;

                method = args[0];

                if (method === "container") {
                    value = select2.container;
                } else if (method === "dropdown") {
                    value = select2.dropdown;
                } else {
                    if (methodsMap[method]) method = methodsMap[method];

                    value = select2[method].apply(select2, args.slice(1));
                }
                if (indexOf(args[0], valueMethods) >= 0
                    || (indexOf(args[0], propertyMethods) >= 0 && args.length == 1)) {
                    return false; // abort the iteration, ready to return first matched value
                }
            } else {
                throw "Invalid arguments to select2 plugin: " + args;
            }
        });
        return (value === undefined) ? this : value;
    };

    // plugin defaults, accessible to users
    $.fn.select2.defaults = {
        debug: false,
        width: "copy",
        loadMorePadding: 0,
        closeOnSelect: true,
        openOnEnter: true,
        containerCss: {},
        dropdownCss: {},
        containerCssClass: "",
        dropdownCssClass: "",
        formatResult: function (result, container, query, escapeMarkup) {
            var markup = [];
            markMatch(this.text(result), query.term, markup, escapeMarkup);
            return markup.join("");
        },
        transformVal: function (val) {
            return $.trim(val);
        },
        formatSelection: function (data, container, escapeMarkup) {
            return data ? escapeMarkup(this.text(data)) : undefined;
        },
        sortResults: function (results, container, query) {
            return results;
        },
        formatResultCssClass: function (data) { return data.css; },
        formatSelectionCssClass: function (data, container) { return undefined; },
        minimumResultsForSearch: 0,
        minimumInputLength: 0,
        maximumInputLength: null,
        maximumSelectionSize: 0,
        id: function (e) { return e == undefined ? null : e.id; },
        text: function (e) {
            if (e && this.data && this.data.text) {
                if ($.isFunction(this.data.text)) {
                    return this.data.text(e);
                } else {
                    return e[this.data.text];
                }
            } else {
                return e.text;
            }
        },
        matcher: function (term, text) {
            return stripDiacritics('' + text).toUpperCase().indexOf(stripDiacritics('' + term).toUpperCase()) >= 0;
        },
        separator: ",",
        tokenSeparators: [],
        tokenizer: defaultTokenizer,
        escapeMarkup: defaultEscapeMarkup,
        blurOnChange: false,
        selectOnBlur: false,
        adaptContainerCssClass: function (c) { return c; },
        adaptDropdownCssClass: function (c) { return null; },
        nextSearchTerm: function (selectedObject, currentSearchTerm) { return undefined; },
        searchInputPlaceholder: '',
        createSearchChoicePosition: 'top',
        shouldFocusInput: function (instance) {
            // Attempt to detect touch devices
            var supportsTouchEvents = (('ontouchstart' in window) ||
                (navigator.msMaxTouchPoints > 0));

            // Only devices which support touch events should be special cased
            if (!supportsTouchEvents) {
                return true;
            }

            // Never focus the input if search is disabled
            if (instance.opts.minimumResultsForSearch < 0) {
                return false;
            }

            return true;
        }
    };

    $.fn.select2.locales = [];

    $.fn.select2.locales['en'] = {
        formatMatches: function (matches) { if (matches === 1) { return "One result is available, press enter to select it."; } return matches + " results are available, use up and down arrow keys to navigate."; },
        formatNoMatches: function () { return "No matches found"; },
        formatAjaxError: function (jqXHR, textStatus, errorThrown) { return "Loading failed"; },
        formatInputTooShort: function (input, min) { var n = min - input.length; return "Please enter " + n + " or more character" + (n == 1 ? "" : "s"); },
        formatInputTooLong: function (input, max) { var n = input.length - max; return "Please delete " + n + " character" + (n == 1 ? "" : "s"); },
        formatSelectionTooBig: function (limit) { return "You can only select " + limit + " item" + (limit == 1 ? "" : "s"); },
        formatLoadMore: function (pageNumber) { return "Loading more resultsâ€¦"; },
        formatSearching: function () { return "Searchingâ€¦"; }
    };

    $.extend($.fn.select2.defaults, $.fn.select2.locales['en']);

    $.fn.select2.ajaxDefaults = {
        transport: $.ajax,
        params: {
            type: "GET",
            cache: false,
            dataType: "json"
        }
    };

    // exports
    window.Select2 = {
        query: {
            ajax: ajax,
            local: local,
            tags: tags
        }, util: {
            debounce: debounce,
            markMatch: markMatch,
            escapeMarkup: defaultEscapeMarkup,
            stripDiacritics: stripDiacritics
        }, "class": {
            "abstract": AbstractSelect2,
            "single": SingleSelect2,
            "multi": MultiSelect2
        }
    };

}(jQuery));
;
// TinyColor v1.3.0
// https://github.com/bgrins/TinyColor
// Brian Grinstead, MIT License

(function (Math) {

    var trimLeft = /^\s+/,
        trimRight = /\s+$/,
        tinyCounter = 0,
        mathRound = Math.round,
        mathMin = Math.min,
        mathMax = Math.max,
        mathRandom = Math.random;

    function tinycolor(color, opts) {

        color = (color) ? color : '';
        opts = opts || {};

        // If input is already a tinycolor, return itself
        if (color instanceof tinycolor) {
            return color;
        }
        // If we are called as a function, call using new instead
        if (!(this instanceof tinycolor)) {
            return new tinycolor(color, opts);
        }

        var rgb = inputToRGB(color);
        this._originalInput = color,
            this._r = rgb.r,
            this._g = rgb.g,
            this._b = rgb.b,
            this._a = rgb.a,
            this._roundA = mathRound(100 * this._a) / 100,
            this._format = opts.format || rgb.format;
        this._gradientType = opts.gradientType;

        // Don't let the range of [0,255] come back in [0,1].
        // Potentially lose a little bit of precision here, but will fix issues where
        // .5 gets interpreted as half of the total, instead of half of 1
        // If it was supposed to be 128, this was already taken care of by `inputToRgb`
        if (this._r < 1) { this._r = mathRound(this._r); }
        if (this._g < 1) { this._g = mathRound(this._g); }
        if (this._b < 1) { this._b = mathRound(this._b); }

        this._ok = rgb.ok;
        this._tc_id = tinyCounter++;
    }

    tinycolor.prototype = {
        isDark: function () {
            return this.getBrightness() < 128;
        },
        isLight: function () {
            return !this.isDark();
        },
        isValid: function () {
            return this._ok;
        },
        getOriginalInput: function () {
            return this._originalInput;
        },
        getFormat: function () {
            return this._format;
        },
        getAlpha: function () {
            return this._a;
        },
        getBrightness: function () {
            //http://www.w3.org/TR/AERT#color-contrast
            var rgb = this.toRgb();
            return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
        },
        getLuminance: function () {
            //http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef
            var rgb = this.toRgb();
            var RsRGB, GsRGB, BsRGB, R, G, B;
            RsRGB = rgb.r / 255;
            GsRGB = rgb.g / 255;
            BsRGB = rgb.b / 255;

            if (RsRGB <= 0.03928) { R = RsRGB / 12.92; } else { R = Math.pow(((RsRGB + 0.055) / 1.055), 2.4); }
            if (GsRGB <= 0.03928) { G = GsRGB / 12.92; } else { G = Math.pow(((GsRGB + 0.055) / 1.055), 2.4); }
            if (BsRGB <= 0.03928) { B = BsRGB / 12.92; } else { B = Math.pow(((BsRGB + 0.055) / 1.055), 2.4); }
            return (0.2126 * R) + (0.7152 * G) + (0.0722 * B);
        },
        setAlpha: function (value) {
            this._a = boundAlpha(value);
            this._roundA = mathRound(100 * this._a) / 100;
            return this;
        },
        toHsv: function () {
            var hsv = rgbToHsv(this._r, this._g, this._b);
            return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this._a };
        },
        toHsvString: function () {
            var hsv = rgbToHsv(this._r, this._g, this._b);
            var h = mathRound(hsv.h * 360), s = mathRound(hsv.s * 100), v = mathRound(hsv.v * 100);
            return (this._a == 1) ?
                "hsv(" + h + ", " + s + "%, " + v + "%)" :
                "hsva(" + h + ", " + s + "%, " + v + "%, " + this._roundA + ")";
        },
        toHsl: function () {
            var hsl = rgbToHsl(this._r, this._g, this._b);
            return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this._a };
        },
        toHslString: function () {
            var hsl = rgbToHsl(this._r, this._g, this._b);
            var h = mathRound(hsl.h * 360), s = mathRound(hsl.s * 100), l = mathRound(hsl.l * 100);
            return (this._a == 1) ?
                "hsl(" + h + ", " + s + "%, " + l + "%)" :
                "hsla(" + h + ", " + s + "%, " + l + "%, " + this._roundA + ")";
        },
        toHex: function (allow3Char) {
            return rgbToHex(this._r, this._g, this._b, allow3Char);
        },
        toHexString: function (allow3Char) {
            return '#' + this.toHex(allow3Char);
        },
        toHex8: function () {
            return rgbaToHex(this._r, this._g, this._b, this._a);
        },
        toHex8String: function () {
            return '#' + this.toHex8();
        },
        toRgb: function () {
            return { r: mathRound(this._r), g: mathRound(this._g), b: mathRound(this._b), a: this._a };
        },
        toRgbString: function () {
            return (this._a == 1) ?
                "rgb(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ")" :
                "rgba(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ", " + this._roundA + ")";
        },
        toPercentageRgb: function () {
            return { r: mathRound(bound01(this._r, 255) * 100) + "%", g: mathRound(bound01(this._g, 255) * 100) + "%", b: mathRound(bound01(this._b, 255) * 100) + "%", a: this._a };
        },
        toPercentageRgbString: function () {
            return (this._a == 1) ?
                "rgb(" + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%)" :
                "rgba(" + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
        },
        toName: function () {
            if (this._a === 0) {
                return "transparent";
            }

            if (this._a < 1) {
                return false;
            }

            return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
        },
        toFilter: function (secondColor) {
            var hex8String = '#' + rgbaToHex(this._r, this._g, this._b, this._a);
            var secondHex8String = hex8String;
            var gradientType = this._gradientType ? "GradientType = 1, " : "";

            if (secondColor) {
                var s = tinycolor(secondColor);
                secondHex8String = s.toHex8String();
            }

            return "progid:DXImageTransform.Microsoft.gradient(" + gradientType + "startColorstr=" + hex8String + ",endColorstr=" + secondHex8String + ")";
        },
        toString: function (format) {
            var formatSet = !!format;
            format = format || this._format;

            var formattedString = false;
            var hasAlpha = this._a < 1 && this._a >= 0;
            var needsAlphaFormat = !formatSet && hasAlpha && (format === "hex" || format === "hex6" || format === "hex3" || format === "name");

            if (needsAlphaFormat) {
                // Special case for "transparent", all other non-alpha formats
                // will return rgba when there is transparency.
                if (format === "name" && this._a === 0) {
                    return this.toName();
                }
                return this.toRgbString();
            }
            if (format === "rgb") {
                formattedString = this.toRgbString();
            }
            if (format === "prgb") {
                formattedString = this.toPercentageRgbString();
            }
            if (format === "hex" || format === "hex6") {
                formattedString = this.toHexString();
            }
            if (format === "hex3") {
                formattedString = this.toHexString(true);
            }
            if (format === "hex8") {
                formattedString = this.toHex8String();
            }
            if (format === "name") {
                formattedString = this.toName();
            }
            if (format === "hsl") {
                formattedString = this.toHslString();
            }
            if (format === "hsv") {
                formattedString = this.toHsvString();
            }

            return formattedString || this.toHexString();
        },
        clone: function () {
            return tinycolor(this.toString());
        },

        _applyModification: function (fn, args) {
            var color = fn.apply(null, [this].concat([].slice.call(args)));
            this._r = color._r;
            this._g = color._g;
            this._b = color._b;
            this.setAlpha(color._a);
            return this;
        },
        lighten: function () {
            return this._applyModification(lighten, arguments);
        },
        brighten: function () {
            return this._applyModification(brighten, arguments);
        },
        darken: function () {
            return this._applyModification(darken, arguments);
        },
        desaturate: function () {
            return this._applyModification(desaturate, arguments);
        },
        saturate: function () {
            return this._applyModification(saturate, arguments);
        },
        greyscale: function () {
            return this._applyModification(greyscale, arguments);
        },
        spin: function () {
            return this._applyModification(spin, arguments);
        },

        _applyCombination: function (fn, args) {
            return fn.apply(null, [this].concat([].slice.call(args)));
        },
        analogous: function () {
            return this._applyCombination(analogous, arguments);
        },
        complement: function () {
            return this._applyCombination(complement, arguments);
        },
        monochromatic: function () {
            return this._applyCombination(monochromatic, arguments);
        },
        splitcomplement: function () {
            return this._applyCombination(splitcomplement, arguments);
        },
        triad: function () {
            return this._applyCombination(triad, arguments);
        },
        tetrad: function () {
            return this._applyCombination(tetrad, arguments);
        }
    };

    // If input is an object, force 1 into "1.0" to handle ratios properly
    // String input requires "1.0" as input, so 1 will be treated as 1
    tinycolor.fromRatio = function (color, opts) {
        if (typeof color == "object") {
            var newColor = {};
            for (var i in color) {
                if (color.hasOwnProperty(i)) {
                    if (i === "a") {
                        newColor[i] = color[i];
                    }
                    else {
                        newColor[i] = convertToPercentage(color[i]);
                    }
                }
            }
            color = newColor;
        }

        return tinycolor(color, opts);
    };

    // Given a string or object, convert that input to RGB
    // Possible string inputs:
    //
    //     "red"
    //     "#f00" or "f00"
    //     "#ff0000" or "ff0000"
    //     "#ff000000" or "ff000000"
    //     "rgb 255 0 0" or "rgb (255, 0, 0)"
    //     "rgb 1.0 0 0" or "rgb (1, 0, 0)"
    //     "rgba (255, 0, 0, 1)" or "rgba 255, 0, 0, 1"
    //     "rgba (1.0, 0, 0, 1)" or "rgba 1.0, 0, 0, 1"
    //     "hsl(0, 100%, 50%)" or "hsl 0 100% 50%"
    //     "hsla(0, 100%, 50%, 1)" or "hsla 0 100% 50%, 1"
    //     "hsv(0, 100%, 100%)" or "hsv 0 100% 100%"
    //
    function inputToRGB(color) {

        var rgb = { r: 0, g: 0, b: 0 };
        var a = 1;
        var s = null;
        var v = null;
        var l = null;
        var ok = false;
        var format = false;

        if (typeof color == "string") {
            color = stringInputToObject(color);
        }

        if (typeof color == "object") {
            if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
                rgb = rgbToRgb(color.r, color.g, color.b);
                ok = true;
                format = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
            }
            else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
                s = convertToPercentage(color.s);
                v = convertToPercentage(color.v);
                rgb = hsvToRgb(color.h, s, v);
                ok = true;
                format = "hsv";
            }
            else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
                s = convertToPercentage(color.s);
                l = convertToPercentage(color.l);
                rgb = hslToRgb(color.h, s, l);
                ok = true;
                format = "hsl";
            }

            if (color.hasOwnProperty("a")) {
                a = color.a;
            }
        }

        a = boundAlpha(a);

        return {
            ok: ok,
            format: color.format || format,
            r: mathMin(255, mathMax(rgb.r, 0)),
            g: mathMin(255, mathMax(rgb.g, 0)),
            b: mathMin(255, mathMax(rgb.b, 0)),
            a: a
        };
    }


    // Conversion Functions
    // --------------------

    // `rgbToHsl`, `rgbToHsv`, `hslToRgb`, `hsvToRgb` modified from:
    // <http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript>

    // `rgbToRgb`
    // Handle bounds / percentage checking to conform to CSS color spec
    // <http://www.w3.org/TR/css3-color/>
    // *Assumes:* r, g, b in [0, 255] or [0, 1]
    // *Returns:* { r, g, b } in [0, 255]
    function rgbToRgb(r, g, b) {
        return {
            r: bound01(r, 255) * 255,
            g: bound01(g, 255) * 255,
            b: bound01(b, 255) * 255
        };
    }

    // `rgbToHsl`
    // Converts an RGB color value to HSL.
    // *Assumes:* r, g, and b are contained in [0, 255] or [0, 1]
    // *Returns:* { h, s, l } in [0,1]
    function rgbToHsl(r, g, b) {

        r = bound01(r, 255);
        g = bound01(g, 255);
        b = bound01(b, 255);

        var max = mathMax(r, g, b), min = mathMin(r, g, b);
        var h, s, l = (max + min) / 2;

        if (max == min) {
            h = s = 0; // achromatic
        }
        else {
            var d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch (max) {
                case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                case g: h = (b - r) / d + 2; break;
                case b: h = (r - g) / d + 4; break;
            }

            h /= 6;
        }

        return { h: h, s: s, l: l };
    }

    // `hslToRgb`
    // Converts an HSL color value to RGB.
    // *Assumes:* h is contained in [0, 1] or [0, 360] and s and l are contained [0, 1] or [0, 100]
    // *Returns:* { r, g, b } in the set [0, 255]
    function hslToRgb(h, s, l) {
        var r, g, b;

        h = bound01(h, 360);
        s = bound01(s, 100);
        l = bound01(l, 100);

        function hue2rgb(p, q, t) {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1 / 6) return p + (q - p) * 6 * t;
            if (t < 1 / 2) return q;
            if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
            return p;
        }

        if (s === 0) {
            r = g = b = l; // achromatic
        }
        else {
            var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            var p = 2 * l - q;
            r = hue2rgb(p, q, h + 1 / 3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1 / 3);
        }

        return { r: r * 255, g: g * 255, b: b * 255 };
    }

    // `rgbToHsv`
    // Converts an RGB color value to HSV
    // *Assumes:* r, g, and b are contained in the set [0, 255] or [0, 1]
    // *Returns:* { h, s, v } in [0,1]
    function rgbToHsv(r, g, b) {

        r = bound01(r, 255);
        g = bound01(g, 255);
        b = bound01(b, 255);

        var max = mathMax(r, g, b), min = mathMin(r, g, b);
        var h, s, v = max;

        var d = max - min;
        s = max === 0 ? 0 : d / max;

        if (max == min) {
            h = 0; // achromatic
        }
        else {
            switch (max) {
                case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                case g: h = (b - r) / d + 2; break;
                case b: h = (r - g) / d + 4; break;
            }
            h /= 6;
        }
        return { h: h, s: s, v: v };
    }

    // `hsvToRgb`
    // Converts an HSV color value to RGB.
    // *Assumes:* h is contained in [0, 1] or [0, 360] and s and v are contained in [0, 1] or [0, 100]
    // *Returns:* { r, g, b } in the set [0, 255]
    function hsvToRgb(h, s, v) {

        h = bound01(h, 360) * 6;
        s = bound01(s, 100);
        v = bound01(v, 100);

        var i = Math.floor(h),
            f = h - i,
            p = v * (1 - s),
            q = v * (1 - f * s),
            t = v * (1 - (1 - f) * s),
            mod = i % 6,
            r = [v, q, p, p, t, v][mod],
            g = [t, v, v, q, p, p][mod],
            b = [p, p, t, v, v, q][mod];

        return { r: r * 255, g: g * 255, b: b * 255 };
    }

    // `rgbToHex`
    // Converts an RGB color to hex
    // Assumes r, g, and b are contained in the set [0, 255]
    // Returns a 3 or 6 character hex
    function rgbToHex(r, g, b, allow3Char) {

        var hex = [
            pad2(mathRound(r).toString(16)),
            pad2(mathRound(g).toString(16)),
            pad2(mathRound(b).toString(16))
        ];

        // Return a 3 character hex if possible
        if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {
            return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
        }

        return hex.join("");
    }

    // `rgbaToHex`
    // Converts an RGBA color plus alpha transparency to hex
    // Assumes r, g, b and a are contained in the set [0, 255]
    // Returns an 8 character hex
    function rgbaToHex(r, g, b, a) {

        var hex = [
            pad2(convertDecimalToHex(a)),
            pad2(mathRound(r).toString(16)),
            pad2(mathRound(g).toString(16)),
            pad2(mathRound(b).toString(16))
        ];

        return hex.join("");
    }

    // `equals`
    // Can be called with any tinycolor input
    tinycolor.equals = function (color1, color2) {
        if (!color1 || !color2) { return false; }
        return tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();
    };

    tinycolor.random = function () {
        return tinycolor.fromRatio({
            r: mathRandom(),
            g: mathRandom(),
            b: mathRandom()
        });
    };


    // Modification Functions
    // ----------------------
    // Thanks to less.js for some of the basics here
    // <https://github.com/cloudhead/less.js/blob/master/lib/less/functions.js>

    function desaturate(color, amount) {
        amount = (amount === 0) ? 0 : (amount || 10);
        var hsl = tinycolor(color).toHsl();
        hsl.s -= amount / 100;
        hsl.s = clamp01(hsl.s);
        return tinycolor(hsl);
    }

    function saturate(color, amount) {
        amount = (amount === 0) ? 0 : (amount || 10);
        var hsl = tinycolor(color).toHsl();
        hsl.s += amount / 100;
        hsl.s = clamp01(hsl.s);
        return tinycolor(hsl);
    }

    function greyscale(color) {
        return tinycolor(color).desaturate(100);
    }

    function lighten(color, amount) {
        amount = (amount === 0) ? 0 : (amount || 10);
        var hsl = tinycolor(color).toHsl();
        hsl.l += amount / 100;
        hsl.l = clamp01(hsl.l);
        return tinycolor(hsl);
    }

    function brighten(color, amount) {
        amount = (amount === 0) ? 0 : (amount || 10);
        var rgb = tinycolor(color).toRgb();
        rgb.r = mathMax(0, mathMin(255, rgb.r - mathRound(255 * - (amount / 100))));
        rgb.g = mathMax(0, mathMin(255, rgb.g - mathRound(255 * - (amount / 100))));
        rgb.b = mathMax(0, mathMin(255, rgb.b - mathRound(255 * - (amount / 100))));
        return tinycolor(rgb);
    }

    function darken(color, amount) {
        amount = (amount === 0) ? 0 : (amount || 10);
        var hsl = tinycolor(color).toHsl();
        hsl.l -= amount / 100;
        hsl.l = clamp01(hsl.l);
        return tinycolor(hsl);
    }

    // Spin takes a positive or negative amount within [-360, 360] indicating the change of hue.
    // Values outside of this range will be wrapped into this range.
    function spin(color, amount) {
        var hsl = tinycolor(color).toHsl();
        var hue = (hsl.h + amount) % 360;
        hsl.h = hue < 0 ? 360 + hue : hue;
        return tinycolor(hsl);
    }

    // Combination Functions
    // ---------------------
    // Thanks to jQuery xColor for some of the ideas behind these
    // <https://github.com/infusion/jQuery-xcolor/blob/master/jquery.xcolor.js>

    function complement(color) {
        var hsl = tinycolor(color).toHsl();
        hsl.h = (hsl.h + 180) % 360;
        return tinycolor(hsl);
    }

    function triad(color) {
        var hsl = tinycolor(color).toHsl();
        var h = hsl.h;
        return [
            tinycolor(color),
            tinycolor({ h: (h + 120) % 360, s: hsl.s, l: hsl.l }),
            tinycolor({ h: (h + 240) % 360, s: hsl.s, l: hsl.l })
        ];
    }

    function tetrad(color) {
        var hsl = tinycolor(color).toHsl();
        var h = hsl.h;
        return [
            tinycolor(color),
            tinycolor({ h: (h + 90) % 360, s: hsl.s, l: hsl.l }),
            tinycolor({ h: (h + 180) % 360, s: hsl.s, l: hsl.l }),
            tinycolor({ h: (h + 270) % 360, s: hsl.s, l: hsl.l })
        ];
    }

    function splitcomplement(color) {
        var hsl = tinycolor(color).toHsl();
        var h = hsl.h;
        return [
            tinycolor(color),
            tinycolor({ h: (h + 72) % 360, s: hsl.s, l: hsl.l }),
            tinycolor({ h: (h + 216) % 360, s: hsl.s, l: hsl.l })
        ];
    }

    function analogous(color, results, slices) {
        results = results || 6;
        slices = slices || 30;

        var hsl = tinycolor(color).toHsl();
        var part = 360 / slices;
        var ret = [tinycolor(color)];

        for (hsl.h = ((hsl.h - (part * results >> 1)) + 720) % 360; --results;) {
            hsl.h = (hsl.h + part) % 360;
            ret.push(tinycolor(hsl));
        }
        return ret;
    }

    function monochromatic(color, results) {
        results = results || 6;
        var hsv = tinycolor(color).toHsv();
        var h = hsv.h, s = hsv.s, v = hsv.v;
        var ret = [];
        var modification = 1 / results;

        while (results--) {
            ret.push(tinycolor({ h: h, s: s, v: v }));
            v = (v + modification) % 1;
        }

        return ret;
    }

    // Utility Functions
    // ---------------------

    tinycolor.mix = function (color1, color2, amount) {
        amount = (amount === 0) ? 0 : (amount || 50);

        var rgb1 = tinycolor(color1).toRgb();
        var rgb2 = tinycolor(color2).toRgb();

        var p = amount / 100;

        var rgba = {
            r: ((rgb2.r - rgb1.r) * p) + rgb1.r,
            g: ((rgb2.g - rgb1.g) * p) + rgb1.g,
            b: ((rgb2.b - rgb1.b) * p) + rgb1.b,
            a: ((rgb2.a - rgb1.a) * p) + rgb1.a
        };

        return tinycolor(rgba);
    };


    // Readability Functions
    // ---------------------
    // <http://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef (WCAG Version 2)

    // `contrast`
    // Analyze the 2 colors and returns the color contrast defined by (WCAG Version 2)
    tinycolor.readability = function (color1, color2) {
        var c1 = tinycolor(color1);
        var c2 = tinycolor(color2);
        return (Math.max(c1.getLuminance(), c2.getLuminance()) + 0.05) / (Math.min(c1.getLuminance(), c2.getLuminance()) + 0.05);
    };

    // `isReadable`
    // Ensure that foreground and background color combinations meet WCAG2 guidelines.
    // The third argument is an optional Object.
    //      the 'level' property states 'AA' or 'AAA' - if missing or invalid, it defaults to 'AA';
    //      the 'size' property states 'large' or 'small' - if missing or invalid, it defaults to 'small'.
    // If the entire object is absent, isReadable defaults to {level:"AA",size:"small"}.

    // *Example*
    //    tinycolor.isReadable("#000", "#111") => false
    //    tinycolor.isReadable("#000", "#111",{level:"AA",size:"large"}) => false
    tinycolor.isReadable = function (color1, color2, wcag2) {
        var readability = tinycolor.readability(color1, color2);
        var wcag2Parms, out;

        out = false;

        wcag2Parms = validateWCAG2Parms(wcag2);
        switch (wcag2Parms.level + wcag2Parms.size) {
            case "AAsmall":
            case "AAAlarge":
                out = readability >= 4.5;
                break;
            case "AAlarge":
                out = readability >= 3;
                break;
            case "AAAsmall":
                out = readability >= 7;
                break;
        }
        return out;

    };

    // `mostReadable`
    // Given a base color and a list of possible foreground or background
    // colors for that base, returns the most readable color.
    // Optionally returns Black or White if the most readable color is unreadable.
    // *Example*
    //    tinycolor.mostReadable(tinycolor.mostReadable("#123", ["#124", "#125"],{includeFallbackColors:false}).toHexString(); // "#112255"
    //    tinycolor.mostReadable(tinycolor.mostReadable("#123", ["#124", "#125"],{includeFallbackColors:true}).toHexString();  // "#ffffff"
    //    tinycolor.mostReadable("#a8015a", ["#faf3f3"],{includeFallbackColors:true,level:"AAA",size:"large"}).toHexString(); // "#faf3f3"
    //    tinycolor.mostReadable("#a8015a", ["#faf3f3"],{includeFallbackColors:true,level:"AAA",size:"small"}).toHexString(); // "#ffffff"
    tinycolor.mostReadable = function (baseColor, colorList, args) {
        var bestColor = null;
        var bestScore = 0;
        var readability;
        var includeFallbackColors, level, size;
        args = args || {};
        includeFallbackColors = args.includeFallbackColors;
        level = args.level;
        size = args.size;

        for (var i = 0; i < colorList.length; i++) {
            readability = tinycolor.readability(baseColor, colorList[i]);
            if (readability > bestScore) {
                bestScore = readability;
                bestColor = tinycolor(colorList[i]);
            }
        }

        if (tinycolor.isReadable(baseColor, bestColor, { "level": level, "size": size }) || !includeFallbackColors) {
            return bestColor;
        }
        else {
            args.includeFallbackColors = false;
            return tinycolor.mostReadable(baseColor, ["#fff", "#000"], args);
        }
    };


    // Big List of Colors
    // ------------------
    // <http://www.w3.org/TR/css3-color/#svg-color>
    var names = tinycolor.names = {
        aliceblue: "f0f8ff",
        antiquewhite: "faebd7",
        aqua: "0ff",
        aquamarine: "7fffd4",
        azure: "f0ffff",
        beige: "f5f5dc",
        bisque: "ffe4c4",
        black: "000",
        blanchedalmond: "ffebcd",
        blue: "00f",
        blueviolet: "8a2be2",
        brown: "a52a2a",
        burlywood: "deb887",
        burntsienna: "ea7e5d",
        cadetblue: "5f9ea0",
        chartreuse: "7fff00",
        chocolate: "d2691e",
        coral: "ff7f50",
        cornflowerblue: "6495ed",
        cornsilk: "fff8dc",
        crimson: "dc143c",
        cyan: "0ff",
        darkblue: "00008b",
        darkcyan: "008b8b",
        darkgoldenrod: "b8860b",
        darkgray: "a9a9a9",
        darkgreen: "006400",
        darkgrey: "a9a9a9",
        darkkhaki: "bdb76b",
        darkmagenta: "8b008b",
        darkolivegreen: "556b2f",
        darkorange: "ff8c00",
        darkorchid: "9932cc",
        darkred: "8b0000",
        darksalmon: "e9967a",
        darkseagreen: "8fbc8f",
        darkslateblue: "483d8b",
        darkslategray: "2f4f4f",
        darkslategrey: "2f4f4f",
        darkturquoise: "00ced1",
        darkviolet: "9400d3",
        deeppink: "ff1493",
        deepskyblue: "00bfff",
        dimgray: "696969",
        dimgrey: "696969",
        dodgerblue: "1e90ff",
        firebrick: "b22222",
        floralwhite: "fffaf0",
        forestgreen: "228b22",
        fuchsia: "f0f",
        gainsboro: "dcdcdc",
        ghostwhite: "f8f8ff",
        gold: "ffd700",
        goldenrod: "daa520",
        gray: "808080",
        green: "008000",
        greenyellow: "adff2f",
        grey: "808080",
        honeydew: "f0fff0",
        hotpink: "ff69b4",
        indianred: "cd5c5c",
        indigo: "4b0082",
        ivory: "fffff0",
        khaki: "f0e68c",
        lavender: "e6e6fa",
        lavenderblush: "fff0f5",
        lawngreen: "7cfc00",
        lemonchiffon: "fffacd",
        lightblue: "add8e6",
        lightcoral: "f08080",
        lightcyan: "e0ffff",
        lightgoldenrodyellow: "fafad2",
        lightgray: "d3d3d3",
        lightgreen: "90ee90",
        lightgrey: "d3d3d3",
        lightpink: "ffb6c1",
        lightsalmon: "ffa07a",
        lightseagreen: "20b2aa",
        lightskyblue: "87cefa",
        lightslategray: "789",
        lightslategrey: "789",
        lightsteelblue: "b0c4de",
        lightyellow: "ffffe0",
        lime: "0f0",
        limegreen: "32cd32",
        linen: "faf0e6",
        magenta: "f0f",
        maroon: "800000",
        mediumaquamarine: "66cdaa",
        mediumblue: "0000cd",
        mediumorchid: "ba55d3",
        mediumpurple: "9370db",
        mediumseagreen: "3cb371",
        mediumslateblue: "7b68ee",
        mediumspringgreen: "00fa9a",
        mediumturquoise: "48d1cc",
        mediumvioletred: "c71585",
        midnightblue: "191970",
        mintcream: "f5fffa",
        mistyrose: "ffe4e1",
        moccasin: "ffe4b5",
        navajowhite: "ffdead",
        navy: "000080",
        oldlace: "fdf5e6",
        olive: "808000",
        olivedrab: "6b8e23",
        orange: "ffa500",
        orangered: "ff4500",
        orchid: "da70d6",
        palegoldenrod: "eee8aa",
        palegreen: "98fb98",
        paleturquoise: "afeeee",
        palevioletred: "db7093",
        papayawhip: "ffefd5",
        peachpuff: "ffdab9",
        peru: "cd853f",
        pink: "ffc0cb",
        plum: "dda0dd",
        powderblue: "b0e0e6",
        purple: "800080",
        rebeccapurple: "663399",
        red: "f00",
        rosybrown: "bc8f8f",
        royalblue: "4169e1",
        saddlebrown: "8b4513",
        salmon: "fa8072",
        sandybrown: "f4a460",
        seagreen: "2e8b57",
        seashell: "fff5ee",
        sienna: "a0522d",
        silver: "c0c0c0",
        skyblue: "87ceeb",
        slateblue: "6a5acd",
        slategray: "708090",
        slategrey: "708090",
        snow: "fffafa",
        springgreen: "00ff7f",
        steelblue: "4682b4",
        tan: "d2b48c",
        teal: "008080",
        thistle: "d8bfd8",
        tomato: "ff6347",
        turquoise: "40e0d0",
        violet: "ee82ee",
        wheat: "f5deb3",
        white: "fff",
        whitesmoke: "f5f5f5",
        yellow: "ff0",
        yellowgreen: "9acd32"
    };

    // Make it easy to access colors via `hexNames[hex]`
    var hexNames = tinycolor.hexNames = flip(names);


    // Utilities
    // ---------

    // `{ 'name1': 'val1' }` becomes `{ 'val1': 'name1' }`
    function flip(o) {
        var flipped = {};
        for (var i in o) {
            if (o.hasOwnProperty(i)) {
                flipped[o[i]] = i;
            }
        }
        return flipped;
    }

    // Return a valid alpha value [0,1] with all invalid values being set to 1
    function boundAlpha(a) {
        a = parseFloat(a);

        if (isNaN(a) || a < 0 || a > 1) {
            a = 1;
        }

        return a;
    }

    // Take input from [0, n] and return it as [0, 1]
    function bound01(n, max) {
        if (isOnePointZero(n)) { n = "100%"; }

        var processPercent = isPercentage(n);
        n = mathMin(max, mathMax(0, parseFloat(n)));

        // Automatically convert percentage into number
        if (processPercent) {
            n = parseInt(n * max, 10) / 100;
        }

        // Handle floating point rounding errors
        if ((Math.abs(n - max) < 0.000001)) {
            return 1;
        }

        // Convert into [0, 1] range if it isn't already
        return (n % max) / parseFloat(max);
    }

    // Force a number between 0 and 1
    function clamp01(val) {
        return mathMin(1, mathMax(0, val));
    }

    // Parse a base-16 hex value into a base-10 integer
    function parseIntFromHex(val) {
        return parseInt(val, 16);
    }

    // Need to handle 1.0 as 100%, since once it is a number, there is no difference between it and 1
    // <http://stackoverflow.com/questions/7422072/javascript-how-to-detect-number-as-a-decimal-including-1-0>
    function isOnePointZero(n) {
        return typeof n == "string" && n.indexOf('.') != -1 && parseFloat(n) === 1;
    }

    // Check to see if string passed in is a percentage
    function isPercentage(n) {
        return typeof n === "string" && n.indexOf('%') != -1;
    }

    // Force a hex value to have 2 characters
    function pad2(c) {
        return c.length == 1 ? '0' + c : '' + c;
    }

    // Replace a decimal with it's percentage value
    function convertToPercentage(n) {
        if (n <= 1) {
            n = (n * 100) + "%";
        }

        return n;
    }

    // Converts a decimal to a hex value
    function convertDecimalToHex(d) {
        return Math.round(parseFloat(d) * 255).toString(16);
    }
    // Converts a hex value to a decimal
    function convertHexToDecimal(h) {
        return (parseIntFromHex(h) / 255);
    }

    var matchers = (function () {

        // <http://www.w3.org/TR/css3-values/#integers>
        var CSS_INTEGER = "[-\\+]?\\d+%?";

        // <http://www.w3.org/TR/css3-values/#number-value>
        var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";

        // Allow positive/negative integer/number.  Don't capture the either/or, just the entire outcome.
        var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";

        // Actual matching.
        // Parentheses and commas are optional, but not required.
        // Whitespace can take the place of commas or opening paren
        var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
        var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";

        return {
            CSS_UNIT: new RegExp(CSS_UNIT),
            rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
            rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
            hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
            hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
            hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
            hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
            hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
            hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
            hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
        };
    })();

    // `isValidCSSUnit`
    // Take in a single string / number and check to see if it looks like a CSS unit
    // (see `matchers` above for definition).
    function isValidCSSUnit(color) {
        return !!matchers.CSS_UNIT.exec(color);
    }

    // `stringInputToObject`
    // Permissive string parsing.  Take in a number of formats, and output an object
    // based on detected format.  Returns `{ r, g, b }` or `{ h, s, l }` or `{ h, s, v}`
    function stringInputToObject(color) {

        color = color.replace(trimLeft, '').replace(trimRight, '').toLowerCase();
        var named = false;
        if (names[color]) {
            color = names[color];
            named = true;
        }
        else if (color == 'transparent') {
            return { r: 0, g: 0, b: 0, a: 0, format: "name" };
        }

        // Try to match string input using regular expressions.
        // Keep most of the number bounding out of this function - don't worry about [0,1] or [0,100] or [0,360]
        // Just return an object and let the conversion functions handle that.
        // This way the result will be the same whether the tinycolor is initialized with string or object.
        var match;
        if ((match = matchers.rgb.exec(color))) {
            return { r: match[1], g: match[2], b: match[3] };
        }
        if ((match = matchers.rgba.exec(color))) {
            return { r: match[1], g: match[2], b: match[3], a: match[4] };
        }
        if ((match = matchers.hsl.exec(color))) {
            return { h: match[1], s: match[2], l: match[3] };
        }
        if ((match = matchers.hsla.exec(color))) {
            return { h: match[1], s: match[2], l: match[3], a: match[4] };
        }
        if ((match = matchers.hsv.exec(color))) {
            return { h: match[1], s: match[2], v: match[3] };
        }
        if ((match = matchers.hsva.exec(color))) {
            return { h: match[1], s: match[2], v: match[3], a: match[4] };
        }
        if ((match = matchers.hex8.exec(color))) {
            return {
                a: convertHexToDecimal(match[1]),
                r: parseIntFromHex(match[2]),
                g: parseIntFromHex(match[3]),
                b: parseIntFromHex(match[4]),
                format: named ? "name" : "hex8"
            };
        }
        if ((match = matchers.hex6.exec(color))) {
            return {
                r: parseIntFromHex(match[1]),
                g: parseIntFromHex(match[2]),
                b: parseIntFromHex(match[3]),
                format: named ? "name" : "hex"
            };
        }
        if ((match = matchers.hex3.exec(color))) {
            return {
                r: parseIntFromHex(match[1] + '' + match[1]),
                g: parseIntFromHex(match[2] + '' + match[2]),
                b: parseIntFromHex(match[3] + '' + match[3]),
                format: named ? "name" : "hex"
            };
        }

        return false;
    }

    function validateWCAG2Parms(parms) {
        // return valid WCAG2 parms for isReadable.
        // If input parms are invalid, return {"level":"AA", "size":"small"}
        var level, size;
        parms = parms || { "level": "AA", "size": "small" };
        level = (parms.level || "AA").toUpperCase();
        size = (parms.size || "small").toLowerCase();
        if (level !== "AA" && level !== "AAA") {
            level = "AA";
        }
        if (size !== "small" && size !== "large") {
            size = "small";
        }
        return { "level": level, "size": size };
    }

    // Node: Export function
    if (typeof module !== "undefined" && module.exports) {
        module.exports = tinycolor;
    }
    // AMD/requirejs: Define the module
    else if (typeof define === 'function' && define.amd) {
        define(function () { return tinycolor; });
    }
    // Browser: Expose to window
    else {
        window.tinycolor = tinycolor;
    }

})(Math);
;
(function (globals) {
    var define, requireModule;

    (function () {
        var registry = {}, seen = {};

        define = function (name, deps, callback) {
            registry[name] = { deps: deps, callback: callback };
        };

        define.registry = registry;

        requireModule = function (name) {
            if (seen[name]) { return seen[name]; }
            seen[name] = {};

            if (!registry[name]) {
                throw new Error("Could not find module " + name);
            }

            var mod = registry[name],
                deps = mod.deps,
                callback = mod.callback,
                reified = [],
                exports;

            for (var i = 0, l = deps.length; i < l; i++) {
                if (deps[i] === 'exports') {
                    reified.push(exports = {});
                } else {
                    reified.push(requireModule(deps[i]));
                }
            }

            var value = callback.apply(this, reified);
            return seen[name] = exports || value;
        };
    })();

    define("backburner/deferred_action_queues",
        ["backburner/queue", "exports"],
        function (__dependency1__, __exports__) {
            "use strict";
            var Queue = __dependency1__.Queue;

            function DeferredActionQueues(queueNames, options) {
                var queues = this.queues = {};
                this.queueNames = queueNames = queueNames || [];

                var queueName;
                for (var i = 0, l = queueNames.length; i < l; i++) {
                    queueName = queueNames[i];
                    queues[queueName] = new Queue(this, queueName, options[queueName]);
                }
            }

            DeferredActionQueues.prototype = {
                queueNames: null,
                queues: null,

                schedule: function (queueName, target, method, args, onceFlag, stack) {
                    var queues = this.queues,
                        queue = queues[queueName];

                    if (!queue) { throw new Error("You attempted to schedule an action in a queue (" + queueName + ") that doesn't exist"); }

                    if (onceFlag) {
                        return queue.pushUnique(target, method, args, stack);
                    } else {
                        return queue.push(target, method, args, stack);
                    }
                },

                flush: function () {
                    var queues = this.queues,
                        queueNames = this.queueNames,
                        queueName, queue, queueItems, priorQueueNameIndex,
                        queueNameIndex = 0, numberOfQueues = queueNames.length;

                    outerloop:
                    while (queueNameIndex < numberOfQueues) {
                        queueName = queueNames[queueNameIndex];
                        queue = queues[queueName];
                        queueItems = queue._queueBeingFlushed = queue._queue.slice();
                        queue._queue = [];

                        var options = queue.options,
                            before = options && options.before,
                            after = options && options.after,
                            target, method, args, stack,
                            queueIndex = 0, numberOfQueueItems = queueItems.length;

                        if (numberOfQueueItems && before) { before(); }
                        while (queueIndex < numberOfQueueItems) {
                            target = queueItems[queueIndex];
                            method = queueItems[queueIndex + 1];
                            args = queueItems[queueIndex + 2];
                            stack = queueItems[queueIndex + 3]; // Debugging assistance

                            if (typeof method === 'string') { method = target[method]; }

                            // method could have been nullified / canceled during flush
                            if (method) {
                                // TODO: error handling
                                if (args && args.length > 0) {
                                    method.apply(target, args);
                                } else {
                                    method.call(target);
                                }
                            }

                            queueIndex += 4;
                        }
                        queue._queueBeingFlushed = null;
                        if (numberOfQueueItems && after) { after(); }

                        if ((priorQueueNameIndex = indexOfPriorQueueWithActions(this, queueNameIndex)) !== -1) {
                            queueNameIndex = priorQueueNameIndex;
                            continue outerloop;
                        }

                        queueNameIndex++;
                    }
                }
            };

            function indexOfPriorQueueWithActions(daq, currentQueueIndex) {
                var queueName, queue;

                for (var i = 0, l = currentQueueIndex; i <= l; i++) {
                    queueName = daq.queueNames[i];
                    queue = daq.queues[queueName];
                    if (queue._queue.length) { return i; }
                }

                return -1;
            }

            __exports__.DeferredActionQueues = DeferredActionQueues;
        });
    define("backburner/queue",
        ["exports"],
        function (__exports__) {
            "use strict";
            function Queue(daq, name, options) {
                this.daq = daq;
                this.name = name;
                this.options = options;
                this._queue = [];
            }

            Queue.prototype = {
                daq: null,
                name: null,
                options: null,
                _queue: null,

                push: function (target, method, args, stack) {
                    var queue = this._queue;
                    queue.push(target, method, args, stack);
                    return { queue: this, target: target, method: method };
                },

                pushUnique: function (target, method, args, stack) {
                    var queue = this._queue, currentTarget, currentMethod, i, l;

                    for (i = 0, l = queue.length; i < l; i += 4) {
                        currentTarget = queue[i];
                        currentMethod = queue[i + 1];

                        if (currentTarget === target && currentMethod === method) {
                            queue[i + 2] = args; // replace args
                            queue[i + 3] = stack; // replace stack
                            return { queue: this, target: target, method: method };
                        }
                    }

                    this._queue.push(target, method, args, stack);
                    return { queue: this, target: target, method: method };
                },

                // TODO: remove me, only being used for Ember.run.sync
                flush: function () {
                    var queue = this._queue,
                        options = this.options,
                        before = options && options.before,
                        after = options && options.after,
                        target, method, args, stack, i, l = queue.length;

                    if (l && before) { before(); }
                    for (i = 0; i < l; i += 4) {
                        target = queue[i];
                        method = queue[i + 1];
                        args = queue[i + 2];
                        stack = queue[i + 3]; // Debugging assistance

                        // TODO: error handling
                        if (args && args.length > 0) {
                            method.apply(target, args);
                        } else {
                            method.call(target);
                        }
                    }
                    if (l && after) { after(); }

                    // check if new items have been added
                    if (queue.length > l) {
                        this._queue = queue.slice(l);
                        this.flush();
                    } else {
                        this._queue.length = 0;
                    }
                },

                cancel: function (actionToCancel) {
                    var queue = this._queue, currentTarget, currentMethod, i, l;

                    for (i = 0, l = queue.length; i < l; i += 4) {
                        currentTarget = queue[i];
                        currentMethod = queue[i + 1];

                        if (currentTarget === actionToCancel.target && currentMethod === actionToCancel.method) {
                            queue.splice(i, 4);
                            return true;
                        }
                    }

                    // if not found in current queue
                    // could be in the queue that is being flushed
                    queue = this._queueBeingFlushed;
                    if (!queue) {
                        return;
                    }
                    for (i = 0, l = queue.length; i < l; i += 4) {
                        currentTarget = queue[i];
                        currentMethod = queue[i + 1];

                        if (currentTarget === actionToCancel.target && currentMethod === actionToCancel.method) {
                            // don't mess with array during flush
                            // just nullify the method
                            queue[i + 1] = null;
                            return true;
                        }
                    }
                }
            };

            __exports__.Queue = Queue;
        });

    define("backburner",
        ["backburner/deferred_action_queues", "exports"],
        function (__dependency1__, __exports__) {
            "use strict";
            var DeferredActionQueues = __dependency1__.DeferredActionQueues;

            var slice = [].slice,
                pop = [].pop,
                throttlers = [],
                debouncees = [],
                timers = [],
                autorun, laterTimer, laterTimerExpiresAt,
                global = this,
                NUMBER = /\d+/;

            function isCoercableNumber(number) {
                return typeof number === 'number' || NUMBER.test(number);
            }

            function Backburner(queueNames, options) {
                this.queueNames = queueNames;
                this.options = options || {};
                if (!this.options.defaultQueue) {
                    this.options.defaultQueue = queueNames[0];
                }
                this.instanceStack = [];
            }

            Backburner.prototype = {
                queueNames: null,
                options: null,
                currentInstance: null,
                instanceStack: null,

                begin: function () {
                    var onBegin = this.options && this.options.onBegin,
                        previousInstance = this.currentInstance;

                    if (previousInstance) {
                        this.instanceStack.push(previousInstance);
                    }

                    this.currentInstance = new DeferredActionQueues(this.queueNames, this.options);
                    if (onBegin) {
                        onBegin(this.currentInstance, previousInstance);
                    }
                },

                end: function () {
                    var onEnd = this.options && this.options.onEnd,
                        currentInstance = this.currentInstance,
                        nextInstance = null;

                    try {
                        currentInstance.flush();
                    } finally {
                        this.currentInstance = null;

                        if (this.instanceStack.length) {
                            nextInstance = this.instanceStack.pop();
                            this.currentInstance = nextInstance;
                        }

                        if (onEnd) {
                            onEnd(currentInstance, nextInstance);
                        }
                    }
                },

                run: function (target, method /*, args */) {
                    var ret;
                    this.begin();

                    if (!method) {
                        method = target;
                        target = null;
                    }

                    if (typeof method === 'string') {
                        method = target[method];
                    }

                    // Prevent Safari double-finally.
                    var finallyAlreadyCalled = false;
                    try {
                        if (arguments.length > 2) {
                            ret = method.apply(target, slice.call(arguments, 2));
                        } else {
                            ret = method.call(target);
                        }
                    } finally {
                        if (!finallyAlreadyCalled) {
                            finallyAlreadyCalled = true;
                            this.end();
                        }
                    }
                    return ret;
                },

                defer: function (queueName, target, method /* , args */) {
                    if (!method) {
                        method = target;
                        target = null;
                    }

                    if (typeof method === 'string') {
                        method = target[method];
                    }

                    var stack = this.DEBUG ? new Error() : undefined,
                        args = arguments.length > 3 ? slice.call(arguments, 3) : undefined;
                    if (!this.currentInstance) { createAutorun(this); }
                    return this.currentInstance.schedule(queueName, target, method, args, false, stack);
                },

                deferOnce: function (queueName, target, method /* , args */) {
                    if (!method) {
                        method = target;
                        target = null;
                    }

                    if (typeof method === 'string') {
                        method = target[method];
                    }

                    var stack = this.DEBUG ? new Error() : undefined,
                        args = arguments.length > 3 ? slice.call(arguments, 3) : undefined;
                    if (!this.currentInstance) { createAutorun(this); }
                    return this.currentInstance.schedule(queueName, target, method, args, true, stack);
                },

                setTimeout: function () {
                    var args = slice.call(arguments);
                    var length = args.length;
                    var method, wait, target;
                    var self = this;
                    var methodOrTarget, methodOrWait, methodOrArgs;

                    if (length === 0) {
                        return;
                    } else if (length === 1) {
                        method = args.shift();
                        wait = 0;
                    } else if (length === 2) {
                        methodOrTarget = args[0];
                        methodOrWait = args[1];

                        if (typeof methodOrWait === 'function' || typeof methodOrTarget[methodOrWait] === 'function') {
                            target = args.shift();
                            method = args.shift();
                            wait = 0;
                        } else if (isCoercableNumber(methodOrWait)) {
                            method = args.shift();
                            wait = args.shift();
                        } else {
                            method = args.shift();
                            wait = 0;
                        }
                    } else {
                        var last = args[args.length - 1];

                        if (isCoercableNumber(last)) {
                            wait = args.pop();
                        } else {
                            wait = 0;
                        }

                        methodOrTarget = args[0];
                        methodOrArgs = args[1];

                        if (typeof methodOrArgs === 'function' || (typeof methodOrArgs === 'string' &&
                            methodOrTarget !== null &&
                            methodOrArgs in methodOrTarget)) {
                            target = args.shift();
                            method = args.shift();
                        } else {
                            method = args.shift();
                        }
                    }

                    var executeAt = (+new Date()) + parseInt(wait, 10);

                    if (typeof method === 'string') {
                        method = target[method];
                    }

                    function fn() {
                        method.apply(target, args);
                    }

                    // find position to insert
                    var i = searchTimer(executeAt, timers, 0, timers.length - 2);

                    timers.splice(i, 0, executeAt, fn);

                    updateLaterTimer(self, executeAt, wait);

                    return fn;
                },

                throttle: function (target, method /* , args, wait, [immediate] */) {
                    var self = this,
                        args = arguments,
                        immediate = pop.call(args),
                        wait,
                        throttler,
                        index,
                        timer;

                    if (typeof immediate === "number" || typeof immediate === "string") {
                        wait = immediate;
                        immediate = true;
                    } else {
                        wait = pop.call(args);
                    }

                    wait = parseInt(wait, 10);

                    index = findThrottler(target, method);
                    if (index > -1) { return throttlers[index]; } // throttled

                    timer = global.setTimeout(function () {
                        if (!immediate) {
                            self.run.apply(self, args);
                        }
                        var index = findThrottler(target, method);
                        if (index > -1) { throttlers.splice(index, 1); }
                    }, wait);

                    if (immediate) {
                        self.run.apply(self, args);
                    }

                    throttler = [target, method, timer];

                    throttlers.push(throttler);

                    return throttler;
                },

                debounce: function (target, method /* , args, wait, [immediate] */) {
                    var self = this,
                        args = arguments,
                        immediate = pop.call(args),
                        wait,
                        index,
                        debouncee,
                        timer;

                    if (typeof immediate === "number" || typeof immediate === "string") {
                        wait = immediate;
                        immediate = false;
                    } else {
                        wait = pop.call(args);
                    }

                    wait = parseInt(wait, 10);
                    // Remove debouncee
                    index = findDebouncee(target, method);

                    if (index > -1) {
                        debouncee = debouncees[index];
                        debouncees.splice(index, 1);
                        clearTimeout(debouncee[2]);
                    }

                    timer = global.setTimeout(function () {
                        if (!immediate) {
                            self.run.apply(self, args);
                        }
                        var index = findDebouncee(target, method);
                        if (index > -1) {
                            debouncees.splice(index, 1);
                        }
                    }, wait);

                    if (immediate && index === -1) {
                        self.run.apply(self, args);
                    }

                    debouncee = [target, method, timer];

                    debouncees.push(debouncee);

                    return debouncee;
                },

                cancelTimers: function () {
                    var i, len;

                    for (i = 0, len = throttlers.length; i < len; i++) {
                        clearTimeout(throttlers[i][2]);
                    }
                    throttlers = [];

                    for (i = 0, len = debouncees.length; i < len; i++) {
                        clearTimeout(debouncees[i][2]);
                    }
                    debouncees = [];

                    if (laterTimer) {
                        clearTimeout(laterTimer);
                        laterTimer = null;
                    }
                    timers = [];

                    if (autorun) {
                        clearTimeout(autorun);
                        autorun = null;
                    }
                },

                hasTimers: function () {
                    return !!timers.length || autorun;
                },

                cancel: function (timer) {
                    var timerType = typeof timer;

                    if (timer && timerType === 'object' && timer.queue && timer.method) { // we're cancelling a deferOnce
                        return timer.queue.cancel(timer);
                    } else if (timerType === 'function') { // we're cancelling a setTimeout
                        for (var i = 0, l = timers.length; i < l; i += 2) {
                            if (timers[i + 1] === timer) {
                                timers.splice(i, 2); // remove the two elements
                                return true;
                            }
                        }
                    } else if (Object.prototype.toString.call(timer) === "[object Array]") { // we're cancelling a throttle or debounce
                        return this._cancelItem(findThrottler, throttlers, timer) ||
                            this._cancelItem(findDebouncee, debouncees, timer);
                    } else {
                        return; // timer was null or not a timer
                    }
                },

                _cancelItem: function (findMethod, array, timer) {
                    var item,
                        index;

                    if (timer.length < 3) { return false; }

                    index = findMethod(timer[0], timer[1]);

                    if (index > -1) {

                        item = array[index];

                        if (item[2] === timer[2]) {
                            array.splice(index, 1);
                            clearTimeout(timer[2]);
                            return true;
                        }
                    }

                    return false;
                }

            };

            Backburner.prototype.schedule = Backburner.prototype.defer;
            Backburner.prototype.scheduleOnce = Backburner.prototype.deferOnce;
            Backburner.prototype.later = Backburner.prototype.setTimeout;

            function createAutorun(backburner) {
                backburner.begin();
                autorun = global.setTimeout(function () {
                    autorun = null;
                    backburner.end();
                });
            }

            function updateLaterTimer(self, executeAt, wait) {
                if (!laterTimer || executeAt < laterTimerExpiresAt) {
                    if (laterTimer) {
                        clearTimeout(laterTimer);
                    }
                    laterTimer = global.setTimeout(function () {
                        laterTimer = null;
                        laterTimerExpiresAt = null;
                        executeTimers(self);
                    }, wait);
                    laterTimerExpiresAt = executeAt;
                }
            }

            function executeTimers(self) {
                var now = +new Date(),
                    time, fns, i, l;

                self.run(function () {
                    i = searchTimer(now, timers, 0, timers.length - 2);

                    fns = timers.splice(0, i);

                    for (i = 1, l = fns.length; i < l; i += 2) {
                        self.schedule(self.options.defaultQueue, null, fns[i]);
                    }
                });

                if (timers.length) {
                    updateLaterTimer(self, timers[0], timers[0] - now);
                }
            }

            function findDebouncee(target, method) {
                var debouncee,
                    index = -1;

                for (var i = 0, l = debouncees.length; i < l; i++) {
                    debouncee = debouncees[i];
                    if (debouncee[0] === target && debouncee[1] === method) {
                        index = i;
                        break;
                    }
                }

                return index;
            }

            function findThrottler(target, method) {
                var throttler,
                    index = -1;

                for (var i = 0, l = throttlers.length; i < l; i++) {
                    throttler = throttlers[i];
                    if (throttler[0] === target && throttler[1] === method) {
                        index = i;
                        break;
                    }
                }

                return index;
            }

            function searchTimer(time, timers, start, end) {
                var middle;

                while (start < end) {
                    middle = start + Math.floor((end - start) / 4);
                    if (time >= timers[middle]) {
                        start = middle + 2;
                    } else {
                        end = middle;
                    }
                }

                if (timers[start] !== undefined && time > timers[start]) {
                    return start + 2;
                } else {
                    return start;
                }
            }

            __exports__.Backburner = Backburner;
        });
    window.backburner = requireModule("backburner");
})(window);
;
//     Underscore.js 1.8.3
//     http://underscorejs.org
//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.
(function () { function n(n) { function t(t, r, e, u, i, o) { for (; i >= 0 && o > i; i += n) { var a = u ? u[i] : i; e = r(e, t[a], a, t) } return e } return function (r, e, u, i) { e = b(e, i, 4); var o = !k(r) && m.keys(r), a = (o || r).length, c = n > 0 ? 0 : a - 1; return arguments.length < 3 && (u = r[o ? o[c] : c], c += n), t(r, e, u, o, c, a) } } function t(n) { return function (t, r, e) { r = x(r, e); for (var u = O(t), i = n > 0 ? 0 : u - 1; i >= 0 && u > i; i += n)if (r(t[i], i, t)) return i; return -1 } } function r(n, t, r) { return function (e, u, i) { var o = 0, a = O(e); if ("number" == typeof i) n > 0 ? o = i >= 0 ? i : Math.max(i + a, o) : a = i >= 0 ? Math.min(i + 1, a) : i + a + 1; else if (r && i && a) return i = r(e, u), e[i] === u ? i : -1; if (u !== u) return i = t(l.call(e, o, a), m.isNaN), i >= 0 ? i + o : -1; for (i = n > 0 ? o : a - 1; i >= 0 && a > i; i += n)if (e[i] === u) return i; return -1 } } function e(n, t) { var r = I.length, e = n.constructor, u = m.isFunction(e) && e.prototype || a, i = "constructor"; for (m.has(n, i) && !m.contains(t, i) && t.push(i); r--;)i = I[r], i in n && n[i] !== u[i] && !m.contains(t, i) && t.push(i) } var u = this, i = u._, o = Array.prototype, a = Object.prototype, c = Function.prototype, f = o.push, l = o.slice, s = a.toString, p = a.hasOwnProperty, h = Array.isArray, v = Object.keys, g = c.bind, y = Object.create, d = function () { }, m = function (n) { return n instanceof m ? n : this instanceof m ? void (this._wrapped = n) : new m(n) }; "undefined" != typeof exports ? ("undefined" != typeof module && module.exports && (exports = module.exports = m), exports._ = m) : u._ = m, m.VERSION = "1.8.3"; var b = function (n, t, r) { if (t === void 0) return n; switch (null == r ? 3 : r) { case 1: return function (r) { return n.call(t, r) }; case 2: return function (r, e) { return n.call(t, r, e) }; case 3: return function (r, e, u) { return n.call(t, r, e, u) }; case 4: return function (r, e, u, i) { return n.call(t, r, e, u, i) } }return function () { return n.apply(t, arguments) } }, x = function (n, t, r) { return null == n ? m.identity : m.isFunction(n) ? b(n, t, r) : m.isObject(n) ? m.matcher(n) : m.property(n) }; m.iteratee = function (n, t) { return x(n, t, 1 / 0) }; var _ = function (n, t) { return function (r) { var e = arguments.length; if (2 > e || null == r) return r; for (var u = 1; e > u; u++)for (var i = arguments[u], o = n(i), a = o.length, c = 0; a > c; c++) { var f = o[c]; t && r[f] !== void 0 || (r[f] = i[f]) } return r } }, j = function (n) { if (!m.isObject(n)) return {}; if (y) return y(n); d.prototype = n; var t = new d; return d.prototype = null, t }, w = function (n) { return function (t) { return null == t ? void 0 : t[n] } }, A = Math.pow(2, 53) - 1, O = w("length"), k = function (n) { var t = O(n); return "number" == typeof t && t >= 0 && A >= t }; m.each = m.forEach = function (n, t, r) { t = b(t, r); var e, u; if (k(n)) for (e = 0, u = n.length; u > e; e++)t(n[e], e, n); else { var i = m.keys(n); for (e = 0, u = i.length; u > e; e++)t(n[i[e]], i[e], n) } return n }, m.map = m.collect = function (n, t, r) { t = x(t, r); for (var e = !k(n) && m.keys(n), u = (e || n).length, i = Array(u), o = 0; u > o; o++) { var a = e ? e[o] : o; i[o] = t(n[a], a, n) } return i }, m.reduce = m.foldl = m.inject = n(1), m.reduceRight = m.foldr = n(-1), m.find = m.detect = function (n, t, r) { var e; return e = k(n) ? m.findIndex(n, t, r) : m.findKey(n, t, r), e !== void 0 && e !== -1 ? n[e] : void 0 }, m.filter = m.select = function (n, t, r) { var e = []; return t = x(t, r), m.each(n, function (n, r, u) { t(n, r, u) && e.push(n) }), e }, m.reject = function (n, t, r) { return m.filter(n, m.negate(x(t)), r) }, m.every = m.all = function (n, t, r) { t = x(t, r); for (var e = !k(n) && m.keys(n), u = (e || n).length, i = 0; u > i; i++) { var o = e ? e[i] : i; if (!t(n[o], o, n)) return !1 } return !0 }, m.some = m.any = function (n, t, r) { t = x(t, r); for (var e = !k(n) && m.keys(n), u = (e || n).length, i = 0; u > i; i++) { var o = e ? e[i] : i; if (t(n[o], o, n)) return !0 } return !1 }, m.contains = m.includes = m.include = function (n, t, r, e) { return k(n) || (n = m.values(n)), ("number" != typeof r || e) && (r = 0), m.indexOf(n, t, r) >= 0 }, m.invoke = function (n, t) { var r = l.call(arguments, 2), e = m.isFunction(t); return m.map(n, function (n) { var u = e ? t : n[t]; return null == u ? u : u.apply(n, r) }) }, m.pluck = function (n, t) { return m.map(n, m.property(t)) }, m.where = function (n, t) { return m.filter(n, m.matcher(t)) }, m.findWhere = function (n, t) { return m.find(n, m.matcher(t)) }, m.max = function (n, t, r) { var e, u, i = -1 / 0, o = -1 / 0; if (null == t && null != n) { n = k(n) ? n : m.values(n); for (var a = 0, c = n.length; c > a; a++)e = n[a], e > i && (i = e) } else t = x(t, r), m.each(n, function (n, r, e) { u = t(n, r, e), (u > o || u === -1 / 0 && i === -1 / 0) && (i = n, o = u) }); return i }, m.min = function (n, t, r) { var e, u, i = 1 / 0, o = 1 / 0; if (null == t && null != n) { n = k(n) ? n : m.values(n); for (var a = 0, c = n.length; c > a; a++)e = n[a], i > e && (i = e) } else t = x(t, r), m.each(n, function (n, r, e) { u = t(n, r, e), (o > u || 1 / 0 === u && 1 / 0 === i) && (i = n, o = u) }); return i }, m.shuffle = function (n) { for (var t, r = k(n) ? n : m.values(n), e = r.length, u = Array(e), i = 0; e > i; i++)t = m.random(0, i), t !== i && (u[i] = u[t]), u[t] = r[i]; return u }, m.sample = function (n, t, r) { return null == t || r ? (k(n) || (n = m.values(n)), n[m.random(n.length - 1)]) : m.shuffle(n).slice(0, Math.max(0, t)) }, m.sortBy = function (n, t, r) { return t = x(t, r), m.pluck(m.map(n, function (n, r, e) { return { value: n, index: r, criteria: t(n, r, e) } }).sort(function (n, t) { var r = n.criteria, e = t.criteria; if (r !== e) { if (r > e || r === void 0) return 1; if (e > r || e === void 0) return -1 } return n.index - t.index }), "value") }; var F = function (n) { return function (t, r, e) { var u = {}; return r = x(r, e), m.each(t, function (e, i) { var o = r(e, i, t); n(u, e, o) }), u } }; m.groupBy = F(function (n, t, r) { m.has(n, r) ? n[r].push(t) : n[r] = [t] }), m.indexBy = F(function (n, t, r) { n[r] = t }), m.countBy = F(function (n, t, r) { m.has(n, r) ? n[r]++ : n[r] = 1 }), m.toArray = function (n) { return n ? m.isArray(n) ? l.call(n) : k(n) ? m.map(n, m.identity) : m.values(n) : [] }, m.size = function (n) { return null == n ? 0 : k(n) ? n.length : m.keys(n).length }, m.partition = function (n, t, r) { t = x(t, r); var e = [], u = []; return m.each(n, function (n, r, i) { (t(n, r, i) ? e : u).push(n) }), [e, u] }, m.first = m.head = m.take = function (n, t, r) { return null == n ? void 0 : null == t || r ? n[0] : m.initial(n, n.length - t) }, m.initial = function (n, t, r) { return l.call(n, 0, Math.max(0, n.length - (null == t || r ? 1 : t))) }, m.last = function (n, t, r) { return null == n ? void 0 : null == t || r ? n[n.length - 1] : m.rest(n, Math.max(0, n.length - t)) }, m.rest = m.tail = m.drop = function (n, t, r) { return l.call(n, null == t || r ? 1 : t) }, m.compact = function (n) { return m.filter(n, m.identity) }; var S = function (n, t, r, e) { for (var u = [], i = 0, o = e || 0, a = O(n); a > o; o++) { var c = n[o]; if (k(c) && (m.isArray(c) || m.isArguments(c))) { t || (c = S(c, t, r)); var f = 0, l = c.length; for (u.length += l; l > f;)u[i++] = c[f++] } else r || (u[i++] = c) } return u }; m.flatten = function (n, t) { return S(n, t, !1) }, m.without = function (n) { return m.difference(n, l.call(arguments, 1)) }, m.uniq = m.unique = function (n, t, r, e) { m.isBoolean(t) || (e = r, r = t, t = !1), null != r && (r = x(r, e)); for (var u = [], i = [], o = 0, a = O(n); a > o; o++) { var c = n[o], f = r ? r(c, o, n) : c; t ? (o && i === f || u.push(c), i = f) : r ? m.contains(i, f) || (i.push(f), u.push(c)) : m.contains(u, c) || u.push(c) } return u }, m.union = function () { return m.uniq(S(arguments, !0, !0)) }, m.intersection = function (n) { for (var t = [], r = arguments.length, e = 0, u = O(n); u > e; e++) { var i = n[e]; if (!m.contains(t, i)) { for (var o = 1; r > o && m.contains(arguments[o], i); o++); o === r && t.push(i) } } return t }, m.difference = function (n) { var t = S(arguments, !0, !0, 1); return m.filter(n, function (n) { return !m.contains(t, n) }) }, m.zip = function () { return m.unzip(arguments) }, m.unzip = function (n) { for (var t = n && m.max(n, O).length || 0, r = Array(t), e = 0; t > e; e++)r[e] = m.pluck(n, e); return r }, m.object = function (n, t) { for (var r = {}, e = 0, u = O(n); u > e; e++)t ? r[n[e]] = t[e] : r[n[e][0]] = n[e][1]; return r }, m.findIndex = t(1), m.findLastIndex = t(-1), m.sortedIndex = function (n, t, r, e) { r = x(r, e, 1); for (var u = r(t), i = 0, o = O(n); o > i;) { var a = Math.floor((i + o) / 2); r(n[a]) < u ? i = a + 1 : o = a } return i }, m.indexOf = r(1, m.findIndex, m.sortedIndex), m.lastIndexOf = r(-1, m.findLastIndex), m.range = function (n, t, r) { null == t && (t = n || 0, n = 0), r = r || 1; for (var e = Math.max(Math.ceil((t - n) / r), 0), u = Array(e), i = 0; e > i; i++ , n += r)u[i] = n; return u }; var E = function (n, t, r, e, u) { if (!(e instanceof t)) return n.apply(r, u); var i = j(n.prototype), o = n.apply(i, u); return m.isObject(o) ? o : i }; m.bind = function (n, t) { if (g && n.bind === g) return g.apply(n, l.call(arguments, 1)); if (!m.isFunction(n)) throw new TypeError("Bind must be called on a function"); var r = l.call(arguments, 2), e = function () { return E(n, e, t, this, r.concat(l.call(arguments))) }; return e }, m.partial = function (n) { var t = l.call(arguments, 1), r = function () { for (var e = 0, u = t.length, i = Array(u), o = 0; u > o; o++)i[o] = t[o] === m ? arguments[e++] : t[o]; for (; e < arguments.length;)i.push(arguments[e++]); return E(n, r, this, this, i) }; return r }, m.bindAll = function (n) { var t, r, e = arguments.length; if (1 >= e) throw new Error("bindAll must be passed function names"); for (t = 1; e > t; t++)r = arguments[t], n[r] = m.bind(n[r], n); return n }, m.memoize = function (n, t) { var r = function (e) { var u = r.cache, i = "" + (t ? t.apply(this, arguments) : e); return m.has(u, i) || (u[i] = n.apply(this, arguments)), u[i] }; return r.cache = {}, r }, m.delay = function (n, t) { var r = l.call(arguments, 2); return setTimeout(function () { return n.apply(null, r) }, t) }, m.defer = m.partial(m.delay, m, 1), m.throttle = function (n, t, r) { var e, u, i, o = null, a = 0; r || (r = {}); var c = function () { a = r.leading === !1 ? 0 : m.now(), o = null, i = n.apply(e, u), o || (e = u = null) }; return function () { var f = m.now(); a || r.leading !== !1 || (a = f); var l = t - (f - a); return e = this, u = arguments, 0 >= l || l > t ? (o && (clearTimeout(o), o = null), a = f, i = n.apply(e, u), o || (e = u = null)) : o || r.trailing === !1 || (o = setTimeout(c, l)), i } }, m.debounce = function (n, t, r) { var e, u, i, o, a, c = function () { var f = m.now() - o; t > f && f >= 0 ? e = setTimeout(c, t - f) : (e = null, r || (a = n.apply(i, u), e || (i = u = null))) }; return function () { i = this, u = arguments, o = m.now(); var f = r && !e; return e || (e = setTimeout(c, t)), f && (a = n.apply(i, u), i = u = null), a } }, m.wrap = function (n, t) { return m.partial(t, n) }, m.negate = function (n) { return function () { return !n.apply(this, arguments) } }, m.compose = function () { var n = arguments, t = n.length - 1; return function () { for (var r = t, e = n[t].apply(this, arguments); r--;)e = n[r].call(this, e); return e } }, m.after = function (n, t) { return function () { return --n < 1 ? t.apply(this, arguments) : void 0 } }, m.before = function (n, t) { var r; return function () { return --n > 0 && (r = t.apply(this, arguments)), 1 >= n && (t = null), r } }, m.once = m.partial(m.before, 2); var M = !{ toString: null }.propertyIsEnumerable("toString"), I = ["valueOf", "isPrototypeOf", "toString", "propertyIsEnumerable", "hasOwnProperty", "toLocaleString"]; m.keys = function (n) { if (!m.isObject(n)) return []; if (v) return v(n); var t = []; for (var r in n) m.has(n, r) && t.push(r); return M && e(n, t), t }, m.allKeys = function (n) { if (!m.isObject(n)) return []; var t = []; for (var r in n) t.push(r); return M && e(n, t), t }, m.values = function (n) { for (var t = m.keys(n), r = t.length, e = Array(r), u = 0; r > u; u++)e[u] = n[t[u]]; return e }, m.mapObject = function (n, t, r) { t = x(t, r); for (var e, u = m.keys(n), i = u.length, o = {}, a = 0; i > a; a++)e = u[a], o[e] = t(n[e], e, n); return o }, m.pairs = function (n) { for (var t = m.keys(n), r = t.length, e = Array(r), u = 0; r > u; u++)e[u] = [t[u], n[t[u]]]; return e }, m.invert = function (n) { for (var t = {}, r = m.keys(n), e = 0, u = r.length; u > e; e++)t[n[r[e]]] = r[e]; return t }, m.functions = m.methods = function (n) { var t = []; for (var r in n) m.isFunction(n[r]) && t.push(r); return t.sort() }, m.extend = _(m.allKeys), m.extendOwn = m.assign = _(m.keys), m.findKey = function (n, t, r) { t = x(t, r); for (var e, u = m.keys(n), i = 0, o = u.length; o > i; i++)if (e = u[i], t(n[e], e, n)) return e }, m.pick = function (n, t, r) { var e, u, i = {}, o = n; if (null == o) return i; m.isFunction(t) ? (u = m.allKeys(o), e = b(t, r)) : (u = S(arguments, !1, !1, 1), e = function (n, t, r) { return t in r }, o = Object(o)); for (var a = 0, c = u.length; c > a; a++) { var f = u[a], l = o[f]; e(l, f, o) && (i[f] = l) } return i }, m.omit = function (n, t, r) { if (m.isFunction(t)) t = m.negate(t); else { var e = m.map(S(arguments, !1, !1, 1), String); t = function (n, t) { return !m.contains(e, t) } } return m.pick(n, t, r) }, m.defaults = _(m.allKeys, !0), m.create = function (n, t) { var r = j(n); return t && m.extendOwn(r, t), r }, m.clone = function (n) { return m.isObject(n) ? m.isArray(n) ? n.slice() : m.extend({}, n) : n }, m.tap = function (n, t) { return t(n), n }, m.isMatch = function (n, t) { var r = m.keys(t), e = r.length; if (null == n) return !e; for (var u = Object(n), i = 0; e > i; i++) { var o = r[i]; if (t[o] !== u[o] || !(o in u)) return !1 } return !0 }; var N = function (n, t, r, e) { if (n === t) return 0 !== n || 1 / n === 1 / t; if (null == n || null == t) return n === t; n instanceof m && (n = n._wrapped), t instanceof m && (t = t._wrapped); var u = s.call(n); if (u !== s.call(t)) return !1; switch (u) { case "[object RegExp]": case "[object String]": return "" + n == "" + t; case "[object Number]": return +n !== +n ? +t !== +t : 0 === +n ? 1 / +n === 1 / t : +n === +t; case "[object Date]": case "[object Boolean]": return +n === +t }var i = "[object Array]" === u; if (!i) { if ("object" != typeof n || "object" != typeof t) return !1; var o = n.constructor, a = t.constructor; if (o !== a && !(m.isFunction(o) && o instanceof o && m.isFunction(a) && a instanceof a) && "constructor" in n && "constructor" in t) return !1 } r = r || [], e = e || []; for (var c = r.length; c--;)if (r[c] === n) return e[c] === t; if (r.push(n), e.push(t), i) { if (c = n.length, c !== t.length) return !1; for (; c--;)if (!N(n[c], t[c], r, e)) return !1 } else { var f, l = m.keys(n); if (c = l.length, m.keys(t).length !== c) return !1; for (; c--;)if (f = l[c], !m.has(t, f) || !N(n[f], t[f], r, e)) return !1 } return r.pop(), e.pop(), !0 }; m.isEqual = function (n, t) { return N(n, t) }, m.isEmpty = function (n) { return null == n ? !0 : k(n) && (m.isArray(n) || m.isString(n) || m.isArguments(n)) ? 0 === n.length : 0 === m.keys(n).length }, m.isElement = function (n) { return !(!n || 1 !== n.nodeType) }, m.isArray = h || function (n) { return "[object Array]" === s.call(n) }, m.isObject = function (n) { var t = typeof n; return "function" === t || "object" === t && !!n }, m.each(["Arguments", "Function", "String", "Number", "Date", "RegExp", "Error"], function (n) { m["is" + n] = function (t) { return s.call(t) === "[object " + n + "]" } }), m.isArguments(arguments) || (m.isArguments = function (n) { return m.has(n, "callee") }), "function" != typeof /./ && "object" != typeof Int8Array && (m.isFunction = function (n) { return "function" == typeof n || !1 }), m.isFinite = function (n) { return isFinite(n) && !isNaN(parseFloat(n)) }, m.isNaN = function (n) { return m.isNumber(n) && n !== +n }, m.isBoolean = function (n) { return n === !0 || n === !1 || "[object Boolean]" === s.call(n) }, m.isNull = function (n) { return null === n }, m.isUndefined = function (n) { return n === void 0 }, m.has = function (n, t) { return null != n && p.call(n, t) }, m.noConflict = function () { return u._ = i, this }, m.identity = function (n) { return n }, m.constant = function (n) { return function () { return n } }, m.noop = function () { }, m.property = w, m.propertyOf = function (n) { return null == n ? function () { } : function (t) { return n[t] } }, m.matcher = m.matches = function (n) { return n = m.extendOwn({}, n), function (t) { return m.isMatch(t, n) } }, m.times = function (n, t, r) { var e = Array(Math.max(0, n)); t = b(t, r, 1); for (var u = 0; n > u; u++)e[u] = t(u); return e }, m.random = function (n, t) { return null == t && (t = n, n = 0), n + Math.floor(Math.random() * (t - n + 1)) }, m.now = Date.now || function () { return (new Date).getTime() }; var B = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#x27;", "`": "&#x60;" }, T = m.invert(B), R = function (n) { var t = function (t) { return n[t] }, r = "(?:" + m.keys(n).join("|") + ")", e = RegExp(r), u = RegExp(r, "g"); return function (n) { return n = null == n ? "" : "" + n, e.test(n) ? n.replace(u, t) : n } }; m.escape = R(B), m.unescape = R(T), m.result = function (n, t, r) { var e = null == n ? void 0 : n[t]; return e === void 0 && (e = r), m.isFunction(e) ? e.call(n) : e }; var q = 0; m.uniqueId = function (n) { var t = ++q + ""; return n ? n + t : t }, m.templateSettings = { evaluate: /<%([\s\S]+?)%>/g, interpolate: /<%=([\s\S]+?)%>/g, escape: /<%-([\s\S]+?)%>/g }; var K = /(.)^/, z = { "'": "'", "\\": "\\", "\r": "r", "\n": "n", "\u2028": "u2028", "\u2029": "u2029" }, D = /\\|'|\r|\n|\u2028|\u2029/g, L = function (n) { return "\\" + z[n] }; m.template = function (n, t, r) { !t && r && (t = r), t = m.defaults({}, t, m.templateSettings); var e = RegExp([(t.escape || K).source, (t.interpolate || K).source, (t.evaluate || K).source].join("|") + "|$", "g"), u = 0, i = "__p+='"; n.replace(e, function (t, r, e, o, a) { return i += n.slice(u, a).replace(D, L), u = a + t.length, r ? i += "'+\n((__t=(" + r + "))==null?'':_.escape(__t))+\n'" : e ? i += "'+\n((__t=(" + e + "))==null?'':__t)+\n'" : o && (i += "';\n" + o + "\n__p+='"), t }), i += "';\n", t.variable || (i = "with(obj||{}){\n" + i + "}\n"), i = "var __t,__p='',__j=Array.prototype.join," + "print=function(){__p+=__j.call(arguments,'');};\n" + i + "return __p;\n"; try { var o = new Function(t.variable || "obj", "_", i) } catch (a) { throw a.source = i, a } var c = function (n) { return o.call(this, n, m) }, f = t.variable || "obj"; return c.source = "function(" + f + "){\n" + i + "}", c }, m.chain = function (n) { var t = m(n); return t._chain = !0, t }; var P = function (n, t) { return n._chain ? m(t).chain() : t }; m.mixin = function (n) { m.each(m.functions(n), function (t) { var r = m[t] = n[t]; m.prototype[t] = function () { var n = [this._wrapped]; return f.apply(n, arguments), P(this, r.apply(m, n)) } }) }, m.mixin(m), m.each(["pop", "push", "reverse", "shift", "sort", "splice", "unshift"], function (n) { var t = o[n]; m.prototype[n] = function () { var r = this._wrapped; return t.apply(r, arguments), "shift" !== n && "splice" !== n || 0 !== r.length || delete r[0], P(this, r) } }), m.each(["concat", "join", "slice"], function (n) { var t = o[n]; m.prototype[n] = function () { return P(this, t.apply(this._wrapped, arguments)) } }), m.prototype.value = function () { return this._wrapped }, m.prototype.valueOf = m.prototype.toJSON = m.prototype.value, m.prototype.toString = function () { return "" + this._wrapped }, "function" == typeof define && define.amd && define("underscore", [], function () { return m }) }).call(this);
//# sourceMappingURL=underscore-min.map;
//     Backbone.js 1.2.1

//     (c) 2010-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Backbone may be freely distributed under the MIT license.
//     For all details and documentation:
//     http://backbonejs.org

(function (factory) {

    // Establish the root object, `window` (`self`) in the browser, or `global` on the server.
    // We use `self` instead of `window` for `WebWorker` support.
    var root = (typeof self == 'object' && self.self == self && self) ||
        (typeof global == 'object' && global.global == global && global);

    // Set up Backbone appropriately for the environment. Start with AMD.
    if (typeof define === 'function' && define.amd) {
        define(['underscore', 'jquery', 'exports'], function (_, $, exports) {
            // Export global even in AMD case in case this script is loaded with
            // others that may still expect a global Backbone.
            root.Backbone = factory(root, exports, _, $);
        });

        // Next for Node.js or CommonJS. jQuery may not be needed as a module.
    } else if (typeof exports !== 'undefined') {
        var _ = require('underscore'), $;
        try { $ = require('jquery'); } catch (e) { }
        factory(root, exports, _, $);

        // Finally, as a browser global.
    } else {
        root.Backbone = factory(root, {}, root._, (root.jQuery || root.Zepto || root.ender || root.$));
    }

}(function (root, Backbone, _, $) {

    // Initial Setup
    // -------------

    // Save the previous value of the `Backbone` variable, so that it can be
    // restored later on, if `noConflict` is used.
    var previousBackbone = root.Backbone;

    // Create a local reference to a common array method we'll want to use later.
    var slice = [].slice;

    // Current version of the library. Keep in sync with `package.json`.
    Backbone.VERSION = '1.2.1';

    // For Backbone's purposes, jQuery, Zepto, Ender, or My Library (kidding) owns
    // the `$` variable.
    Backbone.$ = $;

    // Runs Backbone.js in *noConflict* mode, returning the `Backbone` variable
    // to its previous owner. Returns a reference to this Backbone object.
    Backbone.noConflict = function () {
        root.Backbone = previousBackbone;
        return this;
    };

    // Turn on `emulateHTTP` to support legacy HTTP servers. Setting this option
    // will fake `"PATCH"`, `"PUT"` and `"DELETE"` requests via the `_method` parameter and
    // set a `X-Http-Method-Override` header.
    Backbone.emulateHTTP = false;

    // Turn on `emulateJSON` to support legacy servers that can't deal with direct
    // `application/json` requests ... this will encode the body as
    // `application/x-www-form-urlencoded` instead and will send the model in a
    // form param named `model`.
    Backbone.emulateJSON = false;

    // Proxy Underscore methods to a Backbone class' prototype using a
    // particular attribute as the data argument
    var addMethod = function (length, method, attribute) {
        switch (length) {
            case 1: return function () {
                return _[method](this[attribute]);
            };
            case 2: return function (value) {
                return _[method](this[attribute], value);
            };
            case 3: return function (iteratee, context) {
                return _[method](this[attribute], iteratee, context);
            };
            case 4: return function (iteratee, defaultVal, context) {
                return _[method](this[attribute], iteratee, defaultVal, context);
            };
            default: return function () {
                var args = slice.call(arguments);
                args.unshift(this[attribute]);
                return _[method].apply(_, args);
            };
        }
    };
    var addUnderscoreMethods = function (Class, methods, attribute) {
        _.each(methods, function (length, method) {
            if (_[method]) Class.prototype[method] = addMethod(length, method, attribute);
        });
    };

    // Backbone.Events
    // ---------------

    // A module that can be mixed in to *any object* in order to provide it with
    // custom events. You may bind with `on` or remove with `off` callback
    // functions to an event; `trigger`-ing an event fires all callbacks in
    // succession.
    //
    //     var object = {};
    //     _.extend(object, Backbone.Events);
    //     object.on('expand', function(){ alert('expanded'); });
    //     object.trigger('expand');
    //
    var Events = Backbone.Events = {};

    // Regular expression used to split event strings.
    var eventSplitter = /\s+/;

    // Iterates over the standard `event, callback` (as well as the fancy multiple
    // space-separated events `"change blur", callback` and jQuery-style event
    // maps `{event: callback}`), reducing them by manipulating `memo`.
    // Passes a normalized single event name and callback, as well as any
    // optional `opts`.
    var eventsApi = function (iteratee, memo, name, callback, opts) {
        var i = 0, names;
        if (name && typeof name === 'object') {
            // Handle event maps.
            if (callback !== void 0 && 'context' in opts && opts.context === void 0) opts.context = callback;
            for (names = _.keys(name); i < names.length; i++) {
                memo = iteratee(memo, names[i], name[names[i]], opts);
            }
        } else if (name && eventSplitter.test(name)) {
            // Handle space separated event names.
            for (names = name.split(eventSplitter); i < names.length; i++) {
                memo = iteratee(memo, names[i], callback, opts);
            }
        } else {
            memo = iteratee(memo, name, callback, opts);
        }
        return memo;
    };

    // Bind an event to a `callback` function. Passing `"all"` will bind
    // the callback to all events fired.
    Events.on = function (name, callback, context) {
        return internalOn(this, name, callback, context);
    };

    // An internal use `on` function, used to guard the `listening` argument from
    // the public API.
    var internalOn = function (obj, name, callback, context, listening) {
        obj._events = eventsApi(onApi, obj._events || {}, name, callback, {
            context: context,
            ctx: obj,
            listening: listening
        });

        if (listening) {
            var listeners = obj._listeners || (obj._listeners = {});
            listeners[listening.id] = listening;
        }

        return obj;
    };

    // Inversion-of-control versions of `on`. Tell *this* object to listen to
    // an event in another object... keeping track of what it's listening to.
    Events.listenTo = function (obj, name, callback) {
        if (!obj) return this;
        var id = obj._listenId || (obj._listenId = _.uniqueId('l'));
        var listeningTo = this._listeningTo || (this._listeningTo = {});
        var listening = listeningTo[id];

        // This object is not listening to any other events on `obj` yet.
        // Setup the necessary references to track the listening callbacks.
        if (!listening) {
            var thisId = this._listenId || (this._listenId = _.uniqueId('l'));
            listening = listeningTo[id] = { obj: obj, objId: id, id: thisId, listeningTo: listeningTo, count: 0 };
        }

        // Bind callbacks on obj, and keep track of them on listening.
        internalOn(obj, name, callback, this, listening);
        return this;
    };

    // The reducing API that adds a callback to the `events` object.
    var onApi = function (events, name, callback, options) {
        if (callback) {
            var handlers = events[name] || (events[name] = []);
            var context = options.context, ctx = options.ctx, listening = options.listening;
            if (listening) listening.count++;

            handlers.push({ callback: callback, context: context, ctx: context || ctx, listening: listening });
        }
        return events;
    };

    // Remove one or many callbacks. If `context` is null, removes all
    // callbacks with that function. If `callback` is null, removes all
    // callbacks for the event. If `name` is null, removes all bound
    // callbacks for all events.
    Events.off = function (name, callback, context) {
        if (!this._events) return this;
        this._events = eventsApi(offApi, this._events, name, callback, {
            context: context,
            listeners: this._listeners
        });
        return this;
    };

    // Tell this object to stop listening to either specific events ... or
    // to every object it's currently listening to.
    Events.stopListening = function (obj, name, callback) {
        var listeningTo = this._listeningTo;
        if (!listeningTo) return this;

        var ids = obj ? [obj._listenId] : _.keys(listeningTo);

        for (var i = 0; i < ids.length; i++) {
            var listening = listeningTo[ids[i]];

            // If listening doesn't exist, this object is not currently
            // listening to obj. Break out early.
            if (!listening) break;

            listening.obj.off(name, callback, this);
        }
        if (_.isEmpty(listeningTo)) this._listeningTo = void 0;

        return this;
    };

    // The reducing API that removes a callback from the `events` object.
    var offApi = function (events, name, callback, options) {
        // No events to consider.
        if (!events) return;

        var i = 0, listening;
        var context = options.context, listeners = options.listeners;

        // Delete all events listeners and "drop" events.
        if (!name && !callback && !context) {
            var ids = _.keys(listeners);
            for (; i < ids.length; i++) {
                listening = listeners[ids[i]];
                delete listeners[listening.id];
                delete listening.listeningTo[listening.objId];
            }
            return;
        }

        var names = name ? [name] : _.keys(events);
        for (; i < names.length; i++) {
            name = names[i];
            var handlers = events[name];

            // Bail out if there are no events stored.
            if (!handlers) break;

            // Replace events if there are any remaining.  Otherwise, clean up.
            var remaining = [];
            for (var j = 0; j < handlers.length; j++) {
                var handler = handlers[j];
                if (
                    callback && callback !== handler.callback &&
                    callback !== handler.callback._callback ||
                    context && context !== handler.context
                ) {
                    remaining.push(handler);
                } else {
                    listening = handler.listening;
                    if (listening && --listening.count === 0) {
                        delete listeners[listening.id];
                        delete listening.listeningTo[listening.objId];
                    }
                }
            }

            // Update tail event if the list has any events.  Otherwise, clean up.
            if (remaining.length) {
                events[name] = remaining;
            } else {
                delete events[name];
            }
        }
        if (_.size(events)) return events;
    };

    // Bind an event to only be triggered a single time. After the first time
    // the callback is invoked, it will be removed. When multiple events are
    // passed in using the space-separated syntax, the event will fire once for every
    // event you passed in, not once for a combination of all events
    Events.once = function (name, callback, context) {
        // Map the event into a `{event: once}` object.
        var events = eventsApi(onceMap, {}, name, callback, _.bind(this.off, this));
        return this.on(events, void 0, context);
    };

    // Inversion-of-control versions of `once`.
    Events.listenToOnce = function (obj, name, callback) {
        // Map the event into a `{event: once}` object.
        var events = eventsApi(onceMap, {}, name, callback, _.bind(this.stopListening, this, obj));
        return this.listenTo(obj, events);
    };

    // Reduces the event callbacks into a map of `{event: onceWrapper}`.
    // `offer` unbinds the `onceWrapper` after it has been called.
    var onceMap = function (map, name, callback, offer) {
        if (callback) {
            var once = map[name] = _.once(function () {
                offer(name, once);
                callback.apply(this, arguments);
            });
            once._callback = callback;
        }
        return map;
    };

    // Trigger one or many events, firing all bound callbacks. Callbacks are
    // passed the same arguments as `trigger` is, apart from the event name
    // (unless you're listening on `"all"`, which will cause your callback to
    // receive the true name of the event as the first argument).
    Events.trigger = function (name) {
        if (!this._events) return this;

        var length = Math.max(0, arguments.length - 1);
        var args = Array(length);
        for (var i = 0; i < length; i++) args[i] = arguments[i + 1];

        eventsApi(triggerApi, this._events, name, void 0, args);
        return this;
    };

    // Handles triggering the appropriate event callbacks.
    var triggerApi = function (objEvents, name, cb, args) {
        if (objEvents) {
            var events = objEvents[name];
            var allEvents = objEvents.all;
            if (events && allEvents) allEvents = allEvents.slice();
            if (events) triggerEvents(events, args);
            if (allEvents) triggerEvents(allEvents, [name].concat(args));
        }
        return objEvents;
    };

    // A difficult-to-believe, but optimized internal dispatch function for
    // triggering events. Tries to keep the usual cases speedy (most internal
    // Backbone events have 3 arguments).
    var triggerEvents = function (events, args) {
        var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];
        switch (args.length) {
            case 0: while (++i < l) (ev = events[i]).callback.call(ev.ctx); return;
            case 1: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1); return;
            case 2: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return;
            case 3: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;
            default: while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args); return;
        }
    };

    // Aliases for backwards compatibility.
    Events.bind = Events.on;
    Events.unbind = Events.off;

    // Allow the `Backbone` object to serve as a global event bus, for folks who
    // want global "pubsub" in a convenient place.
    _.extend(Backbone, Events);

    // Backbone.Model
    // --------------

    // Backbone **Models** are the basic data object in the framework --
    // frequently representing a row in a table in a database on your server.
    // A discrete chunk of data and a bunch of useful, related methods for
    // performing computations and transformations on that data.

    // Create a new model with the specified attributes. A client id (`cid`)
    // is automatically generated and assigned for you.
    var Model = Backbone.Model = function (attributes, options) {
        var attrs = attributes || {};
        options || (options = {});
        this.cid = _.uniqueId(this.cidPrefix);
        this.attributes = {};
        if (options.collection) this.collection = options.collection;
        if (options.parse) attrs = this.parse(attrs, options) || {};
        attrs = _.defaults({}, attrs, _.result(this, 'defaults'));
        this.set(attrs, options);
        this.changed = {};
        this.initialize.apply(this, arguments);
    };

    // Attach all inheritable methods to the Model prototype.
    _.extend(Model.prototype, Events, {

        // A hash of attributes whose current and previous value differ.
        changed: null,

        // The value returned during the last failed validation.
        validationError: null,

        // The default name for the JSON `id` attribute is `"id"`. MongoDB and
        // CouchDB users may want to set this to `"_id"`.
        idAttribute: 'id',

        // The prefix is used to create the client id which is used to identify models locally.
        // You may want to override this if you're experiencing name clashes with model ids.
        cidPrefix: 'c',

        // Initialize is an empty function by default. Override it with your own
        // initialization logic.
        initialize: function () { },

        // Return a copy of the model's `attributes` object.
        toJSON: function (options) {
            return _.clone(this.attributes);
        },

        // Proxy `Backbone.sync` by default -- but override this if you need
        // custom syncing semantics for *this* particular model.
        sync: function () {
            return Backbone.sync.apply(this, arguments);
        },

        // Get the value of an attribute.
        get: function (attr) {
            return this.attributes[attr];
        },

        // Get the HTML-escaped value of an attribute.
        escape: function (attr) {
            return _.escape(this.get(attr));
        },

        // Returns `true` if the attribute contains a value that is not null
        // or undefined.
        has: function (attr) {
            return this.get(attr) != null;
        },

        // Special-cased proxy to underscore's `_.matches` method.
        matches: function (attrs) {
            return !!_.iteratee(attrs, this)(this.attributes);
        },

        // Set a hash of model attributes on the object, firing `"change"`. This is
        // the core primitive operation of a model, updating the data and notifying
        // anyone who needs to know about the change in state. The heart of the beast.
        set: function (key, val, options) {
            if (key == null) return this;

            // Handle both `"key", value` and `{key: value}` -style arguments.
            var attrs;
            if (typeof key === 'object') {
                attrs = key;
                options = val;
            } else {
                (attrs = {})[key] = val;
            }

            options || (options = {});

            // Run validation.
            if (!this._validate(attrs, options)) return false;

            // Extract attributes and options.
            var unset = options.unset;
            var silent = options.silent;
            var changes = [];
            var changing = this._changing;
            this._changing = true;

            if (!changing) {
                this._previousAttributes = _.clone(this.attributes);
                this.changed = {};
            }

            var current = this.attributes;
            var changed = this.changed;
            var prev = this._previousAttributes;

            // Check for changes of `id`.
            if (this.idAttribute in attrs) this.id = attrs[this.idAttribute];

            // For each `set` attribute, update or delete the current value.
            for (var attr in attrs) {
                val = attrs[attr];
                if (!_.isEqual(current[attr], val)) changes.push(attr);
                if (!_.isEqual(prev[attr], val)) {
                    changed[attr] = val;
                } else {
                    delete changed[attr];
                }
                unset ? delete current[attr] : current[attr] = val;
            }

            // Trigger all relevant attribute changes.
            if (!silent) {
                if (changes.length) this._pending = options;
                for (var i = 0; i < changes.length; i++) {
                    this.trigger('change:' + changes[i], this, current[changes[i]], options);
                }
            }

            // You might be wondering why there's a `while` loop here. Changes can
            // be recursively nested within `"change"` events.
            if (changing) return this;
            if (!silent) {
                while (this._pending) {
                    options = this._pending;
                    this._pending = false;
                    this.trigger('change', this, options);
                }
            }
            this._pending = false;
            this._changing = false;
            return this;
        },

        // Remove an attribute from the model, firing `"change"`. `unset` is a noop
        // if the attribute doesn't exist.
        unset: function (attr, options) {
            return this.set(attr, void 0, _.extend({}, options, { unset: true }));
        },

        // Clear all attributes on the model, firing `"change"`.
        clear: function (options) {
            var attrs = {};
            for (var key in this.attributes) attrs[key] = void 0;
            return this.set(attrs, _.extend({}, options, { unset: true }));
        },

        // Determine if the model has changed since the last `"change"` event.
        // If you specify an attribute name, determine if that attribute has changed.
        hasChanged: function (attr) {
            if (attr == null) return !_.isEmpty(this.changed);
            return _.has(this.changed, attr);
        },

        // Return an object containing all the attributes that have changed, or
        // false if there are no changed attributes. Useful for determining what
        // parts of a view need to be updated and/or what attributes need to be
        // persisted to the server. Unset attributes will be set to undefined.
        // You can also pass an attributes object to diff against the model,
        // determining if there *would be* a change.
        changedAttributes: function (diff) {
            if (!diff) return this.hasChanged() ? _.clone(this.changed) : false;
            var old = this._changing ? this._previousAttributes : this.attributes;
            var changed = {};
            for (var attr in diff) {
                var val = diff[attr];
                if (_.isEqual(old[attr], val)) continue;
                changed[attr] = val;
            }
            return _.size(changed) ? changed : false;
        },

        // Get the previous value of an attribute, recorded at the time the last
        // `"change"` event was fired.
        previous: function (attr) {
            if (attr == null || !this._previousAttributes) return null;
            return this._previousAttributes[attr];
        },

        // Get all of the attributes of the model at the time of the previous
        // `"change"` event.
        previousAttributes: function () {
            return _.clone(this._previousAttributes);
        },

        // Fetch the model from the server, merging the response with the model's
        // local attributes. Any changed attributes will trigger a "change" event.
        fetch: function (options) {
            options = _.extend({ parse: true }, options);
            var model = this;
            var success = options.success;
            options.success = function (resp) {
                var serverAttrs = options.parse ? model.parse(resp, options) : resp;
                if (!model.set(serverAttrs, options)) return false;
                if (success) success.call(options.context, model, resp, options);
                model.trigger('sync', model, resp, options);
            };
            wrapError(this, options);
            return this.sync('read', this, options);
        },

        // Set a hash of model attributes, and sync the model to the server.
        // If the server returns an attributes hash that differs, the model's
        // state will be `set` again.
        save: function (key, val, options) {
            // Handle both `"key", value` and `{key: value}` -style arguments.
            var attrs;
            if (key == null || typeof key === 'object') {
                attrs = key;
                options = val;
            } else {
                (attrs = {})[key] = val;
            }

            options = _.extend({ validate: true, parse: true }, options);
            var wait = options.wait;

            // If we're not waiting and attributes exist, save acts as
            // `set(attr).save(null, opts)` with validation. Otherwise, check if
            // the model will be valid when the attributes, if any, are set.
            if (attrs && !wait) {
                if (!this.set(attrs, options)) return false;
            } else {
                if (!this._validate(attrs, options)) return false;
            }

            // After a successful server-side save, the client is (optionally)
            // updated with the server-side state.
            var model = this;
            var success = options.success;
            var attributes = this.attributes;
            options.success = function (resp) {
                // Ensure attributes are restored during synchronous saves.
                model.attributes = attributes;
                var serverAttrs = options.parse ? model.parse(resp, options) : resp;
                if (wait) serverAttrs = _.extend({}, attrs, serverAttrs);
                if (serverAttrs && !model.set(serverAttrs, options)) return false;
                if (success) success.call(options.context, model, resp, options);
                model.trigger('sync', model, resp, options);
            };
            wrapError(this, options);

            // Set temporary attributes if `{wait: true}` to properly find new ids.
            if (attrs && wait) this.attributes = _.extend({}, attributes, attrs);

            var method = this.isNew() ? 'create' : (options.patch ? 'patch' : 'update');
            if (method === 'patch' && !options.attrs) options.attrs = attrs;
            var xhr = this.sync(method, this, options);

            // Restore attributes.
            this.attributes = attributes;

            return xhr;
        },

        // Destroy this model on the server if it was already persisted.
        // Optimistically removes the model from its collection, if it has one.
        // If `wait: true` is passed, waits for the server to respond before removal.
        destroy: function (options) {
            options = options ? _.clone(options) : {};
            var model = this;
            var success = options.success;
            var wait = options.wait;

            var destroy = function () {
                model.stopListening();
                model.trigger('destroy', model, model.collection, options);
            };

            options.success = function (resp) {
                if (wait) destroy();
                if (success) success.call(options.context, model, resp, options);
                if (!model.isNew()) model.trigger('sync', model, resp, options);
            };

            var xhr = false;
            if (this.isNew()) {
                _.defer(options.success);
            } else {
                wrapError(this, options);
                xhr = this.sync('delete', this, options);
            }
            if (!wait) destroy();
            return xhr;
        },

        // Default URL for the model's representation on the server -- if you're
        // using Backbone's restful methods, override this to change the endpoint
        // that will be called.
        url: function () {
            var base =
                _.result(this, 'urlRoot') ||
                _.result(this.collection, 'url') ||
                urlError();
            if (this.isNew()) return base;
            var id = this.get(this.idAttribute);
            return base.replace(/[^\/]$/, '$&/') + encodeURIComponent(id);
        },

        // **parse** converts a response into the hash of attributes to be `set` on
        // the model. The default implementation is just to pass the response along.
        parse: function (resp, options) {
            return resp;
        },

        // Create a new model with identical attributes to this one.
        clone: function () {
            return new this.constructor(this.attributes);
        },

        // A model is new if it has never been saved to the server, and lacks an id.
        isNew: function () {
            return !this.has(this.idAttribute);
        },

        // Check if the model is currently in a valid state.
        isValid: function (options) {
            return this._validate({}, _.defaults({ validate: true }, options));
        },

        // Run validation against the next complete set of model attributes,
        // returning `true` if all is well. Otherwise, fire an `"invalid"` event.
        _validate: function (attrs, options) {
            if (!options.validate || !this.validate) return true;
            attrs = _.extend({}, this.attributes, attrs);
            var error = this.validationError = this.validate(attrs, options) || null;
            if (!error) return true;
            this.trigger('invalid', this, error, _.extend(options, { validationError: error }));
            return false;
        }

    });

    // Underscore methods that we want to implement on the Model.
    var modelMethods = {
        keys: 1, values: 1, pairs: 1, invert: 1, pick: 0,
        omit: 0, chain: 1, isEmpty: 1
    };

    // Mix in each Underscore method as a proxy to `Model#attributes`.
    addUnderscoreMethods(Model, modelMethods, 'attributes');

    // Backbone.Collection
    // -------------------

    // If models tend to represent a single row of data, a Backbone Collection is
    // more analogous to a table full of data ... or a small slice or page of that
    // table, or a collection of rows that belong together for a particular reason
    // -- all of the messages in this particular folder, all of the documents
    // belonging to this particular author, and so on. Collections maintain
    // indexes of their models, both in order, and for lookup by `id`.

    // Create a new **Collection**, perhaps to contain a specific type of `model`.
    // If a `comparator` is specified, the Collection will maintain
    // its models in sort order, as they're added and removed.
    var Collection = Backbone.Collection = function (models, options) {
        options || (options = {});
        if (options.model) this.model = options.model;
        if (options.comparator !== void 0) this.comparator = options.comparator;
        this._reset();
        this.initialize.apply(this, arguments);
        if (models) this.reset(models, _.extend({ silent: true }, options));
    };

    // Default options for `Collection#set`.
    var setOptions = { add: true, remove: true, merge: true };
    var addOptions = { add: true, remove: false };

    // Define the Collection's inheritable methods.
    _.extend(Collection.prototype, Events, {

        // The default model for a collection is just a **Backbone.Model**.
        // This should be overridden in most cases.
        model: Model,

        // Initialize is an empty function by default. Override it with your own
        // initialization logic.
        initialize: function () { },

        // The JSON representation of a Collection is an array of the
        // models' attributes.
        toJSON: function (options) {
            return this.map(function (model) { return model.toJSON(options); });
        },

        // Proxy `Backbone.sync` by default.
        sync: function () {
            return Backbone.sync.apply(this, arguments);
        },

        // Add a model, or list of models to the set.
        add: function (models, options) {
            return this.set(models, _.extend({ merge: false }, options, addOptions));
        },

        // Remove a model, or a list of models from the set.
        remove: function (models, options) {
            options = _.extend({}, options);
            var singular = !_.isArray(models);
            models = singular ? [models] : _.clone(models);
            var removed = this._removeModels(models, options);
            if (!options.silent && removed) this.trigger('update', this, options);
            return singular ? removed[0] : removed;
        },

        // Update a collection by `set`-ing a new list of models, adding new ones,
        // removing models that are no longer present, and merging models that
        // already exist in the collection, as necessary. Similar to **Model#set**,
        // the core operation for updating the data contained by the collection.
        set: function (models, options) {
            options = _.defaults({}, options, setOptions);
            if (options.parse && !this._isModel(models)) models = this.parse(models, options);
            var singular = !_.isArray(models);
            models = singular ? (models ? [models] : []) : models.slice();
            var id, model, attrs, existing, sort;
            var at = options.at;
            if (at != null) at = +at;
            if (at < 0) at += this.length + 1;
            var sortable = this.comparator && (at == null) && options.sort !== false;
            var sortAttr = _.isString(this.comparator) ? this.comparator : null;
            var toAdd = [], toRemove = [], modelMap = {};
            var add = options.add, merge = options.merge, remove = options.remove;
            var order = !sortable && add && remove ? [] : false;
            var orderChanged = false;

            // Turn bare objects into model references, and prevent invalid models
            // from being added.
            for (var i = 0; i < models.length; i++) {
                attrs = models[i];

                // If a duplicate is found, prevent it from being added and
                // optionally merge it into the existing model.
                if (existing = this.get(attrs)) {
                    if (remove) modelMap[existing.cid] = true;
                    if (merge && attrs !== existing) {
                        attrs = this._isModel(attrs) ? attrs.attributes : attrs;
                        if (options.parse) attrs = existing.parse(attrs, options);
                        existing.set(attrs, options);
                        if (sortable && !sort && existing.hasChanged(sortAttr)) sort = true;
                    }
                    models[i] = existing;

                    // If this is a new, valid model, push it to the `toAdd` list.
                } else if (add) {
                    model = models[i] = this._prepareModel(attrs, options);
                    if (!model) continue;
                    toAdd.push(model);
                    this._addReference(model, options);
                }

                // Do not add multiple models with the same `id`.
                model = existing || model;
                if (!model) continue;
                id = this.modelId(model.attributes);
                if (order && (model.isNew() || !modelMap[id])) {
                    order.push(model);

                    // Check to see if this is actually a new model at this index.
                    orderChanged = orderChanged || !this.models[i] || model.cid !== this.models[i].cid;
                }

                modelMap[id] = true;
            }

            // Remove nonexistent models if appropriate.
            if (remove) {
                for (var i = 0; i < this.length; i++) {
                    if (!modelMap[(model = this.models[i]).cid]) toRemove.push(model);
                }
                if (toRemove.length) this._removeModels(toRemove, options);
            }

            // See if sorting is needed, update `length` and splice in new models.
            if (toAdd.length || orderChanged) {
                if (sortable) sort = true;
                this.length += toAdd.length;
                if (at != null) {
                    for (var i = 0; i < toAdd.length; i++) {
                        this.models.splice(at + i, 0, toAdd[i]);
                    }
                } else {
                    if (order) this.models.length = 0;
                    var orderedModels = order || toAdd;
                    for (var i = 0; i < orderedModels.length; i++) {
                        this.models.push(orderedModels[i]);
                    }
                }
            }

            // Silently sort the collection if appropriate.
            if (sort) this.sort({ silent: true });

            // Unless silenced, it's time to fire all appropriate add/sort events.
            if (!options.silent) {
                var addOpts = at != null ? _.clone(options) : options;
                for (var i = 0; i < toAdd.length; i++) {
                    if (at != null) addOpts.index = at + i;
                    (model = toAdd[i]).trigger('add', model, this, addOpts);
                }
                if (sort || orderChanged) this.trigger('sort', this, options);
                if (toAdd.length || toRemove.length) this.trigger('update', this, options);
            }

            // Return the added (or merged) model (or models).
            return singular ? models[0] : models;
        },

        // When you have more items than you want to add or remove individually,
        // you can reset the entire set with a new list of models, without firing
        // any granular `add` or `remove` events. Fires `reset` when finished.
        // Useful for bulk operations and optimizations.
        reset: function (models, options) {
            options = options ? _.clone(options) : {};
            for (var i = 0; i < this.models.length; i++) {
                this._removeReference(this.models[i], options);
            }
            options.previousModels = this.models;
            this._reset();
            models = this.add(models, _.extend({ silent: true }, options));
            if (!options.silent) this.trigger('reset', this, options);
            return models;
        },

        // Add a model to the end of the collection.
        push: function (model, options) {
            return this.add(model, _.extend({ at: this.length }, options));
        },

        // Remove a model from the end of the collection.
        pop: function (options) {
            var model = this.at(this.length - 1);
            return this.remove(model, options);
        },

        // Add a model to the beginning of the collection.
        unshift: function (model, options) {
            return this.add(model, _.extend({ at: 0 }, options));
        },

        // Remove a model from the beginning of the collection.
        shift: function (options) {
            var model = this.at(0);
            return this.remove(model, options);
        },

        // Slice out a sub-array of models from the collection.
        slice: function () {
            return slice.apply(this.models, arguments);
        },

        // Get a model from the set by id.
        get: function (obj) {
            if (obj == null) return void 0;
            var id = this.modelId(this._isModel(obj) ? obj.attributes : obj);
            return this._byId[obj] || this._byId[id] || this._byId[obj.cid];
        },

        // Get the model at the given index.
        at: function (index) {
            if (index < 0) index += this.length;
            return this.models[index];
        },

        // Return models with matching attributes. Useful for simple cases of
        // `filter`.
        where: function (attrs, first) {
            var matches = _.matches(attrs);
            return this[first ? 'find' : 'filter'](function (model) {
                return matches(model.attributes);
            });
        },

        // Return the first model with matching attributes. Useful for simple cases
        // of `find`.
        findWhere: function (attrs) {
            return this.where(attrs, true);
        },

        // Force the collection to re-sort itself. You don't need to call this under
        // normal circumstances, as the set will maintain sort order as each item
        // is added.
        sort: function (options) {
            if (!this.comparator) throw new Error('Cannot sort a set without a comparator');
            options || (options = {});

            // Run sort based on type of `comparator`.
            if (_.isString(this.comparator) || this.comparator.length === 1) {
                this.models = this.sortBy(this.comparator, this);
            } else {
                this.models.sort(_.bind(this.comparator, this));
            }

            if (!options.silent) this.trigger('sort', this, options);
            return this;
        },

        // Pluck an attribute from each model in the collection.
        pluck: function (attr) {
            return _.invoke(this.models, 'get', attr);
        },

        // Fetch the default set of models for this collection, resetting the
        // collection when they arrive. If `reset: true` is passed, the response
        // data will be passed through the `reset` method instead of `set`.
        fetch: function (options) {
            options = _.extend({ parse: true }, options);
            var success = options.success;
            var collection = this;
            options.success = function (resp) {
                var method = options.reset ? 'reset' : 'set';
                collection[method](resp, options);
                if (success) success.call(options.context, collection, resp, options);
                collection.trigger('sync', collection, resp, options);
            };
            wrapError(this, options);
            return this.sync('read', this, options);
        },

        // Create a new instance of a model in this collection. Add the model to the
        // collection immediately, unless `wait: true` is passed, in which case we
        // wait for the server to agree.
        create: function (model, options) {
            options = options ? _.clone(options) : {};
            var wait = options.wait;
            model = this._prepareModel(model, options);
            if (!model) return false;
            if (!wait) this.add(model, options);
            var collection = this;
            var success = options.success;
            options.success = function (model, resp, callbackOpts) {
                if (wait) collection.add(model, callbackOpts);
                if (success) success.call(callbackOpts.context, model, resp, callbackOpts);
            };
            model.save(null, options);
            return model;
        },

        // **parse** converts a response into a list of models to be added to the
        // collection. The default implementation is just to pass it through.
        parse: function (resp, options) {
            return resp;
        },

        // Create a new collection with an identical list of models as this one.
        clone: function () {
            return new this.constructor(this.models, {
                model: this.model,
                comparator: this.comparator
            });
        },

        // Define how to uniquely identify models in the collection.
        modelId: function (attrs) {
            return attrs[this.model.prototype.idAttribute || 'id'];
        },

        // Private method to reset all internal state. Called when the collection
        // is first initialized or reset.
        _reset: function () {
            this.length = 0;
            this.models = [];
            this._byId = {};
        },

        // Prepare a hash of attributes (or other model) to be added to this
        // collection.
        _prepareModel: function (attrs, options) {
            if (this._isModel(attrs)) {
                if (!attrs.collection) attrs.collection = this;
                return attrs;
            }
            options = options ? _.clone(options) : {};
            options.collection = this;
            var model = new this.model(attrs, options);
            if (!model.validationError) return model;
            this.trigger('invalid', this, model.validationError, options);
            return false;
        },

        // Internal method called by both remove and set.
        // Returns removed models, or false if nothing is removed.
        _removeModels: function (models, options) {
            var removed = [];
            for (var i = 0; i < models.length; i++) {
                var model = this.get(models[i]);
                if (!model) continue;

                var index = this.indexOf(model);
                this.models.splice(index, 1);
                this.length--;

                if (!options.silent) {
                    options.index = index;
                    model.trigger('remove', model, this, options);
                }

                removed.push(model);
                this._removeReference(model, options);
            }
            return removed.length ? removed : false;
        },

        // Method for checking whether an object should be considered a model for
        // the purposes of adding to the collection.
        _isModel: function (model) {
            return model instanceof Model;
        },

        // Internal method to create a model's ties to a collection.
        _addReference: function (model, options) {
            this._byId[model.cid] = model;
            var id = this.modelId(model.attributes);
            if (id != null) this._byId[id] = model;
            model.on('all', this._onModelEvent, this);
        },

        // Internal method to sever a model's ties to a collection.
        _removeReference: function (model, options) {
            delete this._byId[model.cid];
            var id = this.modelId(model.attributes);
            if (id != null) delete this._byId[id];
            if (this === model.collection) delete model.collection;
            model.off('all', this._onModelEvent, this);
        },

        // Internal method called every time a model in the set fires an event.
        // Sets need to update their indexes when models change ids. All other
        // events simply proxy through. "add" and "remove" events that originate
        // in other collections are ignored.
        _onModelEvent: function (event, model, collection, options) {
            if ((event === 'add' || event === 'remove') && collection !== this) return;
            if (event === 'destroy') this.remove(model, options);
            if (event === 'change') {
                var prevId = this.modelId(model.previousAttributes());
                var id = this.modelId(model.attributes);
                if (prevId !== id) {
                    if (prevId != null) delete this._byId[prevId];
                    if (id != null) this._byId[id] = model;
                }
            }
            this.trigger.apply(this, arguments);
        }

    });

    // Underscore methods that we want to implement on the Collection.
    // 90% of the core usefulness of Backbone Collections is actually implemented
    // right here:
    var collectionMethods = {
        forEach: 3, each: 3, map: 3, collect: 3, reduce: 4,
        foldl: 4, inject: 4, reduceRight: 4, foldr: 4, find: 3, detect: 3, filter: 3,
        select: 3, reject: 3, every: 3, all: 3, some: 3, any: 3, include: 2,
        contains: 2, invoke: 0, max: 3, min: 3, toArray: 1, size: 1, first: 3,
        head: 3, take: 3, initial: 3, rest: 3, tail: 3, drop: 3, last: 3,
        without: 0, difference: 0, indexOf: 3, shuffle: 1, lastIndexOf: 3,
        isEmpty: 1, chain: 1, sample: 3, partition: 3
    };

    // Mix in each Underscore method as a proxy to `Collection#models`.
    addUnderscoreMethods(Collection, collectionMethods, 'models');

    // Underscore methods that take a property name as an argument.
    var attributeMethods = ['groupBy', 'countBy', 'sortBy', 'indexBy'];

    // Use attributes instead of properties.
    _.each(attributeMethods, function (method) {
        if (!_[method]) return;
        Collection.prototype[method] = function (value, context) {
            var iterator = _.isFunction(value) ? value : function (model) {
                return model.get(value);
            };
            return _[method](this.models, iterator, context);
        };
    });

    // Backbone.View
    // -------------

    // Backbone Views are almost more convention than they are actual code. A View
    // is simply a JavaScript object that represents a logical chunk of UI in the
    // DOM. This might be a single item, an entire list, a sidebar or panel, or
    // even the surrounding frame which wraps your whole app. Defining a chunk of
    // UI as a **View** allows you to define your DOM events declaratively, without
    // having to worry about render order ... and makes it easy for the view to
    // react to specific changes in the state of your models.

    // Creating a Backbone.View creates its initial element outside of the DOM,
    // if an existing element is not provided...
    var View = Backbone.View = function (options) {
        this.cid = _.uniqueId('view');
        _.extend(this, _.pick(options, viewOptions));
        this._ensureElement();
        this.initialize.apply(this, arguments);
    };

    // Cached regex to split keys for `delegate`.
    var delegateEventSplitter = /^(\S+)\s*(.*)$/;

    // List of view options to be merged as properties.
    var viewOptions = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName', 'events'];

    // Set up all inheritable **Backbone.View** properties and methods.
    _.extend(View.prototype, Events, {

        // The default `tagName` of a View's element is `"div"`.
        tagName: 'div',

        // jQuery delegate for element lookup, scoped to DOM elements within the
        // current view. This should be preferred to global lookups where possible.
        $: function (selector) {
            return this.$el.find(selector);
        },

        // Initialize is an empty function by default. Override it with your own
        // initialization logic.
        initialize: function () { },

        // **render** is the core function that your view should override, in order
        // to populate its element (`this.el`), with the appropriate HTML. The
        // convention is for **render** to always return `this`.
        render: function () {
            return this;
        },

        // Remove this view by taking the element out of the DOM, and removing any
        // applicable Backbone.Events listeners.
        remove: function () {
            this._removeElement();
            this.stopListening();
            return this;
        },

        // Remove this view's element from the document and all event listeners
        // attached to it. Exposed for subclasses using an alternative DOM
        // manipulation API.
        _removeElement: function () {
            this.$el.remove();
        },

        // Change the view's element (`this.el` property) and re-delegate the
        // view's events on the new element.
        setElement: function (element) {
            this.undelegateEvents();
            this._setElement(element);
            this.delegateEvents();
            return this;
        },

        // Creates the `this.el` and `this.$el` references for this view using the
        // given `el`. `el` can be a CSS selector or an HTML string, a jQuery
        // context or an element. Subclasses can override this to utilize an
        // alternative DOM manipulation API and are only required to set the
        // `this.el` property.
        _setElement: function (el) {
            this.$el = el instanceof Backbone.$ ? el : Backbone.$(el);
            this.el = this.$el[0];
        },

        // Set callbacks, where `this.events` is a hash of
        //
        // *{"event selector": "callback"}*
        //
        //     {
        //       'mousedown .title':  'edit',
        //       'click .button':     'save',
        //       'click .open':       function(e) { ... }
        //     }
        //
        // pairs. Callbacks will be bound to the view, with `this` set properly.
        // Uses event delegation for efficiency.
        // Omitting the selector binds the event to `this.el`.
        delegateEvents: function (events) {
            events || (events = _.result(this, 'events'));
            if (!events) return this;
            this.undelegateEvents();
            for (var key in events) {
                var method = events[key];
                if (!_.isFunction(method)) method = this[method];
                if (!method) continue;
                var match = key.match(delegateEventSplitter);
                this.delegate(match[1], match[2], _.bind(method, this));
            }
            return this;
        },

        // Add a single event listener to the view's element (or a child element
        // using `selector`). This only works for delegate-able events: not `focus`,
        // `blur`, and not `change`, `submit`, and `reset` in Internet Explorer.
        delegate: function (eventName, selector, listener) {
            this.$el.on(eventName + '.delegateEvents' + this.cid, selector, listener);
            return this;
        },

        // Clears all callbacks previously bound to the view by `delegateEvents`.
        // You usually don't need to use this, but may wish to if you have multiple
        // Backbone views attached to the same DOM element.
        undelegateEvents: function () {
            if (this.$el) this.$el.off('.delegateEvents' + this.cid);
            return this;
        },

        // A finer-grained `undelegateEvents` for removing a single delegated event.
        // `selector` and `listener` are both optional.
        undelegate: function (eventName, selector, listener) {
            this.$el.off(eventName + '.delegateEvents' + this.cid, selector, listener);
            return this;
        },

        // Produces a DOM element to be assigned to your view. Exposed for
        // subclasses using an alternative DOM manipulation API.
        _createElement: function (tagName) {
            return document.createElement(tagName);
        },

        // Ensure that the View has a DOM element to render into.
        // If `this.el` is a string, pass it through `$()`, take the first
        // matching element, and re-assign it to `el`. Otherwise, create
        // an element from the `id`, `className` and `tagName` properties.
        _ensureElement: function () {
            if (!this.el) {
                var attrs = _.extend({}, _.result(this, 'attributes'));
                if (this.id) attrs.id = _.result(this, 'id');
                if (this.className) attrs['class'] = _.result(this, 'className');
                this.setElement(this._createElement(_.result(this, 'tagName')));
                this._setAttributes(attrs);
            } else {
                this.setElement(_.result(this, 'el'));
            }
        },

        // Set attributes from a hash on this view's element.  Exposed for
        // subclasses using an alternative DOM manipulation API.
        _setAttributes: function (attributes) {
            this.$el.attr(attributes);
        }

    });

    // Backbone.sync
    // -------------

    // Override this function to change the manner in which Backbone persists
    // models to the server. You will be passed the type of request, and the
    // model in question. By default, makes a RESTful Ajax request
    // to the model's `url()`. Some possible customizations could be:
    //
    // * Use `setTimeout` to batch rapid-fire updates into a single request.
    // * Send up the models as XML instead of JSON.
    // * Persist models via WebSockets instead of Ajax.
    //
    // Turn on `Backbone.emulateHTTP` in order to send `PUT` and `DELETE` requests
    // as `POST`, with a `_method` parameter containing the true HTTP method,
    // as well as all requests with the body as `application/x-www-form-urlencoded`
    // instead of `application/json` with the model in a param named `model`.
    // Useful when interfacing with server-side languages like **PHP** that make
    // it difficult to read the body of `PUT` requests.
    Backbone.sync = function (method, model, options) {
        var type = methodMap[method];

        // Default options, unless specified.
        _.defaults(options || (options = {}), {
            emulateHTTP: Backbone.emulateHTTP,
            emulateJSON: Backbone.emulateJSON
        });

        // Default JSON-request options.
        var params = { type: type, dataType: 'json' };

        // Ensure that we have a URL.
        if (!options.url) {
            params.url = _.result(model, 'url') || urlError();
        }

        // Ensure that we have the appropriate request data.
        if (options.data == null && model && (method === 'create' || method === 'update' || method === 'patch')) {
            params.contentType = 'application/json';
            params.data = JSON.stringify(options.attrs || model.toJSON(options));
        }

        // For older servers, emulate JSON by encoding the request into an HTML-form.
        if (options.emulateJSON) {
            params.contentType = 'application/x-www-form-urlencoded';
            params.data = params.data ? { model: params.data } : {};
        }

        // For older servers, emulate HTTP by mimicking the HTTP method with `_method`
        // And an `X-HTTP-Method-Override` header.
        if (options.emulateHTTP && (type === 'PUT' || type === 'DELETE' || type === 'PATCH')) {
            params.type = 'POST';
            if (options.emulateJSON) params.data._method = type;
            var beforeSend = options.beforeSend;
            options.beforeSend = function (xhr) {
                xhr.setRequestHeader('X-HTTP-Method-Override', type);
                if (beforeSend) return beforeSend.apply(this, arguments);
            };
        }

        // Don't process data on a non-GET request.
        if (params.type !== 'GET' && !options.emulateJSON) {
            params.processData = false;
        }

        // Pass along `textStatus` and `errorThrown` from jQuery.
        var error = options.error;
        options.error = function (xhr, textStatus, errorThrown) {
            options.textStatus = textStatus;
            options.errorThrown = errorThrown;
            if (error) error.call(options.context, xhr, textStatus, errorThrown);
        };

        // Make the request, allowing the user to override any Ajax options.
        var xhr = options.xhr = Backbone.ajax(_.extend(params, options));
        model.trigger('request', model, xhr, options);
        return xhr;
    };

    // Map from CRUD to HTTP for our default `Backbone.sync` implementation.
    var methodMap = {
        'create': 'POST',
        'update': 'PUT',
        'patch': 'PATCH',
        'delete': 'DELETE',
        'read': 'GET'
    };

    // Set the default implementation of `Backbone.ajax` to proxy through to `$`.
    // Override this if you'd like to use a different library.
    Backbone.ajax = function () {
        return Backbone.$.ajax.apply(Backbone.$, arguments);
    };

    // Backbone.Router
    // ---------------

    // Routers map faux-URLs to actions, and fire events when routes are
    // matched. Creating a new one sets its `routes` hash, if not set statically.
    var Router = Backbone.Router = function (options) {
        options || (options = {});
        if (options.routes) this.routes = options.routes;
        this._bindRoutes();
        this.initialize.apply(this, arguments);
    };

    // Cached regular expressions for matching named param parts and splatted
    // parts of route strings.
    var optionalParam = /\((.*?)\)/g;
    var namedParam = /(\(\?)?:\w+/g;
    var splatParam = /\*\w+/g;
    var escapeRegExp = /[\-{}\[\]+?.,\\\^$|#\s]/g;

    // Set up all inheritable **Backbone.Router** properties and methods.
    _.extend(Router.prototype, Events, {

        // Initialize is an empty function by default. Override it with your own
        // initialization logic.
        initialize: function () { },

        // Manually bind a single named route to a callback. For example:
        //
        //     this.route('search/:query/p:num', 'search', function(query, num) {
        //       ...
        //     });
        //
        route: function (route, name, callback) {
            if (!_.isRegExp(route)) route = this._routeToRegExp(route);
            if (_.isFunction(name)) {
                callback = name;
                name = '';
            }
            if (!callback) callback = this[name];
            var router = this;
            Backbone.history.route(route, function (fragment) {
                var args = router._extractParameters(route, fragment);
                if (router.execute(callback, args, name) !== false) {
                    router.trigger.apply(router, ['route:' + name].concat(args));
                    router.trigger('route', name, args);
                    Backbone.history.trigger('route', router, name, args);
                }
            });
            return this;
        },

        // Execute a route handler with the provided parameters.  This is an
        // excellent place to do pre-route setup or post-route cleanup.
        execute: function (callback, args, name) {
            if (callback) callback.apply(this, args);
        },

        // Simple proxy to `Backbone.history` to save a fragment into the history.
        navigate: function (fragment, options) {
            Backbone.history.navigate(fragment, options);
            return this;
        },

        // Bind all defined routes to `Backbone.history`. We have to reverse the
        // order of the routes here to support behavior where the most general
        // routes can be defined at the bottom of the route map.
        _bindRoutes: function () {
            if (!this.routes) return;
            this.routes = _.result(this, 'routes');
            var route, routes = _.keys(this.routes);
            while ((route = routes.pop()) != null) {
                this.route(route, this.routes[route]);
            }
        },

        // Convert a route string into a regular expression, suitable for matching
        // against the current location hash.
        _routeToRegExp: function (route) {
            route = route.replace(escapeRegExp, '\\$&')
                .replace(optionalParam, '(?:$1)?')
                .replace(namedParam, function (match, optional) {
                    return optional ? match : '([^/?]+)';
                })
                .replace(splatParam, '([^?]*?)');
            return new RegExp('^' + route + '(?:\\?([\\s\\S]*))?$');
        },

        // Given a route, and a URL fragment that it matches, return the array of
        // extracted decoded parameters. Empty or unmatched parameters will be
        // treated as `null` to normalize cross-browser behavior.
        _extractParameters: function (route, fragment) {
            var params = route.exec(fragment).slice(1);
            return _.map(params, function (param, i) {
                // Don't decode the search params.
                if (i === params.length - 1) return param || null;
                return param ? decodeURIComponent(param) : null;
            });
        }

    });

    // Backbone.History
    // ----------------

    // Handles cross-browser history management, based on either
    // [pushState](http://diveintohtml5.info/history.html) and real URLs, or
    // [onhashchange](https://developer.mozilla.org/en-US/docs/DOM/window.onhashchange)
    // and URL fragments. If the browser supports neither (old IE, natch),
    // falls back to polling.
    var History = Backbone.History = function () {
        this.handlers = [];
        _.bindAll(this, 'checkUrl');

        // Ensure that `History` can be used outside of the browser.
        if (typeof window !== 'undefined') {
            this.location = window.location;
            this.history = window.history;
        }
    };

    // Cached regex for stripping a leading hash/slash and trailing space.
    var routeStripper = /^[#\/]|\s+$/g;

    // Cached regex for stripping leading and trailing slashes.
    var rootStripper = /^\/+|\/+$/g;

    // Cached regex for stripping urls of hash.
    var pathStripper = /#.*$/;

    // Has the history handling already been started?
    History.started = false;

    // Set up all inheritable **Backbone.History** properties and methods.
    _.extend(History.prototype, Events, {

        // The default interval to poll for hash changes, if necessary, is
        // twenty times a second.
        interval: 50,

        // Are we at the app root?
        atRoot: function () {
            var path = this.location.pathname.replace(/[^\/]$/, '$&/');
            return path === this.root && !this.getSearch();
        },

        // Does the pathname match the root?
        matchRoot: function () {
            var path = this.decodeFragment(this.location.pathname);
            var root = path.slice(0, this.root.length - 1) + '/';
            return root === this.root;
        },

        // Unicode characters in `location.pathname` are percent encoded so they're
        // decoded for comparison. `%25` should not be decoded since it may be part
        // of an encoded parameter.
        decodeFragment: function (fragment) {
            return decodeURI(fragment.replace(/%25/g, '%2525'));
        },

        // In IE6, the hash fragment and search params are incorrect if the
        // fragment contains `?`.
        getSearch: function () {
            var match = this.location.href.replace(/#.*/, '').match(/\?.+/);
            return match ? match[0] : '';
        },

        // Gets the true hash value. Cannot use location.hash directly due to bug
        // in Firefox where location.hash will always be decoded.
        getHash: function (window) {
            var match = (window || this).location.href.match(/#(.*)$/);
            return match ? match[1] : '';
        },

        // Get the pathname and search params, without the root.
        getPath: function () {
            var path = this.decodeFragment(
                this.location.pathname + this.getSearch()
            ).slice(this.root.length - 1);
            return path.charAt(0) === '/' ? path.slice(1) : path;
        },

        // Get the cross-browser normalized URL fragment from the path or hash.
        getFragment: function (fragment) {
            if (fragment == null) {
                if (this._usePushState || !this._wantsHashChange) {
                    fragment = this.getPath();
                } else {
                    fragment = this.getHash();
                }
            }
            return fragment.replace(routeStripper, '');
        },

        // Start the hash change handling, returning `true` if the current URL matches
        // an existing route, and `false` otherwise.
        start: function (options) {
            if (History.started) throw new Error('Backbone.history has already been started');
            History.started = true;

            // Figure out the initial configuration. Do we need an iframe?
            // Is pushState desired ... is it available?
            this.options = _.extend({ root: '/' }, this.options, options);
            this.root = this.options.root;
            this._wantsHashChange = this.options.hashChange !== false;
            this._hasHashChange = 'onhashchange' in window;
            this._useHashChange = this._wantsHashChange && this._hasHashChange;
            this._wantsPushState = !!this.options.pushState;
            this._hasPushState = !!(this.history && this.history.pushState);
            this._usePushState = this._wantsPushState && this._hasPushState;
            this.fragment = this.getFragment();

            // Normalize root to always include a leading and trailing slash.
            this.root = ('/' + this.root + '/').replace(rootStripper, '/');

            // Transition from hashChange to pushState or vice versa if both are
            // requested.
            if (this._wantsHashChange && this._wantsPushState) {

                // If we've started off with a route from a `pushState`-enabled
                // browser, but we're currently in a browser that doesn't support it...
                if (!this._hasPushState && !this.atRoot()) {
                    var root = this.root.slice(0, -1) || '/';
                    this.location.replace(root + '#' + this.getPath());
                    // Return immediately as browser will do redirect to new url
                    return true;

                    // Or if we've started out with a hash-based route, but we're currently
                    // in a browser where it could be `pushState`-based instead...
                } else if (this._hasPushState && this.atRoot()) {
                    this.navigate(this.getHash(), { replace: true });
                }

            }

            // Proxy an iframe to handle location events if the browser doesn't
            // support the `hashchange` event, HTML5 history, or the user wants
            // `hashChange` but not `pushState`.
            if (!this._hasHashChange && this._wantsHashChange && !this._usePushState) {
                this.iframe = document.createElement('iframe');
                this.iframe.src = 'javascript:0';
                this.iframe.style.display = 'none';
                this.iframe.tabIndex = -1;
                var body = document.body;
                // Using `appendChild` will throw on IE < 9 if the document is not ready.
                var iWindow = body.insertBefore(this.iframe, body.firstChild).contentWindow;
                iWindow.document.open();
                iWindow.document.close();
                iWindow.location.hash = '#' + this.fragment;
            }

            // Add a cross-platform `addEventListener` shim for older browsers.
            var addEventListener = window.addEventListener || function (eventName, listener) {
                return attachEvent('on' + eventName, listener);
            };

            // Depending on whether we're using pushState or hashes, and whether
            // 'onhashchange' is supported, determine how we check the URL state.
            if (this._usePushState) {
                addEventListener('popstate', this.checkUrl, false);
            } else if (this._useHashChange && !this.iframe) {
                addEventListener('hashchange', this.checkUrl, false);
            } else if (this._wantsHashChange) {
                this._checkUrlInterval = setInterval(this.checkUrl, this.interval);
            }

            if (!this.options.silent) return this.loadUrl();
        },

        // Disable Backbone.history, perhaps temporarily. Not useful in a real app,
        // but possibly useful for unit testing Routers.
        stop: function () {
            // Add a cross-platform `removeEventListener` shim for older browsers.
            var removeEventListener = window.removeEventListener || function (eventName, listener) {
                return detachEvent('on' + eventName, listener);
            };

            // Remove window listeners.
            if (this._usePushState) {
                removeEventListener('popstate', this.checkUrl, false);
            } else if (this._useHashChange && !this.iframe) {
                removeEventListener('hashchange', this.checkUrl, false);
            }

            // Clean up the iframe if necessary.
            if (this.iframe) {
                document.body.removeChild(this.iframe);
                this.iframe = null;
            }

            // Some environments will throw when clearing an undefined interval.
            if (this._checkUrlInterval) clearInterval(this._checkUrlInterval);
            History.started = false;
        },

        // Add a route to be tested when the fragment changes. Routes added later
        // may override previous routes.
        route: function (route, callback) {
            this.handlers.unshift({ route: route, callback: callback });
        },

        // Checks the current URL to see if it has changed, and if it has,
        // calls `loadUrl`, normalizing across the hidden iframe.
        checkUrl: function (e) {
            var current = this.getFragment();

            // If the user pressed the back button, the iframe's hash will have
            // changed and we should use that for comparison.
            if (current === this.fragment && this.iframe) {
                current = this.getHash(this.iframe.contentWindow);
            }

            if (current === this.fragment) return false;
            if (this.iframe) this.navigate(current);
            this.loadUrl();
        },

        // Attempt to load the current URL fragment. If a route succeeds with a
        // match, returns `true`. If no defined routes matches the fragment,
        // returns `false`.
        loadUrl: function (fragment) {
            // If the root doesn't match, no routes can match either.
            if (!this.matchRoot()) return false;
            fragment = this.fragment = this.getFragment(fragment);
            return _.any(this.handlers, function (handler) {
                if (handler.route.test(fragment)) {
                    handler.callback(fragment);
                    return true;
                }
            });
        },

        // Save a fragment into the hash history, or replace the URL state if the
        // 'replace' option is passed. You are responsible for properly URL-encoding
        // the fragment in advance.
        //
        // The options object can contain `trigger: true` if you wish to have the
        // route callback be fired (not usually desirable), or `replace: true`, if
        // you wish to modify the current URL without adding an entry to the history.
        navigate: function (fragment, options) {
            if (!History.started) return false;
            if (!options || options === true) options = { trigger: !!options };

            // Normalize the fragment.
            fragment = this.getFragment(fragment || '');

            // Don't include a trailing slash on the root.
            var root = this.root;
            if (fragment === '' || fragment.charAt(0) === '?') {
                root = root.slice(0, -1) || '/';
            }
            var url = root + fragment;

            // Strip the hash and decode for matching.
            fragment = this.decodeFragment(fragment.replace(pathStripper, ''));

            if (this.fragment === fragment) return;
            this.fragment = fragment;

            // If pushState is available, we use it to set the fragment as a real URL.
            if (this._usePushState) {
                this.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url);

                // If hash changes haven't been explicitly disabled, update the hash
                // fragment to store history.
            } else if (this._wantsHashChange) {
                this._updateHash(this.location, fragment, options.replace);
                if (this.iframe && (fragment !== this.getHash(this.iframe.contentWindow))) {
                    var iWindow = this.iframe.contentWindow;

                    // Opening and closing the iframe tricks IE7 and earlier to push a
                    // history entry on hash-tag change.  When replace is true, we don't
                    // want this.
                    if (!options.replace) {
                        iWindow.document.open();
                        iWindow.document.close();
                    }

                    this._updateHash(iWindow.location, fragment, options.replace);
                }

                // If you've told us that you explicitly don't want fallback hashchange-
                // based history, then `navigate` becomes a page refresh.
            } else {
                return this.location.assign(url);
            }
            if (options.trigger) return this.loadUrl(fragment);
        },

        // Update the hash location, either replacing the current entry, or adding
        // a new one to the browser history.
        _updateHash: function (location, fragment, replace) {
            if (replace) {
                var href = location.href.replace(/(javascript:|#).*$/, '');
                location.replace(href + '#' + fragment);
            } else {
                // Some browsers require that `hash` contains a leading #.
                location.hash = '#' + fragment;
            }
        }

    });

    // Create the default Backbone.history.
    Backbone.history = new History;

    // Helpers
    // -------

    // Helper function to correctly set up the prototype chain for subclasses.
    // Similar to `goog.inherits`, but uses a hash of prototype properties and
    // class properties to be extended.
    var extend = function (protoProps, staticProps) {
        var parent = this;
        var child;

        // The constructor function for the new subclass is either defined by you
        // (the "constructor" property in your `extend` definition), or defaulted
        // by us to simply call the parent constructor.
        if (protoProps && _.has(protoProps, 'constructor')) {
            child = protoProps.constructor;
        } else {
            child = function () { return parent.apply(this, arguments); };
        }

        // Add static properties to the constructor function, if supplied.
        _.extend(child, parent, staticProps);

        // Set the prototype chain to inherit from `parent`, without calling
        // `parent` constructor function.
        var Surrogate = function () { this.constructor = child; };
        Surrogate.prototype = parent.prototype;
        child.prototype = new Surrogate;

        // Add prototype properties (instance properties) to the subclass,
        // if supplied.
        if (protoProps) _.extend(child.prototype, protoProps);

        // Set a convenience property in case the parent's prototype is needed
        // later.
        child.__super__ = parent.prototype;

        return child;
    };

    // Set up inheritance for the model, collection, router, view and history.
    Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend;

    // Throw an error when a URL is needed, and none is supplied.
    var urlError = function () {
        throw new Error('A "url" property or function must be specified');
    };

    // Wrap an optional error callback with a fallback error event.
    var wrapError = function (model, options) {
        var error = options.error;
        options.error = function (resp) {
            if (error) error.call(options.context, model, resp, options);
            model.trigger('error', model, resp, options);
        };
    };

    return Backbone;

}));
;
/*global define, module */
/*jshint undef:true, smarttabs:true */
// Set up Autolinker appropriately for the environment.
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define(factory);             // Define as AMD module if an AMD loader is present (ex: RequireJS).
    } else if (typeof exports !== 'undefined') {
        module.exports = factory();    // Define as CommonJS module for Node.js, if available.
    } else {
        root.Autolinker = factory();   // Finally, define as a browser global if no module loader.
    }
}(this, function () {

    /**
     * @class Autolinker
     * @extends Object
     *
     * Utility class used to process a given string of text, and wrap the URLs, email addresses, and Twitter handles in
     * the appropriate anchor (&lt;a&gt;) tags to turn them into links.
     *
     * Any of the configuration options may be provided in an Object (map) provided to the Autolinker constructor, which
     * will configure how the {@link #link link()} method will process the links.
     *
     * For example:
     *
     *     var autolinker = new Autolinker( {
     *         newWindow : false,
     *         truncate  : 30
     *     } );
     *
     *     var html = autolinker.link( "Joe went to www.yahoo.com" );
     *     // produces: 'Joe went to <a href="http://www.yahoo.com">yahoo.com</a>'
     *
     *
     * The {@link #static-link static link()} method may also be used to inline options into a single call, which may
     * be more convenient for one-off uses. For example:
     *
     *     var html = Autolinker.link( "Joe went to www.yahoo.com", {
     *         newWindow : false,
     *         truncate  : 30
     *     } );
     *     // produces: 'Joe went to <a href="http://www.yahoo.com">yahoo.com</a>'
     *
     * @constructor
     * @param {Object} [config] The configuration options for the Autolinker instance, specified in an Object (map).
     */
    var Autolinker = function (cfg) {
        cfg = cfg || {};

        // Assign the properties of `cfg` onto the Autolinker instance
        for (var prop in cfg)
            if (cfg.hasOwnProperty(prop)) this[prop] = cfg[prop];
    };


    Autolinker.prototype = {
        constructor: Autolinker,  // fix constructor property

        /**
         * @cfg {Boolean} newWindow
         *
         * `true` if the links should open in a new window, `false` otherwise.
         */
        newWindow: true,

        /**
         * @cfg {Boolean} stripPrefix
         *
         * `true` if 'http://' or 'https://' and/or the 'www.' should be stripped from the beginning of links, `false` otherwise.
         */
        stripPrefix: false,

        /**
         * @cfg {Number} truncate
         *
         * A number for how many characters long URLs/emails/twitter handles should be truncated to inside the text of
         * a link. If the URL/email/twitter is over this number of characters, it will be truncated to this length by
         * adding a two period ellipsis ('..') into the middle of the string.
         *
         * For example: A url like 'http://www.yahoo.com/some/long/path/to/a/file' truncated to 25 characters might look
         * something like this: 'http://www...th/to/a/file'
         */

        /**
         * @cfg {Boolean} twitter
         *
         * `true` if Twitter handles ("@example") should be automatically linked, `false` if they should not be.
         */
        twitter: true,

        /**
         * @cfg {Boolean} email
         *
         * `true` if email addresses should be automatically linked, `false` if they should not be.
         */
        email: true,

        /**
         * @cfg {Boolean} urls
         *
         * `true` if miscellaneous URLs should be automatically linked, `false` if they should not be.
         */
        urls: true,

        /**
         * @cfg {String} className
         *
         * A CSS class name to add to the generated links. This class will be added to all links, as well as this class
         * plus url/email/twitter suffixes for styling url/email/twitter links differently.
         *
         * For example, if this config is provided as "myLink", then:
         *
         * 1) URL links will have the CSS classes: "myLink myLink-url"
         * 2) Email links will have the CSS classes: "myLink myLink-email", and
         * 3) Twitter links will have the CSS classes: "myLink myLink-twitter"
         */
        className: "",


        /**
         * @private
         * @property {RegExp} matcherRegex
         *
         * The regular expression that matches URLs, email addresses, and Twitter handles.
         *
         * This regular expression has the following capturing groups:
         *
         * 1. Group that is used to determine if there is a Twitter handle match (i.e. @someTwitterUser). Simply check for its
         *    existence to determine if there is a Twitter handle match. The next couple of capturing groups give information
         *    about the Twitter handle match.
         * 2. The whitespace character before the @sign in a Twitter handle. This is needed because there are no lookbehinds in
         *    JS regular expressions, and can be used to reconstruct the original string in a replace().
         * 3. The Twitter handle itself in a Twitter match. If the match is '@someTwitterUser', the handle is 'someTwitterUser'.
         * 4. Group that matches an email address. Used to determine if the match is an email address, as well as holding the full
         *    address. Ex: 'me@my.com'
         * 5. Group that matches a URL in the input text. Ex: 'http://google.com', 'www.google.com', or just 'google.com'.
         *    This also includes a path, url parameters, or hash anchors. Ex: google.com/path/to/file?q1=1&q2=2#myAnchor
         * 6. A protocol-relative ('//') match for the case of a 'www.' prefixed URL. Will be an empty string if it is not a
         *    protocol-relative match. We need to know the character before the '//' in order to determine if it is a valid match
         *    or the // was in a string we don't want to auto-link.
         * 7. A protocol-relative ('//') match for the case of a known TLD prefixed URL. Will be an empty string if it is not a
         *    protocol-relative match. See #6 for more info.
         */
        matcherRegex: (function () {
            var twitterRegex = /(^|[^\w])@(\w{1,15})/,              // For matching a twitter handle. Ex: @gregory_jacobs

                emailRegex = /(?:[\-;:&=\+\$,\w\.]+@)/,             // something@ for email addresses (a.k.a. local-part)

                protocolRegex = /(?:[A-Za-z]{3,9}:(?:\/\/)?)/,      // match protocol, allow in format http:// or mailto:
                wwwRegex = /(?:www\.)/,                             // starting with 'www.'
                domainNameRegex = /[A-Za-z0-9\.\-]*[A-Za-z0-9\-]/,  // anything looking at all like a domain, non-unicode domains, not ending in a period
                tldRegex = /\.(?:international|construction|contractors|enterprises|photography|productions|foundation|immobilien|industries|management|properties|technology|christmas|community|directory|education|equipment|institute|marketing|solutions|vacations|bargains|boutique|builders|catering|cleaning|clothing|computer|democrat|diamonds|graphics|holdings|lighting|partners|plumbing|supplies|training|ventures|academy|careers|company|cruises|domains|exposed|flights|florist|gallery|guitars|holiday|kitchen|neustar|okinawa|recipes|rentals|reviews|shiksha|singles|support|systems|agency|berlin|camera|center|coffee|condos|dating|estate|events|expert|futbol|kaufen|luxury|maison|monash|museum|nagoya|photos|repair|report|social|supply|tattoo|tienda|travel|viajes|villas|vision|voting|voyage|actor|build|cards|cheap|codes|dance|email|glass|house|mango|ninja|parts|photo|shoes|solar|today|tokyo|tools|watch|works|aero|arpa|asia|best|bike|blue|buzz|camp|club|cool|coop|farm|fish|gift|guru|info|jobs|kiwi|kred|land|limo|link|menu|mobi|moda|name|pics|pink|post|qpon|rich|ruhr|sexy|tips|vote|voto|wang|wien|wiki|zone|bar|bid|biz|cab|cat|ceo|com|edu|gov|int|kim|mil|net|onl|org|pro|pub|red|tel|uno|wed|xxx|xyz|ac|ad|ae|af|ag|ai|al|am|an|ao|aq|ar|as|at|au|aw|ax|az|ba|bb|bd|be|bf|bg|bh|bi|bj|bm|bn|bo|br|bs|bt|bv|bw|by|bz|ca|cc|cd|cf|cg|ch|ci|ck|cl|cm|cn|co|cr|cu|cv|cw|cx|cy|cz|de|dj|dk|dm|do|dz|ec|ee|eg|er|es|et|eu|fi|fj|fk|fm|fo|fr|ga|gb|gd|ge|gf|gg|gh|gi|gl|gm|gn|gp|gq|gr|gs|gt|gu|gw|gy|hk|hm|hn|hr|ht|hu|id|ie|il|im|in|io|iq|ir|is|it|je|jm|jo|jp|ke|kg|kh|ki|km|kn|kp|kr|kw|ky|kz|la|lb|lc|li|lk|lr|ls|lt|lu|lv|ly|ma|mc|md|me|mg|mh|mk|ml|mm|mn|mo|mp|mq|mr|ms|mt|mu|mv|mw|mx|my|mz|na|nc|ne|nf|ng|ni|nl|no|np|nr|nu|nz|om|pa|pe|pf|pg|ph|pk|pl|pm|pn|pr|ps|pt|pw|py|qa|re|ro|rs|ru|rw|sa|sb|sc|sd|se|sg|sh|si|sj|sk|sl|sm|sn|so|sr|st|su|sv|sx|sy|sz|tc|td|tf|tg|th|tj|tk|tl|tm|tn|to|tp|tr|tt|tv|tw|tz|ua|ug|uk|us|uy|uz|va|vc|ve|vg|vi|vn|vu|wf|ws|ye|yt|za|zm|zw)\b/,   // match our known top level domains (TLDs)

                // Allow optional path, query string, and hash anchor, not ending in the following characters: "!:,.;"
                // http://blog.codinghorror.com/the-problem-with-urls/
                urlSuffixRegex = /(?:[\-A-Za-z0-9+&@#\/%?=~_()|!:,.;]*[\-A-Za-z0-9+&@#\/%=~_()|])?/;  // note: optional part of the full regex

            return new RegExp([
                '(',  // *** Capturing group $1, which can be used to check for a twitter handle match. Use group $3 for the actual twitter handle though. $2 may be used to reconstruct the original string in a replace()
                // *** Capturing group $2, which matches the whitespace character before the '@' sign (needed because of no lookbehinds), and
                // *** Capturing group $3, which matches the actual twitter handle
                twitterRegex.source,
                ')',

                '|',

                '(',  // *** Capturing group $4, which is used to determine an email match
                emailRegex.source,
                domainNameRegex.source,
                tldRegex.source,
                ')',

                '|',

                '(',  // *** Capturing group $5, which is used to match a URL
                '(?:', // parens to cover match for protocol (optional), and domain
                '(?:',  // non-capturing paren for a protocol-prefixed url (ex: http://google.com)
                protocolRegex.source,
                domainNameRegex.source,
                ')',

                '|',

                '(?:',  // non-capturing paren for a 'www.' prefixed url (ex: www.google.com)
                '(.?//)?',  // *** Capturing group $6 for an optional protocol-relative URL. Must be at the beginning of the string or start with a non-word character
                wwwRegex.source,
                domainNameRegex.source,
                ')',

                '|',

                '(?:',  // non-capturing paren for known a TLD url (ex: google.com)
                '(.?//)?',  // *** Capturing group $7 for an optional protocol-relative URL. Must be at the beginning of the string or start with a non-word character
                domainNameRegex.source,
                tldRegex.source,
                ')',
                ')',

                urlSuffixRegex.source,  // match for path, query string, and/or hash anchor
                ')'
            ].join(""), 'gi');
        })(),

        /**
         * @private
         * @property {RegExp} protocolRelativeRegex
         *
         * The regular expression used to find protocol-relative URLs. A protocol-relative URL is, for example, "//yahoo.com"
         *
         * This regular expression needs to match the character before the '//', in order to determine if we should actually
         * autolink a protocol-relative URL. For instance, we want to autolink something like "//google.com", but we
         * don't want to autolink something like "abc//google.com"
         */
        protocolRelativeRegex: /(.)?\/\//,

        /**
         * @private
         * @property {RegExp} htmlRegex
         *
         * The regular expression used to pull out HTML tags from a string. Handles namespaced HTML tags and
         * attribute names, as specified by http://www.w3.org/TR/html-markup/syntax.html.
         *
         * Capturing groups:
         *
         * 1. If it is an end tag, this group will have the '/'.
         * 2. The tag name.
         */
        htmlRegex: (function () {
            var tagNameRegex = /[0-9a-zA-Z:]+/,
                attrNameRegex = /[^\s\0"'>\/=\x01-\x1F\x7F]+/,   // the unicode range accounts for excluding control chars, and the delete char
                attrValueRegex = /(?:".*?"|'.*?'|[^'"=<>`\s]+)/; // double quoted, single quoted, or unquoted attribute values

            return new RegExp([
                '<(/)?',  // Beginning of a tag. Either '<' for a start tag, or '</' for an end tag. The slash or an empty string is Capturing Group 1.

                // The tag name (Capturing Group 2)
                '(' + tagNameRegex.source + ')',

                // Zero or more attributes following the tag name
                '(?:',
                '\\s+',  // one or more whitespace chars before an attribute
                attrNameRegex.source,
                '(?:\\s*=\\s*' + attrValueRegex.source + ')?',  // optional '=[value]'
                ')*',

                '\\s*',  // any trailing spaces before the closing '>'
                '>'
            ].join(""), 'g');
        })(),

        /**
         * @private
         * @property {RegExp} urlPrefixRegex
         *
         * A regular expression used to remove the 'http://' or 'https://' and/or the 'www.' from URLs.
         */
        urlPrefixRegex: /^(https?:\/\/)?(www\.)?/i,


        /**
         * Automatically links URLs, email addresses, and Twitter handles found in the given chunk of HTML.
         * Does not link URLs found within HTML tags.
         *
         * For instance, if given the text: `You should go to http://www.yahoo.com`, then the result
         * will be `You should go to &lt;a href="http://www.yahoo.com"&gt;http://www.yahoo.com&lt;/a&gt;`
         *
         * @method link
         * @param {String} textOrHtml The HTML or text to link URLs, email addresses, and Twitter handles within.
         * @return {String} The HTML, with URLs/emails/twitter handles automatically linked.
         */
        link: function (textOrHtml) {
            return this.processHtml(textOrHtml);
        },


        /**
         * Processes the given HTML to auto-link URLs/emails/Twitter handles.
         *
         * Finds the text around any HTML elements in the input `html`, which will be the text that is processed.
         * Any original HTML elements will be left as-is, as well as the text that is already wrapped in anchor tags.
         *
         * @private
         * @method processHtml
         * @param {String} html The input text or HTML to process in order to auto-link.
         * @return {String}
         */
        processHtml: function (html) {
            // Loop over the HTML string, ignoring HTML tags, and processing the text that lies between them,
            // wrapping the URLs in anchor tags
            var htmlRegex = this.htmlRegex,
                currentResult,
                inBetweenTagsText,
                lastIndex = 0,
                anchorTagStackCount = 0,
                resultHtml = [];

            while ((currentResult = htmlRegex.exec(html)) !== null) {
                var tagText = currentResult[0],
                    tagName = currentResult[2],
                    isClosingTag = !!currentResult[1];

                inBetweenTagsText = html.substring(lastIndex, currentResult.index);
                lastIndex = currentResult.index + tagText.length;

                // Process around anchor tags, and any inner text / html they may have
                if (tagName === 'a') {
                    if (!isClosingTag) {  // it's the start <a> tag
                        anchorTagStackCount++;
                        resultHtml.push(this.processTextNode(inBetweenTagsText));

                    } else {   // it's the end </a> tag
                        anchorTagStackCount = Math.max(anchorTagStackCount - 1, 0);  // attempt to handle extraneous </a> tags by making sure the stack count never goes below 0
                        if (anchorTagStackCount === 0) {
                            resultHtml.push(inBetweenTagsText);  // We hit the matching </a> tag, simply add all of the text from the start <a> tag to the end </a> tag without linking it
                        }
                    }

                } else if (anchorTagStackCount === 0) {   // not within an anchor tag, link the "in between" text
                    resultHtml.push(this.processTextNode(inBetweenTagsText));

                } else {
                    // if we have a tag that is in between anchor tags (ex: <a href="..."><b>google.com</b></a>),
                    // just append the inner text
                    resultHtml.push(inBetweenTagsText);
                }

                resultHtml.push(tagText);  // now add the text of the tag itself verbatim
            }

            // Process any remaining text after the last HTML element. Will process all of the text if there were no HTML elements.
            if (lastIndex < html.length) {
                var processedTextNode = this.processTextNode(html.substring(lastIndex));
                resultHtml.push(processedTextNode);
            }

            return resultHtml.join("");
        },


        /**
         * Process the text that lies inbetween HTML tags. This method does the actual wrapping of URLs with
         * anchor tags.
         *
         * @private
         * @param {String} text The text to auto-link.
         * @return {String} The text with anchor tags auto-filled.
         */
        processTextNode: function (text) {
            var me = this,  // for closures
                matcherRegex = this.matcherRegex,
                enableTwitter = this.twitter,
                enableEmailAddresses = this.email,
                enableUrls = this.urls;

            return text.replace(matcherRegex, function (matchStr, $1, $2, $3, $4, $5, $6, $7) {
                var twitterMatch = $1,
                    twitterHandlePrefixWhitespaceChar = $2,  // The whitespace char before the @ sign in a Twitter handle match. This is needed because of no lookbehinds in JS regexes
                    twitterHandle = $3,   // The actual twitterUser (i.e the word after the @ sign in a Twitter handle match)
                    emailAddress = $4,    // For both determining if it is an email address, and stores the actual email address
                    urlMatch = $5,        // The matched URL string
                    protocolRelativeMatch = $6 || $7,  // The '//' for a protocol-relative match, with the character that comes before the '//'

                    prefixStr = "",       // A string to use to prefix the anchor tag that is created. This is needed for the Twitter handle match
                    suffixStr = "";       // A string to suffix the anchor tag that is created. This is used if there is a trailing parenthesis that should not be auto-linked.

                // Early exits with no replacements for:
                // 1) Disabled link types
                // 2) URL matches which do not have at least have one period ('.') in the domain name (effectively skipping over
                //    matches like "abc:def")
                // 3) A protocol-relative url match (a URL beginning with '//') whose previous character is a word character
                //    (effectively skipping over strings like "abc//google.com")
                if (
                    (twitterMatch && !enableTwitter) || (emailAddress && !enableEmailAddresses) || (urlMatch && !enableUrls) ||
                    (urlMatch && urlMatch.indexOf('.') === -1) ||  // At least one period ('.') must exist in the URL match for us to consider it an actual URL
                    (urlMatch && /^[A-Za-z]{3,9}:/.test(urlMatch) && !/:.*?[A-Za-z]/.test(urlMatch)) ||  // At least one letter character must exist in the domain name after a protocol match. Ex: skip over something like "git:1.0"
                    (protocolRelativeMatch && /^[\w]\/\//.test(protocolRelativeMatch))  // a protocol-relative match which has a word character in front of it (so we can skip something like "abc//google.com")
                ) {
                    return matchStr;
                }


                // Handle a closing parenthesis at the end of the match, and exclude it if there is not a matching open parenthesis
                // in the match. This handles cases like the string "wikipedia.com/something_(disambiguation)" (which should be auto-
                // linked, and when it is enclosed in parenthesis itself, such as: "(wikipedia.com/something_(disambiguation))" (in
                // which the outer parens should *not* be auto-linked.
                var lastChar = matchStr.charAt(matchStr.length - 1);
                if (lastChar === ')') {
                    var openParensMatch = matchStr.match(/\(/g),
                        closeParensMatch = matchStr.match(/\)/g),
                        numOpenParens = (openParensMatch && openParensMatch.length) || 0,
                        numCloseParens = (closeParensMatch && closeParensMatch.length) || 0;

                    if (numOpenParens < numCloseParens) {
                        matchStr = matchStr.substr(0, matchStr.length - 1);  // remove the trailing ")"
                        suffixStr = ")";  // this will be added after the <a> tag
                    }
                }


                var anchorHref = matchStr,  // initialize both of these
                    anchorText = matchStr,  // values as the full match
                    linkType;

                // Process the urls that are found. We need to change URLs like "www.yahoo.com" to "http://www.yahoo.com" (or the browser
                // will try to direct the user to "http://current-domain.com/www.yahoo.com"), and we need to prefix 'mailto:' to email addresses.
                if (twitterMatch) {
                    linkType = 'twitter';
                    prefixStr = twitterHandlePrefixWhitespaceChar;
                    anchorHref = 'https://twitter.com/' + twitterHandle;
                    anchorText = '@' + twitterHandle;

                } else if (emailAddress) {
                    linkType = 'email';
                    anchorHref = 'mailto:' + emailAddress;
                    anchorText = emailAddress;

                } else {  // url match
                    linkType = 'url';

                    if (protocolRelativeMatch) {
                        // Strip off any protocol-relative '//' from the anchor text (leaving the previous non-word character
                        // intact, if there is one)
                        var protocolRelRegex = new RegExp("^" + me.protocolRelativeRegex.source),  // for this one, we want to only match at the beginning of the string
                            charBeforeMatch = protocolRelativeMatch.match(protocolRelRegex)[1] || "";

                        prefixStr = charBeforeMatch + prefixStr;  // re-add the character before the '//' to what will be placed before the <a> tag
                        anchorHref = anchorHref.replace(protocolRelRegex, "//");  // remove the char before the match for the href
                        anchorText = anchorText.replace(protocolRelRegex, "");    // remove both the char before the match and the '//' for the anchor text

                    } else if (!/^[A-Za-z]{3,9}:/i.test(anchorHref)) {
                        // url string doesn't begin with a protocol, assume http://
                        anchorHref = 'http://' + anchorHref;
                    }
                }

                // wrap the match in an anchor tag
                var anchorTag = me.createAnchorTag(linkType, anchorHref, anchorText);
                return prefixStr + anchorTag + suffixStr;
            });
        },


        /**
         * Generates the actual anchor (&lt;a&gt;) tag to use in place of a source url/email/twitter link.
         *
         * @private
         * @param {"url"/"email"/"twitter"} linkType The type of link that an anchor tag is being generated for.
         * @param {String} anchorHref The href for the anchor tag.
         * @param {String} anchorText The anchor tag's text (i.e. what will be displayed).
         * @return {String} The full HTML for the anchor tag.
         */
        createAnchorTag: function (linkType, anchorHref, anchorText) {
            var attributesStr = this.createAnchorAttrsStr(linkType, anchorHref);
            anchorText = this.processAnchorText(anchorText);

            return '<a ' + attributesStr + '>' + anchorText + '</a>';
        },


        /**
         * Creates the string which will be the HTML attributes for the anchor (&lt;a&gt;) tag being generated.
         *
         * @private
         * @param {"url"/"email"/"twitter"} linkType The type of link that an anchor tag is being generated for.
         * @param {String} href The href for the anchor tag.
         * @return {String} The anchor tag's attribute. Ex: `href="http://google.com" class="myLink myLink-url" target="_blank"`
         */
        createAnchorAttrsStr: function (linkType, anchorHref) {
            var attrs = ['href="' + anchorHref + '"'];  // we'll always have the `href` attribute

            var cssClass = this.createCssClass(linkType);
            if (cssClass) {
                attrs.push('class="' + cssClass + '"');
            }
            if (this.newWindow) {
                if (anchorHref.match(/(?:mailto:)/) == null) {
                    attrs.push('target="_blank"');
                }
            }

            return attrs.join(" ");
        },


        /**
         * Creates the CSS class that will be used for a given anchor tag, based on the `linkType` and the {@link #className}
         * config.
         *
         * @private
         * @param {"url"/"email"/"twitter"} linkType The type of link that an anchor tag is being generated for.
         * @return {String} The CSS class string for the link. Example return: "myLink myLink-url". If no {@link #className}
         *   was configured, returns an empty string.
         */
        createCssClass: function (linkType) {
            var className = this.className;

            if (!className)
                return "";
            else
                return className + " " + className + "-" + linkType;  // ex: "myLink myLink-url", "myLink myLink-email", or "myLink myLink-twitter"
        },


        /**
         * Processes the `anchorText` by stripping the URL prefix (if {@link #stripPrefix} is `true`), removing
         * any trailing slash, and truncating the text according to the {@link #truncate} config.
         *
         * @private
         * @param {String} anchorText The anchor tag's text (i.e. what will be displayed).
         * @return {String} The processed `anchorText`.
         */
        processAnchorText: function (anchorText) {
            if (this.stripPrefix) {
                anchorText = this.stripUrlPrefix(anchorText);
            }
            anchorText = this.removeTrailingSlash(anchorText);  // remove trailing slash, if there is one
            anchorText = this.doTruncate(anchorText);

            return anchorText;
        },


        /**
         * Strips the URL prefix (such as "http://" or "https://") from the given text.
         *
         * @private
         * @param {String} text The text of the anchor that is being generated, for which to strip off the
         *   url prefix (such as stripping off "http://")
         * @return {String} The `anchorText`, with the prefix stripped.
         */
        stripUrlPrefix: function (text) {
            return text.replace(this.urlPrefixRegex, '');
        },


        /**
         * Removes any trailing slash from the given `anchorText`, in prepration for the text to be displayed.
         *
         * @private
         * @param {String} anchorText The text of the anchor that is being generated, for which to remove any trailing
         *   slash ('/') that may exist.
         * @return {String} The `anchorText`, with the trailing slash removed.
         */
        removeTrailingSlash: function (anchorText) {
            if (anchorText.charAt(anchorText.length - 1) === '/') {
                anchorText = anchorText.slice(0, -1);
            }
            return anchorText;
        },


        /**
         * Performs the truncation of the `anchorText`, if the `anchorText` is longer than the {@link #truncate} option.
         * Truncates the text to 2 characters fewer than the {@link #truncate} option, and adds ".." to the end.
         *
         * @private
         * @param {String} text The anchor tag's text (i.e. what will be displayed).
         * @return {String} The truncated anchor text.
         */
        doTruncate: function (anchorText) {
            var truncateLen = this.truncate;

            // Truncate the anchor text if it is longer than the provided 'truncate' option
            if (truncateLen && anchorText.length > truncateLen) {
                anchorText = anchorText.substring(0, truncateLen - 2) + '..';
            }
            return anchorText;
        }

    };


    /**
     * Automatically links URLs, email addresses, and Twitter handles found in the given chunk of HTML.
     * Does not link URLs found within HTML tags.
     *
     * For instance, if given the text: `You should go to http://www.yahoo.com`, then the result
     * will be `You should go to &lt;a href="http://www.yahoo.com"&gt;http://www.yahoo.com&lt;/a&gt;`
     *
     * Example:
     *
     *     var linkedText = Autolinker.link( "Go to google.com", { newWindow: false } );
     *     // Produces: "Go to <a href="http://google.com">google.com</a>"
     *
     * @static
     * @method link
     * @param {String} html The HTML text to link URLs within.
     * @param {Object} [options] Any of the configuration options for the Autolinker class, specified in an Object (map).
     *   See the class description for an example call.
     * @return {String} The HTML text, with URLs automatically linked
     */
    Autolinker.link = function (text, options) {
        var autolinker = new Autolinker(options);
        return autolinker.link(text);
    };


    return Autolinker;

}));
;
/***********************************************
Copyright 2010 - 2012 Chris Winberry <chris@winberry.net>. All rights reserved.
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to
deal in the Software without restriction, including without limitation the
rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
sell copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
IN THE SOFTWARE.
***********************************************/
/* v2.0.0 */

(function () {

    var exports;
    if (typeof (module) !== 'undefined' && typeof (module.exports) !== 'undefined') {
        exports = module.exports;
    } else {
        exports = {};
        if (!this.Tautologistics) {
            this.Tautologistics = {};
        }
        if (this.Tautologistics.NodeHtmlParser) {
            return;
        }
        this.Tautologistics.NodeHtmlParser = exports;
    }

    function inherits(ctor, superCtor) {
        var tempCtor = function () { };
        tempCtor.prototype = superCtor.prototype;
        ctor.super_ = superCtor;
        ctor.prototype = new tempCtor();
        ctor.prototype.constructor = ctor;
    }

    var Mode = {
        Text: 'text',
        Tag: 'tag',
        Attr: 'attr',
        CData: 'cdata',
        Doctype: 'doctype',
        Comment: 'comment'
    };

    function Parser(builder, options) {
        this._options = options ? options : {};
        // if (this._options.includeLocation === undefined) {
        //     this._options.includeLocation = false; //Include position of element (row, col) on nodes
        // }
        this._validateBuilder(builder);
        var self = this;
        this._builder = builder;
        this.reset();
    }

    if (typeof (module) !== 'undefined' && typeof (module.exports) !== 'undefined') {

        var Stream = require('stream');
        inherits(Parser, Stream);

        Parser.prototype.writable = true;
        Parser.prototype.write = function (data) {
            if (data instanceof Buffer) {
                data = data.toString();
            }
            this.parseChunk(data);
        };

        Parser.prototype.end = function (data) {
            if (arguments.length) {
                this.write(data);
            }
            this.writable = false;
            this.done();
        };

        Parser.prototype.destroy = function () {
            this.writable = false;
        };

    }

    //**Public**//
    Parser.prototype.reset = function Parser$reset() {
        this._state = {
            mode: Mode.Text,
            pos: 0,
            data: null,
            pendingText: null,
            pendingWrite: null,
            lastTag: null,
            isScript: false,
            needData: false,
            output: [],
            done: false//,
            // line: 1,
            // col: 1
        };
        this._builder.reset();
    };

    Parser.prototype.parseChunk = function Parser$parseChunk(chunk) {
        this._state.needData = false;
        this._state.data = (this._state.data !== null) ?
            this._state.data.substr(this.pos) + chunk
            :
            chunk
            ;
        while (this._state.pos < this._state.data.length && !this._state.needData) {
            this._parse(this._state);
        }
    };

    Parser.prototype.parseComplete = function Parser$parseComplete(data) {
        this.reset();
        this.parseChunk(data);
        this.done();
    };

    Parser.prototype.done = function Parser$done() {
        this._state.done = true;
        this._parse(this._state);
        this._flushWrite();
        this._builder.done();
    };

    //**Private**//
    Parser.prototype._validateBuilder = function Parser$_validateBuilder(builder) {
        if ((typeof builder) != "object") {
            throw new Error("Builder is not an object");
        }
        if ((typeof builder.reset) != "function") {
            throw new Error("Builder method 'reset' is invalid");
        }
        if ((typeof builder.done) != "function") {
            throw new Error("Builder method 'done' is invalid");
        }
        if ((typeof builder.write) != "function") {
            throw new Error("Builder method 'write' is invalid");
        }
        if ((typeof builder.error) != "function") {
            throw new Error("Builder method 'error' is invalid");
        }
    };

    Parser.prototype._parse = function Parser$_parse() {
        switch (this._state.mode) {
            case Mode.Text:
                return this._parseText(this._state);
            case Mode.Tag:
                return this._parseTag(this._state);
            case Mode.Attr:
                return this._parseAttr(this._state);
            case Mode.CData:
                return this._parseCData(this._state);
            case Mode.Doctype:
                return this._parseDoctype(this._state);
            case Mode.Comment:
                return this._parseComment(this._state);
        }
    };

    Parser.prototype._writePending = function Parser$_writePending(node) {
        if (!this._state.pendingWrite) {
            this._state.pendingWrite = [];
        }
        this._state.pendingWrite.push(node);
    };

    Parser.prototype._flushWrite = function Parser$_flushWrite() {
        if (this._state.pendingWrite) {
            for (var i = 0, len = this._state.pendingWrite.length; i < len; i++) {
                var node = this._state.pendingWrite[i];
                this._builder.write(node);
            }
            this._state.pendingWrite = null;
        }
    };

    Parser.prototype._write = function Parser$_write(node) {
        this._flushWrite();
        this._builder.write(node);
    };

    Parser._re_parseText_scriptClose = /<\s*\/\s*script/ig;
    Parser.prototype._parseText = function Parser$_parseText() {
        var state = this._state;
        var foundPos;
        if (state.isScript) {
            Parser._re_parseText_scriptClose.lastIndex = state.pos;
            foundPos = Parser._re_parseText_scriptClose.exec(state.data);
            foundPos = (foundPos) ?
                foundPos.index
                :
                -1
                ;
        } else {
            foundPos = state.data.indexOf('<', state.pos);
        }
        var text = (foundPos === -1) ? state.data.substring(state.pos, state.data.length) : state.data.substring(state.pos, foundPos);
        if (foundPos < 0 && state.done) {
            foundPos = state.data.length;
        }
        if (foundPos < 0) {
            if (state.isScript) {
                state.needData = true;
                return;
            }
            if (!state.pendingText) {
                state.pendingText = [];
            }
            state.pendingText.push(state.data.substring(state.pos, state.data.length));
            state.pos = state.data.length;
        } else {
            if (state.pendingText) {
                state.pendingText.push(state.data.substring(state.pos, foundPos));
                text = state.pendingText.join('');
                state.pendingText = null;
            } else {
                text = state.data.substring(state.pos, foundPos);
            }
            if (text !== '') {
                this._write({ type: Mode.Text, data: text });
            }
            state.pos = foundPos + 1;
            state.mode = Mode.Tag;
        }
    };

    Parser.re_parseTag = /\s*(\/?)\s*([^\s>\/]+)(\s*)\??(>?)/g;
    Parser.prototype._parseTag = function Parser$_parseTag() {
        var state = this._state;
        Parser.re_parseTag.lastIndex = state.pos;
        var match = Parser.re_parseTag.exec(state.data);
        if (match) {
            if (!match[1] && match[2].substr(0, 3) === '!--') {
                state.mode = Mode.Comment;
                state.pos += 3;
                return;
            }
            if (!match[1] && match[2].substr(0, 8) === '![CDATA[') {
                state.mode = Mode.CData;
                state.pos += 8;
                return;
            }
            if (!match[1] && match[2].substr(0, 8) === '!DOCTYPE') {
                state.mode = Mode.Doctype;
                state.pos += 8;
                return;
            }
            if (!state.done && (state.pos + match[0].length) === state.data.length) {
                //We're at the and of the data, might be incomplete
                state.needData = true;
                return;
            }
            var raw;
            if (match[4] === '>') {
                state.mode = Mode.Text;
                raw = match[0].substr(0, match[0].length - 1);
            } else {
                state.mode = Mode.Attr;
                raw = match[0];
            }
            state.pos += match[0].length;
            var tag = { type: Mode.Tag, name: match[1] + match[2], raw: raw };
            if (state.mode === Mode.Attr) {
                state.lastTag = tag;
            }
            if (tag.name.toLowerCase() === 'script') {
                state.isScript = true;
            } else if (tag.name.toLowerCase() === '/script') {
                state.isScript = false;
            }
            if (state.mode === Mode.Attr) {
                this._writePending(tag);
            } else {
                this._write(tag);
            }
        } else {
            //TODO: end of tag?
            //TODO: push to pending?
            state.needData = true;
        }
    };

    Parser.re_parseAttr_findName = /\s*([^=<>\s'"\/]+)\s*/g;
    Parser.prototype._parseAttr_findName = function Parser$_parseAttr_findName() {
        Parser.re_parseAttr_findName.lastIndex = this._state.pos;
        var match = Parser.re_parseAttr_findName.exec(this._state.data);
        if (!match) {
            return null;
        }
        if (this._state.pos + match[0].length !== Parser.re_parseAttr_findName.lastIndex) {
            return null;
        }
        return {
            match: match[0]
            , name: match[1]
        };
    };
    Parser.re_parseAttr_findValue = /\s*=\s*(?:'([^']*)'|"([^"]*)"|([^'"\s\/>]+))\s*/g;
    Parser.re_parseAttr_findValue_last = /\s*=\s*['"]?(.*)$/g;
    Parser.prototype._parseAttr_findValue = function Parser$_parseAttr_findValue() {
        var state = this._state;
        Parser.re_parseAttr_findValue.lastIndex = state.pos;
        var match = Parser.re_parseAttr_findValue.exec(state.data);
        if (!match) {
            if (!state.done) {
                return null;
            }
            Parser.re_parseAttr_findValue_last.lastIndex = state.pos;
            match = Parser.re_parseAttr_findValue_last.exec(state.data);
            if (!match) {
                return null;
            }
            return {
                match: match[0]
                , value: (match[1] !== '') ? match[1] : null
            };
        }
        if (state.pos + match[0].length !== Parser.re_parseAttr_findValue.lastIndex) {
            return null;
        }
        return {
            match: match[0]
            , value: match[1] || match[2] || match[3]
        };
    };
    Parser.re_parseAttr_splitValue = /\s*=\s*['"]?/g;
    Parser.re_parseAttr_selfClose = /(\s*\/\s*)(>?)/g;
    Parser.prototype._parseAttr = function Parser$_parseAttr() {
        var state = this._state;
        var name_data = this._parseAttr_findName(state);
        if (!name_data || name_data.name === '?') {
            Parser.re_parseAttr_selfClose.lastIndex = state.pos;
            var matchTrailingSlash = Parser.re_parseAttr_selfClose.exec(state.data);
            if (matchTrailingSlash && matchTrailingSlash.index === state.pos) {
                if (!state.done && !matchTrailingSlash[2] && state.pos + matchTrailingSlash[0].length === state.data.length) {
                    state.needData = true;
                    return;
                }
                state.lastTag.raw += matchTrailingSlash[1];
                // state.output.push({ type: Mode.Tag, name: '/' + state.lastTag.name, raw: null });
                this._write({ type: Mode.Tag, name: '/' + state.lastTag.name, raw: null });
                state.pos += matchTrailingSlash[1].length;
            }
            var foundPos = state.data.indexOf('>', state.pos);
            if (foundPos < 0) {
                if (state.done) { //TODO: is this needed?
                    state.lastTag.raw += state.data.substr(state.pos);
                    state.pos = state.data.length;
                    return;
                }
                state.needData = true;
            } else {
                // state.lastTag = null;
                state.pos = foundPos + 1;
                state.mode = Mode.Text;
            }
            return;
        }
        if (!state.done && state.pos + name_data.match.length === state.data.length) {
            state.needData = true;
            return null;
        }
        state.pos += name_data.match.length;
        var value_data = this._parseAttr_findValue(state);
        if (value_data) {
            if (!state.done && state.pos + value_data.match.length === state.data.length) {
                state.needData = true;
                state.pos -= name_data.match.length;
                return;
            }
            state.pos += value_data.match.length;
        } else {
            Parser.re_parseAttr_splitValue.lastIndex = state.pos;
            if (Parser.re_parseAttr_splitValue.exec(state.data)) {
                state.needData = true;
                state.pos -= name_data.match.length;
                return;
            }
            value_data = {
                match: ''
                , value: null
            };
        }
        state.lastTag.raw += name_data.match + value_data.match;

        this._writePending({ type: Mode.Attr, name: name_data.name, data: value_data.value });
    };

    Parser.re_parseCData_findEnding = /\]{1,2}$/;
    Parser.prototype._parseCData = function Parser$_parseCData() {
        var state = this._state;
        var foundPos = state.data.indexOf(']]>', state.pos);
        if (foundPos < 0 && state.done) {
            foundPos = state.data.length;
        }
        if (foundPos < 0) {
            Parser.re_parseCData_findEnding.lastIndex = state.pos;
            var matchPartialCDataEnd = Parser.re_parseCData_findEnding.exec(state.data);
            if (matchPartialCDataEnd) {
                state.needData = true;
                return;
            }
            if (!state.pendingText) {
                state.pendingText = [];
            }
            state.pendingText.push(state.data.substr(state.pos, state.data.length));
            state.pos = state.data.length;
            state.needData = true;
        } else {
            var text;
            if (state.pendingText) {
                state.pendingText.push(state.data.substring(state.pos, foundPos));
                text = state.pendingText.join('');
                state.pendingText = null;
            } else {
                text = state.data.substring(state.pos, foundPos);
            }
            this._write({ type: Mode.CData, data: text });
            state.mode = Mode.Text;
            state.pos = foundPos + 3;
        }
    };

    Parser.prototype._parseDoctype = function Parser$_parseDoctype() {
        var state = this._state;
        var foundPos = state.data.indexOf('>', state.pos);
        if (foundPos < 0 && state.done) {
            foundPos = state.data.length;
        }
        if (foundPos < 0) {
            Parser.re_parseCData_findEnding.lastIndex = state.pos;
            if (!state.pendingText) {
                state.pendingText = [];
            }
            state.pendingText.push(state.data.substr(state.pos, state.data.length));
            state.pos = state.data.length;
            state.needData = true;
        } else {
            var text;
            if (state.pendingText) {
                state.pendingText.push(state.data.substring(state.pos, foundPos));
                text = state.pendingText.join('');
                state.pendingText = null;
            } else {
                text = state.data.substring(state.pos, foundPos);
            }
            this._write({ type: Mode.Doctype, data: text });
            state.mode = Mode.Text;
            state.pos = foundPos + 1;
        }
    };

    Parser.re_parseComment_findEnding = /\-{1,2}$/;
    Parser.prototype._parseComment = function Parser$_parseComment() {
        var state = this._state;
        var foundPos = state.data.indexOf('-->', state.pos);
        if (foundPos < 0 && state.done) {
            foundPos = state.data.length;
        }
        if (foundPos < 0) {
            Parser.re_parseComment_findEnding.lastIndex = state.pos;
            var matchPartialCommentEnd = Parser.re_parseComment_findEnding.exec(state.data);
            if (matchPartialCommentEnd) {
                state.needData = true;
                return;
            }
            if (!state.pendingText) {
                state.pendingText = [];
            }
            state.pendingText.push(state.data.substr(state.pos, state.data.length));
            state.pos = state.data.length;
            state.needData = true;
        } else {
            var text;
            if (state.pendingText) {
                state.pendingText.push(state.data.substring(state.pos, foundPos));
                text = state.pendingText.join('');
                state.pendingText = null;
            } else {
                text = state.data.substring(state.pos, foundPos);
            }
            // state.output.push({ type: Mode.Comment, data: text });
            this._write({ type: Mode.Comment, data: text });
            state.mode = Mode.Text;
            state.pos = foundPos + 3;
        }
    };


    function HtmlBuilder(callback, options) {
        this.reset();
        this._options = options ? options : {};
        if (this._options.ignoreWhitespace === undefined) {
            this._options.ignoreWhitespace = false; //Keep whitespace-only text nodes
        }
        if (this._options.includeLocation === undefined) {
            this._options.includeLocation = false; //Include position of element (row, col) on nodes
        }
        if (this._options.verbose === undefined) {
            this._options.verbose = true; //Keep data property for tags and raw property for all
        }
        if (this._options.enforceEmptyTags === undefined) {
            this._options.enforceEmptyTags = true; //Don't allow children for HTML tags defined as empty in spec
        }
        if (this._options.caseSensitiveTags === undefined) {
            this._options.caseSensitiveTags = false; //Lowercase all tag names
        }
        if (this._options.caseSensitiveAttr === undefined) {
            this._options.caseSensitiveAttr = false; //Lowercase all attribute names
        }
        if ((typeof callback) == "function") {
            this._callback = callback;
        }
    }

    //**"Static"**//
    //HTML Tags that shouldn't contain child nodes
    HtmlBuilder._emptyTags = {
        area: 1
        , base: 1
        , basefont: 1
        , br: 1
        , col: 1
        , frame: 1
        , hr: 1
        , img: 1
        , input: 1
        , isindex: 1
        , link: 1
        , meta: 1
        , param: 1
        , embed: 1
        , '?xml': 1
    };
    //Regex to detect whitespace only text nodes
    HtmlBuilder.reWhitespace = /^\s*$/;

    //**Public**//
    //Properties//
    HtmlBuilder.prototype.dom = null; //The hierarchical object containing the parsed HTML
    //Methods//
    //Resets the builder back to starting state
    HtmlBuilder.prototype.reset = function HtmlBuilder$reset() {
        this.dom = [];
        // this._raw = [];
        this._done = false;
        this._tagStack = [];
        this._lastTag = null;
        this._tagStack.last = function HtmlBuilder$_tagStack$last() {
            return (this.length ? this[this.length - 1] : null);
        };
        this._line = 1;
        this._col = 1;
    };
    //Signals the builder that parsing is done
    HtmlBuilder.prototype.done = function HtmlBuilder$done() {
        this._done = true;
        this.handleCallback(null);
    };

    HtmlBuilder.prototype.error = function HtmlBuilder$error(error) {
        this.handleCallback(error);
    };

    HtmlBuilder.prototype.handleCallback = function HtmlBuilder$handleCallback(error) {
        if ((typeof this._callback) != "function") {
            if (error) {
                throw error;
            } else {
                return;
            }
        }
        this._callback(error, this.dom);
    };

    HtmlBuilder.prototype.isEmptyTag = function HtmlBuilder$isEmptyTag(element) {
        var name = element.name.toLowerCase();
        if (name.charAt(0) == '?') {
            return true;
        }
        if (name.charAt(0) == '/') {
            name = name.substring(1);
        }
        return this._options.enforceEmptyTags && !!HtmlBuilder._emptyTags[name];
    };

    HtmlBuilder.prototype._getLocation = function HtmlBuilder$_getLocation() {
        return { line: this._line, col: this._col };
    };

    // HtmlBuilder.reLineSplit = /(\r\n|\r|\n)/g;
    HtmlBuilder.prototype._updateLocation = function HtmlBuilder$_updateLocation(node) {
        var positionData = (node.type === Mode.Tag) ? node.raw : node.data;
        if (positionData === null) {
            return;
        }
        // var lines = positionData.split(HtmlBuilder.reLineSplit);
        var lines = positionData.split("\n");
        this._line += lines.length - 1;
        if (lines.length > 1) {
            this._col = 1;
        }
        this._col += lines[lines.length - 1].length;
        if (node.type === Mode.Tag) {
            this._col += 2;
        } else if (node.type === Mode.Comment) {
            this._col += 7;
        } else if (node.type === Mode.CData) {
            this._col += 12;
        }
    };

    HtmlBuilder.prototype._copyElement = function HtmlBuilder$_copyElement(element) {
        var newElement = { type: element.type };

        if (this._options.verbose && element['raw'] !== undefined) {
            newElement.raw = element.raw;
        }
        if (element['name'] !== undefined) {
            switch (element.type) {

                case Mode.Tag:
                    newElement.name = this._options.caseSensitiveTags ?
                        element.name
                        :
                        element.name.toLowerCase()
                        ;
                    break;

                case Mode.Attr:
                    newElement.name = this._options.caseSensitiveAttr ?
                        element.name
                        :
                        element.name.toLowerCase()
                        ;
                    break;

                default:
                    newElement.name = this._options.caseSensitiveTags ?
                        element.name
                        :
                        element.name.toLowerCase()
                        ;
                    break;

            }
        }
        if (element['data'] !== undefined) {
            newElement.data = element.data;
        }
        if (element.location) {
            newElement.location = { line: element.location.line, col: element.location.col };
        }

        return newElement;
    };

    HtmlBuilder.prototype.write = function HtmlBuilder$write(element) {
        // this._raw.push(element);
        if (this._done) {
            this.handleCallback(new Error("Writing to the builder after done() called is not allowed without a reset()"));
        }
        if (this._options.includeLocation) {
            if (element.type !== Mode.Attr) {
                element.location = this._getLocation();
                this._updateLocation(element);
            }
        }
        if (element.type === Mode.Text && this._options.ignoreWhitespace) {
            if (HtmlBuilder.reWhitespace.test(element.data)) {
                return;
            }
        }
        var parent;
        var node;
        if (!this._tagStack.last()) { //There are no parent elements
            //If the element can be a container, add it to the tag stack and the top level list
            if (element.type === Mode.Tag) {
                if (element.name.charAt(0) != "/") { //Ignore closing tags that obviously don't have an opening tag
                    node = this._copyElement(element);
                    this.dom.push(node);
                    if (!this.isEmptyTag(node)) { //Don't add tags to the tag stack that can't have children
                        this._tagStack.push(node);
                    }
                    this._lastTag = node;
                }
            } else if (element.type === Mode.Attr && this._lastTag) {
                if (!this._lastTag.attributes) {
                    this._lastTag.attributes = {};
                }
                this._lastTag.attributes[this._options.caseSensitiveAttr ? element.name : element.name.toLowerCase()] =
                    element.data;
            } else { //Otherwise just add to the top level list
                this.dom.push(this._copyElement(element));
            }
        } else { //There are parent elements
            //If the element can be a container, add it as a child of the element
            //on top of the tag stack and then add it to the tag stack
            if (element.type === Mode.Tag) {
                if (element.name.charAt(0) == "/") {
                    //This is a closing tag, scan the tagStack to find the matching opening tag
                    //and pop the stack up to the opening tag's parent
                    var baseName = this._options.caseSensitiveTags ?
                        element.name.substring(1)
                        :
                        element.name.substring(1).toLowerCase()
                        ;
                    if (!this.isEmptyTag(element)) {
                        var pos = this._tagStack.length - 1;
                        while (pos > -1 && this._tagStack[pos--].name != baseName) { }
                        if (pos > -1 || this._tagStack[0].name == baseName) {
                            while (pos < this._tagStack.length - 1) {
                                this._tagStack.pop();
                            }
                        }
                    }
                }
                else { //This is not a closing tag
                    parent = this._tagStack.last();
                    if (element.type === Mode.Attr) {
                        if (!parent.attributes) {
                            parent.attributes = {};
                        }
                        parent.attributes[this._options.caseSensitiveAttr ? element.name : element.name.toLowerCase()] =
                            element.data;
                    } else {
                        node = this._copyElement(element);
                        if (!parent.children) {
                            parent.children = [];
                        }
                        parent.children.push(node);
                        if (!this.isEmptyTag(node)) { //Don't add tags to the tag stack that can't have children
                            this._tagStack.push(node);
                        }
                        if (element.type === Mode.Tag) {
                            this._lastTag = node;
                        }
                    }
                }
            }
            else { //This is not a container element
                parent = this._tagStack.last();
                if (element.type === Mode.Attr) {
                    if (!parent.attributes) {
                        parent.attributes = {};
                    }
                    parent.attributes[this._options.caseSensitiveAttr ? element.name : element.name.toLowerCase()] =
                        element.data;
                } else {
                    if (!parent.children) {
                        parent.children = [];
                    }
                    parent.children.push(this._copyElement(element));
                }
            }
        }
    };


    //**Private**//
    //Properties//
    HtmlBuilder.prototype._options = null; //Builder options for how to behave
    HtmlBuilder.prototype._callback = null; //Callback to respond to when parsing done
    HtmlBuilder.prototype._done = false; //Flag indicating whether builder has been notified of parsing completed
    HtmlBuilder.prototype._tagStack = null; //List of parents to the currently element being processed
    //Methods//


    function RssBuilder(callback) {
        RssBuilder.super_.call(this, callback, { ignoreWhitespace: true, verbose: false, enforceEmptyTags: false, caseSensitiveTags: true });
    }
    inherits(RssBuilder, HtmlBuilder);

    RssBuilder.prototype.done = function RssBuilder$done() {
        var feed = {};
        var feedRoot;

        var found = DomUtils.getElementsByTagName(function (value) { return (value == "rss" || value == "feed"); }, this.dom, false);
        if (found.length) {
            feedRoot = found[0];
        }
        if (feedRoot) {
            if (feedRoot.name == "rss") {
                feed.type = "rss";
                feedRoot = feedRoot.children[0]; //<channel/>
                feed.id = "";
                try {
                    feed.title = DomUtils.getElementsByTagName("title", feedRoot.children, false)[0].children[0].data;
                } catch (ex) { }
                try {
                    feed.link = DomUtils.getElementsByTagName("link", feedRoot.children, false)[0].children[0].data;
                } catch (ex) { }
                try {
                    feed.description = DomUtils.getElementsByTagName("description", feedRoot.children, false)[0].children[0].data;
                } catch (ex) { }
                try {
                    feed.updated = new Date(DomUtils.getElementsByTagName("lastBuildDate", feedRoot.children, false)[0].children[0].data);
                } catch (ex) { }
                try {
                    feed.author = DomUtils.getElementsByTagName("managingEditor", feedRoot.children, false)[0].children[0].data;
                } catch (ex) { }
                feed.items = [];
                DomUtils.getElementsByTagName("item", feedRoot.children).forEach(function (item, index, list) {
                    var entry = {};
                    try {
                        entry.id = DomUtils.getElementsByTagName("guid", item.children, false)[0].children[0].data;
                    } catch (ex) { }
                    try {
                        entry.title = DomUtils.getElementsByTagName("title", item.children, false)[0].children[0].data;
                    } catch (ex) { }
                    try {
                        entry.link = DomUtils.getElementsByTagName("link", item.children, false)[0].children[0].data;
                    } catch (ex) { }
                    try {
                        entry.description = DomUtils.getElementsByTagName("description", item.children, false)[0].children[0].data;
                    } catch (ex) { }
                    try {
                        entry.pubDate = new Date(DomUtils.getElementsByTagName("pubDate", item.children, false)[0].children[0].data);
                    } catch (ex) { }
                    feed.items.push(entry);
                });
            } else {
                feed.type = "atom";
                try {
                    feed.id = DomUtils.getElementsByTagName("id", feedRoot.children, false)[0].children[0].data;
                } catch (ex) { }
                try {
                    feed.title = DomUtils.getElementsByTagName("title", feedRoot.children, false)[0].children[0].data;
                } catch (ex) { }
                try {
                    feed.link = DomUtils.getElementsByTagName("link", feedRoot.children, false)[0].attributes.href;
                } catch (ex) { }
                try {
                    feed.description = DomUtils.getElementsByTagName("subtitle", feedRoot.children, false)[0].children[0].data;
                } catch (ex) { }
                try {
                    feed.updated = new Date(DomUtils.getElementsByTagName("updated", feedRoot.children, false)[0].children[0].data);
                } catch (ex) { }
                try {
                    feed.author = DomUtils.getElementsByTagName("email", feedRoot.children, true)[0].children[0].data;
                } catch (ex) { }
                feed.items = [];
                DomUtils.getElementsByTagName("entry", feedRoot.children).forEach(function (item, index, list) {
                    var entry = {};
                    try {
                        entry.id = DomUtils.getElementsByTagName("id", item.children, false)[0].children[0].data;
                    } catch (ex) { }
                    try {
                        entry.title = DomUtils.getElementsByTagName("title", item.children, false)[0].children[0].data;
                    } catch (ex) { }
                    try {
                        entry.link = DomUtils.getElementsByTagName("link", item.children, false)[0].attributes.href;
                    } catch (ex) { }
                    try {
                        entry.description = DomUtils.getElementsByTagName("summary", item.children, false)[0].children[0].data;
                    } catch (ex) { }
                    try {
                        entry.pubDate = new Date(DomUtils.getElementsByTagName("updated", item.children, false)[0].children[0].data);
                    } catch (ex) { }
                    feed.items.push(entry);
                });
            }

            this.dom = feed;
        }
        RssBuilder.super_.prototype.done.call(this);
    };

    var DomUtils = {
        testElement: function DomUtils$testElement(options, element) {
            if (!element) {
                return false;
            }

            for (var key in options) {
                if (!options.hasOwnProperty(key)) {
                    continue;
                }
                if (key == "tag_name") {
                    if (element.type !== Mode.Tag) {
                        return false;
                    }
                    if (!options["tag_name"](element.name)) {
                        return false;
                    }
                } else if (key == "tag_type") {
                    if (!options["tag_type"](element.type)) {
                        return false;
                    }
                } else if (key == "tag_contains") {
                    if (element.type !== Mode.Text && element.type !== Mode.Comment && element.type !== Mode.CData) {
                        return false;
                    }
                    if (!options["tag_contains"](element.data)) {
                        return false;
                    }
                } else {
                    if (!element.attributes || !options[key](element.attributes[key])) {
                        return false;
                    }
                }
            }

            return true;
        }

        , getElements: function DomUtils$getElements(options, currentElement, recurse, limit) {
            recurse = (recurse === undefined || recurse === null) || !!recurse;
            limit = isNaN(parseInt(limit)) ? -1 : parseInt(limit);

            if (!currentElement) {
                return ([]);
            }

            var found = [];
            var elementList;

            function getTest(checkVal) {
                return function (value) {
                    return (value == checkVal);
                };
            }
            for (var key in options) {
                if ((typeof options[key]) != "function") {
                    options[key] = getTest(options[key]);
                }
            }

            if (DomUtils.testElement(options, currentElement)) {
                found.push(currentElement);
            }

            if (limit >= 0 && found.length >= limit) {
                return (found);
            }

            if (recurse && currentElement.children) {
                elementList = currentElement.children;
            } else if (currentElement instanceof Array) {
                elementList = currentElement;
            } else {
                return (found);
            }

            for (var i = 0; i < elementList.length; i++) {
                found = found.concat(DomUtils.getElements(options, elementList[i], recurse, limit));
                if (limit >= 0 && found.length >= limit) {
                    break;
                }
            }

            return (found);
        }

        , getElementById: function DomUtils$getElementById(id, currentElement, recurse) {
            var result = DomUtils.getElements({ id: id }, currentElement, recurse, 1);
            return (result.length ? result[0] : null);
        }

        , getElementsByTagName: function DomUtils$getElementsByTagName(name, currentElement, recurse, limit) {
            return (DomUtils.getElements({ tag_name: name }, currentElement, recurse, limit));
        }

        , getElementsByTagType: function DomUtils$getElementsByTagType(type, currentElement, recurse, limit) {
            return (DomUtils.getElements({ tag_type: type }, currentElement, recurse, limit));
        }
    };

    exports.Parser = Parser;

    exports.HtmlBuilder = HtmlBuilder;

    exports.RssBuilder = RssBuilder;

    exports.ElementType = Mode;

    exports.DomUtils = DomUtils;

})();
;
// Polyfill taken from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find

if (!Array.prototype.find) {
    Array.prototype.find = function (predicate) {
        if (this === null) {
            throw new TypeError('Array.prototype.find called on null or undefined');
        }
        if (typeof predicate !== 'function') {
            throw new TypeError('predicate must be a function');
        }
        var list = Object(this);
        var length = list.length >>> 0;
        var thisArg = arguments[1];
        var value;

        for (var i = 0; i < length; i++) {
            value = list[i];
            if (predicate.call(thisArg, value, i, list)) {
                return value;
            }
        }
        return undefined;
    };
}
;
// Polyfill taken from https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind
if (!Function.prototype.bind) {
    Function.prototype.bind = function (oThis) {
        if (typeof this !== 'function') {
            // closest thing possible to the ECMAScript 5
            // internal IsCallable function
            throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
        }

        var aArgs = Array.prototype.slice.call(arguments, 1),
            fToBind = this,
            fNOP = function () { },
            fBound = function () {
                return fToBind.apply(this instanceof fNOP
                    ? this
                    : oThis,
                    aArgs.concat(Array.prototype.slice.call(arguments)));
            };

        if (this.prototype) {
            // native functions don't have a prototype
            fNOP.prototype = this.prototype;
        }
        fBound.prototype = new fNOP();

        return fBound;
    };
}
;
(function () {
    var ref, ref1;

    window.RG = {
        Calendar: {
            Units: {}
        },
        Models: {},
        Collections: {},
        Commands: {},
        Controllers: {},
        Popovers: null,
        Renderer: {},
        Factories: {},
        Validators: {},
        DTO: {},
        FSM: {},
        Interactions: {},
        Views: {
            Calendar: {},
            CustomAvailability: {},
            Downtimes: {},
            Dialogs: {},
            Factories: {},
            Filters: {},
            Resource: {},
            Selectors: {}
        },
        Routers: {},
        Support: {},
        Utils: {},
        Parsers: {},
        Variables: {
            lastRenderCall: null,
            colorSets: {},
            DowntimeType: {
                publicHoliday: 'Public holiday',
                vacation: 'Vacation (personal)',
                personalHoliday: 'Holiday (personal)',
                maternity: 'Maternity/paternity leave',
                sick: 'Sick leave',
                compassionate: 'Compassionate leave'
            },
            Validation: {
                Project: {
                    Archived: "Sorry, this project has been archived and can't be scheduled beyond the date when it was archived."
                },
                Client: {
                    Archived: "Sorry, this client has been archived and can't be scheduled beyond the date when it was archived."
                }
            },
            MaximumDowntimeLength: parseInt((ref = window.validationData) != null ? ref['MaximumDowntimeLength'] : void 0) || 365,
            MaximumCustomAvailabilityLength: parseInt((ref1 = window.validationData) != null ? ref1['MaximumCustomAvailabilityLength'] : void 0) || 365
        },
        initialize: function (root) {
            this.router = new RG.Routers.Calendar({
                root: root
            });
            Backbone.history.start();
        },
        scrollToDate: function (date) {
            window.location.hash = date;
        },
        scrollToToday: function () {
            var offsetLeft;
            offsetLeft = $("aside").width() - 1;
            setTimeout(function () {
                return $(window).scrollLeft($(".cal-unit.current").offset().left - offsetLeft);
            }, 500);
        },
        getApiRoot: function () {
            return "/v1/";
        },
        getCurrentAccount: function () {
            return this._currentAccount != null ? this._currentAccount : this._currentAccount = new RG.Models.Account({
                subdomain: window.location.host.substr(0, window.location.host.indexOf(".")),
                downtimes: window.downtimes
            });
        },
        getLayerHeight: function () {
            var ref2;
            if ((ref2 = document.getElementById("calendar")) != null ? ref2.classList.contains("detailed") : void 0) {
                return 72;
            } else {
                return 38;
            }
        },
        getUnitWidth: function () {
            var ref2;
            if ((ref2 = document.getElementById("calendar")) != null ? ref2.classList.contains("detailed") : void 0) {
                return 160;
            } else {
                return 40;
            }
        },
        resizeBookingWidths: function (factor) {
            window.dateController.triggerChange();
            window.resources.each(function (ri) {
                return ri.trigger("change", ri);
            });
        },
        resizeCards: function () {
            if (this.cardResizer == null) {
                this.cardResizer = new RG.Utils.CardResizer;
            }
            RG.backburner.debounce('resizeCards', this.cardResizer.resize, 100);
        },
        getDateAtClientX: function (clientX) {
            var calUnit, calUnits;
            calUnits = Array.prototype.slice.call(document.querySelectorAll(".cal-unit"));
            calUnit = calUnits.find(function (calUnit) {
                var box;
                box = calUnit.getBoundingClientRect();
                return clientX >= box.left && clientX <= box.left + box.width;
            });
            if (!calUnit) {
                if (clientX <= calUnits[0].getBoundingClientRect().left) {
                    calUnit = calUnits[0];
                } else {
                    calUnit = calUnits[calUnits.length - 1];
                }
            }
            return RG.Utils.BookingMerger.getDateFromStr(calUnit.dataset.date);
        },
        getCurrentResource: function () {
            var y;
            y = $("#calendar").hasClass("detailed") ? 180 : 200;
            return RG.getResourceAtClientY(y);
        },
        setCurrentResource: function (resource) {
            var firstCardPosition, lineElement;
            lineElement = $(".resource-line[data-resource-id=" + resource.cid + "]");
            firstCardPosition = $("#calendar").hasClass("detailed") ? 135 : 167;
            $(window).scrollTop(lineElement.offset().top - firstCardPosition);
        },
        getResourceAtClientY: function (clientY) {
            var cardElement;
            cardElement = $(document.elementFromPoint(1, clientY)).closest(".resource");
            return window.resources.find(function (ri) {
                return ri.cid === cardElement.data('resource-id');
            });
        },
        setHoverElement: function (el) {
            var ref2, ref3;
            if (this._currentHover === el) {
                return;
            }
            if ((ref2 = this._currentHover) != null) {
                ref2.classList.remove("hover");
            }
            this._currentHover = el;
            if ((ref3 = this._currentHover) != null) {
                ref3.classList.add("hover");
            }
        },
        updateLongBookings: function () {
            var booking, i, j, len, len1, range, ref2, ref3, resource;
            ref2 = window.resources.models;
            for (i = 0, len = ref2.length; i < len; i++) {
                resource = ref2[i];
                ref3 = resource.bookings.models;
                for (j = 0, len1 = ref3.length; j < len1; j++) {
                    booking = ref3[j];
                    range = booking.getSavedDateRange();
                    if (range.getNumberOfDays() > RG.Utils.numberOfVisibleDays()) {
                        booking.trigger('reset');
                    }
                    null;
                }
            }
        },
        moveToDate: function (date) {
            var element;
            element = $(".cal-unit[data-date=" + (RG.Utils.DateFormatter.getISODate(date)) + "]");
            $(window).scrollLeft(element.offset().left - 250);
        },
        spin: function (target, options) {
            if (options == null) {
                options = {
                    lines: 9,
                    length: 3,
                    width: 2,
                    radius: 2,
                    corners: 1,
                    rotate: 0,
                    speed: 1,
                    shadow: false,
                    hwaccel: false,
                    left: '160px'
                };
            }
            window.requestAnimationFrame((function (_this) {
                return function () {
                    _this.stopSpinners();
                    if (target) {
                        _this.Variables.spinner = new Spinner(options).spin(target);
                    }
                };
            })(this));
        },
        stopSpinners: function () {
            window.requestAnimationFrame((function (_this) {
                return function () {
                    if (_this.Variables.spinner) {
                        _this.Variables.spinner.stop();
                        _this.Variables.spinner = null;
                    }
                };
            })(this));
        },
        getStylesheet: function () {
            if (this._stylesheet) {
                return this._stylesheet;
            }
            return this._stylesheet = (function () {
                var style;
                style = document.createElement("style");
                style.appendChild(document.createTextNode(""));
                document.head.appendChild(style);
                return style.sheet;
            })();
        },
        closeAllSelections: function () {
            var ref2, ref3;
            RG.Utils.select2Close($(".select2-drop-active"), true);
            if ((ref2 = $(".match-type-select.select2-container-active")) != null) {
                if ((ref3 = ref2.data('select2')) != null) {
                    ref3.close();
                }
            }
            $(".filters").removeClass("open");
        },
        closeSelectedOptions: function () {
            var ref2, ref3;
            RG.Utils.select2Close($(".select2-drop-active"), true);
            if ((ref2 = $(".match-type-select.select2-container-active")) != null) {
                if ((ref3 = ref2.data('select2')) != null) {
                    ref3.close();
                }
            }
        },
        clearStaleDropdowns: function () {
            $(".select2-drop-active").select2('enable', false).select2('enable', true);
        },
        closeAllDropdowns: function () {
            $(".years-dropdown").removeClass("open");
            $(".color-by.dropdown").removeClass("open");
            $('.right-menu li.dropdown.open').removeClass('open');
            $(".filters").removeClass("open");
        },
        closeControlDropdowns: function () {
            $('.right-menu li.dropdown.open').removeClass('open');
            $(".years-dropdown").removeClass("open");
            $(".color-by.dropdown").removeClass("open");
        },
        backburner: new backburner.Backburner(['layers', 'resizeCards', 'render', 'renderCheck']),
        getBookingById: function (id) {
            var booking, i, j, len, len1, ref2, ref3, resource;
            ref2 = window.resources.models;
            for (i = 0, len = ref2.length; i < len; i++) {
                resource = ref2[i];
                ref3 = resource.bookings.models;
                for (j = 0, len1 = ref3.length; j < len1; j++) {
                    booking = ref3[j];
                    if (booking.id === id) {
                        return booking;
                    }
                }
            }
        }
    };

}).call(this);
;
(function () {
    RG.Factories.AvailabilityManager = (function () {
        function AvailabilityManager(resource) {
            this.resource = resource;
        }

        AvailabilityManager.prototype.create = function () {
            return new RG.Utils.AvailabilityManager({
                availablePeriods: this.resource.availablePeriods,
                customAvailablePeriods: this.resource.customAvailablePeriods,
                overtimes: this.resource.overtimes,
                downtimes: this.resource.downtimes,
                resource: this.resource,
                timeZone: this.resource.getTimeZone()
            });
        };

        return AvailabilityManager;

    })();

}).call(this);
;
(function () {
    RG.Validators.CustomAvailabilityLengthValidator = (function () {
        function CustomAvailabilityLengthValidator() { }

        CustomAvailabilityLengthValidator.prototype.validate = function (view) {
            if (view.getDateRange().getNumberOfDays() <= RG.Variables.MaximumCustomAvailabilityLength) {
                $(view.el).find(".error").hide();
                return true;
            }
            $(view.el).find(".error").text("Woah there, you're changing the availability for over a year. It is much better to make this type of change to the resource's \"normal availability\" which you can edit in the Resources section. Alternatively, you can make multiple changes here with each one spanning less than a year.").show();
            return false;
        };

        return CustomAvailabilityLengthValidator;

    })();

}).call(this);
;
(function () {
    RG.Validators.DowntimeLengthValidator = (function () {
        function DowntimeLengthValidator() { }

        DowntimeLengthValidator.prototype.validate = function (view) {
            if (view.dateRangeSelector.getDateRange().getNumberOfDays() <= RG.Variables.MaximumDowntimeLength) {
                $(view.el).find(".error").hide();
                return true;
            }
            $(view.el).find(".error").text("Woah there, you're changing the availability for over a year. It is much better to make this type of change to the resource's \"normal availability\" which you can edit in the Resources section. Alternatively, you can make multiple changes here with each one spanning less than a year.").show();
            return false;
        };

        return DowntimeLengthValidator;

    })();

}).call(this);
;
(function () {
    RG.Utils.AvailabilityToggle = (function () {
        AvailabilityToggle.prototype.toggleTitle = function (mode) {
            if (mode) {
                return 'Hide Availability';
            } else {
                return 'Show Availability';
            }
        };

        function AvailabilityToggle(linesView, defaultValue) {
            this.linesView = linesView;
            this.bToggle = new RG.Utils.BinaryToggle(defaultValue, 'availabilityToggle');
            this.title = this.toggleTitle(this.bToggle.mode);
            this.analytics = window.analytics || {
                track: function () {
                    return console.log('Analytics not initialized');
                }
            };
        }

        AvailabilityToggle.prototype.toggle = function () {
            this.bToggle.toggle();
            this.title = this.toggleTitle(this.bToggle.mode);
            this._refreshCalendar();
            return this._track();
        };

        AvailabilityToggle.prototype.shouldRenderUtilisation = function () {
            return this.bToggle.mode;
        };

        AvailabilityToggle.prototype._refreshCalendar = function () {
            return setTimeout((function (_this) {
                return function () {
                    var dateRange, endDate, startDate;
                    startDate = _this.linesView.dateController._startDate();
                    endDate = _this.linesView.dateController._endDate();
                    dateRange = new RG.Utils.DateRange(startDate, endDate);
                    return _this.linesView.collection.each(function (resource) {
                        return resource.availability.trigger('refresh', dateRange);
                    });
                };
            })(this), 0);
        };

        AvailabilityToggle.prototype._track = function () {
            return setTimeout((function (_this) {
                return function () {
                    return _this.analytics.track('Toggled Availability Bar');
                };
            })(this), 1000);
        };

        return AvailabilityToggle;

    })();

}).call(this);
;
(function () {
    RG.Utils.BinaryToggle = (function () {
        function BinaryToggle(mode, storageString) {
            this.mode = mode != null ? mode : false;
            this.storageString = storageString != null ? storageString : 'binaryToggle';
        }

        BinaryToggle.prototype.toggle = function () {
            this.mode = !this.mode;
            return window.rgStorage.set(this.storageString, this.mode);
        };

        return BinaryToggle;

    })();

}).call(this);
;
(function () {
    RG.Utils.BookingDataParser = {
        boot: function (host) {
            var bookingsPromise, bootData, bootstrapPromise, data, requestDate, resourcesPromise;
            this.host = host;
            this.lastPoll = new Date();
            this.pollId = 0;
            this.resourcesToReset = {};
            this.bookingsEtag = this.resourcesEtag = this.downtimesEtag = null;
            this.lastResourceBookingRender = {};
            data = {
                calendar: 1
            };
            if (window.location.hash) {
                data['date'] = window.location.hash.replace('#', '');
            }
            if (data['date']) {
                requestDate = new Date(data['date']);
            } else {
                requestDate = new Date();
            }
            if (isNaN(requestDate)) {
                requestDate = new Date();
            }
            bootData = {};
            bootstrapPromise = Q.promise(function (resolve) {
                //return $.ajax("/schedule/bootstrap", {
                //return $.ajax("/schedule/bootstrap", {
                return $.ajax("http://localhost/EMRMAPI/schedule/resources/bootstrap", {
                    data: data,
                    timeout: 30000,
                    success: function (data, status, xhr) {
                        //var data = { "users": "[{\"id\":147899,\"first_name\":\"Viniston\",\"last_name\":\"Arockiasamy\",\"email\":\"myprivcy2015@gmail.com\",\"image\":\"https://rg-storage-us-east.s3.amazonaws.com/images/user/147899/image/thumb_78433bfc-4f89-4cb3-b35e-bf2ebf46d236.jpg\",\"timezone\":\"Kolkata\",\"last_login_at\":\"2017-12-07T07:36:30.000Z\",\"last_logout_at\":\"2017-12-04T16:55:13.000Z\",\"last_activity_at\":null,\"activation_state\":\"active\",\"created_at\":\"2017-12-04T12:02:01.000Z\",\"updated_at\":\"2017-12-07T12:54:12.000Z\",\"permissions\":\"administrator\",\"booking_rights\":\"manage_all\",\"client_rights\":\"manage_all\",\"project_rights\":\"manage_all\",\"resource_rights\":\"manage_all\",\"report_rights\":\"view\",\"owner\":\"true\"},{\"id\":79043,\"first_name\":\"viniston\",\"last_name\":\"fernando\",\"email\":\"viniston.viniston@gmail.com\",\"image\":\"https://rg-storage-us-east.s3.amazonaws.com/images/user/79043/image/thumb_a7e50de5-0008-4a12-b049-791a340d9fdd.jpg\",\"timezone\":\"Kolkata\",\"last_login_at\":\"2017-12-04T11:58:11.000Z\",\"last_logout_at\":\"2017-12-04T12:00:51.000Z\",\"last_activity_at\":null,\"activation_state\":\"active\",\"created_at\":\"2016-01-18T16:45:57.000Z\",\"updated_at\":\"2017-12-04T11:58:11.000Z\",\"permissions\":\"basic_user\",\"booking_rights\":\"view\",\"client_rights\":\"view\",\"project_rights\":\"view\",\"resource_rights\":\"view\",\"report_rights\":\"view\",\"owner\":\"false\"},{\"id\":148461,\"first_name\":\"A\",\"last_name\":\"B\",\"email\":\"viniston1@gmail.com\",\"image\":\"/images/fallback/user/thumb_default.png\",\"timezone\":\"Kolkata\",\"last_login_at\":null,\"last_logout_at\":null,\"last_activity_at\":null,\"activation_state\":null,\"created_at\":\"2017-12-08T17:06:31.000Z\",\"updated_at\":\"2017-12-08T17:06:31.000Z\",\"permissions\":\"custom\",\"booking_rights\":\"none\",\"client_rights\":\"none\",\"project_rights\":\"none\",\"resource_rights\":\"none\",\"report_rights\":\"none\",\"owner\":\"false\"},{\"id\":148462,\"first_name\":\"A\",\"last_name\":\"1\",\"email\":\"viniston.viniston1@gmail.com\",\"image\":\"/images/fallback/user/thumb_default.png\",\"timezone\":\"Kolkata\",\"last_login_at\":null,\"last_logout_at\":null,\"last_activity_at\":null,\"activation_state\":null,\"created_at\":\"2017-12-08T17:06:51.000Z\",\"updated_at\":\"2017-12-08T17:06:51.000Z\",\"permissions\":\"basic_user\",\"booking_rights\":\"view\",\"client_rights\":\"view\",\"project_rights\":\"view\",\"resource_rights\":\"view\",\"report_rights\":\"view\",\"owner\":\"false\"},{\"id\":148463,\"first_name\":\"C\",\"last_name\":\"1\",\"email\":\"viniston.viniston2@gmail.com\",\"image\":\"/images/fallback/user/thumb_default.png\",\"timezone\":\"Kolkata\",\"last_login_at\":null,\"last_logout_at\":null,\"last_activity_at\":null,\"activation_state\":null,\"created_at\":\"2017-12-08T17:07:44.000Z\",\"updated_at\":\"2017-12-08T17:07:44.000Z\",\"permissions\":\"basic_user\",\"booking_rights\":\"view\",\"client_rights\":\"view\",\"project_rights\":\"view\",\"resource_rights\":\"view\",\"report_rights\":\"view\",\"owner\":\"false\"},{\"id\":148465,\"first_name\":\"D\",\"last_name\":\"1\",\"email\":\"viniston.viniston3@gmail.com\",\"image\":\"/images/fallback/user/thumb_default.png\",\"timezone\":\"Kolkata\",\"last_login_at\":null,\"last_logout_at\":null,\"last_activity_at\":null,\"activation_state\":null,\"created_at\":\"2017-12-08T17:08:20.000Z\",\"updated_at\":\"2017-12-08T17:08:20.000Z\",\"permissions\":\"basic_user\",\"booking_rights\":\"view\",\"client_rights\":\"view\",\"project_rights\":\"view\",\"resource_rights\":\"view\",\"report_rights\":\"view\",\"owner\":\"false\"},{\"id\":148466,\"first_name\":\"E\",\"last_name\":\"1\",\"email\":\"viniston.viniston4@gmail.com\",\"image\":\"/images/fallback/user/thumb_default.png\",\"timezone\":\"Kolkata\",\"last_login_at\":null,\"last_logout_at\":null,\"last_activity_at\":null,\"activation_state\":null,\"created_at\":\"2017-12-08T17:08:49.000Z\",\"updated_at\":\"2017-12-08T17:08:49.000Z\",\"permissions\":\"basic_user\",\"booking_rights\":\"view\",\"client_rights\":\"view\",\"project_rights\":\"view\",\"resource_rights\":\"view\",\"report_rights\":\"view\",\"owner\":\"false\"},{\"id\":148467,\"first_name\":\"F\",\"last_name\":\"1\",\"email\":\"viniston.viniston6@gmail.com\",\"image\":\"/images/fallback/user/thumb_default.png\",\"timezone\":\"Kolkata\",\"last_login_at\":null,\"last_logout_at\":null,\"last_activity_at\":null,\"activation_state\":null,\"created_at\":\"2017-12-08T17:09:18.000Z\",\"updated_at\":\"2017-12-08T17:09:18.000Z\",\"permissions\":\"basic_user\",\"booking_rights\":\"view\",\"client_rights\":\"view\",\"project_rights\":\"view\",\"resource_rights\":\"view\",\"report_rights\":\"view\",\"owner\":\"false\"},{\"id\":148468,\"first_name\":\"G\",\"last_name\":\"1\",\"email\":\"viniston.viniston7@gmail.com\",\"image\":\"/images/fallback/user/thumb_default.png\",\"timezone\":\"Kolkata\",\"last_login_at\":null,\"last_logout_at\":null,\"last_activity_at\":null,\"activation_state\":null,\"created_at\":\"2017-12-08T17:09:35.000Z\",\"updated_at\":\"2017-12-08T17:09:35.000Z\",\"permissions\":\"basic_user\",\"booking_rights\":\"view\",\"client_rights\":\"view\",\"project_rights\":\"view\",\"resource_rights\":\"view\",\"report_rights\":\"view\",\"owner\":\"false\"},{\"id\":148470,\"first_name\":\"g\",\"last_name\":\"1\",\"email\":\"viniston.viniston8@gmail.com\",\"image\":\"/images/fallback/user/thumb_default.png\",\"timezone\":\"Kolkata\",\"last_login_at\":null,\"last_logout_at\":null,\"last_activity_at\":null,\"activation_state\":null,\"created_at\":\"2017-12-08T17:10:01.000Z\",\"updated_at\":\"2017-12-08T17:10:01.000Z\",\"permissions\":\"basic_user\",\"booking_rights\":\"view\",\"client_rights\":\"view\",\"project_rights\":\"view\",\"resource_rights\":\"view\",\"report_rights\":\"view\",\"owner\":\"false\"},{\"id\":148471,\"first_name\":\"H\",\"last_name\":\"1\",\"email\":\"viniston.viniston9@gmail.com\",\"image\":\"/images/fallback/user/thumb_default.png\",\"timezone\":\"Kolkata\",\"last_login_at\":null,\"last_logout_at\":null,\"last_activity_at\":null,\"activation_state\":null,\"created_at\":\"2017-12-08T17:10:19.000Z\",\"updated_at\":\"2017-12-08T17:10:19.000Z\",\"permissions\":\"basic_user\",\"booking_rights\":\"view\",\"client_rights\":\"view\",\"project_rights\":\"view\",\"resource_rights\":\"view\",\"report_rights\":\"view\",\"owner\":\"false\"},{\"id\":148472,\"first_name\":\"I\",\"last_name\":\"1\",\"email\":\"viniston.viniston11@gmail.com\",\"image\":\"/images/fallback/user/thumb_default.png\",\"timezone\":\"Kolkata\",\"last_login_at\":null,\"last_logout_at\":null,\"last_activity_at\":null,\"activation_state\":null,\"created_at\":\"2017-12-08T17:10:41.000Z\",\"updated_at\":\"2017-12-08T17:10:41.000Z\",\"permissions\":\"basic_user\",\"booking_rights\":\"view\",\"client_rights\":\"view\",\"project_rights\":\"view\",\"resource_rights\":\"view\",\"report_rights\":\"view\",\"owner\":\"false\"}]", "deleted_bookers": "[]", "resource_types": "[{\"id\":199579,\"name\":\"Person\",\"human\":true,\"created_at\":\"2017-12-04T12:02:01.000Z\",\"updated_at\":\"2017-12-04T12:02:01.000Z\",\"custom_fields\":[{\"id\":60780,\"name\":\"Contractor/Employee\",\"required\":false,\"single_select\":false,\"created_at\":\"2017-12-04T12:02:01.000Z\",\"updated_at\":\"2017-12-04T12:02:01.000Z\",\"custom_field_options\":[{\"id\":137324,\"value\":\"Contractor\"},{\"id\":137325,\"value\":\"Employee\"}]},{\"id\":60779,\"name\":\"Department\",\"required\":false,\"single_select\":false,\"created_at\":\"2017-12-04T12:02:01.000Z\",\"updated_at\":\"2017-12-04T12:02:01.000Z\",\"custom_field_options\":[]},{\"id\":60777,\"name\":\"Job Title\",\"required\":false,\"single_select\":true,\"created_at\":\"2017-12-04T12:02:01.000Z\",\"updated_at\":\"2017-12-04T12:02:01.000Z\",\"custom_field_options\":[]},{\"id\":60778,\"name\":\"Skills\",\"required\":false,\"single_select\":false,\"created_at\":\"2017-12-04T12:02:01.000Z\",\"updated_at\":\"2017-12-04T12:02:01.000Z\",\"custom_field_options\":[]}],\"custom_attributes\":[\"phone\"]},{\"id\":199580,\"name\":\"Conference Call Line\",\"human\":false,\"created_at\":\"2017-12-04T12:02:01.000Z\",\"updated_at\":\"2017-12-04T12:02:01.000Z\",\"custom_fields\":[],\"custom_attributes\":[]},{\"id\":199581,\"name\":\"Meeting Room\",\"human\":false,\"created_at\":\"2017-12-04T12:02:01.000Z\",\"updated_at\":\"2017-12-04T12:02:01.000Z\",\"custom_fields\":[],\"custom_attributes\":[\"capacity\"]},{\"id\":199582,\"name\":\"Vehicle\",\"human\":false,\"created_at\":\"2017-12-04T12:02:01.000Z\",\"updated_at\":\"2017-12-04T12:02:01.000Z\",\"custom_fields\":[],\"custom_attributes\":[\"registration_number\"]},{\"id\":199583,\"name\":\"Miscellaneous\",\"human\":false,\"created_at\":\"2017-12-04T12:02:01.000Z\",\"updated_at\":\"2017-12-04T12:02:01.000Z\",\"custom_fields\":[],\"custom_attributes\":[]}]", "clients": "[]", "deleted_clients": "[]", "clients_archived": "[]", "projects": "[]", "deleted_projects": "[]", "projects_archived": "[]", "saved_filters": "[]", "overtimes": "[]", "downtime_types": "[{\"id\":142581,\"name\":\"Holiday (personal)\"},{\"id\":142582,\"name\":\"Public holiday\"},{\"id\":142583,\"name\":\"Sick leave\"},{\"id\":142584,\"name\":\"Maternity/paternity leave\"},{\"id\":142585,\"name\":\"Compassionate leave\"}]", "downtimes": "[]", "notice": "{\"id\":59858,\"dismissed_custom_availability\":true}", "today": "2017-12-09", "start_date": "2017-11-11", "end_date": "2018-03-03", "time_zones": "[{\"name\":\"American Samoa\",\"offset\":-660},{\"name\":\"International Date Line West\",\"offset\":-660},{\"name\":\"Midway Island\",\"offset\":-660},{\"name\":\"Hawaii\",\"offset\":-600},{\"name\":\"Alaska\",\"offset\":-540},{\"name\":\"Pacific Time (US \\u0026 Canada)\",\"offset\":-480},{\"name\":\"Tijuana\",\"offset\":-480},{\"name\":\"Arizona\",\"offset\":-420},{\"name\":\"Chihuahua\",\"offset\":-420},{\"name\":\"Mazatlan\",\"offset\":-420},{\"name\":\"Mountain Time (US \\u0026 Canada)\",\"offset\":-420},{\"name\":\"Central America\",\"offset\":-360},{\"name\":\"Central Time (US \\u0026 Canada)\",\"offset\":-360},{\"name\":\"Guadalajara\",\"offset\":-360},{\"name\":\"Mexico City\",\"offset\":-360},{\"name\":\"Monterrey\",\"offset\":-360},{\"name\":\"Saskatchewan\",\"offset\":-360},{\"name\":\"Bogota\",\"offset\":-300},{\"name\":\"Eastern Time (US \\u0026 Canada)\",\"offset\":-300},{\"name\":\"Indiana (East)\",\"offset\":-300},{\"name\":\"Lima\",\"offset\":-300},{\"name\":\"Quito\",\"offset\":-300},{\"name\":\"Atlantic Time (Canada)\",\"offset\":-240},{\"name\":\"Caracas\",\"offset\":-240},{\"name\":\"Georgetown\",\"offset\":-240},{\"name\":\"La Paz\",\"offset\":-240},{\"name\":\"Santiago\",\"offset\":-240},{\"name\":\"Newfoundland\",\"offset\":-210},{\"name\":\"Brasilia\",\"offset\":-180},{\"name\":\"Buenos Aires\",\"offset\":-180},{\"name\":\"Greenland\",\"offset\":-180},{\"name\":\"Montevideo\",\"offset\":-180},{\"name\":\"Mid-Atlantic\",\"offset\":-120},{\"name\":\"Azores\",\"offset\":-60},{\"name\":\"Cape Verde Is.\",\"offset\":-60},{\"name\":\"Casablanca\",\"offset\":0},{\"name\":\"Dublin\",\"offset\":0},{\"name\":\"Edinburgh\",\"offset\":0},{\"name\":\"Lisbon\",\"offset\":0},{\"name\":\"London\",\"offset\":0},{\"name\":\"Monrovia\",\"offset\":0},{\"name\":\"UTC\",\"offset\":0},{\"name\":\"Amsterdam\",\"offset\":60},{\"name\":\"Belgrade\",\"offset\":60},{\"name\":\"Berlin\",\"offset\":60},{\"name\":\"Bern\",\"offset\":60},{\"name\":\"Bratislava\",\"offset\":60},{\"name\":\"Brussels\",\"offset\":60},{\"name\":\"Budapest\",\"offset\":60},{\"name\":\"Copenhagen\",\"offset\":60},{\"name\":\"Ljubljana\",\"offset\":60},{\"name\":\"Madrid\",\"offset\":60},{\"name\":\"Paris\",\"offset\":60},{\"name\":\"Prague\",\"offset\":60},{\"name\":\"Rome\",\"offset\":60},{\"name\":\"Sarajevo\",\"offset\":60},{\"name\":\"Skopje\",\"offset\":60},{\"name\":\"Stockholm\",\"offset\":60},{\"name\":\"Vienna\",\"offset\":60},{\"name\":\"Warsaw\",\"offset\":60},{\"name\":\"West Central Africa\",\"offset\":60},{\"name\":\"Zagreb\",\"offset\":60},{\"name\":\"Athens\",\"offset\":120},{\"name\":\"Bucharest\",\"offset\":120},{\"name\":\"Cairo\",\"offset\":120},{\"name\":\"Harare\",\"offset\":120},{\"name\":\"Helsinki\",\"offset\":120},{\"name\":\"Istanbul\",\"offset\":120},{\"name\":\"Jerusalem\",\"offset\":120},{\"name\":\"Kaliningrad\",\"offset\":120},{\"name\":\"Kyiv\",\"offset\":120},{\"name\":\"Pretoria\",\"offset\":120},{\"name\":\"Riga\",\"offset\":120},{\"name\":\"Sofia\",\"offset\":120},{\"name\":\"Tallinn\",\"offset\":120},{\"name\":\"Vilnius\",\"offset\":120},{\"name\":\"Baghdad\",\"offset\":180},{\"name\":\"Kuwait\",\"offset\":180},{\"name\":\"Minsk\",\"offset\":180},{\"name\":\"Moscow\",\"offset\":180},{\"name\":\"Nairobi\",\"offset\":180},{\"name\":\"Riyadh\",\"offset\":180},{\"name\":\"St. Petersburg\",\"offset\":180},{\"name\":\"Volgograd\",\"offset\":180},{\"name\":\"Tehran\",\"offset\":210},{\"name\":\"Abu Dhabi\",\"offset\":240},{\"name\":\"Baku\",\"offset\":240},{\"name\":\"Muscat\",\"offset\":240},{\"name\":\"Samara\",\"offset\":240},{\"name\":\"Tbilisi\",\"offset\":240},{\"name\":\"Yerevan\",\"offset\":240},{\"name\":\"Kabul\",\"offset\":270},{\"name\":\"Ekaterinburg\",\"offset\":300},{\"name\":\"Islamabad\",\"offset\":300},{\"name\":\"Karachi\",\"offset\":300},{\"name\":\"Tashkent\",\"offset\":300},{\"name\":\"Chennai\",\"offset\":330},{\"name\":\"Kolkata\",\"offset\":330},{\"name\":\"Mumbai\",\"offset\":330},{\"name\":\"New Delhi\",\"offset\":330},{\"name\":\"Sri Jayawardenepura\",\"offset\":330},{\"name\":\"Kathmandu\",\"offset\":345},{\"name\":\"Almaty\",\"offset\":360},{\"name\":\"Astana\",\"offset\":360},{\"name\":\"Dhaka\",\"offset\":360},{\"name\":\"Novosibirsk\",\"offset\":360},{\"name\":\"Urumqi\",\"offset\":360},{\"name\":\"Rangoon\",\"offset\":390},{\"name\":\"Bangkok\",\"offset\":420},{\"name\":\"Hanoi\",\"offset\":420},{\"name\":\"Jakarta\",\"offset\":420},{\"name\":\"Krasnoyarsk\",\"offset\":420},{\"name\":\"Beijing\",\"offset\":480},{\"name\":\"Chongqing\",\"offset\":480},{\"name\":\"Hong Kong\",\"offset\":480},{\"name\":\"Irkutsk\",\"offset\":480},{\"name\":\"Kuala Lumpur\",\"offset\":480},{\"name\":\"Perth\",\"offset\":480},{\"name\":\"Singapore\",\"offset\":480},{\"name\":\"Taipei\",\"offset\":480},{\"name\":\"Ulaanbaatar\",\"offset\":480},{\"name\":\"Osaka\",\"offset\":540},{\"name\":\"Sapporo\",\"offset\":540},{\"name\":\"Seoul\",\"offset\":540},{\"name\":\"Tokyo\",\"offset\":540},{\"name\":\"Yakutsk\",\"offset\":540},{\"name\":\"Adelaide\",\"offset\":570},{\"name\":\"Darwin\",\"offset\":570},{\"name\":\"Brisbane\",\"offset\":600},{\"name\":\"Canberra\",\"offset\":600},{\"name\":\"Guam\",\"offset\":600},{\"name\":\"Hobart\",\"offset\":600},{\"name\":\"Melbourne\",\"offset\":600},{\"name\":\"Port Moresby\",\"offset\":600},{\"name\":\"Sydney\",\"offset\":600},{\"name\":\"Vladivostok\",\"offset\":600},{\"name\":\"Magadan\",\"offset\":660},{\"name\":\"New Caledonia\",\"offset\":660},{\"name\":\"Solomon Is.\",\"offset\":660},{\"name\":\"Srednekolymsk\",\"offset\":660},{\"name\":\"Auckland\",\"offset\":720},{\"name\":\"Fiji\",\"offset\":720},{\"name\":\"Kamchatka\",\"offset\":720},{\"name\":\"Marshall Is.\",\"offset\":720},{\"name\":\"Wellington\",\"offset\":720},{\"name\":\"Chatham Is.\",\"offset\":765},{\"name\":\"Nuku'alofa\",\"offset\":780},{\"name\":\"Samoa\",\"offset\":780},{\"name\":\"Tokelau Is.\",\"offset\":780}]", "downtimes_etag": "d751713988987e9331980363e24189ce" }
                        //var data = { "users": "[{\"id\":147899,\"first_name\":\"Viniston\",\"last_name\":\"Arockiasamy\",\"email\":\"myprivcy2015@gmail.com\",\"image\":\"https://rg-storage-us-east.s3.amazonaws.com/images/user/147899/image/thumb_78433bfc-4f89-4cb3-b35e-bf2ebf46d236.jpg\",\"timezone\":\"Kolkata\",\"last_login_at\":\"2017-12-07T07:36:30.000Z\",\"last_logout_at\":\"2017-12-04T16:55:13.000Z\",\"last_activity_at\":null,\"activation_state\":\"active\",\"created_at\":\"2017-12-04T12:02:01.000Z\",\"updated_at\":\"2017-12-07T12:54:12.000Z\",\"color\":\"#ffb400\",\"permissions\":\"administrator\",\"booking_rights\":\"manage_all\",\"client_rights\":\"manage_all\",\"project_rights\":\"manage_all\",\"resource_rights\":\"manage_all\",\"report_rights\":\"view\",\"owner\":\"true\"},{\"id\":79043,\"first_name\":\"viniston\",\"last_name\":\"fernando\",\"email\":\"viniston.viniston@gmail.com\",\"image\":\"https://rg-storage-us-east.s3.amazonaws.com/images/user/79043/image/thumb_a7e50de5-0008-4a12-b049-791a340d9fdd.jpg\",\"timezone\":\"Kolkata\",\"last_login_at\":\"2017-12-04T11:58:11.000Z\",\"last_logout_at\":\"2017-12-04T12:00:51.000Z\",\"last_activity_at\":null,\"activation_state\":\"active\",\"created_at\":\"2016-01-18T16:45:57.000Z\",\"updated_at\":\"2017-12-04T11:58:11.000Z\",\"color\":\"#0264b0\",\"permissions\":\"basic_user\",\"booking_rights\":\"view\",\"client_rights\":\"view\",\"project_rights\":\"view\",\"resource_rights\":\"view\",\"report_rights\":\"view\",\"owner\":\"false\"},{\"id\":148461,\"first_name\":\"A\",\"last_name\":\"B\",\"email\":\"viniston1@gmail.com\",\"image\":\"/images/fallback/user/thumb_default.png\",\"timezone\":\"Kolkata\",\"last_login_at\":null,\"last_logout_at\":null,\"last_activity_at\":null,\"activation_state\":null,\"created_at\":\"2017-12-08T17:06:31.000Z\",\"updated_at\":\"2017-12-08T17:06:31.000Z\",\"permissions\":\"custom\",\"booking_rights\":\"none\",\"client_rights\":\"none\",\"project_rights\":\"none\",\"resource_rights\":\"none\",\"report_rights\":\"none\",\"owner\":\"false\"},{\"id\":148462,\"first_name\":\"A\",\"last_name\":\"1\",\"email\":\"viniston.viniston1@gmail.com\",\"image\":\"/images/fallback/user/thumb_default.png\",\"timezone\":\"Kolkata\",\"last_login_at\":null,\"last_logout_at\":null,\"last_activity_at\":null,\"activation_state\":null,\"created_at\":\"2017-12-08T17:06:51.000Z\",\"updated_at\":\"2017-12-08T17:06:51.000Z\",\"color\":\"#bb4b01\",\"permissions\":\"basic_user\",\"booking_rights\":\"view\",\"client_rights\":\"view\",\"project_rights\":\"view\",\"resource_rights\":\"view\",\"report_rights\":\"view\",\"owner\":\"false\"},{\"id\":148463,\"first_name\":\"C\",\"last_name\":\"1\",\"email\":\"viniston.viniston2@gmail.com\",\"image\":\"/images/fallback/user/thumb_default.png\",\"timezone\":\"Kolkata\",\"last_login_at\":null,\"last_logout_at\":null,\"last_activity_at\":null,\"activation_state\":null,\"created_at\":\"2017-12-08T17:07:44.000Z\",\"updated_at\":\"2017-12-08T17:07:44.000Z\",\"permissions\":\"basic_user\",\"booking_rights\":\"view\",\"client_rights\":\"view\",\"project_rights\":\"view\",\"resource_rights\":\"view\",\"report_rights\":\"view\",\"owner\":\"false\"},{\"id\":148465,\"first_name\":\"D\",\"last_name\":\"1\",\"email\":\"viniston.viniston3@gmail.com\",\"image\":\"/images/fallback/user/thumb_default.png\",\"timezone\":\"Kolkata\",\"last_login_at\":null,\"last_logout_at\":null,\"last_activity_at\":null,\"activation_state\":null,\"created_at\":\"2017-12-08T17:08:20.000Z\",\"updated_at\":\"2017-12-08T17:08:20.000Z\",\"permissions\":\"basic_user\",\"booking_rights\":\"view\",\"client_rights\":\"view\",\"project_rights\":\"view\",\"resource_rights\":\"view\",\"report_rights\":\"view\",\"owner\":\"false\"},{\"id\":148466,\"first_name\":\"E\",\"last_name\":\"1\",\"email\":\"viniston.viniston4@gmail.com\",\"image\":\"/images/fallback/user/thumb_default.png\",\"timezone\":\"Kolkata\",\"last_login_at\":null,\"last_logout_at\":null,\"last_activity_at\":null,\"activation_state\":null,\"created_at\":\"2017-12-08T17:08:49.000Z\",\"updated_at\":\"2017-12-08T17:08:49.000Z\",\"permissions\":\"basic_user\",\"booking_rights\":\"view\",\"client_rights\":\"view\",\"project_rights\":\"view\",\"resource_rights\":\"view\",\"report_rights\":\"view\",\"owner\":\"false\"},{\"id\":148467,\"first_name\":\"F\",\"last_name\":\"1\",\"email\":\"viniston.viniston6@gmail.com\",\"image\":\"/images/fallback/user/thumb_default.png\",\"timezone\":\"Kolkata\",\"last_login_at\":null,\"last_logout_at\":null,\"last_activity_at\":null,\"activation_state\":null,\"created_at\":\"2017-12-08T17:09:18.000Z\",\"updated_at\":\"2017-12-08T17:09:18.000Z\",\"permissions\":\"basic_user\",\"booking_rights\":\"view\",\"client_rights\":\"view\",\"project_rights\":\"view\",\"resource_rights\":\"view\",\"report_rights\":\"view\",\"owner\":\"false\"},{\"id\":148468,\"first_name\":\"G\",\"last_name\":\"1\",\"email\":\"viniston.viniston7@gmail.com\",\"image\":\"/images/fallback/user/thumb_default.png\",\"timezone\":\"Kolkata\",\"last_login_at\":null,\"last_logout_at\":null,\"last_activity_at\":null,\"activation_state\":null,\"created_at\":\"2017-12-08T17:09:35.000Z\",\"updated_at\":\"2017-12-08T17:09:35.000Z\",\"permissions\":\"basic_user\",\"booking_rights\":\"view\",\"client_rights\":\"view\",\"project_rights\":\"view\",\"resource_rights\":\"view\",\"report_rights\":\"view\",\"owner\":\"false\"},{\"id\":148470,\"first_name\":\"g\",\"last_name\":\"1\",\"email\":\"viniston.viniston8@gmail.com\",\"image\":\"/images/fallback/user/thumb_default.png\",\"timezone\":\"Kolkata\",\"last_login_at\":null,\"last_logout_at\":null,\"last_activity_at\":null,\"activation_state\":null,\"created_at\":\"2017-12-08T17:10:01.000Z\",\"updated_at\":\"2017-12-08T17:10:01.000Z\",\"permissions\":\"basic_user\",\"booking_rights\":\"view\",\"client_rights\":\"view\",\"project_rights\":\"view\",\"resource_rights\":\"view\",\"report_rights\":\"view\",\"owner\":\"false\"},{\"id\":148471,\"first_name\":\"H\",\"last_name\":\"1\",\"email\":\"viniston.viniston9@gmail.com\",\"image\":\"/images/fallback/user/thumb_default.png\",\"timezone\":\"Kolkata\",\"last_login_at\":null,\"last_logout_at\":null,\"last_activity_at\":null,\"activation_state\":null,\"created_at\":\"2017-12-08T17:10:19.000Z\",\"updated_at\":\"2017-12-08T17:10:19.000Z\",\"permissions\":\"basic_user\",\"booking_rights\":\"view\",\"client_rights\":\"view\",\"project_rights\":\"view\",\"resource_rights\":\"view\",\"report_rights\":\"view\",\"owner\":\"false\"},{\"id\":148472,\"first_name\":\"I\",\"last_name\":\"1\",\"email\":\"viniston.viniston11@gmail.com\",\"image\":\"/images/fallback/user/thumb_default.png\",\"timezone\":\"Kolkata\",\"last_login_at\":null,\"last_logout_at\":null,\"last_activity_at\":null,\"activation_state\":null,\"created_at\":\"2017-12-08T17:10:41.000Z\",\"updated_at\":\"2017-12-08T17:10:41.000Z\",\"permissions\":\"basic_user\",\"booking_rights\":\"view\",\"client_rights\":\"view\",\"project_rights\":\"view\",\"resource_rights\":\"view\",\"report_rights\":\"view\",\"owner\":\"false\"}]", "deleted_bookers": "[]", "resource_types": "[{\"id\":199579,\"name\":\"Person\",\"human\":true,\"created_at\":\"2017-12-04T12:02:01.000Z\",\"updated_at\":\"2017-12-04T12:02:01.000Z\",\"custom_fields\":[{\"id\":60780,\"name\":\"Contractor/Employee\",\"required\":false,\"single_select\":false,\"created_at\":\"2017-12-04T12:02:01.000Z\",\"updated_at\":\"2017-12-04T12:02:01.000Z\",\"custom_field_options\":[{\"id\":137324,\"value\":\"Contractor\"},{\"id\":137325,\"value\":\"Employee\"}]},{\"id\":60779,\"name\":\"Department\",\"required\":false,\"single_select\":false,\"created_at\":\"2017-12-04T12:02:01.000Z\",\"updated_at\":\"2017-12-04T12:02:01.000Z\",\"custom_field_options\":[]},{\"id\":60777,\"name\":\"Job Title\",\"required\":false,\"single_select\":true,\"created_at\":\"2017-12-04T12:02:01.000Z\",\"updated_at\":\"2017-12-04T12:02:01.000Z\",\"custom_field_options\":[]},{\"id\":60778,\"name\":\"Skills\",\"required\":false,\"single_select\":false,\"created_at\":\"2017-12-04T12:02:01.000Z\",\"updated_at\":\"2017-12-04T12:02:01.000Z\",\"custom_field_options\":[]}],\"custom_attributes\":[\"phone\"]},{\"id\":199580,\"name\":\"Conference Call Line\",\"human\":false,\"created_at\":\"2017-12-04T12:02:01.000Z\",\"updated_at\":\"2017-12-04T12:02:01.000Z\",\"custom_fields\":[],\"custom_attributes\":[]},{\"id\":199581,\"name\":\"Meeting Room\",\"human\":false,\"created_at\":\"2017-12-04T12:02:01.000Z\",\"updated_at\":\"2017-12-04T12:02:01.000Z\",\"custom_fields\":[],\"custom_attributes\":[\"capacity\"]},{\"id\":199582,\"name\":\"Vehicle\",\"human\":false,\"created_at\":\"2017-12-04T12:02:01.000Z\",\"updated_at\":\"2017-12-04T12:02:01.000Z\",\"custom_fields\":[],\"custom_attributes\":[\"registration_number\"]},{\"id\":199583,\"name\":\"Miscellaneous\",\"human\":false,\"created_at\":\"2017-12-04T12:02:01.000Z\",\"updated_at\":\"2017-12-04T12:02:01.000Z\",\"custom_fields\":[],\"custom_attributes\":[]}]", "clients": "[{\"id\":242096,\"name\":\"Test client\",\"notes\":null,\"created_at\":\"2017-12-11T08:18:42.000Z\",\"updated_at\":\"2017-12-11T08:18:42.000Z\",\"last_updated_by\":147899,\"url\":\"https://api.resourceguruapp.com/v1/vini/clients/242096\",\"color\":\"#683DB8\"}]", "deleted_clients": "[]", "clients_archived": "[]", "projects": "[{\"id\":666791,\"name\":\"Project 1\",\"project_code\":\"PX82\",\"notes\":null,\"default_billable\":true,\"created_at\":\"2017-12-11T08:19:51.000Z\",\"updated_at\":\"2017-12-11T08:19:51.000Z\",\"last_updated_by\":147899,\"url\":\"https://api.resourceguruapp.com/v1/vini/projects/666791\",\"account_id\":39923,\"client_id\":null,\"color\":\"#A675FF\"},{\"id\":666794,\"name\":\"Project 10\",\"project_code\":\"PX71\",\"notes\":null,\"default_billable\":true,\"created_at\":\"2017-12-11T08:21:08.000Z\",\"updated_at\":\"2017-12-11T08:21:08.000Z\",\"last_updated_by\":147899,\"url\":\"https://api.resourceguruapp.com/v1/vini/projects/666794\",\"account_id\":39923,\"client_id\":null,\"color\":\"#B70655\"},{\"id\":666795,\"name\":\"Project 11\",\"project_code\":\"PX96\",\"notes\":null,\"default_billable\":true,\"created_at\":\"2017-12-11T08:21:56.000Z\",\"updated_at\":\"2017-12-11T08:21:56.000Z\",\"last_updated_by\":147899,\"url\":\"https://api.resourceguruapp.com/v1/vini/projects/666795\",\"account_id\":39923,\"client_id\":null,\"color\":\"#09CA7A\"},{\"id\":666793,\"name\":\"Project 2\",\"project_code\":\"PX22\",\"notes\":null,\"default_billable\":true,\"created_at\":\"2017-12-11T08:20:27.000Z\",\"updated_at\":\"2017-12-11T08:20:27.000Z\",\"last_updated_by\":147899,\"url\":\"https://api.resourceguruapp.com/v1/vini/projects/666793\",\"account_id\":39923,\"client_id\":null,\"color\":\"#9C8803\"},{\"id\":666789,\"name\":\"Red project\",\"project_code\":\"RP58\",\"notes\":null,\"default_billable\":true,\"created_at\":\"2017-12-11T08:18:45.000Z\",\"updated_at\":\"2017-12-11T08:18:45.000Z\",\"last_updated_by\":147899,\"url\":\"https://api.resourceguruapp.com/v1/vini/projects/666789\",\"account_id\":39923,\"client_id\":242096,\"color\":\"#EA1414\"},{\"id\":666788,\"name\":\"Test\",\"project_code\":\"TX81\",\"notes\":null,\"default_billable\":true,\"created_at\":\"2017-12-11T08:17:17.000Z\",\"updated_at\":\"2017-12-11T08:17:17.000Z\",\"last_updated_by\":147899,\"url\":\"https://api.resourceguruapp.com/v1/vini/projects/666788\",\"account_id\":39923,\"client_id\":null,\"color\":\"#FFB400\"}]", "deleted_projects": "[]", "projects_archived": "[]", "saved_filters": "[]", "overtimes": "[]", "downtime_types": "[{\"id\":142581,\"name\":\"Holiday (personal)\"},{\"id\":142582,\"name\":\"Public holiday\"},{\"id\":142583,\"name\":\"Sick leave\"},{\"id\":142584,\"name\":\"Maternity/paternity leave\"},{\"id\":142585,\"name\":\"Compassionate leave\"}]", "downtimes": "[]", "notice": "{\"id\":59858,\"dismissed_custom_availability\":true}", "today": "2017-12-11", "start_date": "2017-11-13", "end_date": "2018-03-05", "time_zones": "[{\"name\":\"American Samoa\",\"offset\":-660},{\"name\":\"International Date Line West\",\"offset\":-660},{\"name\":\"Midway Island\",\"offset\":-660},{\"name\":\"Hawaii\",\"offset\":-600},{\"name\":\"Alaska\",\"offset\":-540},{\"name\":\"Pacific Time (US \\u0026 Canada)\",\"offset\":-480},{\"name\":\"Tijuana\",\"offset\":-480},{\"name\":\"Arizona\",\"offset\":-420},{\"name\":\"Chihuahua\",\"offset\":-420},{\"name\":\"Mazatlan\",\"offset\":-420},{\"name\":\"Mountain Time (US \\u0026 Canada)\",\"offset\":-420},{\"name\":\"Central America\",\"offset\":-360},{\"name\":\"Central Time (US \\u0026 Canada)\",\"offset\":-360},{\"name\":\"Guadalajara\",\"offset\":-360},{\"name\":\"Mexico City\",\"offset\":-360},{\"name\":\"Monterrey\",\"offset\":-360},{\"name\":\"Saskatchewan\",\"offset\":-360},{\"name\":\"Bogota\",\"offset\":-300},{\"name\":\"Eastern Time (US \\u0026 Canada)\",\"offset\":-300},{\"name\":\"Indiana (East)\",\"offset\":-300},{\"name\":\"Lima\",\"offset\":-300},{\"name\":\"Quito\",\"offset\":-300},{\"name\":\"Atlantic Time (Canada)\",\"offset\":-240},{\"name\":\"Caracas\",\"offset\":-240},{\"name\":\"Georgetown\",\"offset\":-240},{\"name\":\"La Paz\",\"offset\":-240},{\"name\":\"Santiago\",\"offset\":-240},{\"name\":\"Newfoundland\",\"offset\":-210},{\"name\":\"Brasilia\",\"offset\":-180},{\"name\":\"Buenos Aires\",\"offset\":-180},{\"name\":\"Greenland\",\"offset\":-180},{\"name\":\"Montevideo\",\"offset\":-180},{\"name\":\"Mid-Atlantic\",\"offset\":-120},{\"name\":\"Azores\",\"offset\":-60},{\"name\":\"Cape Verde Is.\",\"offset\":-60},{\"name\":\"Casablanca\",\"offset\":0},{\"name\":\"Dublin\",\"offset\":0},{\"name\":\"Edinburgh\",\"offset\":0},{\"name\":\"Lisbon\",\"offset\":0},{\"name\":\"London\",\"offset\":0},{\"name\":\"Monrovia\",\"offset\":0},{\"name\":\"UTC\",\"offset\":0},{\"name\":\"Amsterdam\",\"offset\":60},{\"name\":\"Belgrade\",\"offset\":60},{\"name\":\"Berlin\",\"offset\":60},{\"name\":\"Bern\",\"offset\":60},{\"name\":\"Bratislava\",\"offset\":60},{\"name\":\"Brussels\",\"offset\":60},{\"name\":\"Budapest\",\"offset\":60},{\"name\":\"Copenhagen\",\"offset\":60},{\"name\":\"Ljubljana\",\"offset\":60},{\"name\":\"Madrid\",\"offset\":60},{\"name\":\"Paris\",\"offset\":60},{\"name\":\"Prague\",\"offset\":60},{\"name\":\"Rome\",\"offset\":60},{\"name\":\"Sarajevo\",\"offset\":60},{\"name\":\"Skopje\",\"offset\":60},{\"name\":\"Stockholm\",\"offset\":60},{\"name\":\"Vienna\",\"offset\":60},{\"name\":\"Warsaw\",\"offset\":60},{\"name\":\"West Central Africa\",\"offset\":60},{\"name\":\"Zagreb\",\"offset\":60},{\"name\":\"Athens\",\"offset\":120},{\"name\":\"Bucharest\",\"offset\":120},{\"name\":\"Cairo\",\"offset\":120},{\"name\":\"Harare\",\"offset\":120},{\"name\":\"Helsinki\",\"offset\":120},{\"name\":\"Istanbul\",\"offset\":120},{\"name\":\"Jerusalem\",\"offset\":120},{\"name\":\"Kaliningrad\",\"offset\":120},{\"name\":\"Kyiv\",\"offset\":120},{\"name\":\"Pretoria\",\"offset\":120},{\"name\":\"Riga\",\"offset\":120},{\"name\":\"Sofia\",\"offset\":120},{\"name\":\"Tallinn\",\"offset\":120},{\"name\":\"Vilnius\",\"offset\":120},{\"name\":\"Baghdad\",\"offset\":180},{\"name\":\"Kuwait\",\"offset\":180},{\"name\":\"Minsk\",\"offset\":180},{\"name\":\"Moscow\",\"offset\":180},{\"name\":\"Nairobi\",\"offset\":180},{\"name\":\"Riyadh\",\"offset\":180},{\"name\":\"St. Petersburg\",\"offset\":180},{\"name\":\"Volgograd\",\"offset\":180},{\"name\":\"Tehran\",\"offset\":210},{\"name\":\"Abu Dhabi\",\"offset\":240},{\"name\":\"Baku\",\"offset\":240},{\"name\":\"Muscat\",\"offset\":240},{\"name\":\"Samara\",\"offset\":240},{\"name\":\"Tbilisi\",\"offset\":240},{\"name\":\"Yerevan\",\"offset\":240},{\"name\":\"Kabul\",\"offset\":270},{\"name\":\"Ekaterinburg\",\"offset\":300},{\"name\":\"Islamabad\",\"offset\":300},{\"name\":\"Karachi\",\"offset\":300},{\"name\":\"Tashkent\",\"offset\":300},{\"name\":\"Chennai\",\"offset\":330},{\"name\":\"Kolkata\",\"offset\":330},{\"name\":\"Mumbai\",\"offset\":330},{\"name\":\"New Delhi\",\"offset\":330},{\"name\":\"Sri Jayawardenepura\",\"offset\":330},{\"name\":\"Kathmandu\",\"offset\":345},{\"name\":\"Almaty\",\"offset\":360},{\"name\":\"Astana\",\"offset\":360},{\"name\":\"Dhaka\",\"offset\":360},{\"name\":\"Novosibirsk\",\"offset\":360},{\"name\":\"Urumqi\",\"offset\":360},{\"name\":\"Rangoon\",\"offset\":390},{\"name\":\"Bangkok\",\"offset\":420},{\"name\":\"Hanoi\",\"offset\":420},{\"name\":\"Jakarta\",\"offset\":420},{\"name\":\"Krasnoyarsk\",\"offset\":420},{\"name\":\"Beijing\",\"offset\":480},{\"name\":\"Chongqing\",\"offset\":480},{\"name\":\"Hong Kong\",\"offset\":480},{\"name\":\"Irkutsk\",\"offset\":480},{\"name\":\"Kuala Lumpur\",\"offset\":480},{\"name\":\"Perth\",\"offset\":480},{\"name\":\"Singapore\",\"offset\":480},{\"name\":\"Taipei\",\"offset\":480},{\"name\":\"Ulaanbaatar\",\"offset\":480},{\"name\":\"Osaka\",\"offset\":540},{\"name\":\"Sapporo\",\"offset\":540},{\"name\":\"Seoul\",\"offset\":540},{\"name\":\"Tokyo\",\"offset\":540},{\"name\":\"Yakutsk\",\"offset\":540},{\"name\":\"Adelaide\",\"offset\":570},{\"name\":\"Darwin\",\"offset\":570},{\"name\":\"Brisbane\",\"offset\":600},{\"name\":\"Canberra\",\"offset\":600},{\"name\":\"Guam\",\"offset\":600},{\"name\":\"Hobart\",\"offset\":600},{\"name\":\"Melbourne\",\"offset\":600},{\"name\":\"Port Moresby\",\"offset\":600},{\"name\":\"Sydney\",\"offset\":600},{\"name\":\"Vladivostok\",\"offset\":600},{\"name\":\"Magadan\",\"offset\":660},{\"name\":\"New Caledonia\",\"offset\":660},{\"name\":\"Solomon Is.\",\"offset\":660},{\"name\":\"Srednekolymsk\",\"offset\":660},{\"name\":\"Auckland\",\"offset\":720},{\"name\":\"Fiji\",\"offset\":720},{\"name\":\"Kamchatka\",\"offset\":720},{\"name\":\"Marshall Is.\",\"offset\":720},{\"name\":\"Wellington\",\"offset\":720},{\"name\":\"Chatham Is.\",\"offset\":765},{\"name\":\"Nuku'alofa\",\"offset\":780},{\"name\":\"Samoa\",\"offset\":780},{\"name\":\"Tokelau Is.\",\"offset\":780}]", "downtimes_etag": "d751713988987e9331980363e24189ce" }
                        var data = { "users": "[{\"id\":147899,\"first_name\":\"Viniston\",\"last_name\":\"Arockiasamy\",\"email\":\"myprivcy2015@gmail.com\",\"image\":\"https://rg-storage-us-east.s3.amazonaws.com/images/user/147899/image/thumb_78433bfc-4f89-4cb3-b35e-bf2ebf46d236.jpg\",\"timezone\":\"Kolkata\",\"last_login_at\":\"2017-12-30T12:56:52.000Z\",\"last_logout_at\":\"2017-12-04T16:55:13.000Z\",\"last_activity_at\":null,\"activation_state\":\"active\",\"created_at\":\"2017-12-04T12:02:01.000Z\",\"updated_at\":\"2017-12-07T12:54:12.000Z\",\"color\":\"#ffb400\",\"permissions\":\"administrator\",\"booking_rights\":\"manage_all\",\"client_rights\":\"manage_all\",\"project_rights\":\"manage_all\",\"resource_rights\":\"manage_all\",\"report_rights\":\"view\",\"owner\":\"true\"},{\"id\":79043,\"first_name\":\"viniston\",\"last_name\":\"fernando\",\"email\":\"viniston.viniston@gmail.com\",\"image\":\"https://rg-storage-us-east.s3.amazonaws.com/images/user/79043/image/thumb_a7e50de5-0008-4a12-b049-791a340d9fdd.jpg\",\"timezone\":\"Kolkata\",\"last_login_at\":\"2017-12-04T11:58:11.000Z\",\"last_logout_at\":\"2017-12-04T12:00:51.000Z\",\"last_activity_at\":null,\"activation_state\":\"active\",\"created_at\":\"2016-01-18T16:45:57.000Z\",\"updated_at\":\"2017-12-04T11:58:11.000Z\",\"color\":\"#0264b0\",\"permissions\":\"basic_user\",\"booking_rights\":\"view\",\"client_rights\":\"view\",\"project_rights\":\"view\",\"resource_rights\":\"view\",\"report_rights\":\"view\",\"owner\":\"false\"},{\"id\":148461,\"first_name\":\"A\",\"last_name\":\"B\",\"email\":\"viniston1@gmail.com\",\"image\":\"/images/fallback/user/thumb_default.png\",\"timezone\":\"Kolkata\",\"last_login_at\":null,\"last_logout_at\":null,\"last_activity_at\":null,\"activation_state\":null,\"created_at\":\"2017-12-08T17:06:31.000Z\",\"updated_at\":\"2017-12-08T17:06:31.000Z\",\"permissions\":\"custom\",\"booking_rights\":\"none\",\"client_rights\":\"none\",\"project_rights\":\"none\",\"resource_rights\":\"none\",\"report_rights\":\"none\",\"owner\":\"false\"},{\"id\":148462,\"first_name\":\"A\",\"last_name\":\"1\",\"email\":\"viniston.viniston1@gmail.com\",\"image\":\"/images/fallback/user/thumb_default.png\",\"timezone\":\"Kolkata\",\"last_login_at\":null,\"last_logout_at\":null,\"last_activity_at\":null,\"activation_state\":null,\"created_at\":\"2017-12-08T17:06:51.000Z\",\"updated_at\":\"2017-12-08T17:06:51.000Z\",\"color\":\"#bb4b01\",\"permissions\":\"basic_user\",\"booking_rights\":\"view\",\"client_rights\":\"view\",\"project_rights\":\"view\",\"resource_rights\":\"view\",\"report_rights\":\"view\",\"owner\":\"false\"},{\"id\":148463,\"first_name\":\"C\",\"last_name\":\"1\",\"email\":\"viniston.viniston2@gmail.com\",\"image\":\"/images/fallback/user/thumb_default.png\",\"timezone\":\"Kolkata\",\"last_login_at\":null,\"last_logout_at\":null,\"last_activity_at\":null,\"activation_state\":null,\"created_at\":\"2017-12-08T17:07:44.000Z\",\"updated_at\":\"2017-12-08T17:07:44.000Z\",\"permissions\":\"basic_user\",\"booking_rights\":\"view\",\"client_rights\":\"view\",\"project_rights\":\"view\",\"resource_rights\":\"view\",\"report_rights\":\"view\",\"owner\":\"false\"},{\"id\":148465,\"first_name\":\"D\",\"last_name\":\"1\",\"email\":\"viniston.viniston3@gmail.com\",\"image\":\"/images/fallback/user/thumb_default.png\",\"timezone\":\"Kolkata\",\"last_login_at\":null,\"last_logout_at\":null,\"last_activity_at\":null,\"activation_state\":null,\"created_at\":\"2017-12-08T17:08:20.000Z\",\"updated_at\":\"2017-12-08T17:08:20.000Z\",\"permissions\":\"basic_user\",\"booking_rights\":\"view\",\"client_rights\":\"view\",\"project_rights\":\"view\",\"resource_rights\":\"view\",\"report_rights\":\"view\",\"owner\":\"false\"},{\"id\":148466,\"first_name\":\"E\",\"last_name\":\"1\",\"email\":\"viniston.viniston4@gmail.com\",\"image\":\"/images/fallback/user/thumb_default.png\",\"timezone\":\"Kolkata\",\"last_login_at\":null,\"last_logout_at\":null,\"last_activity_at\":null,\"activation_state\":null,\"created_at\":\"2017-12-08T17:08:49.000Z\",\"updated_at\":\"2017-12-08T17:08:49.000Z\",\"permissions\":\"basic_user\",\"booking_rights\":\"view\",\"client_rights\":\"view\",\"project_rights\":\"view\",\"resource_rights\":\"view\",\"report_rights\":\"view\",\"owner\":\"false\"},{\"id\":148467,\"first_name\":\"F\",\"last_name\":\"1\",\"email\":\"viniston.viniston6@gmail.com\",\"image\":\"/images/fallback/user/thumb_default.png\",\"timezone\":\"Kolkata\",\"last_login_at\":null,\"last_logout_at\":null,\"last_activity_at\":null,\"activation_state\":null,\"created_at\":\"2017-12-08T17:09:18.000Z\",\"updated_at\":\"2017-12-08T17:09:18.000Z\",\"permissions\":\"basic_user\",\"booking_rights\":\"view\",\"client_rights\":\"view\",\"project_rights\":\"view\",\"resource_rights\":\"view\",\"report_rights\":\"view\",\"owner\":\"false\"},{\"id\":148468,\"first_name\":\"G\",\"last_name\":\"1\",\"email\":\"viniston.viniston7@gmail.com\",\"image\":\"/images/fallback/user/thumb_default.png\",\"timezone\":\"Kolkata\",\"last_login_at\":null,\"last_logout_at\":null,\"last_activity_at\":null,\"activation_state\":null,\"created_at\":\"2017-12-08T17:09:35.000Z\",\"updated_at\":\"2017-12-08T17:09:35.000Z\",\"permissions\":\"basic_user\",\"booking_rights\":\"view\",\"client_rights\":\"view\",\"project_rights\":\"view\",\"resource_rights\":\"view\",\"report_rights\":\"view\",\"owner\":\"false\"},{\"id\":148470,\"first_name\":\"g\",\"last_name\":\"1\",\"email\":\"viniston.viniston8@gmail.com\",\"image\":\"/images/fallback/user/thumb_default.png\",\"timezone\":\"Kolkata\",\"last_login_at\":null,\"last_logout_at\":null,\"last_activity_at\":null,\"activation_state\":null,\"created_at\":\"2017-12-08T17:10:01.000Z\",\"updated_at\":\"2017-12-08T17:10:01.000Z\",\"permissions\":\"basic_user\",\"booking_rights\":\"view\",\"client_rights\":\"view\",\"project_rights\":\"view\",\"resource_rights\":\"view\",\"report_rights\":\"view\",\"owner\":\"false\"},{\"id\":148471,\"first_name\":\"H\",\"last_name\":\"1\",\"email\":\"viniston.viniston9@gmail.com\",\"image\":\"/images/fallback/user/thumb_default.png\",\"timezone\":\"Kolkata\",\"last_login_at\":null,\"last_logout_at\":null,\"last_activity_at\":null,\"activation_state\":null,\"created_at\":\"2017-12-08T17:10:19.000Z\",\"updated_at\":\"2017-12-08T17:10:19.000Z\",\"permissions\":\"basic_user\",\"booking_rights\":\"view\",\"client_rights\":\"view\",\"project_rights\":\"view\",\"resource_rights\":\"view\",\"report_rights\":\"view\",\"owner\":\"false\"},{\"id\":148472,\"first_name\":\"I\",\"last_name\":\"1\",\"email\":\"viniston.viniston11@gmail.com\",\"image\":\"/images/fallback/user/thumb_default.png\",\"timezone\":\"Kolkata\",\"last_login_at\":null,\"last_logout_at\":null,\"last_activity_at\":null,\"activation_state\":null,\"created_at\":\"2017-12-08T17:10:41.000Z\",\"updated_at\":\"2017-12-08T17:10:41.000Z\",\"permissions\":\"basic_user\",\"booking_rights\":\"view\",\"client_rights\":\"view\",\"project_rights\":\"view\",\"resource_rights\":\"view\",\"report_rights\":\"view\",\"owner\":\"false\"}]", "deleted_bookers": "[]", "resource_types": "[{\"id\":199579,\"name\":\"Person\",\"human\":true,\"created_at\":\"2017-12-04T12:02:01.000Z\",\"updated_at\":\"2017-12-04T12:02:01.000Z\",\"custom_fields\":[{\"id\":60780,\"name\":\"Contractor/Employee\",\"required\":false,\"single_select\":false,\"created_at\":\"2017-12-04T12:02:01.000Z\",\"updated_at\":\"2017-12-04T12:02:01.000Z\",\"custom_field_options\":[{\"id\":137324,\"value\":\"Contractor\"},{\"id\":137325,\"value\":\"Employee\"}]},{\"id\":60779,\"name\":\"Department\",\"required\":false,\"single_select\":false,\"created_at\":\"2017-12-04T12:02:01.000Z\",\"updated_at\":\"2017-12-04T12:02:01.000Z\",\"custom_field_options\":[]},{\"id\":60777,\"name\":\"Job Title\",\"required\":false,\"single_select\":true,\"created_at\":\"2017-12-04T12:02:01.000Z\",\"updated_at\":\"2017-12-04T12:02:01.000Z\",\"custom_field_options\":[]},{\"id\":60778,\"name\":\"Skills\",\"required\":false,\"single_select\":false,\"created_at\":\"2017-12-04T12:02:01.000Z\",\"updated_at\":\"2017-12-04T12:02:01.000Z\",\"custom_field_options\":[]}],\"custom_attributes\":[\"phone\"]},{\"id\":199580,\"name\":\"Conference Call Line\",\"human\":false,\"created_at\":\"2017-12-04T12:02:01.000Z\",\"updated_at\":\"2017-12-04T12:02:01.000Z\",\"custom_fields\":[],\"custom_attributes\":[]},{\"id\":199581,\"name\":\"Meeting Room\",\"human\":false,\"created_at\":\"2017-12-04T12:02:01.000Z\",\"updated_at\":\"2017-12-04T12:02:01.000Z\",\"custom_fields\":[],\"custom_attributes\":[\"capacity\"]},{\"id\":199582,\"name\":\"Vehicle\",\"human\":false,\"created_at\":\"2017-12-04T12:02:01.000Z\",\"updated_at\":\"2017-12-04T12:02:01.000Z\",\"custom_fields\":[],\"custom_attributes\":[\"registration_number\"]},{\"id\":199583,\"name\":\"Miscellaneous\",\"human\":false,\"created_at\":\"2017-12-04T12:02:01.000Z\",\"updated_at\":\"2017-12-04T12:02:01.000Z\",\"custom_fields\":[],\"custom_attributes\":[]}]", "clients": "[{\"id\":242096,\"name\":\"Test client\",\"notes\":null,\"created_at\":\"2017-12-11T08:18:42.000Z\",\"updated_at\":\"2017-12-11T08:18:42.000Z\",\"last_updated_by\":147899,\"url\":\"https://api.resourceguruapp.com/v1/vini/clients/242096\",\"color\":\"#683DB8\"}]", "deleted_clients": "[]", "clients_archived": "[]", "projects": "[{\"id\":666791,\"name\":\"Project 1\",\"project_code\":\"PX82\",\"notes\":null,\"default_billable\":true,\"created_at\":\"2017-12-11T08:19:51.000Z\",\"updated_at\":\"2017-12-11T08:19:51.000Z\",\"last_updated_by\":147899,\"url\":\"https://api.resourceguruapp.com/v1/vini/projects/666791\",\"account_id\":39923,\"client_id\":null,\"color\":\"#A675FF\"},{\"id\":666794,\"name\":\"Project 10\",\"project_code\":\"PX71\",\"notes\":null,\"default_billable\":true,\"created_at\":\"2017-12-11T08:21:08.000Z\",\"updated_at\":\"2017-12-11T08:21:08.000Z\",\"last_updated_by\":147899,\"url\":\"https://api.resourceguruapp.com/v1/vini/projects/666794\",\"account_id\":39923,\"client_id\":null,\"color\":\"#B70655\"},{\"id\":666795,\"name\":\"Project 11\",\"project_code\":\"PX96\",\"notes\":null,\"default_billable\":true,\"created_at\":\"2017-12-11T08:21:56.000Z\",\"updated_at\":\"2017-12-11T08:21:56.000Z\",\"last_updated_by\":147899,\"url\":\"https://api.resourceguruapp.com/v1/vini/projects/666795\",\"account_id\":39923,\"client_id\":null,\"color\":\"#09CA7A\"},{\"id\":666793,\"name\":\"Project 2\",\"project_code\":\"PX22\",\"notes\":null,\"default_billable\":true,\"created_at\":\"2017-12-11T08:20:27.000Z\",\"updated_at\":\"2017-12-11T08:20:27.000Z\",\"last_updated_by\":147899,\"url\":\"https://api.resourceguruapp.com/v1/vini/projects/666793\",\"account_id\":39923,\"client_id\":null,\"color\":\"#9C8803\"},{\"id\":666789,\"name\":\"Red project\",\"project_code\":\"RP58\",\"notes\":null,\"default_billable\":true,\"created_at\":\"2017-12-11T08:18:45.000Z\",\"updated_at\":\"2017-12-11T08:18:45.000Z\",\"last_updated_by\":147899,\"url\":\"https://api.resourceguruapp.com/v1/vini/projects/666789\",\"account_id\":39923,\"client_id\":242096,\"color\":\"#EA1414\"},{\"id\":666788,\"name\":\"Test\",\"project_code\":\"TX81\",\"notes\":null,\"default_billable\":true,\"created_at\":\"2017-12-11T08:17:17.000Z\",\"updated_at\":\"2017-12-11T08:17:17.000Z\",\"last_updated_by\":147899,\"url\":\"https://api.resourceguruapp.com/v1/vini/projects/666788\",\"account_id\":39923,\"client_id\":null,\"color\":\"#FFB400\"}]", "deleted_projects": "[]", "projects_archived": "[]", "saved_filters": "[]", "overtimes": "[]", "downtime_types": "[{\"id\":142581,\"name\":\"Holiday (personal)\"},{\"id\":142582,\"name\":\"Public holiday\"},{\"id\":142583,\"name\":\"Sick leave\"},{\"id\":142584,\"name\":\"Maternity/paternity leave\"},{\"id\":142585,\"name\":\"Compassionate leave\"}]", "downtimes": "[]", "notice": "{\"id\":59858,\"dismissed_custom_availability\":true}", "today": "2017-12-30", "start_date": "2017-12-02", "end_date": "2018-03-24", "time_zones": "[{\"name\":\"American Samoa\",\"offset\":-660},{\"name\":\"International Date Line West\",\"offset\":-660},{\"name\":\"Midway Island\",\"offset\":-660},{\"name\":\"Hawaii\",\"offset\":-600},{\"name\":\"Alaska\",\"offset\":-540},{\"name\":\"Pacific Time (US \\u0026 Canada)\",\"offset\":-480},{\"name\":\"Tijuana\",\"offset\":-480},{\"name\":\"Arizona\",\"offset\":-420},{\"name\":\"Chihuahua\",\"offset\":-420},{\"name\":\"Mazatlan\",\"offset\":-420},{\"name\":\"Mountain Time (US \\u0026 Canada)\",\"offset\":-420},{\"name\":\"Central America\",\"offset\":-360},{\"name\":\"Central Time (US \\u0026 Canada)\",\"offset\":-360},{\"name\":\"Guadalajara\",\"offset\":-360},{\"name\":\"Mexico City\",\"offset\":-360},{\"name\":\"Monterrey\",\"offset\":-360},{\"name\":\"Saskatchewan\",\"offset\":-360},{\"name\":\"Bogota\",\"offset\":-300},{\"name\":\"Eastern Time (US \\u0026 Canada)\",\"offset\":-300},{\"name\":\"Indiana (East)\",\"offset\":-300},{\"name\":\"Lima\",\"offset\":-300},{\"name\":\"Quito\",\"offset\":-300},{\"name\":\"Atlantic Time (Canada)\",\"offset\":-240},{\"name\":\"Caracas\",\"offset\":-240},{\"name\":\"Georgetown\",\"offset\":-240},{\"name\":\"La Paz\",\"offset\":-240},{\"name\":\"Santiago\",\"offset\":-240},{\"name\":\"Newfoundland\",\"offset\":-210},{\"name\":\"Brasilia\",\"offset\":-180},{\"name\":\"Buenos Aires\",\"offset\":-180},{\"name\":\"Greenland\",\"offset\":-180},{\"name\":\"Montevideo\",\"offset\":-180},{\"name\":\"Mid-Atlantic\",\"offset\":-120},{\"name\":\"Azores\",\"offset\":-60},{\"name\":\"Cape Verde Is.\",\"offset\":-60},{\"name\":\"Casablanca\",\"offset\":0},{\"name\":\"Dublin\",\"offset\":0},{\"name\":\"Edinburgh\",\"offset\":0},{\"name\":\"Lisbon\",\"offset\":0},{\"name\":\"London\",\"offset\":0},{\"name\":\"Monrovia\",\"offset\":0},{\"name\":\"UTC\",\"offset\":0},{\"name\":\"Amsterdam\",\"offset\":60},{\"name\":\"Belgrade\",\"offset\":60},{\"name\":\"Berlin\",\"offset\":60},{\"name\":\"Bern\",\"offset\":60},{\"name\":\"Bratislava\",\"offset\":60},{\"name\":\"Brussels\",\"offset\":60},{\"name\":\"Budapest\",\"offset\":60},{\"name\":\"Copenhagen\",\"offset\":60},{\"name\":\"Ljubljana\",\"offset\":60},{\"name\":\"Madrid\",\"offset\":60},{\"name\":\"Paris\",\"offset\":60},{\"name\":\"Prague\",\"offset\":60},{\"name\":\"Rome\",\"offset\":60},{\"name\":\"Sarajevo\",\"offset\":60},{\"name\":\"Skopje\",\"offset\":60},{\"name\":\"Stockholm\",\"offset\":60},{\"name\":\"Vienna\",\"offset\":60},{\"name\":\"Warsaw\",\"offset\":60},{\"name\":\"West Central Africa\",\"offset\":60},{\"name\":\"Zagreb\",\"offset\":60},{\"name\":\"Athens\",\"offset\":120},{\"name\":\"Bucharest\",\"offset\":120},{\"name\":\"Cairo\",\"offset\":120},{\"name\":\"Harare\",\"offset\":120},{\"name\":\"Helsinki\",\"offset\":120},{\"name\":\"Istanbul\",\"offset\":120},{\"name\":\"Jerusalem\",\"offset\":120},{\"name\":\"Kaliningrad\",\"offset\":120},{\"name\":\"Kyiv\",\"offset\":120},{\"name\":\"Pretoria\",\"offset\":120},{\"name\":\"Riga\",\"offset\":120},{\"name\":\"Sofia\",\"offset\":120},{\"name\":\"Tallinn\",\"offset\":120},{\"name\":\"Vilnius\",\"offset\":120},{\"name\":\"Baghdad\",\"offset\":180},{\"name\":\"Kuwait\",\"offset\":180},{\"name\":\"Minsk\",\"offset\":180},{\"name\":\"Moscow\",\"offset\":180},{\"name\":\"Nairobi\",\"offset\":180},{\"name\":\"Riyadh\",\"offset\":180},{\"name\":\"St. Petersburg\",\"offset\":180},{\"name\":\"Volgograd\",\"offset\":180},{\"name\":\"Tehran\",\"offset\":210},{\"name\":\"Abu Dhabi\",\"offset\":240},{\"name\":\"Baku\",\"offset\":240},{\"name\":\"Muscat\",\"offset\":240},{\"name\":\"Samara\",\"offset\":240},{\"name\":\"Tbilisi\",\"offset\":240},{\"name\":\"Yerevan\",\"offset\":240},{\"name\":\"Kabul\",\"offset\":270},{\"name\":\"Ekaterinburg\",\"offset\":300},{\"name\":\"Islamabad\",\"offset\":300},{\"name\":\"Karachi\",\"offset\":300},{\"name\":\"Tashkent\",\"offset\":300},{\"name\":\"Chennai\",\"offset\":330},{\"name\":\"Kolkata\",\"offset\":330},{\"name\":\"Mumbai\",\"offset\":330},{\"name\":\"New Delhi\",\"offset\":330},{\"name\":\"Sri Jayawardenepura\",\"offset\":330},{\"name\":\"Kathmandu\",\"offset\":345},{\"name\":\"Almaty\",\"offset\":360},{\"name\":\"Astana\",\"offset\":360},{\"name\":\"Dhaka\",\"offset\":360},{\"name\":\"Novosibirsk\",\"offset\":360},{\"name\":\"Urumqi\",\"offset\":360},{\"name\":\"Rangoon\",\"offset\":390},{\"name\":\"Bangkok\",\"offset\":420},{\"name\":\"Hanoi\",\"offset\":420},{\"name\":\"Jakarta\",\"offset\":420},{\"name\":\"Krasnoyarsk\",\"offset\":420},{\"name\":\"Beijing\",\"offset\":480},{\"name\":\"Chongqing\",\"offset\":480},{\"name\":\"Hong Kong\",\"offset\":480},{\"name\":\"Irkutsk\",\"offset\":480},{\"name\":\"Kuala Lumpur\",\"offset\":480},{\"name\":\"Perth\",\"offset\":480},{\"name\":\"Singapore\",\"offset\":480},{\"name\":\"Taipei\",\"offset\":480},{\"name\":\"Ulaanbaatar\",\"offset\":480},{\"name\":\"Osaka\",\"offset\":540},{\"name\":\"Sapporo\",\"offset\":540},{\"name\":\"Seoul\",\"offset\":540},{\"name\":\"Tokyo\",\"offset\":540},{\"name\":\"Yakutsk\",\"offset\":540},{\"name\":\"Adelaide\",\"offset\":570},{\"name\":\"Darwin\",\"offset\":570},{\"name\":\"Brisbane\",\"offset\":600},{\"name\":\"Canberra\",\"offset\":600},{\"name\":\"Guam\",\"offset\":600},{\"name\":\"Hobart\",\"offset\":600},{\"name\":\"Melbourne\",\"offset\":600},{\"name\":\"Port Moresby\",\"offset\":600},{\"name\":\"Sydney\",\"offset\":600},{\"name\":\"Vladivostok\",\"offset\":600},{\"name\":\"Magadan\",\"offset\":660},{\"name\":\"New Caledonia\",\"offset\":660},{\"name\":\"Solomon Is.\",\"offset\":660},{\"name\":\"Srednekolymsk\",\"offset\":660},{\"name\":\"Auckland\",\"offset\":720},{\"name\":\"Fiji\",\"offset\":720},{\"name\":\"Kamchatka\",\"offset\":720},{\"name\":\"Marshall Is.\",\"offset\":720},{\"name\":\"Wellington\",\"offset\":720},{\"name\":\"Chatham Is.\",\"offset\":765},{\"name\":\"Nuku'alofa\",\"offset\":780},{\"name\":\"Samoa\",\"offset\":780},{\"name\":\"Tokelau Is.\",\"offset\":780}]", "downtimes_etag": "d751713988987e9331980363e24189ce" }
                        var i, key, len, ref;
                        window.currentUserDate.set(data.today);
                        RG.Variables.dataDateRange = new RG.Utils.DateRange(RG.Utils.BookingDataParser.getDateFromStr(data.start_date), RG.Utils.BookingDataParser.getDateFromStr(data.end_date));
                        ref = ['today', 'end_date', 'start_date'];
                        for (i = 0, len = ref.length; i < len; i++) {
                            key = ref[i];
                            delete data[key];
                        }
                        bootData = _.extend(bootData, data);
                        return resolve();
                    },
                    error: function (responseData) {
                        if (responseData.status === 400 && responseData.statusText === "Bad Request") {
                            return alert(responseData.responseText);
                        } else {
                            return $("body").html(responseData.responseText);
                        }
                    }
                });
            });
            resourcesPromise = Q.promise(function (resolve) {
                //return $.ajax((RG.getApiRoot()) + "/resources?detail=1&limit=0", {
                return $.ajax("http://localhost/EMRMAPI/schedule/resources/bootstrap", {

                    timeout: 30000,
                    success: function (data, status, xhr) {
                        //var data = [{ "id": 308774, "archived": false, "bookable": true, "email": "viniston1@gmail.com", "job_title": null, "notes": "", "color": null, "name": "A B", "image": "/images/fallback/resources/person/thumb_default.png", "account": { "id": 39923, "name": "Test", "url": "https://api.resourceguruapp.com/v1/accounts/39923" }, "phone": "", "human": true, "created_at": "2017-12-08T17:06:31Z", "updated_at": "2017-12-08T18:15:26Z", "last_updated_by": 147899, "url": "https://api.resourceguruapp.com/v1/vini/resources/308774", "resource_type": { "id": 199579, "name": "Person", "url": "https://api.resourceguruapp.com/v1/vini/resource_types/199579" }, "timezone": { "name": "Kolkata", "offset": 330 }, "vacation_allowance": 0, "available_periods": [{ "week_day": 1, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 1, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 2, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 2, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 3, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 3, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 4, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 4, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 5, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 5, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }], "custom_available_periods": [], "selected_custom_field_options": [], "booked_client_ids": [], "booked_project_ids": [], "overtimes": [] }, { "id": 308775, "archived": false, "bookable": true, "email": "viniston.viniston1@gmail.com", "job_title": null, "notes": "", "color": null, "name": "A 1", "image": "/images/fallback/resources/person/thumb_default.png", "account": { "id": 39923, "name": "Test", "url": "https://api.resourceguruapp.com/v1/accounts/39923" }, "phone": "", "human": true, "created_at": "2017-12-08T17:06:51Z", "updated_at": "2017-12-08T17:06:51Z", "last_updated_by": 147899, "url": "https://api.resourceguruapp.com/v1/vini/resources/308775", "resource_type": { "id": 199579, "name": "Person", "url": "https://api.resourceguruapp.com/v1/vini/resource_types/199579" }, "timezone": { "name": "Kolkata", "offset": 330 }, "vacation_allowance": 0, "available_periods": [{ "week_day": 1, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 1, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 2, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 2, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 3, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 3, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 4, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 4, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 5, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 5, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }], "custom_available_periods": [], "selected_custom_field_options": [], "booked_client_ids": [], "booked_project_ids": [], "overtimes": [] }, { "id": 308773, "archived": false, "bookable": true, "email": "viniston.viniston@gmail.com", "job_title": null, "notes": "", "color": null, "name": "B A", "image": "/images/fallback/resources/person/thumb_default.png", "account": { "id": 39923, "name": "Test", "url": "https://api.resourceguruapp.com/v1/accounts/39923" }, "phone": "", "human": true, "created_at": "2017-12-08T17:05:26Z", "updated_at": "2017-12-09T11:37:38Z", "last_updated_by": 147899, "url": "https://api.resourceguruapp.com/v1/vini/resources/308773", "resource_type": { "id": 199579, "name": "Person", "url": "https://api.resourceguruapp.com/v1/vini/resource_types/199579" }, "timezone": { "name": "Kolkata", "offset": 330 }, "vacation_allowance": 0, "available_periods": [{ "week_day": 1, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 1, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 2, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 2, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 3, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 3, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 4, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 4, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 5, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 5, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }], "custom_available_periods": [], "selected_custom_field_options": [], "booked_client_ids": [], "booked_project_ids": [], "overtimes": [] }, { "id": 308776, "archived": false, "bookable": true, "email": "viniston.viniston2@gmail.com", "job_title": null, "notes": "", "color": null, "name": "C 1", "image": "/images/fallback/resources/person/thumb_default.png", "account": { "id": 39923, "name": "Test", "url": "https://api.resourceguruapp.com/v1/accounts/39923" }, "phone": "", "human": true, "created_at": "2017-12-08T17:07:43Z", "updated_at": "2017-12-08T17:07:43Z", "last_updated_by": 147899, "url": "https://api.resourceguruapp.com/v1/vini/resources/308776", "resource_type": { "id": 199579, "name": "Person", "url": "https://api.resourceguruapp.com/v1/vini/resource_types/199579" }, "timezone": { "name": "Kolkata", "offset": 330 }, "vacation_allowance": 0, "available_periods": [{ "week_day": 1, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 1, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 2, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 2, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 3, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 3, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 4, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 4, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 5, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 5, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }], "custom_available_periods": [], "selected_custom_field_options": [], "booked_client_ids": [], "booked_project_ids": [], "overtimes": [] }, { "id": 308777, "archived": false, "bookable": true, "email": "viniston.viniston3@gmail.com", "job_title": null, "notes": "", "color": null, "name": "D 1", "image": "/images/fallback/resources/person/thumb_default.png", "account": { "id": 39923, "name": "Test", "url": "https://api.resourceguruapp.com/v1/accounts/39923" }, "phone": "", "human": true, "created_at": "2017-12-08T17:08:19Z", "updated_at": "2017-12-09T11:26:19Z", "last_updated_by": 147899, "url": "https://api.resourceguruapp.com/v1/vini/resources/308777", "resource_type": { "id": 199579, "name": "Person", "url": "https://api.resourceguruapp.com/v1/vini/resource_types/199579" }, "timezone": { "name": "Kolkata", "offset": 330 }, "vacation_allowance": 0, "available_periods": [{ "week_day": 1, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 1, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 2, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 2, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 3, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 3, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 4, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 4, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 5, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 5, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }], "custom_available_periods": [], "selected_custom_field_options": [], "booked_client_ids": [], "booked_project_ids": [], "overtimes": [] }, { "id": 308778, "archived": false, "bookable": true, "email": "viniston.viniston4@gmail.com", "job_title": null, "notes": "", "color": null, "name": "E 1", "image": "/images/fallback/resources/person/thumb_default.png", "account": { "id": 39923, "name": "Test", "url": "https://api.resourceguruapp.com/v1/accounts/39923" }, "phone": "", "human": true, "created_at": "2017-12-08T17:08:49Z", "updated_at": "2017-12-08T18:02:34Z", "last_updated_by": 147899, "url": "https://api.resourceguruapp.com/v1/vini/resources/308778", "resource_type": { "id": 199579, "name": "Person", "url": "https://api.resourceguruapp.com/v1/vini/resource_types/199579" }, "timezone": { "name": "Kolkata", "offset": 330 }, "vacation_allowance": 0, "available_periods": [{ "week_day": 1, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 1, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 2, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 2, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 3, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 3, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 4, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 4, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 5, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 5, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }], "custom_available_periods": [], "selected_custom_field_options": [], "booked_client_ids": [], "booked_project_ids": [], "overtimes": [] }, { "id": 308779, "archived": false, "bookable": true, "email": "viniston.viniston6@gmail.com", "job_title": null, "notes": "", "color": null, "name": "F 1", "image": "/images/fallback/resources/person/thumb_default.png", "account": { "id": 39923, "name": "Test", "url": "https://api.resourceguruapp.com/v1/accounts/39923" }, "phone": "", "human": true, "created_at": "2017-12-08T17:09:18Z", "updated_at": "2017-12-08T17:09:18Z", "last_updated_by": 147899, "url": "https://api.resourceguruapp.com/v1/vini/resources/308779", "resource_type": { "id": 199579, "name": "Person", "url": "https://api.resourceguruapp.com/v1/vini/resource_types/199579" }, "timezone": { "name": "Kolkata", "offset": 330 }, "vacation_allowance": 0, "available_periods": [{ "week_day": 1, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 1, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 2, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 2, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 3, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 3, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 4, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 4, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 5, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 5, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }], "custom_available_periods": [], "selected_custom_field_options": [], "booked_client_ids": [], "booked_project_ids": [], "overtimes": [] }, { "id": 308780, "archived": false, "bookable": true, "email": "viniston.viniston7@gmail.com", "job_title": null, "notes": "", "color": null, "name": "G 1", "image": "/images/fallback/resources/person/thumb_default.png", "account": { "id": 39923, "name": "Test", "url": "https://api.resourceguruapp.com/v1/accounts/39923" }, "phone": "", "human": true, "created_at": "2017-12-08T17:09:35Z", "updated_at": "2017-12-08T17:09:35Z", "last_updated_by": 147899, "url": "https://api.resourceguruapp.com/v1/vini/resources/308780", "resource_type": { "id": 199579, "name": "Person", "url": "https://api.resourceguruapp.com/v1/vini/resource_types/199579" }, "timezone": { "name": "Kolkata", "offset": 330 }, "vacation_allowance": 0, "available_periods": [{ "week_day": 1, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 1, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 2, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 2, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 3, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 3, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 4, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 4, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 5, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 5, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }], "custom_available_periods": [], "selected_custom_field_options": [], "booked_client_ids": [], "booked_project_ids": [], "overtimes": [] }, { "id": 308782, "archived": false, "bookable": true, "email": "viniston.viniston8@gmail.com", "job_title": null, "notes": "", "color": null, "name": "g 1", "image": "/images/fallback/resources/person/thumb_default.png", "account": { "id": 39923, "name": "Test", "url": "https://api.resourceguruapp.com/v1/accounts/39923" }, "phone": "", "human": true, "created_at": "2017-12-08T17:10:01Z", "updated_at": "2017-12-08T17:10:01Z", "last_updated_by": 147899, "url": "https://api.resourceguruapp.com/v1/vini/resources/308782", "resource_type": { "id": 199579, "name": "Person", "url": "https://api.resourceguruapp.com/v1/vini/resource_types/199579" }, "timezone": { "name": "Kolkata", "offset": 330 }, "vacation_allowance": 0, "available_periods": [{ "week_day": 1, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 1, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 2, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 2, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 3, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 3, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 4, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 4, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 5, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 5, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }], "custom_available_periods": [], "selected_custom_field_options": [], "booked_client_ids": [], "booked_project_ids": [], "overtimes": [] }, { "id": 308783, "archived": false, "bookable": true, "email": "viniston.viniston9@gmail.com", "job_title": null, "notes": "", "color": null, "name": "H 1", "image": "/images/fallback/resources/person/thumb_default.png", "account": { "id": 39923, "name": "Test", "url": "https://api.resourceguruapp.com/v1/accounts/39923" }, "phone": "", "human": true, "created_at": "2017-12-08T17:10:19Z", "updated_at": "2017-12-08T17:10:19Z", "last_updated_by": 147899, "url": "https://api.resourceguruapp.com/v1/vini/resources/308783", "resource_type": { "id": 199579, "name": "Person", "url": "https://api.resourceguruapp.com/v1/vini/resource_types/199579" }, "timezone": { "name": "Kolkata", "offset": 330 }, "vacation_allowance": 0, "available_periods": [{ "week_day": 1, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 1, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 2, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 2, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 3, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 3, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 4, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 4, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 5, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 5, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }], "custom_available_periods": [], "selected_custom_field_options": [], "booked_client_ids": [], "booked_project_ids": [], "overtimes": [] }, { "id": 308784, "archived": false, "bookable": true, "email": "viniston.viniston11@gmail.com", "job_title": null, "notes": "", "color": null, "name": "I 1", "image": "/images/fallback/resources/person/thumb_default.png", "account": { "id": 39923, "name": "Test", "url": "https://api.resourceguruapp.com/v1/accounts/39923" }, "phone": "", "human": true, "created_at": "2017-12-08T17:10:41Z", "updated_at": "2017-12-08T17:10:41Z", "last_updated_by": 147899, "url": "https://api.resourceguruapp.com/v1/vini/resources/308784", "resource_type": { "id": 199579, "name": "Person", "url": "https://api.resourceguruapp.com/v1/vini/resource_types/199579" }, "timezone": { "name": "Kolkata", "offset": 330 }, "vacation_allowance": 0, "available_periods": [{ "week_day": 1, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 1, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 2, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 2, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 3, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 3, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 4, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 4, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 5, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 5, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }], "custom_available_periods": [], "selected_custom_field_options": [], "booked_client_ids": [], "booked_project_ids": [], "overtimes": [] }, { "id": 307388, "archived": false, "bookable": true, "email": "myprivcy2015@gmail.com", "job_title": null, "notes": "", "color": null, "name": "Viniston Arockiasamy", "image": "assets/thumb_78433bfc-4f89-4cb3-b35e-bf2ebf46d236.jpg", "account": { "id": 39923, "name": "Test", "url": "https://api.resourceguruapp.com/v1/accounts/39923" }, "phone": null, "human": true, "created_at": "2017-12-04T12:02:01Z", "updated_at": "2017-12-08T18:02:44Z", "last_updated_by": null, "url": "https://api.resourceguruapp.com/v1/vini/resources/307388", "resource_type": { "id": 199579, "name": "Person", "url": "https://api.resourceguruapp.com/v1/vini/resource_types/199579" }, "timezone": { "name": "Kolkata", "offset": 330 }, "vacation_allowance": 0, "available_periods": [{ "week_day": 1, "start_time": 540, "end_time": 780, "valid_from": "2017-12-04", "valid_until": null }, { "week_day": 1, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-04", "valid_until": null }, { "week_day": 2, "start_time": 540, "end_time": 780, "valid_from": "2017-12-04", "valid_until": null }, { "week_day": 2, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-04", "valid_until": null }, { "week_day": 3, "start_time": 540, "end_time": 780, "valid_from": "2017-12-04", "valid_until": null }, { "week_day": 3, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-04", "valid_until": null }, { "week_day": 4, "start_time": 540, "end_time": 780, "valid_from": "2017-12-04", "valid_until": null }, { "week_day": 4, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-04", "valid_until": null }, { "week_day": 5, "start_time": 540, "end_time": 780, "valid_from": "2017-12-04", "valid_until": null }, { "week_day": 5, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-04", "valid_until": null }, { "week_day": 1, "start_time": 540, "end_time": 780, "valid_from": "2011-10-31", "valid_until": "2017-12-03" }, { "week_day": 1, "start_time": 840, "end_time": 1080, "valid_from": "2011-10-31", "valid_until": "2017-12-03" }, { "week_day": 2, "start_time": 540, "end_time": 780, "valid_from": "2011-10-31", "valid_until": "2017-12-03" }, { "week_day": 2, "start_time": 840, "end_time": 1080, "valid_from": "2011-10-31", "valid_until": "2017-12-03" }, { "week_day": 3, "start_time": 540, "end_time": 780, "valid_from": "2011-10-31", "valid_until": "2017-12-03" }, { "week_day": 3, "start_time": 840, "end_time": 1080, "valid_from": "2011-10-31", "valid_until": "2017-12-03" }, { "week_day": 4, "start_time": 540, "end_time": 780, "valid_from": "2011-10-31", "valid_until": "2017-12-03" }, { "week_day": 4, "start_time": 840, "end_time": 1080, "valid_from": "2011-10-31", "valid_until": "2017-12-03" }, { "week_day": 5, "start_time": 540, "end_time": 780, "valid_from": "2011-10-31", "valid_until": "2017-12-03" }, { "week_day": 5, "start_time": 840, "end_time": 1080, "valid_from": "2011-10-31", "valid_until": "2017-12-03" }], "custom_available_periods": [], "selected_custom_field_options": [], "booked_client_ids": [], "booked_project_ids": [], "overtimes": [] }]
                        var data = [{ "id": 308774, "archived": false, "bookable": true, "email": "viniston1@gmail.com", "job_title": null, "notes": "", "color": null, "name": "A B", "image": "/images/fallback/resources/person/thumb_default.png", "account": { "id": 39923, "name": "Test", "url": "https://api.resourceguruapp.com/v1/accounts/39923" }, "phone": "", "human": true, "created_at": "2017-12-08T17:06:31Z", "updated_at": "2017-12-19T13:48:19Z", "last_updated_by": 147899, "url": "https://api.resourceguruapp.com/v1/vini/resources/308774", "resource_type": { "id": 199579, "name": "Person", "url": "https://api.resourceguruapp.com/v1/vini/resource_types/199579" }, "timezone": { "name": "Kolkata", "offset": 330 }, "vacation_allowance": 0, "available_periods": [{ "week_day": 1, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 1, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 2, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 2, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 3, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 3, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 4, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 4, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 5, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 5, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }], "custom_available_periods": [], "selected_custom_field_options": [], "booked_client_ids": [], "booked_project_ids": [666793, 666791], "overtimes": [] }, { "id": 308775, "archived": false, "bookable": true, "email": "viniston.viniston1@gmail.com", "job_title": null, "notes": "", "color": "#bb4b01", "name": "A 1", "image": "/images/fallback/resources/person/thumb_default.png", "account": { "id": 39923, "name": "Test", "url": "https://api.resourceguruapp.com/v1/accounts/39923" }, "phone": "", "human": true, "created_at": "2017-12-08T17:06:51Z", "updated_at": "2017-12-11T07:27:20Z", "last_updated_by": 147899, "url": "https://api.resourceguruapp.com/v1/vini/resources/308775", "resource_type": { "id": 199579, "name": "Person", "url": "https://api.resourceguruapp.com/v1/vini/resource_types/199579" }, "timezone": { "name": "Kolkata", "offset": 330 }, "vacation_allowance": 0, "available_periods": [{ "week_day": 1, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 1, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 2, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 2, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 3, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 3, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 4, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 4, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 5, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 5, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }], "custom_available_periods": [], "selected_custom_field_options": [], "booked_client_ids": [], "booked_project_ids": [], "overtimes": [] }, { "id": 308773, "archived": false, "bookable": true, "email": "viniston.viniston@gmail.com", "job_title": null, "notes": "", "color": "#0264b0", "name": "B A", "image": "/images/fallback/resources/person/thumb_default.png", "account": { "id": 39923, "name": "Test", "url": "https://api.resourceguruapp.com/v1/accounts/39923" }, "phone": "", "human": true, "created_at": "2017-12-08T17:05:26Z", "updated_at": "2017-12-11T07:30:17Z", "last_updated_by": 147899, "url": "https://api.resourceguruapp.com/v1/vini/resources/308773", "resource_type": { "id": 199579, "name": "Person", "url": "https://api.resourceguruapp.com/v1/vini/resource_types/199579" }, "timezone": { "name": "Kolkata", "offset": 330 }, "vacation_allowance": 0, "available_periods": [{ "week_day": 1, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 1, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 2, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 2, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 3, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 3, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 4, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 4, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 5, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 5, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }], "custom_available_periods": [], "selected_custom_field_options": [], "booked_client_ids": [], "booked_project_ids": [], "overtimes": [] }, { "id": 308776, "archived": false, "bookable": true, "email": "viniston.viniston2@gmail.com", "job_title": null, "notes": "", "color": null, "name": "C 1", "image": "/images/fallback/resources/person/thumb_default.png", "account": { "id": 39923, "name": "Test", "url": "https://api.resourceguruapp.com/v1/accounts/39923" }, "phone": "", "human": true, "created_at": "2017-12-08T17:07:43Z", "updated_at": "2017-12-11T07:29:48Z", "last_updated_by": 147899, "url": "https://api.resourceguruapp.com/v1/vini/resources/308776", "resource_type": { "id": 199579, "name": "Person", "url": "https://api.resourceguruapp.com/v1/vini/resource_types/199579" }, "timezone": { "name": "Kolkata", "offset": 330 }, "vacation_allowance": 0, "available_periods": [{ "week_day": 1, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 1, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 2, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 2, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 3, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 3, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 4, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 4, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 5, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 5, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }], "custom_available_periods": [], "selected_custom_field_options": [], "booked_client_ids": [], "booked_project_ids": [], "overtimes": [] }, { "id": 308777, "archived": false, "bookable": true, "email": "viniston.viniston3@gmail.com", "job_title": null, "notes": "", "color": null, "name": "D 1", "image": "/images/fallback/resources/person/thumb_default.png", "account": { "id": 39923, "name": "Test", "url": "https://api.resourceguruapp.com/v1/accounts/39923" }, "phone": "", "human": true, "created_at": "2017-12-08T17:08:19Z", "updated_at": "2017-12-19T13:48:19Z", "last_updated_by": 147899, "url": "https://api.resourceguruapp.com/v1/vini/resources/308777", "resource_type": { "id": 199579, "name": "Person", "url": "https://api.resourceguruapp.com/v1/vini/resource_types/199579" }, "timezone": { "name": "Kolkata", "offset": 330 }, "vacation_allowance": 0, "available_periods": [{ "week_day": 1, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 1, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 2, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 2, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 3, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 3, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 4, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 4, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 5, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 5, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }], "custom_available_periods": [], "selected_custom_field_options": [], "booked_client_ids": [], "booked_project_ids": [666788], "overtimes": [] }, { "id": 308778, "archived": false, "bookable": true, "email": "viniston.viniston4@gmail.com", "job_title": null, "notes": "", "color": null, "name": "E 1", "image": "/images/fallback/resources/person/thumb_default.png", "account": { "id": 39923, "name": "Test", "url": "https://api.resourceguruapp.com/v1/accounts/39923" }, "phone": "", "human": true, "created_at": "2017-12-08T17:08:49Z", "updated_at": "2017-12-12T06:10:40Z", "last_updated_by": 147899, "url": "https://api.resourceguruapp.com/v1/vini/resources/308778", "resource_type": { "id": 199579, "name": "Person", "url": "https://api.resourceguruapp.com/v1/vini/resource_types/199579" }, "timezone": { "name": "Kolkata", "offset": 330 }, "vacation_allowance": 0, "available_periods": [{ "week_day": 1, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 1, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 2, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 2, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 3, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 3, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 4, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 4, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 5, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 5, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }], "custom_available_periods": [], "selected_custom_field_options": [], "booked_client_ids": [], "booked_project_ids": [], "overtimes": [] }, { "id": 308779, "archived": false, "bookable": true, "email": "viniston.viniston6@gmail.com", "job_title": null, "notes": "", "color": null, "name": "F 1", "image": "/images/fallback/resources/person/thumb_default.png", "account": { "id": 39923, "name": "Test", "url": "https://api.resourceguruapp.com/v1/accounts/39923" }, "phone": "", "human": true, "created_at": "2017-12-08T17:09:18Z", "updated_at": "2017-12-11T08:21:10Z", "last_updated_by": 147899, "url": "https://api.resourceguruapp.com/v1/vini/resources/308779", "resource_type": { "id": 199579, "name": "Person", "url": "https://api.resourceguruapp.com/v1/vini/resource_types/199579" }, "timezone": { "name": "Kolkata", "offset": 330 }, "vacation_allowance": 0, "available_periods": [{ "week_day": 1, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 1, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 2, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 2, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 3, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 3, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 4, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 4, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 5, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 5, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }], "custom_available_periods": [], "selected_custom_field_options": [], "booked_client_ids": [], "booked_project_ids": [666794], "overtimes": [] }, { "id": 308780, "archived": false, "bookable": true, "email": "viniston.viniston7@gmail.com", "job_title": null, "notes": "", "color": null, "name": "G 1", "image": "/images/fallback/resources/person/thumb_default.png", "account": { "id": 39923, "name": "Test", "url": "https://api.resourceguruapp.com/v1/accounts/39923" }, "phone": "", "human": true, "created_at": "2017-12-08T17:09:35Z", "updated_at": "2017-12-11T08:21:58Z", "last_updated_by": 147899, "url": "https://api.resourceguruapp.com/v1/vini/resources/308780", "resource_type": { "id": 199579, "name": "Person", "url": "https://api.resourceguruapp.com/v1/vini/resource_types/199579" }, "timezone": { "name": "Kolkata", "offset": 330 }, "vacation_allowance": 0, "available_periods": [{ "week_day": 1, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 1, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 2, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 2, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 3, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 3, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 4, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 4, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 5, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 5, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }], "custom_available_periods": [], "selected_custom_field_options": [], "booked_client_ids": [], "booked_project_ids": [666795], "overtimes": [] }, { "id": 308782, "archived": false, "bookable": true, "email": "viniston.viniston8@gmail.com", "job_title": null, "notes": "", "color": null, "name": "g 1", "image": "/images/fallback/resources/person/thumb_default.png", "account": { "id": 39923, "name": "Test", "url": "https://api.resourceguruapp.com/v1/accounts/39923" }, "phone": "", "human": true, "created_at": "2017-12-08T17:10:01Z", "updated_at": "2017-12-08T17:10:01Z", "last_updated_by": 147899, "url": "https://api.resourceguruapp.com/v1/vini/resources/308782", "resource_type": { "id": 199579, "name": "Person", "url": "https://api.resourceguruapp.com/v1/vini/resource_types/199579" }, "timezone": { "name": "Kolkata", "offset": 330 }, "vacation_allowance": 0, "available_periods": [{ "week_day": 1, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 1, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 2, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 2, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 3, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 3, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 4, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 4, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 5, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 5, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }], "custom_available_periods": [], "selected_custom_field_options": [], "booked_client_ids": [], "booked_project_ids": [], "overtimes": [] }, { "id": 308783, "archived": false, "bookable": true, "email": "viniston.viniston9@gmail.com", "job_title": null, "notes": "", "color": null, "name": "H 1", "image": "/images/fallback/resources/person/thumb_default.png", "account": { "id": 39923, "name": "Test", "url": "https://api.resourceguruapp.com/v1/accounts/39923" }, "phone": "", "human": true, "created_at": "2017-12-08T17:10:19Z", "updated_at": "2017-12-08T17:10:19Z", "last_updated_by": 147899, "url": "https://api.resourceguruapp.com/v1/vini/resources/308783", "resource_type": { "id": 199579, "name": "Person", "url": "https://api.resourceguruapp.com/v1/vini/resource_types/199579" }, "timezone": { "name": "Kolkata", "offset": 330 }, "vacation_allowance": 0, "available_periods": [{ "week_day": 1, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 1, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 2, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 2, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 3, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 3, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 4, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 4, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 5, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 5, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }], "custom_available_periods": [], "selected_custom_field_options": [], "booked_client_ids": [], "booked_project_ids": [], "overtimes": [] }, { "id": 308784, "archived": false, "bookable": true, "email": "viniston.viniston11@gmail.com", "job_title": null, "notes": "", "color": null, "name": "I 1", "image": "/images/fallback/resources/person/thumb_default.png", "account": { "id": 39923, "name": "Test", "url": "https://api.resourceguruapp.com/v1/accounts/39923" }, "phone": "", "human": true, "created_at": "2017-12-08T17:10:41Z", "updated_at": "2017-12-08T17:10:41Z", "last_updated_by": 147899, "url": "https://api.resourceguruapp.com/v1/vini/resources/308784", "resource_type": { "id": 199579, "name": "Person", "url": "https://api.resourceguruapp.com/v1/vini/resource_types/199579" }, "timezone": { "name": "Kolkata", "offset": 330 }, "vacation_allowance": 0, "available_periods": [{ "week_day": 1, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 1, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 2, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 2, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 3, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 3, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 4, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 4, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 5, "start_time": 540, "end_time": 780, "valid_from": "2017-12-08", "valid_until": null }, { "week_day": 5, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-08", "valid_until": null }], "custom_available_periods": [], "selected_custom_field_options": [], "booked_client_ids": [], "booked_project_ids": [], "overtimes": [] }, { "id": 307388, "archived": false, "bookable": true, "email": "myprivcy2015@gmail.com", "job_title": null, "notes": "", "color": "#ffb400", "name": "Viniston Arockiasamy", "image": "https://rg-storage-us-east.s3.amazonaws.com/images/human_resource_instance/307388/image/thumb_8bd4efd9-bbd2-4fa5-93fc-70625a93c33c.jpg", "account": { "id": 39923, "name": "Test", "url": "https://api.resourceguruapp.com/v1/accounts/39923" }, "phone": "", "human": true, "created_at": "2017-12-04T12:02:01Z", "updated_at": "2017-12-11T10:04:45Z", "last_updated_by": 147899, "url": "https://api.resourceguruapp.com/v1/vini/resources/307388", "resource_type": { "id": 199579, "name": "Person", "url": "https://api.resourceguruapp.com/v1/vini/resource_types/199579" }, "timezone": { "name": "Kolkata", "offset": 330 }, "vacation_allowance": 0, "available_periods": [{ "week_day": 1, "start_time": 540, "end_time": 780, "valid_from": "2017-12-04", "valid_until": null }, { "week_day": 1, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-04", "valid_until": null }, { "week_day": 2, "start_time": 540, "end_time": 780, "valid_from": "2017-12-04", "valid_until": null }, { "week_day": 2, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-04", "valid_until": null }, { "week_day": 3, "start_time": 540, "end_time": 780, "valid_from": "2017-12-04", "valid_until": null }, { "week_day": 3, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-04", "valid_until": null }, { "week_day": 4, "start_time": 540, "end_time": 780, "valid_from": "2017-12-04", "valid_until": null }, { "week_day": 4, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-04", "valid_until": null }, { "week_day": 5, "start_time": 540, "end_time": 780, "valid_from": "2017-12-04", "valid_until": null }, { "week_day": 5, "start_time": 840, "end_time": 1080, "valid_from": "2017-12-04", "valid_until": null }, { "week_day": 1, "start_time": 540, "end_time": 780, "valid_from": "2011-10-31", "valid_until": "2017-12-03" }, { "week_day": 1, "start_time": 840, "end_time": 1080, "valid_from": "2011-10-31", "valid_until": "2017-12-03" }, { "week_day": 2, "start_time": 540, "end_time": 780, "valid_from": "2011-10-31", "valid_until": "2017-12-03" }, { "week_day": 2, "start_time": 840, "end_time": 1080, "valid_from": "2011-10-31", "valid_until": "2017-12-03" }, { "week_day": 3, "start_time": 540, "end_time": 780, "valid_from": "2011-10-31", "valid_until": "2017-12-03" }, { "week_day": 3, "start_time": 840, "end_time": 1080, "valid_from": "2011-10-31", "valid_until": "2017-12-03" }, { "week_day": 4, "start_time": 540, "end_time": 780, "valid_from": "2011-10-31", "valid_until": "2017-12-03" }, { "week_day": 4, "start_time": 840, "end_time": 1080, "valid_from": "2011-10-31", "valid_until": "2017-12-03" }, { "week_day": 5, "start_time": 540, "end_time": 780, "valid_from": "2011-10-31", "valid_until": "2017-12-03" }, { "week_day": 5, "start_time": 840, "end_time": 1080, "valid_from": "2011-10-31", "valid_until": "2017-12-03" }], "custom_available_periods": [], "selected_custom_field_options": [], "booked_client_ids": [], "booked_project_ids": [], "overtimes": [] }]
                        var etag;
                        etag = "c2e3ecb9a19c3816eeb46b2ea75d0aa3";
                        //etag = xhr.getResponseHeader("CustomETag");
                        bootData = _.extend(bootData, {
                            resources: JSON.stringify(data),
                            resources_etag: etag
                        });
                        return resolve();
                    },
                    error: function (responseData) {
                        if (responseData.status === 400 && responseData.statusText === "Bad Request") {
                            return alert(responseData.responseText);
                        } else {
                            return $("body").html(responseData.responseText);
                        }
                    }
                });
            });
            bookingsPromise = Q.promise(function (resolve) {
                var endDate, endDateStr, startDate, startDateStr;
                startDate = new Date(requestDate);
                startDate.setDate(startDate.getDate() - (4 * 7));
                startDateStr = RG.Utils.DateFormatter.getISODate(startDate);
                endDate = new Date(requestDate);
                endDate.setDate(endDate.getDate() + (12 * 7));
                endDateStr = RG.Utils.DateFormatter.getISODate(endDate);
                //return $.ajax((RG.getApiRoot()) + "/bookings?start_date=" + startDateStr + "&end_date=" + endDateStr + "&limit=0&calendar=1", {
                return $.ajax("http://localhost/EMRMAPI/schedule/resources/bootstrap", {
                    timeout: 30000,
                    success: function (data, status, xhr) {
                        var etag;
                        //var data = [{ "id": 10311631, "client_id": null, "project_id": 666793, "resource_id": 308774, "notes": "Welcome Message", "details": "Welcome Message", "start_date": "2017-12-11", "end_date": "2017-12-12", "billable": true, "refreshable": false, "created_at": "2017-12-11T05:13:21Z", "updated_at": "2017-12-11T08:20:31Z", "last_updated_by": 147899, "booker": { "id": 147899, "name": "Viniston Arockiasamy", "email": "myprivcy2015@gmail.com", "color": "#ffb400" }, "durations": [{ "date": "2017-12-11", "duration": 480, "start_time": null, "end_time": null, "waiting": false }, { "date": "2017-12-12", "duration": 480, "start_time": null, "end_time": null, "waiting": false }] }, { "id": 10311785, "client_id": null, "project_id": 666794, "resource_id": 308779, "notes": "Welcome TRack message", "details": "Welcome TRack message", "start_date": "2017-12-12", "end_date": "2017-12-15", "billable": true, "refreshable": false, "created_at": "2017-12-11T05:55:29Z", "updated_at": "2017-12-11T08:21:10Z", "last_updated_by": 147899, "booker": { "id": 147899, "name": "Viniston Arockiasamy", "email": "myprivcy2015@gmail.com", "color": "#ffb400" }, "durations": [{ "date": "2017-12-12", "duration": 480, "start_time": null, "end_time": null, "waiting": false }, { "date": "2017-12-13", "duration": 480, "start_time": null, "end_time": null, "waiting": false }, { "date": "2017-12-14", "duration": 480, "start_time": null, "end_time": null, "waiting": false }, { "date": "2017-12-15", "duration": 480, "start_time": null, "end_time": null, "waiting": false }] }, { "id": 10311639, "client_id": null, "project_id": 666788, "resource_id": 308777, "notes": "Welcome Message 1", "details": "Welcome Message 1", "start_date": "2017-12-12", "end_date": "2017-12-15", "billable": true, "refreshable": false, "created_at": "2017-12-11T05:14:25Z", "updated_at": "2017-12-11T08:17:18Z", "last_updated_by": 147899, "booker": { "id": 147899, "name": "Viniston Arockiasamy", "email": "myprivcy2015@gmail.com", "color": "#ffb400" }, "durations": [{ "date": "2017-12-12", "duration": 480, "start_time": null, "end_time": null, "waiting": false }, { "date": "2017-12-13", "duration": 480, "start_time": null, "end_time": null, "waiting": false }, { "date": "2017-12-14", "duration": 480, "start_time": null, "end_time": null, "waiting": false }, { "date": "2017-12-15", "duration": 480, "start_time": null, "end_time": null, "waiting": false }] }, { "id": 10308908, "client_id": null, "project_id": 666791, "resource_id": 308774, "notes": "", "details": "", "start_date": "2017-12-20", "end_date": "2017-12-29", "billable": true, "refreshable": false, "created_at": "2017-12-09T11:37:30Z", "updated_at": "2017-12-12T06:01:11Z", "last_updated_by": 147899, "booker": { "id": 147899, "name": "Viniston Arockiasamy", "email": "myprivcy2015@gmail.com", "color": "#ffb400" }, "durations": [{ "date": "2017-12-20", "duration": 480, "start_time": null, "end_time": null, "waiting": false }, { "date": "2017-12-21", "duration": 480, "start_time": null, "end_time": null, "waiting": false }, { "date": "2017-12-22", "duration": 480, "start_time": null, "end_time": null, "waiting": false }, { "date": "2017-12-25", "duration": 480, "start_time": null, "end_time": null, "waiting": false }, { "date": "2017-12-26", "duration": 480, "start_time": null, "end_time": null, "waiting": false }, { "date": "2017-12-27", "duration": 480, "start_time": null, "end_time": null, "waiting": false }, { "date": "2017-12-28", "duration": 480, "start_time": null, "end_time": null, "waiting": false }, { "date": "2017-12-29", "duration": 480, "start_time": null, "end_time": null, "waiting": false }] }, { "id": 10398794, "client_id": null, "project_id": 666791, "resource_id": 308777, "notes": "Test task for test name length and need to see how its looks. This is test plan", "details": "Test task for test name length and need to see how its looks. This is test plan", "start_date": "2017-12-25", "end_date": "2017-12-29", "billable": true, "refreshable": false, "created_at": "2017-12-19T13:43:22Z", "updated_at": "2017-12-19T13:45:49Z", "last_updated_by": 147899, "booker": { "id": 147899, "name": "Viniston Arockiasamy", "email": "myprivcy2015@gmail.com", "color": "#ffb400" }, "durations": [{ "date": "2017-12-25", "duration": 480, "start_time": null, "end_time": null, "waiting": false }, { "date": "2017-12-26", "duration": 480, "start_time": null, "end_time": null, "waiting": false }, { "date": "2017-12-27", "duration": 480, "start_time": null, "end_time": null, "waiting": false }, { "date": "2017-12-28", "duration": 480, "start_time": null, "end_time": null, "waiting": false }, { "date": "2017-12-29", "duration": 480, "start_time": null, "end_time": null, "waiting": false }] }, { "id": 10312425, "client_id": null, "project_id": 666795, "resource_id": 308780, "notes": "", "details": "", "start_date": "2017-12-27", "end_date": "2018-01-02", "billable": true, "refreshable": false, "created_at": "2017-12-11T07:28:47Z", "updated_at": "2017-12-11T08:21:58Z", "last_updated_by": 147899, "booker": { "id": 147899, "name": "Viniston Arockiasamy", "email": "myprivcy2015@gmail.com", "color": "#ffb400" }, "durations": [{ "date": "2017-12-27", "duration": 480, "start_time": null, "end_time": null, "waiting": false }, { "date": "2017-12-28", "duration": 480, "start_time": null, "end_time": null, "waiting": false }, { "date": "2017-12-29", "duration": 480, "start_time": null, "end_time": null, "waiting": false }, { "date": "2018-01-01", "duration": 480, "start_time": null, "end_time": null, "waiting": false }, { "date": "2018-01-02", "duration": 480, "start_time": null, "end_time": null, "waiting": false }] }]
                        //var data = [{ "id": 10311631, "client_id": null, "project_id": 666793, "resource_id": 308774, "notes": "Welcome Message", "details": "Welcome Message", "start_date": "2017-12-11", "end_date": "2017-12-12", "billable": true, "refreshable": false, "created_at": "2017-12-11T05:13:21Z", "updated_at": "2017-12-11T08:20:31Z", "last_updated_by": 147899, "booker": { "id": 147899, "name": "Viniston Arockiasamy", "email": "myprivcy2015@gmail.com", "color": "#ffb400" }, "durations": [{ "date": "2017-12-11", "duration": 480, "start_time": null, "end_time": null, "waiting": false }, { "date": "2017-12-12", "duration": 480, "start_time": null, "end_time": null, "waiting": false }] }, { "id": 10311785, "client_id": null, "project_id": 666794, "resource_id": 308779, "notes": "Welcome TRack message", "details": "Welcome TRack message", "start_date": "2017-12-12", "end_date": "2017-12-15", "billable": true, "refreshable": false, "created_at": "2017-12-11T05:55:29Z", "updated_at": "2017-12-11T08:21:10Z", "last_updated_by": 147899, "booker": { "id": 147899, "name": "Viniston Arockiasamy", "email": "myprivcy2015@gmail.com", "color": "#ffb400" }, "durations": [{ "date": "2017-12-12", "duration": 480, "start_time": null, "end_time": null, "waiting": false }, { "date": "2017-12-13", "duration": 480, "start_time": null, "end_time": null, "waiting": false }, { "date": "2017-12-14", "duration": 480, "start_time": null, "end_time": null, "waiting": false }, { "date": "2017-12-15", "duration": 480, "start_time": null, "end_time": null, "waiting": false }] }, { "id": 10311639, "client_id": null, "project_id": 666788, "resource_id": 308777, "notes": "Welcome Message 1", "details": "Welcome Message 1", "start_date": "2017-12-12", "end_date": "2017-12-15", "billable": true, "refreshable": false, "created_at": "2017-12-11T05:14:25Z", "updated_at": "2017-12-11T08:17:18Z", "last_updated_by": 147899, "booker": { "id": 147899, "name": "Viniston Arockiasamy", "email": "myprivcy2015@gmail.com", "color": "#ffb400" }, "durations": [{ "date": "2017-12-12", "duration": 480, "start_time": null, "end_time": null, "waiting": false }, { "date": "2017-12-13", "duration": 480, "start_time": null, "end_time": null, "waiting": false }, { "date": "2017-12-14", "duration": 480, "start_time": null, "end_time": null, "waiting": false }, { "date": "2017-12-15", "duration": 480, "start_time": null, "end_time": null, "waiting": false }] }, { "id": 10312988, "client_id": null, "project_id": null, "resource_id": 307388, "notes": "", "details": "", "start_date": "2017-12-18", "end_date": "2017-12-18", "billable": false, "refreshable": false, "created_at": "2017-12-11T08:10:48Z", "updated_at": "2017-12-11T08:10:48Z", "last_updated_by": 147899, "booker": { "id": 147899, "name": "Viniston Arockiasamy", "email": "myprivcy2015@gmail.com", "color": "#ffb400" }, "durations": [{ "date": "2017-12-18", "duration": 480, "start_time": null, "end_time": null, "waiting": false }] }, { "id": 10312138, "client_id": 242096, "project_id": 666789, "resource_id": 308778, "notes": "", "details": "", "start_date": "2017-12-18", "end_date": "2017-12-21", "billable": true, "refreshable": false, "created_at": "2017-12-11T06:59:29Z", "updated_at": "2017-12-11T08:18:49Z", "last_updated_by": 147899, "booker": { "id": 147899, "name": "Viniston Arockiasamy", "email": "myprivcy2015@gmail.com", "color": "#ffb400" }, "durations": [{ "date": "2017-12-18", "duration": 480, "start_time": null, "end_time": null, "waiting": false }, { "date": "2017-12-19", "duration": 480, "start_time": null, "end_time": null, "waiting": false }, { "date": "2017-12-20", "duration": 480, "start_time": null, "end_time": null, "waiting": false }, { "date": "2017-12-21", "duration": 480, "start_time": null, "end_time": null, "waiting": false }] }, { "id": 10308908, "client_id": null, "project_id": 666791, "resource_id": 308774, "notes": "", "details": "", "start_date": "2017-12-20", "end_date": "2017-12-28", "billable": true, "refreshable": false, "created_at": "2017-12-09T11:37:30Z", "updated_at": "2017-12-11T08:19:54Z", "last_updated_by": 147899, "booker": { "id": 147899, "name": "Viniston Arockiasamy", "email": "myprivcy2015@gmail.com", "color": "#ffb400" }, "durations": [{ "date": "2017-12-20", "duration": 480, "start_time": null, "end_time": null, "waiting": false }, { "date": "2017-12-21", "duration": 480, "start_time": null, "end_time": null, "waiting": false }, { "date": "2017-12-22", "duration": 480, "start_time": null, "end_time": null, "waiting": false }, { "date": "2017-12-25", "duration": 480, "start_time": null, "end_time": null, "waiting": false }, { "date": "2017-12-26", "duration": 480, "start_time": null, "end_time": null, "waiting": false }, { "date": "2017-12-27", "duration": 480, "start_time": null, "end_time": null, "waiting": false }, { "date": "2017-12-28", "duration": 480, "start_time": null, "end_time": null, "waiting": false }] }, { "id": 10312425, "client_id": null, "project_id": 666795, "resource_id": 308780, "notes": "", "details": "", "start_date": "2017-12-27", "end_date": "2018-01-02", "billable": true, "refreshable": false, "created_at": "2017-12-11T07:28:47Z", "updated_at": "2017-12-11T08:21:58Z", "last_updated_by": 147899, "booker": { "id": 147899, "name": "Viniston Arockiasamy", "email": "myprivcy2015@gmail.com", "color": "#ffb400" }, "durations": [{ "date": "2017-12-27", "duration": 480, "start_time": null, "end_time": null, "waiting": false }, { "date": "2017-12-28", "duration": 480, "start_time": null, "end_time": null, "waiting": false }, { "date": "2017-12-29", "duration": 480, "start_time": null, "end_time": null, "waiting": false }, { "date": "2018-01-01", "duration": 480, "start_time": null, "end_time": null, "waiting": false }, { "date": "2018-01-02", "duration": 480, "start_time": null, "end_time": null, "waiting": false }] }]
                        //var data = [{ "id": 10308908, "client_id": null, "project_id": null, "resource_id": 308773, "notes": "", "details": "", "start_date": "2017-12-21", "end_date": "2017-12-29", "billable": false, "refreshable": false, "created_at": "2017-12-09T11:37:30Z", "updated_at": "2017-12-09T11:37:38Z", "last_updated_by": 147899, "booker": { "id": 147899, "name": "Viniston Arockiasamy", "email": "myprivcy2015@gmail.com", "color": null }, "durations": [{ "date": "2017-12-21", "duration": 480, "start_time": null, "end_time": null, "waiting": false }, { "date": "2017-12-22", "duration": 480, "start_time": null, "end_time": null, "waiting": false }, { "date": "2017-12-25", "duration": 480, "start_time": null, "end_time": null, "waiting": false }, { "date": "2017-12-26", "duration": 480, "start_time": null, "end_time": null, "waiting": false }, { "date": "2017-12-27", "duration": 480, "start_time": null, "end_time": null, "waiting": false }, { "date": "2017-12-28", "duration": 480, "start_time": null, "end_time": null, "waiting": false }, { "date": "2017-12-29", "duration": 480, "start_time": null, "end_time": null, "waiting": false }] }]
                        //etag = xhr.getResponseHeader("CustomETag");
                        var data = [{ "id": 10311631, "client_id": null, "project_id": 666793, "resource_id": 308774, "notes": "Welcome Message", "details": "Welcome Message", "start_date": "2017-12-11", "end_date": "2017-12-12", "billable": true, "refreshable": false, "created_at": "2017-12-11T05:13:21Z", "updated_at": "2017-12-11T08:20:31Z", "last_updated_by": 147899, "booker": { "id": 147899, "name": "Viniston Arockiasamy", "email": "myprivcy2015@gmail.com", "color": "#ffb400" }, "durations": [{ "date": "2017-12-11", "duration": 480, "start_time": null, "end_time": null, "waiting": false }, { "date": "2017-12-12", "duration": 480, "start_time": null, "end_time": null, "waiting": false }] }, { "id": 10311785, "client_id": null, "project_id": 666794, "resource_id": 308779, "notes": "Welcome TRack message", "details": "Welcome TRack message", "start_date": "2017-12-12", "end_date": "2017-12-15", "billable": true, "refreshable": false, "created_at": "2017-12-11T05:55:29Z", "updated_at": "2017-12-11T08:21:10Z", "last_updated_by": 147899, "booker": { "id": 147899, "name": "Viniston Arockiasamy", "email": "myprivcy2015@gmail.com", "color": "#ffb400" }, "durations": [{ "date": "2017-12-12", "duration": 480, "start_time": null, "end_time": null, "waiting": false }, { "date": "2017-12-13", "duration": 480, "start_time": null, "end_time": null, "waiting": false }, { "date": "2017-12-14", "duration": 480, "start_time": null, "end_time": null, "waiting": false }, { "date": "2017-12-15", "duration": 480, "start_time": null, "end_time": null, "waiting": false }] }, { "id": 10311639, "client_id": null, "project_id": 666788, "resource_id": 308777, "notes": "Welcome Message 1", "details": "Welcome Message 1", "start_date": "2017-12-12", "end_date": "2017-12-15", "billable": true, "refreshable": false, "created_at": "2017-12-11T05:14:25Z", "updated_at": "2017-12-11T08:17:18Z", "last_updated_by": 147899, "booker": { "id": 147899, "name": "Viniston Arockiasamy", "email": "myprivcy2015@gmail.com", "color": "#ffb400" }, "durations": [{ "date": "2017-12-12", "duration": 480, "start_time": null, "end_time": null, "waiting": false }, { "date": "2017-12-13", "duration": 480, "start_time": null, "end_time": null, "waiting": false }, { "date": "2017-12-14", "duration": 480, "start_time": null, "end_time": null, "waiting": false }, { "date": "2017-12-15", "duration": 480, "start_time": null, "end_time": null, "waiting": false }] }, { "id": 10308908, "client_id": null, "project_id": 666791, "resource_id": 308774, "notes": "", "details": "", "start_date": "2017-12-20", "end_date": "2017-12-29", "billable": true, "refreshable": false, "created_at": "2017-12-09T11:37:30Z", "updated_at": "2017-12-12T06:01:11Z", "last_updated_by": 147899, "booker": { "id": 147899, "name": "Viniston Arockiasamy", "email": "myprivcy2015@gmail.com", "color": "#ffb400" }, "durations": [{ "date": "2017-12-20", "duration": 480, "start_time": null, "end_time": null, "waiting": false }, { "date": "2017-12-21", "duration": 480, "start_time": null, "end_time": null, "waiting": false }, { "date": "2017-12-22", "duration": 480, "start_time": null, "end_time": null, "waiting": false }, { "date": "2017-12-25", "duration": 480, "start_time": null, "end_time": null, "waiting": false }, { "date": "2017-12-26", "duration": 480, "start_time": null, "end_time": null, "waiting": false }, { "date": "2017-12-27", "duration": 480, "start_time": null, "end_time": null, "waiting": false }, { "date": "2017-12-28", "duration": 480, "start_time": null, "end_time": null, "waiting": false }, { "date": "2017-12-29", "duration": 480, "start_time": null, "end_time": null, "waiting": false }] }, { "id": 10312425, "client_id": null, "project_id": 666795, "resource_id": 308780, "notes": "", "details": "", "start_date": "2017-12-27", "end_date": "2018-01-02", "billable": true, "refreshable": false, "created_at": "2017-12-11T07:28:47Z", "updated_at": "2017-12-11T08:21:58Z", "last_updated_by": 147899, "booker": { "id": 147899, "name": "Viniston Arockiasamy", "email": "myprivcy2015@gmail.com", "color": "#ffb400" }, "durations": [{ "date": "2017-12-27", "duration": 480, "start_time": null, "end_time": null, "waiting": false }, { "date": "2017-12-28", "duration": 480, "start_time": null, "end_time": null, "waiting": false }, { "date": "2017-12-29", "duration": 480, "start_time": null, "end_time": null, "waiting": false }, { "date": "2018-01-01", "duration": 480, "start_time": null, "end_time": null, "waiting": false }, { "date": "2018-01-02", "duration": 480, "start_time": null, "end_time": null, "waiting": false }] }, { "id": 10398794, "client_id": null, "project_id": 666791, "resource_id": 308774, "notes": "Test task for test name length and need to see how its looks. This is test plan", "details": "Test task for test name length and need to see how its looks. This is test plan", "start_date": "2018-01-01", "end_date": "2018-01-05", "billable": true, "refreshable": false, "created_at": "2017-12-19T13:43:22Z", "updated_at": "2017-12-19T13:48:19Z", "last_updated_by": 147899, "booker": { "id": 147899, "name": "Viniston Arockiasamy", "email": "myprivcy2015@gmail.com", "color": "#ffb400" }, "durations": [{ "date": "2018-01-01", "duration": 480, "start_time": null, "end_time": null, "waiting": false }, { "date": "2018-01-02", "duration": 480, "start_time": null, "end_time": null, "waiting": false }, { "date": "2018-01-03", "duration": 480, "start_time": null, "end_time": null, "waiting": false }, { "date": "2018-01-04", "duration": 480, "start_time": null, "end_time": null, "waiting": false }, { "date": "2018-01-05", "duration": 480, "start_time": null, "end_time": null, "waiting": false }] }]
                        etag = "c2e3ecb9a19c3816eeb46b2ea75d0aa3";
                        bootData = _.extend(bootData, {
                            bookings: JSON.stringify(data),
                            bookings_etag: etag
                        });
                        return resolve();
                    },
                    error: function (responseData) {
                        if (responseData.status === 400 && responseData.statusText === "Bad Request") {
                            return alert(responseData.responseText);
                        } else {
                            return $("body").html(responseData.responseText);
                        }
                    }
                });
            });
            return Q.allSettled([bootstrapPromise, resourcesPromise, bookingsPromise]).then(function () {
                return RG.Utils.BookingDataParser.parse(bootData).then(function () {
                    var limit;
                    $("#calendar").show();
                    RG.resizeCards();
                    limit = 50;
                    window.resourceScroller = new RG.Utils.InfiniteResourceScroller($(window), $(document), window.resourcePaginator, data.resources, limit);
                    return window.resourceScroller.start();
                });
            });
        },
        parse: function (data) {
            return Q.promise((function (_this) {
                return function (resolve) {
                    var key, parsedData, value;
                    _this.setupEtags(data);
                    parsedData = {};
                    for (key in data) {
                        value = data[key];
                        parsedData[key] = $.parseJSON(value);
                    }
                    _this.setupTimeZones(parsedData);
                    _this.setupBookers(parsedData);
                    _this.setupDeletedBookers(parsedData);
                    _this.setupDowntimeTypes(parsedData);
                    _this.setupNotice(parsedData);
                    _this.setupResourceTypes(parsedData);
                    _this.setupClients(parsedData);
                    _this.setupDeletedClients(parsedData);
                    _this.setupProjects(parsedData);
                    _this.setupDeletedProjects(parsedData);
                    _this.setupResources(parsedData);
                    _this.setupDowntimes(parsedData.downtimes);
                    _this.setupFilters(parsedData);
                    _this.setupDefaultBookingHours();
                    return setTimeout(function () {
                        RG.initialize($("#calendar"));
                        return resolve();
                    }, 1);
                };
            })(this));
        },
        setupEtags: function (data) {
            RG.Utils.BookingDataParser.resourcesEtag = data.resources_etag;
            RG.Utils.BookingDataParser.downtimesEtag = data.downtimes_etag;
            RG.Utils.BookingDataParser.bookingsEtag = data.bookings_etag;
            delete data.resources_etag;
            delete data.downtimes_etag;
            return delete data.bookings_etag;
        },
        setupTimeZones: function (data) {
            return window.timeZones = new RG.Collections.TimeZones(data.time_zones);
        },
        setupDefaultBookingHours: function () {
            var endKey, i, key, len, ref, resourceType, results, startKey;
            ref = window.resourceTypes.models;
            results = [];
            for (i = 0, len = ref.length; i < len; i++) {
                resourceType = ref[i];
                key = "Duration:" + (resourceType.get('name'));
                if (!window.rgStorage.has(key)) {
                    if (resourceType.get('name') === 'Person') {
                        window.rgStorage.set(key, 480);
                    } else {
                        window.rgStorage.set(key, 60);
                    }
                }
                startKey = "TimeRange:StartTime:" + (resourceType.get('name'));
                if (!window.rgStorage.has(startKey)) {
                    window.rgStorage.set(startKey, 540);
                }
                endKey = "TimeRange:EndTime:" + (resourceType.get('name'));
                if (!window.rgStorage.has(endKey)) {
                    results.push(window.rgStorage.set(endKey, 600));
                } else {
                    results.push(void 0);
                }
            }
            return results;
        },
        getDateFromStr: function (dateStr) {
            var d, m, y;
            y = parseInt(dateStr.substr(0, 4), 10);
            m = parseInt(dateStr.substr(5, 2), 10);
            d = parseInt(dateStr.substr(8, 2), 10);
            return new Date(y, m - 1, d);
        },
        setupNotice: function (data) {
            return window.onboardingNotice = data.notice;
        },
        setupDowntimeTypes: function (data) {
            return window.downtimeTypes.reset(data.downtime_types);
        },
        setupDowntimes: function (downtimesData) {
            var dateProcessor, parser;
            dateProcessor = RG.Utils.BookingDataParser.getDateFromStr;
            parser = new RG.Parsers.DowntimeParser(downtimesData, dateProcessor, window.downtimes, window.timeZones, window.downtimeTypes);
            return parser.parse();
        },
        setupFilters: function (data) {
            var parser;
            parser = new RG.Parsers.SavedFilterParser(data.saved_filters, window.savedFilters);
            return parser.parse();
        },
        setupBookers: function (data) {
            var parser;
            parser = new RG.Parsers.BookerParser(data.users, data.resources, window.bookers);
            return parser.parse();
        },
        setupDeletedBookers: function (data) {
            var parser;
            parser = new RG.Parsers.DeletedBookerParser(data.deleted_bookers, window.deletedBookers);
            return parser.parse();
        },
        setupResourceTypes: function (data) {
            var parser;
            parser = new RG.Parsers.ResourceTypeParser(data.resource_types, window.resourceTypes);
            return parser.parse();
        },
        setupResources: function (data) {
            var dateProcessor, options, parser;
            dateProcessor = RG.Utils.BookingDataParser.getDateFromStr;
            this.bookingBuilder = new RG.Parsers.BookingBuilder(dateProcessor, new RG.Parsers.DurationParser(dateProcessor), window.projects, window.clients, window.deletedProjects, window.deletedClients, window.bookers, window.deletedBookers);
            options = {
                resourceTypes: window.resourceTypes,
                clients: window.clients,
                projects: window.projects,
                bookingParser: new RG.Parsers.BookingParser(data.bookings, this.bookingBuilder),
                customFieldParser: new RG.Parsers.CustomFieldParser,
                availablePeriodParser: new RG.Parsers.AvailablePeriodParser(dateProcessor),
                customAvailablePeriodParser: new RG.Parsers.CustomAvailablePeriodParser(dateProcessor),
                overtimeParser: new RG.Parsers.OvertimeParser(data.overtimes, dateProcessor)
            };
            parser = new RG.Parsers.ResourceParser(data.resources, window.resources, window.timeZones, options);
            return parser.parse();
        },
        setupClients: function (data) {
            var parser;
            parser = new RG.Parsers.ClientParser(data.clients, data.clients_archived, window.clients);
            return parser.parse();
        },
        setupDeletedClients: function (data) {
            var parser;
            parser = new RG.Parsers.DeletedClientParser(data.deleted_clients, window.deletedClients);
            return parser.parse();
        },
        setupProjects: function (data) {
            var parser;
            parser = new RG.Parsers.ProjectParser(data.projects, data.projects_archived, window.clients.models, window.projects);
            return parser.parse();
        },
        setupDeletedProjects: function (data) {
            var parser;
            parser = new RG.Parsers.DeletedProjectParser(data.deleted_projects, window.clients.models, window.deletedProjects);
            return parser.parse();
        },
        processRawBookingData: function (data) {
            var b, booking, i, j, k, len, len1, len2, ref, ref1, resource, resource_has_booking, results;
            ref = window.resources.models;
            results = [];
            for (i = 0, len = ref.length; i < len; i++) {
                resource = ref[i];
                for (j = 0, len1 = data.length; j < len1; j++) {
                    booking = data[j];
                    if (!(booking.resource_id === resource.get('id'))) {
                        continue;
                    }
                    resource_has_booking = false;
                    ref1 = resource.bookings.models;
                    for (k = 0, len2 = ref1.length; k < len2; k++) {
                        b = ref1[k];
                        if (booking.id === b.get('id')) {
                            resource_has_booking = true;
                            break;
                        }
                    }
                    if (!resource_has_booking) {
                        resource.bookings.add(this.bookingBuilder.build(booking), {
                            silent: true
                        });
                    }
                }
                results.push(resource.bookings.trigger('reset'));
            }
            return results;
        },
        resourcesPoll: function (staleCheckFn) {
            //return $.ajax("/v1/" + RG.Utils.BookingDataParser.host + "/resources?detail=1&limit=0", {
            return $.ajax("http://localhost/EMRMAPI/bookings/resources?detail=1&limit=0", {
                headers: {
                    "If-None-Match": RG.Utils.BookingDataParser.resourcesEtag
                },
                timeout: 30000,
                success: function (data, status, xhr) {
                    var bookedClientsAndProjectsChanged;
                    if (staleCheckFn()) {
                        return;
                    }
                    RG.Utils.BookingDataParser.resourcesEtag = xhr.getResponseHeader("CustomETag");
                    bookedClientsAndProjectsChanged = false;
                    RG.backburner.run(function () {
                        var ap, apm, aps, cap, capm, caps, i, j, k, lastPollWithOffset, len, len1, len2, oldBookedClientIds, oldBookedProjectIds, parser, ref, ref1, resource, results, ri;
                        if (xhr.status !== 200) {
                            return true;
                        }
                        lastPollWithOffset = (new Date(RG.Utils.BookingDataParser.lastPoll)).valueOf() - 15000;
                        results = [];
                        for (i = 0, len = data.length; i < len; i++) {
                            resource = data[i];
                            if (!((new Date(resource.updated_at)).valueOf() > lastPollWithOffset)) {
                                continue;
                            }
                            ri = window.resources.findWhere({
                                id: resource.id
                            });
                            if (!ri) {
                                continue;
                            }
                            oldBookedClientIds = ri.attributes.bookedClients.map(function (client) {
                                return client.id;
                            }).sort();
                            oldBookedProjectIds = ri.attributes.bookedProjects.map(function (project) {
                                return project.id;
                            }).sort();
                            ri.set('bookedClients', window.clients.select(function (c) {
                                return _.contains(resource.booked_client_ids, c.id);
                            }));
                            ri.set('bookedProjects', window.projects.select(function (c) {
                                return _.contains(resource.booked_project_ids, c.id);
                            }));
                            if (!_.isEqual(oldBookedClientIds, resource.booked_client_ids.sort()) || !_.isEqual(oldBookedProjectIds, resource.booked_project_ids.sort())) {
                                bookedClientsAndProjectsChanged = true;
                            }
                            aps = [];
                            ref = resource.available_periods;
                            for (j = 0, len1 = ref.length; j < len1; j++) {
                                ap = ref[j];
                                apm = new RG.Models.AvailablePeriod({
                                    weekDay: ap.week_day,
                                    startTime: ap.start_time,
                                    endTime: ap.end_time,
                                    validFrom: RG.Utils.BookingDataParser.getDateFromStr(ap.valid_from)
                                });
                                if (ap.valid_until) {
                                    apm.set({
                                        validUntil: RG.Utils.BookingDataParser.getDateFromStr(ap.valid_until)
                                    });
                                }
                                aps.push(apm);
                            }
                            if (!_.isEqual(RG.Utils.getModelAttributes(aps), RG.Utils.getModelAttributes(ri.availablePeriods.models))) {
                                ri.availablePeriods.reset(aps);
                            }
                            caps = [];
                            ref1 = resource.custom_available_periods;
                            for (k = 0, len2 = ref1.length; k < len2; k++) {
                                cap = ref1[k];
                                capm = new RG.Models.CustomAvailablePeriod({
                                    weekDay: cap.week_day,
                                    startTime: cap.start_time,
                                    endTime: cap.end_time,
                                    date: RG.Utils.BookingDataParser.getDateFromStr(cap.date),
                                    creator_id: cap.creator_id
                                });
                                caps.push(capm);
                            }
                            if (!_.isEqual(RG.Utils.getModelAttributes(caps), RG.Utils.getModelAttributes(ri.customAvailablePeriods.models))) {
                                ri.customAvailablePeriods.reset(caps);
                            }
                            if (resource.overtimes) {
                                parser = new RG.Parsers.OvertimeParser(resource.overtimes, RG.Utils.BookingDataParser.getDateFromStr);
                                results.push(parser.parse(ri, resource.overtimes));
                            } else {
                                results.push(void 0);
                            }
                        }
                        return results;
                    });
                    if (bookedClientsAndProjectsChanged) {
                        return window.resources.trigger('change:booked');
                    }
                }
            });
        },
        downtimesPoll: function (staleCheckFn, dateRange) {
            if (dateRange == null) {
                dateRange = new RG.Utils.DateRange(RG.Utils.firstVisibleDate(), RG.Utils.lastVisibleDate());
            }
            //return $.ajax("/v1/" + RG.Utils.BookingDataParser.host + "/downtimes", {
            return $.ajax("http://localhost/EMRMAPI/bookings/downtimes", {
                headers: {
                    'If-None-Match': RG.Utils.BookingDataParser.downtimesEtag
                },
                timeout: 30000,
                data: {
                    from: encodeURIComponent(dateRange.startDate.format('YYYY-MM-DD')),
                    to: encodeURIComponent(dateRange.endDate.format('YYYY-MM-DD'))
                },
                success: function (data, status, xhr) {
                    if (staleCheckFn()) {
                        return;
                    }
                    RG.Utils.BookingDataParser.downtimesEtag = xhr.getResponseHeader("CustomETag");
                    if (xhr.status !== 200) {
                        return true;
                    }
                    RG.Utils.BookingDataParser.setupDowntimes(data);
                }
            });
        },
        bookingsPoll: function (staleCheckFn) {
            var currentPollTime;
            currentPollTime = new Date;
            //return $.ajax("/v1/" + RG.Utils.BookingDataParser.host + "/bookings", {
            return $.ajax("http://localhost/EMRMAPI/bookings/poll", {
                headers: {
                    'If-None-Match': RG.Utils.BookingDataParser.bookingsEtag
                },
                timeout: 30000,
                data: {
                    start_date: encodeURIComponent(RG.Utils.firstVisibleDate().format('YYYY-MM-DD')),
                    end_date: encodeURIComponent(RG.Utils.lastVisibleDate().format('YYYY-MM-DD')),
                    calendar: 1
                },
                success: function (data, status, xhr) {
                    if (staleCheckFn()) {
                        return;
                    }
                    RG.Utils.BookingDataParser.bookingsEtag = xhr.getResponseHeader("CustomETag");
                    return RG.backburner.run(function () {
                        if (xhr.status !== 200) {
                            return true;
                        }
                        return window.resources.each(function (ri) {
                            var allBookingIds, bookings, removedBookings;
                            bookings = data.filter(function (booking) {
                                return booking.resource_id === ri.id;
                            });
                            allBookingIds = data.filter(function (b) {
                                return b.resource_id === ri.id;
                            }).map(function (b) {
                                return b.id;
                            });
                            removedBookings = ri.bookings.filter(function (b) {
                                return allBookingIds.indexOf(b.get('id')) === -1;
                            });
                            bookings.forEach(function (booking) {
                                var b, booker, bookingUpdatedAt, client, newAttributes, project, ref;
                                b = ri.bookings.findWhere({
                                    id: booking.id
                                });
                                if (b == null) {
                                    b = new RG.Models.Booking;
                                }
                                bookingUpdatedAt = new Date(booking.updated_at);
                                if (((ref = b.get('updatedAt')) != null ? ref.getTime() : void 0) === bookingUpdatedAt.getTime()) {
                                    return;
                                }
                                newAttributes = {
                                    id: booking.id,
                                    notes: booking.notes,
                                    startDate: RG.Utils.BookingDataParser.getDateFromStr(booking.start_date),
                                    endDate: RG.Utils.BookingDataParser.getDateFromStr(booking.end_date),
                                    refreshable: booking.refreshable,
                                    createdAt: new Date(booking.created_at),
                                    updatedAt: bookingUpdatedAt,
                                    client: null,
                                    project: null,
                                    booker: null
                                };
                                if (booking.project_id) {
                                    project = window.projects.find(function (p) {
                                        return p.id === booking.project_id;
                                    });
                                    if (project) {
                                        newAttributes.project = project;
                                    } else {
                                        newAttributes.project = window.deletedProjects.findWhere({
                                            id: booking.project_id
                                        });
                                    }
                                } else if (booking.client_id) {
                                    client = window.clients.find(function (c) {
                                        return c.id === booking.client_id;
                                    });
                                    if (client) {
                                        newAttributes.client = client;
                                    } else {
                                        newAttributes.client = window.deletedClients.findWhere({
                                            id: booking.client_id
                                        });
                                    }
                                }
                                booker = window.bookers.findWhere({
                                    id: booking.booker.id
                                });
                                if (booker) {
                                    newAttributes.booker = booker;
                                } else {
                                    newAttributes.booker = window.deletedBookers.findWhere({
                                        id: booking.booker.id
                                    });
                                }
                                return RG.renderer.enqueue(new RG.Renderer.ResourceDateLock(ri, newAttributes.startDate, newAttributes.endDate), function () {
                                    var parser;
                                    if (staleCheckFn()) {
                                        return;
                                    }
                                    parser = new RG.Parsers.DurationParser(RG.Utils.BookingDataParser.getDateFromStr);
                                    parser.parse(b, booking);
                                    b.set(newAttributes);
                                    if (b.collection !== ri.bookings) {
                                        ri.bookings.add(b);
                                    }
                                    return b.collection = ri.bookings;
                                });
                            });
                            return RG.renderer.enqueue(new RG.Renderer.ResourceDateLock(ri, RG.Utils.firstVisibleDate(), RG.Utils.lastVisibleDate()), function () {
                                if (staleCheckFn()) {
                                    return;
                                }
                                return removedBookings.forEach(function (b) {
                                    return ri.bookings.remove(b);
                                });
                            });
                        });
                    });
                }
            });
        },
        todayPoll: function () {
            return Q.Promise(function (resolve, reject, notify) {
                return $.ajax("http://localhost/EMRMAPI/v1/today", {
                    success: function (data, status, xhr) {
                        window.currentUserDate.set(data);
                        return resolve('Today poll data processed');
                    },
                    error: function (xhr, status, errorThrown) {
                        return reject(new Error("Status code for today poll was " + status));
                    }
                });
            });
        },
        updateCalendar: function (pollId) {
            var staleCheckFn;
            staleCheckFn = function () {
                if (pollId !== RG.Utils.BookingDataParser.pollId) {
                    return true;
                }
                return false;
            };
            this.todayPoll();
            this.resourcesPoll(staleCheckFn);
            this.bookingsPoll(staleCheckFn);
            return this.downtimesPoll(staleCheckFn);
        },
        renderResource: function (resource, defer) {
            if (RG.Utils.interactionInProgress()) {
                return Q.delay(100).then(function () {
                    return RG.Utils.BookingDataParser.renderResource(resource, defer);
                });
            } else {
                resource.availability.trigger('reset');
                return defer.resolve();
            }
        },
        poll: function () {
            return RG.Utils.BookingDataParser.pollPromise();
        },
        expirePolls: function () {
            return this.pollId += 1;
        },
        pollPromise: function () {
            this.expirePolls();
            return (function (pollId) {
                return Q.Promise(function (resolve, reject, notify) {
                    return Q.delay(100).then(function () {
                        if (RG.Utils.bookingBeingSaved()) {
                            return reject(new Error("bookingBeingSaved"));
                        } else {
                            return RG.Utils.BookingDataParser.updateCalendar(pollId).then(function () {
                                RG.Utils.BookingDataParser.resourcesToReset = {};
                                RG.Utils.BookingDataParser.lastPoll = new Date();
                                return resolve("pollComplete");
                            })["catch"](function (error) {
                                return reject(error);
                            });
                        }
                    });
                })["catch"](function (err) {
                    RG.Utils.BookingDataParser.resourcesToReset = {};
                    if (_.contains(['staleData', 'interactionInProgress'], err.message)) {
                        return RG.Utils.BookingDataParser.pollPromise();
                    }
                });
            })(this.pollId);
        }
    };

}).call(this);
;
(function () {
    RG.Utils.BookingMerger = {
        getDateFromStr: function (dateStr) {
            return RG.Utils.BookingDataParser.getDateFromStr(dateStr);
        },
        merge: function (resourceBookings, jsonBookings) {
            var returnedBookings;
            returnedBookings = [];
            _.each(jsonBookings, function (jb) {
                var booking, client, date, duration, durations, i, len, project, ref;
                booking = new RG.Models.Booking({
                    id: jb.id,
                    notes: jb.notes,
                    startDate: RG.Utils.BookingMerger.getDateFromStr(jb.start_date),
                    endDate: RG.Utils.BookingMerger.getDateFromStr(jb.end_date),
                    billable: jb.billable,
                    refreshable: jb.refreshable
                });
                booking.set({
                    booker: window.bookers.findWhere({
                        id: jb.booker.id
                    })
                });
                if (jb.project_id) {
                    project = window.projects.find(function (p) {
                        return p.id === jb.project_id;
                    });
                    if (project) {
                        booking.set({
                            project: project
                        });
                    }
                } else if (jb.client_id) {
                    client = window.clients.find(function (c) {
                        return c.id === jb.client_id;
                    });
                    if (client) {
                        booking.set({
                            client: client
                        });
                    }
                }
                durations = [];
                ref = jb.durations;
                for (i = 0, len = ref.length; i < len; i++) {
                    duration = ref[i];
                    date = RG.Utils.BookingMerger.getDateFromStr(duration.date);
                    if (duration.start_time || duration.start_time === 0) {
                        durations.push(new RG.Models.FixedDuration({
                            date: date,
                            startTime: duration.start_time,
                            endTime: duration.end_time,
                            waiting: duration.waiting
                        }));
                    } else {
                        durations.push(new RG.Models.Duration({
                            date: date,
                            minutes: duration.duration,
                            waiting: duration.waiting
                        }));
                    }
                }
                booking.durations.reset(durations);
                resourceBookings.remove(resourceBookings.findWhere({
                    id: booking.id
                }));
                resourceBookings.add(booking, {
                    merge: true
                });
                return returnedBookings.push(booking);
            });
            return returnedBookings;
        }
    };

    Date.fromISO = function (iso) {
        return RG.Utils.BookingMerger.getDateFromStr(iso);
    };

}).call(this);
;
(function () {
    RG.Utils.BookingPopoverPlacer = (function () {
        function BookingPopoverPlacer(event) {
            this.event = event;
        }

        BookingPopoverPlacer.prototype.getCalUnit = function () {
            return this.calUnit || (this.calUnit = this._findCalUnit());
        };

        BookingPopoverPlacer.prototype.createAnchor = function (arg) {
            var anchor, className, height, offset, relativeY;
            className = arg.className;
            this.getCalUnit();
            anchor = $(document.createElement('div')).addClass('dropdown-anchor').addClass(className);
            this.calUnit.append(anchor);
            relativeY = this.event.pageY - this.calUnit.offset().top;
            if (this.booking) {
                height = this.booking.outerHeight();
                offset = this.booking.offset();
                anchor.callback = (function (_this) {
                    return function (droppingUp) {
                        if (droppingUp) {
                            height = 0;
                        }
                        if (!_this.adjustedHeight && RG.Utils.isZoomedIn()) {
                            height = height - height / 4;
                            _this.adjustedHeight = true;
                        }
                        return anchor.offset({
                            top: offset.top + height
                        });
                    };
                })(this);
                return anchor;
            }
            anchor.offset({
                top: this.calUnit.offset().top + relativeY
            });
            return anchor;
        };

        BookingPopoverPlacer.prototype._findCalUnit = function () {
            var element, elements, i, len, target;
            elements = [];
            target = $(this.event.target);
            while (!target.hasClass('resources--cal-unit')) {
                if (target.hasClass('booking')) {
                    this.booking = target;
                }
                elements.push(target);
                target.css('visibility', 'hidden');
                target = $(document.elementFromPoint(this.event.clientX, this.event.clientY));
            }
            for (i = 0, len = elements.length; i < len; i++) {
                element = elements[i];
                element.css('visibility', 'visible');
            }
            return this.calUnit = target;
        };

        return BookingPopoverPlacer;

    })();

}).call(this);
;
(function () {
    RG.Utils.BookingService = {
        reset: function (data, resource, booking, originalAttributes, originalDurations) {
            if (data.project_id) {
                alert(RG.Variables.Validation.Project.Archived);
            }
            if (data.client_id) {
                alert(RG.Variables.Validation.Client.Archived);
            }
            booking.set(originalAttributes);
            booking.set({
                saving: false
            });
            booking.durations.reset(originalDurations);
            resource.bookings.remove(booking, {
                silent: true
            });
            return resource.bookings.add(booking);
        },
        isolate: function (booking, date, callback) {
            var afterDate;
            afterDate = new Date(date.getFullYear(), date.getMonth(), date.getDate() + 1);
            if (RG.Utils.DateComparator.equalsYMD(booking.getDateRange().startDate, date)) {
                return RG.Utils.BookingService.split(booking, afterDate, function (bookings) {
                    return typeof callback === "function" ? callback(bookings[0]) : void 0;
                });
            } else if (RG.Utils.DateComparator.equalsYMD(booking.getDateRange().endDate, date)) {
                return RG.Utils.BookingService.split(booking, date, function (bookings) {
                    return typeof callback === "function" ? callback(bookings[1]) : void 0;
                });
            } else {
                return RG.Utils.BookingService.split(booking, date, function (bookings) {
                    var currBooking;
                    currBooking = bookings[1];
                    return RG.Utils.BookingService.split(currBooking, afterDate, function (lastBookings) {
                        return typeof callback === "function" ? callback(lastBookings[0]) : void 0;
                    });
                });
            }
        },
        split: function (booking, date, callback) {
            var data;
            data = {
                date: RG.Utils.DateFormatter.getISODate(date)
            };
            booking.set('saving', true);
            return $.ajax(RG.getApiRoot() + ("/bookings/" + booking.id + "/split"), {
                method: "PUT",
                data: data,
                dataType: 'json',
                headers: {
                    "X-CSRF-Token": $('meta[name="csrf-token"]').attr('content')
                },
                success: (function (_this) {
                    return function (responseData) {
                        var bookings;
                        bookings = RG.Utils.BookingMerger.merge(booking.collection, responseData);
                        return window.requestAnimationFrame(function () {
                            return typeof callback === "function" ? callback(bookings) : void 0;
                        });
                    };
                })(this),
                error: (function (_this) {
                    return function (responseData) {
                        alert(responseData.responseText);
                        return typeof callback === "function" ? callback() : void 0;
                    };
                })(this)
            });
        },
        setBookingStartDate: function (booking, date, callback) {
            return RG.Utils.BookingService.setBookingAttributes(booking, {
                start_date: RG.Utils.DateFormatter.getISODate(date)
            }, callback);
        },
        setBookingEndDate: function (booking, date, callback) {
            return RG.Utils.BookingService.setBookingAttributes(booking, {
                end_date: RG.Utils.DateFormatter.getISODate(date)
            }, callback);
        },
        deleteBooking: function (booking, callback) {
            booking.set('saving', true);
            return $.ajax(RG.getApiRoot() + ("/bookings/" + (booking.get('id'))), {
                method: 'DELETE',
                headers: {
                    "X-CSRF-Token": $('meta[name="csrf-token"]').attr('content')
                },
                success: (function (_this) {
                    return function () {
                        var collection;
                        collection = booking.collection;
                        if (collection != null) {
                            collection.remove(booking);
                            collection.predictWaitingList();
                            collection.trigger('reset');
                        }
                        if (typeof callback === "function") {
                            callback(booking);
                        }
                        RG.Popovers.popoverActive = false;
                        return window.update();
                    };
                })(this)
            });
        },
        deleteSingleDate: function (booking, date, callback) {
            var cb, d;
            cb = function (booking) {
                if (typeof callback === "function") {
                    callback(booking);
                }
                return window.update();
            };
            if (RG.Utils.DateComparator.equalsYMD(booking.getDateRange().startDate, date)) {
                d = new Date(date.getFullYear(), date.getMonth(), date.getDate() + 1);
                return RG.Utils.BookingService.setBookingStartDate(booking, d, cb);
            } else if (RG.Utils.DateComparator.equalsYMD(booking.getDateRange().endDate, date)) {
                d = new Date(date.getFullYear(), date.getMonth(), date.getDate() - 1);
                return RG.Utils.BookingService.setBookingEndDate(booking, d, cb);
            } else {
                return RG.Utils.BookingService.isolate(booking, date, function (isolatedBooking) {
                    return RG.Utils.BookingService.deleteBooking(isolatedBooking, callback);
                });
            }
        },
        setBookingAttributes: function (booking, attributes, callback) {
            booking.set('saving', true);
            return $.ajax(RG.getApiRoot() + ("/bookings/" + booking.id), {
                method: "PUT",
                data: attributes,
                dataType: 'json',
                headers: {
                    "X-CSRF-Token": $('meta[name="csrf-token"]').attr('content')
                },
                success: (function (_this) {
                    return function (response) {
                        RG.Utils.BookingMerger.merge(booking.collection, [response]);
                        return typeof callback === "function" ? callback() : void 0;
                    };
                })(this)
            });
        }
    };

}).call(this);
;
(function () {
    RG.Utils.CardResizer = (function () {
        function CardResizer() { }

        CardResizer.prototype.resize = function () {
            var calendarEl;
            calendarEl = document.getElementById("calendar");
            if (!calendarEl) {
                return;
            }
            if (this.cardsContainer == null) {
                this.cardsContainer = calendarEl.querySelector("aside");
            }
            if (this.linesContainer == null) {
                this.linesContainer = document.getElementById("resources");
            }
            window.requestAnimationFrame((function (_this) {
                return function () {
                    var card, height, i, len, line, ref;
                    ref = _this.linesContainer.querySelectorAll(".resource-line");
                    for (i = 0, len = ref.length; i < len; i++) {
                        line = ref[i];
                        if (line && line.attributes["data-resource-id"] && line.attributes["data-resource-id"].value) {
                            card = _this.cardsContainer.querySelector(".resource[data-resource-id=" + line.attributes["data-resource-id"].value + "]");
                            height = line.offsetHeight + "px";
                            if (card && card.style.height !== height) {
                                card.style.height = height;
                            }
                        }
                    }
                };
            })(this));
        };

        return CardResizer;

    })();

}).call(this);
;
(function () {
    RG.Utils.ColorSource = (function () {
        function ColorSource() {
            _.extend(this, Backbone.Events);
            this.mode = 'project';
        }

        ColorSource.prototype.colorBy = function (mode) {
            this.mode = mode;
            return this.trigger('change:mode');
        };

        ColorSource.prototype.getColorForBooking = function (booking) {
            var base, color, ref, ref1, ref2, ref3, ref4;
            color = "#BFBFBF";
            if (this.mode === 'project') {
                color = (ref = booking.get('project')) != null ? ref.get('color') : void 0;
            } else if (this.mode === 'client') {
                color = ((ref1 = booking.get('client')) != null ? ref1.get('color') : void 0) || ((ref2 = booking.get('project')) != null ? (ref3 = ref2.get('client')) != null ? ref3.get('color') : void 0 : void 0);
            } else if (this.mode === 'booker') {
                color = (ref4 = booking.get('booker')) != null ? ref4.get('color') : void 0;
            }
            return (base = RG.Variables.colorSets)[color] != null ? base[color] : base[color] = new RG.Utils.Color(color || "#BFBFBF");
        };

        return ColorSource;

    })();

    RG.Utils.Color = (function () {
        Color.prototype.textLight = 35;

        function Color(hexColor) {
            this.hexColor = hexColor;
        }

        Color.prototype.toString = function () {
            return tinycolor(this.hexColor).toHexString();
        };

        Color.prototype.getColor = function () {
            return tinycolor(this.hexColor).toHexString();
        };

        Color.prototype.getBackgroundColor = function () {
            var hsl;
            hsl = tinycolor(this.hexColor).toHsv();
            if (hsl.s > 0.05) {
                hsl.s = 0.5;
                hsl.v = 1;
            } else {
                hsl.v = 0.9;
            }
            return tinycolor(hsl).toHexString();
        };

        Color.prototype.getBorderColor = function () {
            var hsl;
            hsl = tinycolor(this.hexColor).toHsv();
            if (hsl.s > 0.05) {
                hsl.s = 0.15;
                hsl.v = 0.9;
            } else {
                hsl.v = 0.85;
            }
            return tinycolor(hsl).toHexString();
        };

        Color.prototype.getTextColor = function () {
            var hsl;
            hsl = tinycolor(this.hexColor).toHsl();
            hsl.l = this.textLight;
            return tinycolor(hsl).toHexString();
        };

        return Color;

    })();

}).call(this);
;
(function () {
    RG.Utils.DatePopoverPlacer = (function () {
        function DatePopoverPlacer(resource, date, options) {
            this.resource = resource;
            this.date = date;
            if (options == null) {
                options = {};
            }
            this.options = options;
            this.offsetTop = options.offsetTop;
        }

        DatePopoverPlacer.prototype.getCalUnit = function () {
            return this.calUnit || (this.calUnit = this._findCalUnit());
        };

        DatePopoverPlacer.prototype.createAnchor = function (arg) {
            var anchor, className;
            className = (arg != null ? arg : {}).className;
            this.getCalUnit();
            anchor = $(document.createElement('div')).addClass("dropdown-anchor").addClass(className);
            this.calUnit.append(anchor);
            if (this.offsetTop) {
                anchor.offset({
                    top: this.offsetTop
                });
            }
            return anchor;
        };

        DatePopoverPlacer.prototype._findCalUnit = function () {
            var dateSelector, firstVisibleDate, lastVisibleDate;
            firstVisibleDate = window.dateController._startDate();
            lastVisibleDate = window.dateController._endDate();
            if (this.date.getTime() < firstVisibleDate.getTime()) {
                this.date = firstVisibleDate;
            } else if (this.date.getTime() > lastVisibleDate.getTime()) {
                this.date = lastVisibleDate;
            }
            dateSelector = RG.Utils.DateFormatter.getISODate(this.date);
            return $(".resource-line[data-resource-id=" + this.resource.cid + "]").find(".resources--cal-unit[data-date=" + dateSelector + "]");
        };

        return DatePopoverPlacer;

    })();

}).call(this);
;
(function () {
    RG.Utils.DayName = (function () {
        var days, longDays;

        days = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];

        longDays = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];

        function DayName(dayNumber) {
            this.dayNumber = dayNumber;
        }

        DayName.prototype.toString = function () {
            return days[this.dayNumber];
        };

        DayName.prototype.fullName = function () {
            return longDays[this.dayNumber];
        };

        return DayName;

    })();

}).call(this);
;
(function () {
    RG.Utils.DowntimeCalendarUpdater = (function () {
        function DowntimeCalendarUpdater(currentUserTimeZone, account, resources, timeZones, affectedResources) {
            this.currentUserTimeZone = currentUserTimeZone;
            this.account = account;
            this.resources = resources;
            this.timeZones = timeZones;
            this.affectedResources = affectedResources;
        }

        DowntimeCalendarUpdater.prototype.update = function (downtime, durations, shouldDelete) {
            var dTime;
            dTime = this.account.downtimes.findWhere({
                id: downtime.id
            });
            if (dTime != null) {
                dTime.set(downtime.attributes);
            }
            return this._updateCalendar(downtime, durations, shouldDelete);
        };

        DowntimeCalendarUpdater.prototype.add = function (downtime, durations, shouldDelete) {
            this.account.downtimes.add(downtime);
            return this._updateCalendar(downtime, durations, shouldDelete);
        };

        DowntimeCalendarUpdater.prototype._updateCalendar = function (downtime, durations, shouldDelete) {
            var downtimeDurations, end, start;
            downtimeDurations = downtime.getDurations();
            start = downtimeDurations[0].getDate();
            end = downtimeDurations[downtimeDurations.length - 1].getDate();
            RG.renderer.enqueue(new RG.Renderer.ResourcesDateLock(this.resources, start, end), (function (_this) {
                return function () {
                    return _this._updateBookings(durations, shouldDelete);
                };
            })(this));
            return this.updateAffectedResources();
        };

        DowntimeCalendarUpdater.prototype._updateBookings = function (durations, shouldDelete) {
            var duration, i, len;
            for (i = 0, len = durations.length; i < len; i++) {
                duration = durations[i];
                if (shouldDelete) {
                    duration.removeAndUpdateBooking();
                } else {
                    duration.set({
                        waiting: true
                    });
                }
            }
        };

        DowntimeCalendarUpdater.prototype.updateAffectedResources = function () {
            var affectedVisibleResources, resourceMethods, visibleResourceIds;
            visibleResourceIds = window.resourcePaginator.getVisibleResourceIds();
            affectedVisibleResources = this.affectedResources.filter(function (resource) {
                return visibleResourceIds.indexOf(resource.id) !== -1;
            });
            resourceMethods = affectedVisibleResources.forEach(function (resource) {
                resource.refreshDowntimes();
            });
        };

        return DowntimeCalendarUpdater;

    })();

}).call(this);
;
(function () {
    RG.Utils.DowntimePresenter = (function () {
        function DowntimePresenter(downtime) {
            this.downtime = downtime;
            this.from = this.downtime.get('from');
            this.to = this.downtime.get('to');
            this.startTime = this.downtime.get('startTime');
            this.endTime = this.downtime.get('endTime');
        }

        DowntimePresenter.prototype.dateTimeString = function (dateFormatter) {
            var endTimeString, startTimeString;
            startTimeString = '';
            if (this.startTime > 0) {
                startTimeString = "(" + (this._startMinutesToTime()) + ")";
            }
            endTimeString = '';
            if (this.endTime < 1440) {
                endTimeString = "(" + (this._endMinutesToTime()) + ")";
            }
            if (RG.Utils.DateComparator.equalsYMD(this.from, this.to)) {
                if (this.startTime === 0 && this.endTime === 1440) {
                    return "All day";
                } else {
                    return (this._startMinutesToTime()) + " - " + (this._endMinutesToTime());
                }
            } else {
                if (this._sameYear()) {
                    return (RG.Utils.DateFormatter.getShortDate(this.from)) + " " + startTimeString + " - " + (dateFormatter(this.to)) + " " + endTimeString;
                } else {
                    return (dateFormatter(this.from)) + " " + startTimeString + " - " + (dateFormatter(this.to)) + " " + endTimeString;
                }
            }
        };

        DowntimePresenter.prototype._startMinutesToTime = function () {
            return RG.Utils.TimeFormatter.formatFixedTime(this.startTime);
        };

        DowntimePresenter.prototype._endMinutesToTime = function () {
            return RG.Utils.TimeFormatter.formatFixedTime(this.endTime);
        };

        DowntimePresenter.prototype._sameYear = function () {
            return this.from.getYear() === this.to.getYear();
        };

        return DowntimePresenter;

    })();

}).call(this);
;
(function () {
    RG.Utils.ErrorHandler = (function () {
        function ErrorHandler(el1, backpackErrorsFields, errorData1) {
            this.el = el1;
            this.backpackErrorsFields = backpackErrorsFields;
            this.errorData = errorData1;
        }

        ErrorHandler.prototype.handleErrors = function () {
            var handleError, i, len, obj, ref, results;
            handleError = function (el, errorData, obj) {
                return RGComponents.createBackpackError($(el).find(obj.mountpoint)[0], obj.label, errorData);
            };
            ref = this.backpackErrorsFields;
            results = [];
            for (i = 0, len = ref.length; i < len; i++) {
                obj = ref[i];
                results.push(handleError(this.el, this.errorData, obj));
            }
            return results;
        };

        return ErrorHandler;

    })();

}).call(this);
;
(function () {
    RG.Utils.EventPopoverPlacer = (function () {
        function EventPopoverPlacer(event, targetClass, options) {
            this.event = event;
            if (options == null) {
                options = {};
            }
            this.targetClass = targetClass;
            this.options = options;
        }

        EventPopoverPlacer.prototype.getCalUnit = function () {
            return this.calUnit || (this.calUnit = this._findCalUnit());
        };

        EventPopoverPlacer.prototype.createAnchor = function (arg) {
            var anchor, className, height, offset;
            className = (arg != null ? arg : {}).className;
            this.getCalUnit();
            anchor = $(document.createElement('div')).addClass("dropdown-anchor").addClass(className);
            this.calUnit.append(anchor);
            if (this.target) {
                height = this.target.outerHeight();
                offset = this.target.offset();
                anchor.callback = (function (_this) {
                    return function (poppingUp) {
                        var topOffset;
                        if (poppingUp) {
                            height = 0 + _this.options.topAdjustment;
                        }
                        topOffset = (offset != null ? offset.top : void 0) || 0;
                        return anchor.offset({
                            top: topOffset + height
                        });
                    };
                })(this);
                return anchor;
            }
            anchor.offset({
                top: this.calUnit.offset().top + this._relativeY()
            });
            return anchor;
        };

        EventPopoverPlacer.prototype._findCalUnit = function () {
            var counter, element, elements, i, len, target;
            elements = [];
            target = $(this.event.target);
            if (target.hasClass('time-available') || target.closest('.utilisation').length) {
                this.calUnit = target.closest('.resources--cal-unit');
                this.target = this.calUnit.find("." + this.targetClass);
                return this.calUnit;
            }
            counter = 0;
            while (!target.hasClass('resources--cal-unit')) {
                if (counter === 5) {
                    break;
                }
                counter += 1;
                if (target.hasClass(this.targetClass)) {
                    this.target = target;
                }
                elements.push(target);
                target.css('visibility', 'hidden');
                target = $(document.elementFromPoint(this.event.clientX, this.event.clientY));
            }
            for (i = 0, len = elements.length; i < len; i++) {
                element = elements[i];
                element.css('visibility', 'visible');
            }
            return this.calUnit = target;
        };

        EventPopoverPlacer.prototype._relativeY = function () {
            var rect, relativeY;
            relativeY = this.event.pageY - this.calUnit.offset().top;
            rect = this.calUnit[0].getBoundingClientRect();
            if (relativeY < 0 || relativeY > rect.height) {
                if (this.targetClass === 'utilisation') {
                    rect = this.calUnit.find('.utilisation')[0].getBoundingClientRect();
                }
                relativeY = rect.height / 2;
            }
            return relativeY;
        };

        return EventPopoverPlacer;

    })();

}).call(this);
;
(function () {
    RG.Utils.FilterSource = (function () {
        function FilterSource(resourceTypes1, resources, projects1, clients1) {
            this.resourceTypes = resourceTypes1;
            this.resources = resources;
            this.projects = projects1;
            this.clients = clients1;
            _.extend(this, Backbone.Events);
        }

        FilterSource.prototype.getCategories = function () {
            return new RG.Collections.FilterCategories(this.buildCategories());
        };

        FilterSource.prototype.buildCategories = function () {
            var categories, category, i, len, resourceType, resourceTypes;
            categories = [this._getProjectsFilterCategory(), this._getClientsFilterCategory()];
            resourceTypes = this.resourceTypes.sortBy(function (rt) {
                var ref;
                if (rt.get('name') === "Person") {
                    return '0';
                }
                return (ref = rt.get('name')) != null ? ref.toLowerCase() : void 0;
            });
            for (i = 0, len = resourceTypes.length; i < len; i++) {
                resourceType = resourceTypes[i];
                category = new RG.Models.FilterCategory({
                    name: resourceType.getName(),
                    tag: resourceType
                });
                category.optionGroups.reset(this._getOptionGroups(resourceType));
                categories.push(category);
            }
            return categories;
        };

        FilterSource.prototype._getClientsFilterCategory = function () {
            var clients, fc, optionGroup;
            optionGroup = new RG.Models.OptionGroup({
                name: "Client",
                multiple: true
            });
            clients = this.clients.filter(function (c) {
                return !c.get('archived');
            });
            optionGroup.options.reset(_.map(clients, function (c) {
                return new RG.Models.FilterOption({
                    id: c.id,
                    name: c.getName(),
                    tag: 'client',
                    ref: c
                });
            }));
            fc = new RG.Models.FilterCategory({
                name: "Clients"
            });
            fc.optionGroups.reset([optionGroup]);
            return fc;
        };

        FilterSource.prototype._getProjectsFilterCategory = function () {
            var fc, optionGroup, projects;
            optionGroup = new RG.Models.OptionGroup({
                name: "Project",
                multiple: true
            });
            projects = this.projects.filter(function (c) {
                return !c.get('archived');
            });
            optionGroup.options.reset(_.map(projects, function (p) {
                return new RG.Models.FilterOption({
                    id: p.id,
                    name: p.getNameWithProjectCode(),
                    tag: 'project',
                    ref: p
                });
            }));
            fc = new RG.Models.FilterCategory({
                name: "Projects"
            });
            fc.optionGroups.reset([optionGroup]);
            return fc;
        };

        FilterSource.prototype._getOptionGroups = function (resourceType) {
            var nameOptionGroup, optionGroups, resourceNameOptions;
            optionGroups = resourceType.customFields.map(function (cf) {
                var isMultiple, optionGroup, options;
                isMultiple = !(resourceType.getName() === "Person" && cf.get('name') === "Job Title");
                optionGroup = new RG.Models.OptionGroup({
                    name: cf.get('name'),
                    multiple: isMultiple,
                    tag: cf
                });
                options = cf.customFieldOptions.map(function (cfo) {
                    return new RG.Models.FilterOption({
                        id: cfo.id,
                        name: cfo.escape('name'),
                        tag: "custom_field_option",
                        ref: cfo,
                        customField: cf
                    });
                });
                optionGroup.options.reset(options);
                return optionGroup;
            });
            nameOptionGroup = new RG.Models.OptionGroup({
                name: "Name",
                multiple: false
            });
            resourceNameOptions = this.resources.filter(function (r) {
                return r.get('resourceType') === resourceType && r.isBookable();
            }).map(function (r) {
                return new RG.Models.FilterOption({
                    id: r.id,
                    name: r.escape('name'),
                    tag: "resource",
                    ref: r
                });
            });
            nameOptionGroup.options.reset(resourceNameOptions);
            optionGroups.unshift(nameOptionGroup);
            return optionGroups;
        };

        return FilterSource;

    })();

}).call(this);
;
(function () {
    var bind = function (fn, me) { return function () { return fn.apply(me, arguments); }; };

    RG.Utils.InfiniteResourceScroller = (function () {
        function InfiniteResourceScroller($window, $document, paginator, resources, resourceLimit) {
            this.$window = $window;
            this.$document = $document;
            this.paginator = paginator;
            this.resources = resources;
            this.resourceLimit = resourceLimit;
            this.reSizeCards = bind(this.reSizeCards, this);
            this.resizing = false;
            this.scrolling = false;
            this.nextButton = $('.next-resources');
            this.prevButton = $('.previous-resources');
            this.buttons = [this.nextButton, this.prevButton];
        }

        InfiniteResourceScroller.prototype.start = function () {
            var loadMoreResources;
            this.nextButton.on('click', (function (_this) {
                return function () {
                    _this.showLoadButton();
                    return setTimeout(function () {
                        return _this.scrollDown();
                    }, 50);
                };
            })(this));
            this.prevButton.on('click', (function (_this) {
                return function () {
                    _this.showLoadButton();
                    return setTimeout(function () {
                        return _this.scrollUp();
                    }, 50);
                };
            })(this));
            loadMoreResources = (function (_this) {
                return function () {
                    if (_this._scrollingVertical) {
                        return;
                    }
                    _this._scrollingVertical = true;
                    return requestAnimationFrame(function () {
                        _this.fadeButtonElements();
                        return _this._scrollingVertical = false;
                    });
                };
            })(this);
            window.onscroll = loadMoreResources;
            return this.$window.on('touchmove', loadMoreResources);
        };

        InfiniteResourceScroller.prototype.screenTop = function () {
            return this.$window.scrollTop();
        };

        InfiniteResourceScroller.prototype.screenBottom = function () {
            return this.$window.scrollTop() + this.screenHeight();
        };

        InfiniteResourceScroller.prototype.screenHeight = function () {
            return window.innerHeight;
        };

        InfiniteResourceScroller.prototype.nextButtonTriggerPosition = function () {
            return this.pageFullHeight() - 10;
        };

        InfiniteResourceScroller.prototype.pageFullHeight = function () {
            return $(document).height();
        };

        InfiniteResourceScroller.prototype.fadeButtonElements = function () {
            if (this.screenTop() < 10 && !this.paginator.isAtTop()) {
                this.prevButton.fadeIn();
                return this.nextButton.fadeOut();
            } else if (this.screenBottom() >= this.nextButtonTriggerPosition() && !this.paginator.isAtBottom()) {
                this.prevButton.fadeOut();
                return this.nextButton.fadeIn();
            } else {
                this.prevButton.fadeOut();
                return this.nextButton.fadeOut();
            }
        };

        InfiniteResourceScroller.prototype.scrollDown = function () {
            this.resource = this.paginator.getPaginatedCollection().last();
            return setTimeout((function (_this) {
                return function () {
                    var loadSize;
                    loadSize = _this.paginator.loadSize;
                    _this.paginator.loadSize = 10;
                    _this.paginator.next();
                    _this.paginator.loadSize = loadSize;
                    _this.trimToLimit('down');
                    return _this.reSizeCards();
                };
            })(this));
        };

        InfiniteResourceScroller.prototype.scrollUp = function () {
            this.resource = this.paginator.getPaginatedCollection().first();
            if (this.headersHeight == null) {
                this.headersHeight = $('#header').height() + _.reduce($('header'), (function (memory, e) {
                    return e.scrollHeight + memory;
                }), 0);
            }
            return setTimeout((function (_this) {
                return function () {
                    var loadSize;
                    loadSize = _this.paginator.loadSize;
                    _this.paginator.loadSize = 10;
                    _this.paginator.previous();
                    _this.paginator.loadSize = loadSize;
                    _this.trimToLimit('up');
                    setTimeout(function () {
                        return RG.setCurrentResource(_this.resource);
                    });
                    return _this.reSizeCards();
                };
            })(this));
        };

        InfiniteResourceScroller.prototype.displayNext = function () {
            return this.nextButton.show();
        };

        InfiniteResourceScroller.prototype.displayPrev = function () {
            return this.prevButton.show();
        };

        InfiniteResourceScroller.prototype.showLoadButton = function () {
            return window.requestAnimationFrame((function (_this) {
                return function () {
                    return _.each(_this.buttons, function (button) {
                        return button.addClass('loading');
                    });
                };
            })(this));
        };

        InfiniteResourceScroller.prototype.hideLoadButton = function () {
            return window.requestAnimationFrame((function (_this) {
                return function () {
                    return _.each(_this.buttons, function (button) {
                        button.removeClass('loading');
                        return button.hide();
                    });
                };
            })(this));
        };

        InfiniteResourceScroller.prototype.trimToLimit = function (direction) {
            var loadSize;
            if (this.paginator.getPaginatedCollection().length > this.resourceLimit) {
                loadSize = this.paginator.loadSize;
                this.paginator.loadSize = this.resourceLimit;
                if (direction === 'down') {
                    this.paginator.trimTop();
                } else {
                    this.paginator.trimBottom();
                }
                this.paginator.loadSize = loadSize;
            }
            return setTimeout((function (_this) {
                return function () {
                    return _this.hideLoadButton();
                };
            })(this));
        };

        InfiniteResourceScroller.prototype.reSizeCards = function () {
            if (this.resizing) {
                return;
            }
            this.resizing = true;
            this.paginator.getPaginatedCollection().trigger('reset');
            RG.resizeCards();
            return setTimeout((function (_this) {
                return function () {
                    RG.resizeCards();
                    return setTimeout(function () {
                        RG.resizeCards();
                        return setTimeout(function () {
                            RG.resizeCards();
                            return _this.resizing = false;
                        }, 800);
                    }, 200);
                };
            })(this), 50);
        };

        return InfiniteResourceScroller;

    })();

}).call(this);
;
(function () {
    RG.Utils.scrollSize = function () {
        var multiplier;
        multiplier = $("#calendar").hasClass("detailed") ? 2 : 7;
        return ($(".cal-unit").width() * multiplier) + multiplier;
    };

    RG.Utils.firstVisibleDate = function () {
        return moment(window.dateController._startDate());
    };

    RG.Utils.lastVisibleDate = function () {
        return moment(window.dateController._endDate());
    };

    RG.Utils.visibleDateRange = function () {
        return new RG.Utils.DateRange(window.dateController._startDate(), window.dateController._endDate());
    };

    RG.Utils.DayInMilliSeconds = 86400000;

    RG.Utils.numberOfVisibleDays = function () {
        return RG.Utils.visibleDateRange().getNumberOfDays();
    };

    RG.Utils.isMonday = function (duration) {
        return duration.attributes.date.getDay() === 1;
    };

    RG.Utils.endTime = function (typeName) {
        var displacement, startTime;
        startTime = +window.rgStorage.get('startTime');
        displacement = +window.rgStorage.get(typeName);
        return startTime + displacement;
    };

    RG.Utils.generateTimeUnitId = function (cid, date) {
        date = RG.Utils.DateFormatter.getISODate(date);
        return cid + "-" + date;
    };

    RG.Utils.bookingBeingSaved = function () {
        return _.find(_.flatten(_.collect(window.resources.models, function (resource) {
            return resource.bookings;
        })), function (bookings) {
            return _.find(bookings.models, function (booking) {
                return booking.get("saving");
            });
        });
    };

    RG.Utils.enableScrolling = function (shouldEnable) {
        if (shouldEnable == null) {
            shouldEnable = true;
        }
        if (shouldEnable) {
            return $('body').removeClass('stop-scrolling');
        } else {
            return $('body').addClass('stop-scrolling');
        }
    };

    RG.Utils.getLastUsedFilters = function () {
        var ex, lastFiltersAst;
        lastFiltersAst = window.rgStorage.get('lastFiltersAst');
        if (lastFiltersAst) {
            try {
                return JSON.parse(lastFiltersAst);
            } catch (error) {
                ex = error;
                return [];
            }
        } else {
            return [];
        }
    };

    RG.Utils.delayResizeCards = function () {
        if (RG.Variables.cardSizeTimeout != null) {
            clearTimeout(RG.Variables.cardSizeTimeout);
        }
        return RG.Variables.cardSizeTimeout = setTimeout(function () {
            RG.resizeCards();
            return setTimeout(function () {
                return $(window).trigger('scroll');
            }, 2000);
        }, 200);
    };

    RG.Utils.getModelAttributes = function (models) {
        return models.map(function (model) {
            return model.attributes;
        });
    };

    RG.Utils.getTodayISO = function () {
        return RG.Utils.DateFormatter.getISODate(new Date);
    };

    RG.Utils.renderChecker = function () {
        return RG.Variables.lastRenderCall = new Date;
    };

    RG.Utils.unitsRendered = function () {
        if (RG.Variables.lastRenderCall === null) {
            return false;
        }
        return (new Date() - RG.Variables.lastRenderCall) > 500;
    };

    RG.Utils.isZoomedIn = function () {
        var zoomLevel;
        zoomLevel = window.rgStorage.get('zoomLevel');
        return zoomLevel === "detailed";
    };

}).call(this);
;
(function () {
    RG.Utils.Permissions = {
        getAdapter: function () {
            return new RG.Utils.CalendarPermissionsAdapter(window.currentUserId, window.userPermissions);
        },
        canManage: function (booking) {
            return this.getAdapter().canManage(booking);
        },
        canAdd: function (resource) {
            return this.canAddBooking();
        },
        canAddBooking: function (resource) {
            return window.userPermissions.bookingRights === "manage_all" || window.userPermissions.bookingRights === "manage_own";
        },
        canAddProject: function (resource) {
            return window.userPermissions.projectRights === "manage_all" || window.userPermissions.projectRights === "manage_own";
        },
        canAddClient: function (resource) {
            return window.userPermissions.clientRights === "manage_all" || window.userPermissions.clientRights === "manage_own";
        },
        canManageResource: function (resource) {
            return window.userPermissions.resourceRights === "manage_all" || (window.userPermissions.resourceRights === "manage_own" && window.currentResourceInstanceId === resource.id);
        },
        canManageDowntime: function (downtime) {
            return this.getAdapter().canManageDowntime(downtime);
        },
        canAddDowntime: function () {
            return this.getAdapter().canAddDowntime();
        },
        canMoveClashBookingToWaitingList: function () {
            var ref;
            return (ref = this.getAdapter()).canMoveClashBookingToWaitingList.apply(ref, arguments);
        },
        canDeleteClashBooking: function () {
            var ref;
            return (ref = this.getAdapter()).canDeleteClashBooking.apply(ref, arguments);
        }
    };

}).call(this);
;
(function () {
    RG.Utils.profile = function (label, bookingId) {
        if (label == null) {
            label = 'downtime';
        }
        if (bookingId == null) {
            bookingId = 3680550;
        }
        console.profile(label);
        console.time(label);
        return setTimeout(function () {
            var element;
            element = $(".booking[data-booking-id=" + bookingId + "]");
            if (element.length) {
                return window.requestAnimationFrame(function () {
                    console.profileEnd();
                    return console.timeEnd('downtime');
                });
            } else {
                return RG.Utils.profile(label, bookingId);
            }
        }, 10);
    };

}).call(this);
;
(function () {
    RG.Utils.ResourceFilter = (function () {
        function ResourceFilter(resourceTypes) {
            this.resourceTypes = resourceTypes;
        }

        ResourceFilter.prototype.filterBy = function (resources, ast) {
            return resources.select((function (_this) {
                return function (ri) {
                    return _this._resourceVisible(ri, ast);
                };
            })(this));
        };

        ResourceFilter.prototype._resourceVisible = function (ri, ast) {
            var clientOptions, clientVisible, clients, clientsAst, customFieldOptionOptions, matchMethod, options, projectOptions, projectVisible, projects, projectsAst, resourceOptions, resourceTypeAst, resourceTypeFilterVisible;
            if (!ri.isBookable()) {
                return false;
            }
            if (ast.length === 0) {
                return true;
            }
            options = this._getOptionsFromAst(ast);
            resourceOptions = _.filter(options, function (o) {
                return o.get('tag') === "resource";
            });
            customFieldOptionOptions = _.filter(options, function (o) {
                return o.get('tag') === "custom_field_option";
            });
            projectOptions = _.filter(options, function (o) {
                return o.get('tag') === "project";
            });
            clientOptions = _.filter(options, function (o) {
                return o.get('tag') === "client";
            });
            resourceTypeAst = _.filter(ast, function (o) {
                return o.matchType === "all" && !o.selectedOptions;
            });
            projectVisible = false;
            if (projectOptions.length > 0) {
                projectsAst = _.filter(ast, function (x) {
                    return x.selectedOptions && x.selectedOptions[0].get('tag') === "project";
                })[0];
                matchMethod = projectsAst.matchType === "any" ? _.any : _.all;
                projects = _.map(projectOptions, function (o) {
                    return o.get('ref');
                });
                projectVisible = matchMethod(projects, function (p) {
                    return ri.isBookedOnProject(p);
                });
            } else {
                projectVisible = clientOptions.length === 0;
            }
            clientVisible = false;
            if (clientOptions.length > 0) {
                clientsAst = _.filter(ast, function (x) {
                    return x.selectedOptions && x.selectedOptions[0].get('tag') === "client";
                })[0];
                matchMethod = clientsAst.matchType === "any" ? _.any : _.all;
                clients = _.map(clientOptions, function (o) {
                    return o.get('ref');
                });
                clientVisible = matchMethod(clients, function (c) {
                    return ri.isBookedOnClient(c);
                });
            } else {
                clientVisible = projectOptions.length === 0;
            }
            if (!(projectVisible || clientVisible)) {
                return false;
            }
            resourceTypeFilterVisible = [true];
            if (resourceOptions.length > 0 || customFieldOptionOptions.length > 0 || resourceTypeAst.length > 0) {
                resourceTypeFilterVisible = this.resourceTypes.map((function (_this) {
                    return function (resourceType) {
                        var astByOptionGroup, customFieldOptions, optionGroupId, optionGroupsVisible, rtVisible, subAst, typedCustomFieldOptions, typedResourceOptions, typedResourceTypeAst;
                        rtVisible = false;
                        typedResourceOptions = _.filter(resourceOptions, function (o) {
                            return o.get('ref').get('resourceType') === resourceType;
                        });
                        typedCustomFieldOptions = _.filter(customFieldOptionOptions, function (o) {
                            return o.get('ref').get('resourceType') === resourceType;
                        });
                        typedResourceTypeAst = _.filter(resourceTypeAst, function (x) {
                            return x.resourceType === resourceType;
                        });
                        if (typedResourceTypeAst.length > 0) {
                            rtVisible = _.any(typedResourceTypeAst, function (x) {
                                return x.resourceType === ri.get('resourceType');
                            });
                            if (!rtVisible) {
                                return false;
                            }
                        }
                        if (typedResourceOptions.length > 0) {
                            rtVisible = _.include(_.map(typedResourceOptions, function (o) {
                                return o.get('ref');
                            }), ri);
                            if (!rtVisible) {
                                return false;
                            }
                        }
                        if (typedCustomFieldOptions.length > 0 && ri.get('resourceType') === resourceType) {
                            resourceTypeAst = _.filter(ast, function (x) {
                                return x.selectedOptions && x.selectedOptions[0].get('ref').get('resourceType') === resourceType && x.selectedOptions[0].get('tag') === "custom_field_option";
                            });
                            astByOptionGroup = _.groupBy(resourceTypeAst, function (x) {
                                return x.optionGroup.cid;
                            });
                            optionGroupsVisible = [];
                            for (optionGroupId in astByOptionGroup) {
                                subAst = astByOptionGroup[optionGroupId];
                                options = _.flatten(_.map(subAst, function (x) {
                                    return x.selectedOptions;
                                }));
                                customFieldOptions = _.map(options, function (x) {
                                    return x.get('ref');
                                });
                                matchMethod = null;
                                if (subAst[0].matchType === "any") {
                                    matchMethod = _.any;
                                } else {
                                    matchMethod = _.all;
                                }
                                optionGroupsVisible.push(matchMethod(customFieldOptions, function (cfo) {
                                    return ri.hasCustomFieldOption(cfo);
                                }));
                            }
                            rtVisible = _.all(optionGroupsVisible, function (x) {
                                return x === true;
                            });
                        }
                        return rtVisible;
                    };
                })(this));
            }
            return _.any(resourceTypeFilterVisible, function (x) {
                return x === true;
            });
        };

        ResourceFilter.prototype._getOptionsFromAst = function (ast) {
            return _.compact(_.flatten(_.map(ast, function (x) {
                return x.selectedOptions;
            })));
        };

        ResourceFilter.prototype._getCustomFieldOptionsFromTokens = function (tokens) {
            var searches;
            searches = [];
            _.each(tokens, function (term) {
                return _.each(term, function (v, k) {
                    return searches.push([k, v]);
                });
            });
            return _.compact(_.map(searches, (function (_this) {
                return function (search) {
                    var customField, customFieldOption, customFieldStr, key, resourceType, resourceTypeStr, value;
                    key = search[0];
                    value = search[1];
                    resourceTypeStr = key.substr(0, key.indexOf('>') - 1);
                    customFieldStr = key.substr(key.indexOf('>') + 2);
                    resourceType = _this.resourceTypes.findWhere({
                        name: resourceTypeStr
                    });
                    customField = resourceType.customFields.findWhere({
                        name: customFieldStr
                    });
                    if (customField != null) {
                        customFieldOption = customField.customFieldOptions.findWhere({
                            name: value
                        });
                        return customFieldOption;
                    } else {
                        return null;
                    }
                };
            })(this)));
        };

        return ResourceFilter;

    })();

}).call(this);
;
(function () {
    RG.Utils.ResourcePaginator = (function () {
        function ResourcePaginator(resources, loadSize) {
            this.resources = resources;
            this.loadSize = loadSize;
        }

        ResourcePaginator.prototype.getPaginatedCollection = function () {
            if (this._collection) {
                return this._collection;
            }
            this._collection = new RG.Collections.ResourceInstances();
            this.sourceCollection = this.resources;
            this.resources.on('change:visible', (function (_this) {
                return function () {
                    if (_this.resources.any(function (r) {
                        return !r.visible;
                    })) {
                        _this.sourceCollection = new RG.Collections.ResourceInstances(_this.resources.filter(function (r) {
                            return r.visible;
                        }));
                        _this._collection.reset(_this.sourceCollection.first(_this.loadSize));
                    } else {
                        _this.reset();
                    }
                    return _this._collection.trigger('change:visible');
                };
            })(this));
            return this._collection;
        };

        ResourcePaginator.prototype.getVisibleResourceIds = function () {
            return this.getPaginatedCollection().map(function (r) {
                return r.id;
            });
        };

        ResourcePaginator.prototype.isAtBottom = function () {
            return this._collection.models[this._collection.length - 1] === this.sourceCollection.models[this.sourceCollection.length - 1];
        };

        ResourcePaginator.prototype.isAtTop = function () {
            return this._collection.models[0] === this.sourceCollection.models[0];
        };

        ResourcePaginator.prototype.reset = function () {
            if (this.resources.any(function (r) {
                return !r.visible;
            })) {
                this.sourceCollection = new RG.Collections.ResourceInstances(this.resources.filter(function (r) {
                    return r.visible;
                }));
                this._collection.reset(this.sourceCollection.first(this.loadSize));
            } else {
                this.sourceCollection = this.resources;
            }
            return this._collection.reset(this.sourceCollection.first(this.loadSize));
        };

        ResourcePaginator.prototype.next = function () {
            var firstIndex, i, j, model, models, ref, ref1, results;
            if (this.isAtBottom()) {
                return;
            }
            models = [];
            firstIndex = this.sourceCollection.indexOf(this._collection.models[this._collection.length - 1]) + 1;
            results = [];
            for (i = j = ref = firstIndex, ref1 = firstIndex + this.loadSize - 1; ref <= ref1 ? j <= ref1 : j >= ref1; i = ref <= ref1 ? ++j : --j) {
                model = this.sourceCollection.models[i];
                if (model) {
                    results.push(this._collection.add(model));
                } else {
                    results.push(void 0);
                }
            }
            return results;
        };

        ResourcePaginator.prototype.previous = function () {
            var firstIndex, i, j, model, ref, ref1, results;
            if (this.isAtTop()) {
                return;
            }
            firstIndex = this.sourceCollection.indexOf(this._collection.models[0]) - 1;
            results = [];
            for (i = j = ref = firstIndex, ref1 = firstIndex - this.loadSize; ref <= ref1 ? j <= ref1 : j >= ref1; i = ref <= ref1 ? ++j : --j) {
                model = this.sourceCollection.models[i];
                if (model) {
                    results.push(this._collection.unshift(model));
                } else {
                    results.push(void 0);
                }
            }
            return results;
        };

        ResourcePaginator.prototype.overLimitCount = function () {
            return this._collection.length - +(this.loadSize / 2);
        };

        ResourcePaginator.prototype.trimTop = function () {
            var overLimit;
            overLimit = this.overLimitCount();
            return _.each(_.range(0, overLimit), (function (_this) {
                return function (x) {
                    return _this._collection.remove(_this._collection.models[0]);
                };
            })(this));
        };

        ResourcePaginator.prototype.trimBottom = function () {
            var overLimit;
            overLimit = this.overLimitCount();
            return _.each(_.range(0, overLimit), (function (_this) {
                return function (x) {
                    return _this._collection.remove(_this._collection.models[_this._collection.length - 1]);
                };
            })(this));
        };

        ResourcePaginator.prototype.start = function () {
            var $window;
            return $window = $(window);
        };

        return ResourcePaginator;

    })();

}).call(this);
;
(function () {
    SpriteSpinner = function (el, options) {
        var self = this,
            img = el.children[0];
        this.interval = options.interval || 10;
        this.diameter = options.diameter || img.width;
        this.count = 0;
        this.el = el;
        img.setAttribute("style", "position:absolute");
        el.style.width = this.diameter + "px";
        el.style.height = this.diameter + "px";
        return this;
    };
    SpriteSpinner.prototype.start = function () {
        var self = this,
            count = 0,
            img = this.el.children[0];
        this.el.display = "block";
        self.loop = setInterval(function () {
            if (count == 19) {
                count = 0;
            }
            img.style.top = (-self.diameter * count) + "px";
            count++;
        }, this.interval);
    };
    SpriteSpinner.prototype.stop = function () {
        clearInterval(this.loop);
        this.el.style.display = "none";
    };
    document.SpriteSpinner = SpriteSpinner;
})();
// $(document).ready(function(){
//     $(".sprite-spinner").each(function(i){
//       var s = new SpriteSpinner(this, {
//         interval:50
//       });
//       s.start();
//     });
// });
;
(function () {
    RG.Utils.SteppedExecutor = (function () {
        function SteppedExecutor() { }

        SteppedExecutor.prototype.stepEach = function (methods, delayMultiplier) {
            var wrappedPromises;
            if (delayMultiplier == null) {
                delayMultiplier = 10;
            }
            wrappedPromises = _.map(methods, function (method, index) {
                var delay;
                delay = delayMultiplier * (index + 1);
                return Q.delay(delay).then(method)["catch"](function (e) {
                    return console.log(e);
                });
            });
            return Q.allSettled(wrappedPromises);
        };

        return SteppedExecutor;

    })();

}).call(this);
;
(function () {
    RG.Utils.TimePeriodsCalculator = (function () {
        function TimePeriodsCalculator(collection) {
            this.collection = collection;
            this._minutes = {};
            this._dateMinutes = {};
            this.collection.on('add remove reset change:startTime change:endTime maxAvailabilityChanged', (function (_this) {
                return function () {
                    _this._minutes = {};
                    return _this._dateMinutes = {};
                };
            })(this));
        }

        TimePeriodsCalculator.prototype.sum = function (date) {
            var i, key, len, minutes, period, ref;
            key = date.valueOf().toString();
            if (this._dateMinutes[key]) {
                return this._dateMinutes[key];
            }
            minutes = 0;
            ref = this.collection.models;
            for (i = 0, len = ref.length; i < len; i++) {
                period = ref[i];
                if (period.isValidOn(date)) {
                    minutes += period.getMinutesAvailable();
                }
            }
            return this._dateMinutes[key] = minutes;
        };

        TimePeriodsCalculator.prototype.availableMinutes = function (dateRange) {
            var date, day, i, j, key, len, minutes, period, ref, ref1, sd;
            key = dateRange.startDate.valueOf().toString() + ':' + dateRange.endDate.valueOf().toString();
            if (this._minutes[key]) {
                return this._minutes[key];
            }
            sd = dateRange.startDate;
            minutes = 0;
            date = new Date(sd);
            for (day = i = 0, ref = dateRange.getNumberOfDays() - 1; 0 <= ref ? i <= ref : i >= ref; day = 0 <= ref ? ++i : --i) {
                ref1 = this.collection.models;
                for (j = 0, len = ref1.length; j < len; j++) {
                    period = ref1[j];
                    if (period.isValidOn(date)) {
                        minutes += period.getMinutesAvailable();
                    }
                }
                date.setDate(date.getDate() + 1);
            }
            return this._minutes[key] = minutes;
        };

        return TimePeriodsCalculator;

    })();

}).call(this);
;
(function () {
    RG.Utils.VisualSearchFacetAdapter = (function () {
        function VisualSearchFacetAdapter(value, category, facet1) {
            this.value = value;
            this.category = category;
            this.facet = facet1;
        }

        VisualSearchFacetAdapter.prototype.toSearchFacet = function () {
            var facet;
            facet = {
                category: this.category,
                label: {
                    toString: (function (_this) {
                        return function () {
                            return _this.facet;
                        };
                    })(this),
                    trim: (function (_this) {
                        return function () {
                            return {
                                value: _this.value,
                                toString: function () {
                                    return _this.category + " > " + _this.facet;
                                }
                            };
                        };
                    })(this)
                }
            };
            return facet;
        };

        return VisualSearchFacetAdapter;

    })();

}).call(this);
;
(function () {
    RG.Parsers.AvailablePeriodParser = (function () {
        function AvailablePeriodParser(dateStringProcessor) {
            this.dateStringProcessor = dateStringProcessor;
        }

        AvailablePeriodParser.prototype.parse = function (resourceInstance, resource) {
            var ap, apm, aps, i, len, ref;
            aps = [];
            ref = resource.available_periods;
            for (i = 0, len = ref.length; i < len; i++) {
                ap = ref[i];
                apm = new RG.Models.AvailablePeriod({
                    weekDay: ap.week_day,
                    startTime: ap.start_time,
                    endTime: ap.end_time,
                    validFrom: this.dateStringProcessor(ap.valid_from)
                });
                if (ap.valid_until) {
                    apm.set({
                        validUntil: this.dateStringProcessor(ap.valid_until)
                    });
                }
                aps.push(apm);
            }
            resourceInstance.availablePeriods.setModels(aps);
            return aps;
        };

        return AvailablePeriodParser;

    })();

}).call(this);
;
(function () {
    var indexOf = [].indexOf || function (item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

    RG.Parsers.BookerParser = (function () {
        function BookerParser(usersJson, resourcesJson, collection) {
            this.usersJson = usersJson;
            this.resourcesJson = resourcesJson;
            this.collection = collection;
        }

        BookerParser.prototype.parse = function () {
            var activeHumanResources, activeHumanResourcesEmails, bookerModels, i, len, ref, ref1, ref2, u;
            activeHumanResources = this.resourcesJson.filter(function (resource) {
                return resource.human === true;
            });
            activeHumanResourcesEmails = activeHumanResources.map(function (resource) {
                return resource.email;
            });
            bookerModels = [];
            ref = this.usersJson;
            for (i = 0, len = ref.length; i < len; i++) {
                u = ref[i];
                bookerModels.push(new RG.Models.Booker({
                    id: u.id,
                    name: u.first_name + " " + u.last_name,
                    imageUrl: u.image,
                    color: u.color,
                    archived: (ref1 = u.email, indexOf.call(activeHumanResourcesEmails, ref1) < 0)
                }));
            }
            if ((ref2 = this.collection) != null) {
                ref2.reset(bookerModels);
            }
            return bookerModels;
        };

        return BookerParser;

    })();

}).call(this);
;
(function () {
    RG.Parsers.BookingBuilder = (function () {
        function BookingBuilder(dateStringProcessor, durationParser, projects, clients, deletedProjects, deletedClients, bookers, deletedBookers) {
            this.dateStringProcessor = dateStringProcessor;
            this.durationParser = durationParser;
            this.projects = projects;
            this.clients = clients;
            this.deletedProjects = deletedProjects;
            this.deletedClients = deletedClients;
            this.bookers = bookers;
            this.deletedBookers = deletedBookers;
        }

        BookingBuilder.prototype.build = function (booking) {
            var attributes, b, booker, booker_found, c, client_found, deleted_booker, i, j, k, l, len, len1, len2, len3, len4, len5, m, n, p, project_found, ref, ref1, ref2, ref3, ref4, ref5;
            b = new RG.Models.Booking;
            attributes = {
                id: booking.id,
                notes: booking.notes,
                startDate: this.dateStringProcessor(booking.start_date),
                endDate: this.dateStringProcessor(booking.end_date),
                createdAt: new Date(booking.created_at),
                updatedAt: new Date(booking.updated_at),
                billable: booking.billable,
                refreshable: booking.refreshable
            };
            project_found = false;
            client_found = false;
            if (booking.project_id) {
                ref = this.projects.models;
                for (i = 0, len = ref.length; i < len; i++) {
                    p = ref[i];
                    if (p.id === booking.project_id) {
                        attributes.project = p;
                        project_found = true;
                        break;
                    }
                }
            } else if (booking.client_id) {
                ref1 = this.clients.models;
                for (j = 0, len1 = ref1.length; j < len1; j++) {
                    c = ref1[j];
                    if (c.id === booking.client_id) {
                        attributes.client = c;
                        client_found = true;
                        break;
                    }
                }
            }
            if (!project_found && booking.project_id) {
                ref2 = this.deletedProjects.models;
                for (k = 0, len2 = ref2.length; k < len2; k++) {
                    p = ref2[k];
                    if (p.id === booking.project_id) {
                        attributes.project = p;
                        break;
                    }
                }
            } else if (!client_found && booking.client_id) {
                ref3 = this.deletedClients.models;
                for (l = 0, len3 = ref3.length; l < len3; l++) {
                    c = ref3[l];
                    if (c.id === booking.client_id) {
                        attributes.client = c;
                        break;
                    }
                }
            }
            booker_found = false;
            ref4 = this.bookers.models;
            for (m = 0, len4 = ref4.length; m < len4; m++) {
                booker = ref4[m];
                if (booker.id === booking.booker.id) {
                    attributes.booker = booker;
                    booker_found = true;
                    break;
                }
            }
            if (!booker_found) {
                ref5 = this.deletedBookers.models;
                for (n = 0, len5 = ref5.length; n < len5; n++) {
                    deleted_booker = ref5[n];
                    if (deleted_booker.id === booking.booker.id) {
                        attributes.booker = deleted_booker;
                        break;
                    }
                }
            }
            b.attributes = attributes;
            b.id = attributes.id;
            this.durationParser.parse(b, booking);
            return b;
        };

        return BookingBuilder;

    })();

}).call(this);
;
(function () {
    RG.Parsers.BookingParser = (function () {
        function BookingParser(bookingsJson, bookingBuilder) {
            this.bookingsJson = bookingsJson;
            this.bookingBuilder = bookingBuilder;
        }

        BookingParser.prototype.parse = function (resourceModels) {
            var booking, bookings, i, j, len, len1, ref, resource;
            for (i = 0, len = resourceModels.length; i < len; i++) {
                resource = resourceModels[i];
                bookings = [];
                ref = this.bookingsJson;
                for (j = 0, len1 = ref.length; j < len1; j++) {
                    booking = ref[j];
                    if (booking.resource_id === resource.id) {
                        bookings.push(this.bookingBuilder.build(booking));
                    }
                }
                resource.bookings.setModels(bookings);
            }
        };

        return BookingParser;

    })();

}).call(this);
;
(function () {
    RG.Parsers.ClientParser = (function () {
        function ClientParser(clientsJson, archiveClientsJson, collection) {
            this.clientsJson = clientsJson;
            this.archiveClientsJson = archiveClientsJson;
            this.collection = collection;
        }

        ClientParser.prototype.parse = function () {
            var c, client, clientModels, i, j, len, len1, ref, ref1, ref2;
            clientModels = [];
            ref = this.clientsJson;
            for (i = 0, len = ref.length; i < len; i++) {
                client = ref[i];
                c = new RG.Models.Client;
                c.attributes = {
                    id: client.id,
                    name: client.name,
                    color: client.color
                };
                c.id = client.id;
                clientModels.push(c);
            }
            ref1 = this.archiveClientsJson;
            for (j = 0, len1 = ref1.length; j < len1; j++) {
                client = ref1[j];
                c = new RG.Models.Client;
                c.attributes = {
                    id: client.id,
                    name: client.name,
                    color: client.color,
                    archived: true
                };
                c.id = client.id;
                clientModels.push(c);
            }
            if ((ref2 = this.collection) != null) {
                ref2.reset(clientModels);
            }
            return clientModels;
        };

        return ClientParser;

    })();

}).call(this);
;
(function () {
    RG.Parsers.CustomAvailablePeriodParser = (function () {
        function CustomAvailablePeriodParser(dateStringProcessor) {
            this.dateStringProcessor = dateStringProcessor;
        }

        CustomAvailablePeriodParser.prototype.parse = function (resourceInstance, resource) {
            var ap, apm, aps, i, len, ref;
            aps = [];
            ref = resource.custom_available_periods;
            for (i = 0, len = ref.length; i < len; i++) {
                ap = ref[i];
                apm = new RG.Models.CustomAvailablePeriod({
                    date: this.dateStringProcessor(ap.date),
                    startTime: ap.start_time,
                    endTime: ap.end_time
                });
                aps.push(apm);
            }
            resourceInstance.customAvailablePeriods.setModels(aps);
            return aps;
        };

        return CustomAvailablePeriodParser;

    })();

}).call(this);
;
(function () {
    RG.Parsers.CustomFieldParser = (function () {
        function CustomFieldParser() { }

        CustomFieldParser.prototype.parse = function (resourceInstance, resource, resourceType) {
            var cf, i, j, len, len1, ref, resourceTypeFields, results, scf, scfom;
            ref = resource.selected_custom_field_options;
            results = [];
            for (i = 0, len = ref.length; i < len; i++) {
                scf = ref[i];
                resourceTypeFields = _.flatten(resourceType.customFields.map(function (cf) {
                    return cf.customFieldOptions.models;
                }));
                scfom = null;
                for (j = 0, len1 = resourceTypeFields.length; j < len1; j++) {
                    cf = resourceTypeFields[j];
                    if (scf.id === cf.id) {
                        scfom = cf;
                        break;
                    }
                }
                results.push(resourceInstance.customFieldOptions.add(scfom));
            }
            return results;
        };

        return CustomFieldParser;

    })();

}).call(this);
;
(function () {
    RG.Utils.CustomFieldParser = (function () {
        function CustomFieldParser() { }

        CustomFieldParser.prototype.parse = function (resourceInstance, resource, resourceType) {
            var cf, i, j, len, len1, ref, resourceTypeFields, results, scf, scfom;
            ref = resource.selected_custom_field_options;
            results = [];
            for (i = 0, len = ref.length; i < len; i++) {
                scf = ref[i];
                resourceTypeFields = _.flatten(resourceType.customFields.map(function (cf) {
                    return cf.customFieldOptions.models;
                }));
                scfom = null;
                for (j = 0, len1 = resourceTypeFields.length; j < len1; j++) {
                    cf = resourceTypeFields[j];
                    if (scf.id === cf.id) {
                        scfom = cf;
                        break;
                    }
                }
                results.push(resourceInstance.customFieldOptions.add(scfom));
            }
            return results;
        };

        return CustomFieldParser;

    })();

}).call(this);
;
(function () {
    RG.Parsers.DeletedBookerParser = (function () {
        function DeletedBookerParser(deletedBookerJson, collection) {
            this.deletedBookerJson = deletedBookerJson;
            this.collection = collection;
        }

        DeletedBookerParser.prototype.parse = function () {
            var bookerModels, i, len, ref, ref1, u;
            bookerModels = [];
            if (this.deletedBookerJson) {
                ref = this.deletedBookerJson;
                for (i = 0, len = ref.length; i < len; i++) {
                    u = ref[i];
                    bookerModels.push(new RG.Models.Booker({
                        id: u.id,
                        name: u.first_name + " " + u.last_name
                    }));
                }
                if ((ref1 = this.collection) != null) {
                    ref1.reset(bookerModels);
                }
            }
            return bookerModels;
        };

        return DeletedBookerParser;

    })();

}).call(this);
;
(function () {
    RG.Parsers.DeletedClientParser = (function () {
        function DeletedClientParser(deletedClientsJson, collection) {
            this.deletedClientsJson = deletedClientsJson;
            this.collection = collection;
        }

        DeletedClientParser.prototype.parse = function () {
            var client, deletedClients, i, len, ref, ref1;
            deletedClients = [];
            ref = this.deletedClientsJson;
            for (i = 0, len = ref.length; i < len; i++) {
                client = ref[i];
                deletedClients.push(new RG.Models.Client({
                    id: client.id,
                    name: client.name,
                    color: client.color
                }));
            }
            if ((ref1 = this.collection) != null) {
                ref1.reset(deletedClients);
            }
            return deletedClients;
        };

        return DeletedClientParser;

    })();

}).call(this);
;
(function () {
    RG.Parsers.DeletedProjectParser = (function () {
        function DeletedProjectParser(deletedProjectsJson, clientModels, collection) {
            this.deletedProjectsJson = deletedProjectsJson;
            this.clientModels = clientModels;
            this.collection = collection;
        }

        DeletedProjectParser.prototype.parse = function () {
            var i, len, p, project, projectModels, ref, ref1;
            projectModels = [];
            ref = this.deletedProjectsJson;
            for (i = 0, len = ref.length; i < len; i++) {
                p = ref[i];
                project = new RG.Models.Project({
                    id: p.id,
                    name: p.name,
                    color: p.color
                });
                if (p.client_id) {
                    project.set({
                        client: _.find(this.clientModels, function (c) {
                            return c.get('id') === p.client_id;
                        })
                    });
                }
                projectModels.push(project);
            }
            if ((ref1 = this.collection) != null) {
                ref1.reset(projectModels);
            }
            return projectModels;
        };

        return DeletedProjectParser;

    })();

}).call(this);
;
(function () {
    RG.Parsers.DowntimeParser = (function () {
        function DowntimeParser(downtimesJson, dateStringProcessor, collection, timezones, downtimeTypes) {
            this.downtimesJson = downtimesJson;
            this.dateStringProcessor = dateStringProcessor;
            this.collection = collection;
            this.timezones = timezones;
            this.downtimeTypes = downtimeTypes;
        }

        DowntimeParser.prototype.parse = function () {
            var allDowntimeIds, removedDowntimes;
            allDowntimeIds = this.downtimesJson.map(function (c) {
                return c.id;
            });
            removedDowntimes = this.collection.models.filter(function (d) {
                return allDowntimeIds.indexOf(d.id) === -1;
            });
            removedDowntimes.forEach((function (_this) {
                return function (d) {
                    var i, len, ref, results, rid;
                    _this.collection.remove(d);
                    ref = d.get('resourceIds');
                    results = [];
                    for (i = 0, len = ref.length; i < len; i++) {
                        rid = ref[i];
                        results.push(_this.collection.trigger("remove:resource_id:" + rid, d));
                    }
                    return results;
                };
            })(this));
            return this.downtimesJson.forEach((function (_this) {
                return function (downtime) {
                    var d, downtimeUpdatedAt, isNew, newAttributes, ref, resources;
                    d = _this.collection.findWhere({
                        id: downtime.id
                    });
                    if (!d) {
                        isNew = true;
                        d = new RG.Models.Downtime;
                    }
                    downtimeUpdatedAt = _this.dateStringProcessor(downtime.updated_at);
                    if (((ref = d.get('updatedAt')) != null ? ref.getTime() : void 0) === downtimeUpdatedAt) {
                        return;
                    }
                    newAttributes = {
                        id: downtime.id,
                        from: _this.dateStringProcessor(downtime.from),
                        to: _this.dateStringProcessor(downtime.to),
                        updatedAt: _this.dateStringProcessor(downtime.updated_at),
                        timeZone: _this.timezones.findWhere({
                            name: downtime.timezone
                        }),
                        startTime: downtime.start_time,
                        endTime: downtime.end_time,
                        downtimeTypeId: downtime.downtime_type_id,
                        details: downtime.details,
                        state: downtime.state,
                        creatorId: downtime.creator_id,
                        leave: downtime.leave,
                        resourceIds: downtime.resource_ids,
                        downtimeType: _this.downtimeTypes.findWhere({
                            id: downtime.downtime_type_id
                        })
                    };
                    resources = window.resources.filter(function (r) {
                        return downtime.resource_ids.indexOf(r) !== -1;
                    });
                    d.id = newAttributes.id;
                    return RG.renderer.enqueue(new RG.Renderer.GlobalLock, function () {
                        var i, len, ref1, results, rid;
                        if (!isNew && !_.isEqual(newAttributes, d.attributes)) {
                            d.set(newAttributes);
                        }
                        if (isNew) {
                            d.attributes = newAttributes;
                            _this.collection.add(d);
                            ref1 = downtime.resource_ids;
                            results = [];
                            for (i = 0, len = ref1.length; i < len; i++) {
                                rid = ref1[i];
                                results.push(_this.collection.trigger("add:resource_id:" + rid, d));
                            }
                            return results;
                        }
                    });
                };
            })(this));
        };

        return DowntimeParser;

    })();

}).call(this);
;
(function () {
    RG.Parsers.DurationParser = (function () {
        function DurationParser(dateStringProcessor) {
            this.dateStringProcessor = dateStringProcessor;
        }

        DurationParser.prototype.parse = function (bookingModel, booking) {
            var d, date, duration, durations, i, len, nextDate, prevDate, ref;
            durations = [];
            prevDate = null;
            ref = booking.durations;
            for (i = 0, len = ref.length; i < len; i++) {
                duration = ref[i];
                date = this.dateStringProcessor(duration.date);
                if (prevDate) {
                    while (new RG.Utils.DateRange(date, prevDate).getNumberOfDays() > 1) {
                        d = new RG.Models.Duration;
                        nextDate = new Date(prevDate);
                        nextDate.setDate(nextDate.getDate() + 1);
                        d.attributes = {
                            date: nextDate,
                            minutes: 0,
                            waiting: false
                        };
                        durations.push(d);
                        prevDate = new Date(nextDate);
                    }
                }
                if (duration.start_time || duration.start_time === 0) {
                    d = new RG.Models.FixedDuration;
                    d.attributes = {
                        date: date,
                        startTime: duration.start_time,
                        endTime: duration.end_time,
                        waiting: duration.waiting
                    };
                    durations.push(d);
                } else {
                    d = new RG.Models.Duration;
                    d.attributes = {
                        date: date,
                        minutes: duration.duration,
                        waiting: duration.waiting
                    };
                    durations.push(d);
                }
                prevDate = date;
            }
            bookingModel.durations.reset(durations);
            return durations;
        };

        return DurationParser;

    })();

}).call(this);
;
(function () {
    RG.Parsers.OvertimeParser = (function () {
        function OvertimeParser(overtimesJson, dateStringProcessor) {
            this.overtimesJson = overtimesJson;
            this.dateStringProcessor = dateStringProcessor;
        }

        OvertimeParser.prototype.parse = function (resourceInstance, resetOptions) {
            var i, len, otimes, overtime, overtimeModel, overtimes;
            if (resetOptions == null) {
                resetOptions = {};
            }
            otimes = [];
            overtimes = this._groupOvertimes()[resourceInstance.id];
            if (!overtimes) {
                return [];
            }
            for (i = 0, len = overtimes.length; i < len; i++) {
                overtime = overtimes[i];
                overtimeModel = new RG.Models.Overtime({
                    id: overtime.id,
                    resourceInstanceId: overtime.resource_instance_id,
                    date: this.dateStringProcessor(overtime.date),
                    duration: overtime.duration,
                    creatorId: overtime.creator_id
                });
                otimes.push(overtimeModel);
            }
            resourceInstance.overtimes.setModels(otimes, resetOptions);
            return otimes;
        };

        OvertimeParser.prototype._groupOvertimes = function () {
            if (this._groupedOvertimes) {
                return this._groupedOvertimes;
            }
            return this._groupedOvertimes = _.groupBy(this.overtimesJson, 'resource_instance_id');
        };

        return OvertimeParser;

    })();

}).call(this);
;
(function () {
    RG.Parsers.ProjectParser = (function () {
        function ProjectParser(projectsJson, archivedProjectsJson, clientModels, collection) {
            this.projectsJson = projectsJson;
            this.archivedProjectsJson = archivedProjectsJson;
            this.clientModels = clientModels;
            this.collection = collection;
        }

        ProjectParser.prototype.parse = function () {
            var i, j, len, len1, p, project, projectModels, ref, ref1, ref2;
            projectModels = [];
            ref = this.projectsJson;
            for (i = 0, len = ref.length; i < len; i++) {
                p = ref[i];
                project = new RG.Models.Project;
                project.attributes = {
                    id: p.id,
                    name: p.name,
                    color: p.color,
                    default_billable: p.default_billable
                };
                if (p.client_id) {
                    project.attributes.client = this.clientModels.find(function (c) {
                        return c.get('id') === p.client_id;
                    });
                }
                if (p.project_code) {
                    project.attributes.project_code = p.project_code;
                }
                project.id = p.id;
                projectModels.push(project);
            }
            ref1 = this.archivedProjectsJson;
            for (j = 0, len1 = ref1.length; j < len1; j++) {
                p = ref1[j];
                project = new RG.Models.Project;
                project.attributes = {
                    id: p.id,
                    name: p.name,
                    color: p.color,
                    default_billable: p.default_billable,
                    archived: true
                };
                if (p.client_id) {
                    project.attributes.client = this.clientModels.find(function (c) {
                        return c.get('id') === p.client_id;
                    });
                }
                if (p.project_code) {
                    project.attributes.project_code = p.project_code;
                }
                project.id = p.id;
                projectModels.push(project);
            }
            if ((ref2 = this.collection) != null) {
                ref2.reset(projectModels);
            }
            return projectModels;
        };

        return ProjectParser;

    })();

}).call(this);
;
(function () {
    RG.Parsers.ResourceParser = (function () {
        function ResourceParser(resourcesJson, collection, timezones, options) {
            this.resourcesJson = resourcesJson;
            this.collection = collection;
            this.timezones = timezones;
            _.extend(this, options);
        }

        ResourceParser.prototype.parse = function () {
            var i, len, offset, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, resource, resourceClass, resourceType, ri, rm;
            rm = [];
            ref = this.resourcesJson;
            for (i = 0, len = ref.length; i < len; i++) {
                resource = ref[i];
                resourceType = (ref1 = this.resourceTypes) != null ? ref1.findWhere({
                    id: resource.resource_type.id
                }) : void 0;
                if (resource.resource_type.name === "Person") {
                    resourceClass = RG.Models.HumanResourceInstance;
                } else {
                    resourceClass = RG.Models.ResourceInstance;
                }
                offset = this.findTimeZoneOffset(resource.timezone);
                ri = new resourceClass({
                    account: RG.Utils.getCurrentAccount(),
                    id: resource.id,
                    name: resource.name,
                    type: resource.job_title || resource.resource_type.name,
                    resourceType: resourceType,
                    human: resource.human,
                    bookable: resource.bookable,
                    vacationAllowance: resource.vacation_allowance,
                    imageUrl: resource.image,
                    timeZone: new RG.Models.TimeZone({
                        name: resource.timezone.name,
                        offset: offset
                    }),
                    displayTimeZone: new RG.Models.TimeZone({
                        name: resource.timezone.name,
                        offset: resource.timezone.offset
                    }),
                    bookedClients: (ref2 = this.clients) != null ? ref2.select(function (c) {
                        return _.contains(resource.booked_client_ids, c.id);
                    }) : void 0,
                    bookedProjects: (ref3 = this.projects) != null ? ref3.select(function (c) {
                        return _.contains(resource.booked_project_ids, c.id);
                    }) : void 0
                });
                ri.layerController = new RG.Controllers.TimeAllocationLayers(ri.bookings, ri.downtimes);
                if ((ref4 = this.availablePeriodParser) != null) {
                    ref4.parse(ri, resource);
                }
                if ((ref5 = this.customAvailablePeriodParser) != null) {
                    ref5.parse(ri, resource);
                }
                if ((ref6 = this.overtimeParser) != null) {
                    ref6.parse(ri);
                }
                if ((ref7 = this.customFieldParser) != null) {
                    ref7.parse(ri, resource, resourceType);
                }
                rm.push(ri);
            }
            if ((ref8 = this.bookingParser) != null) {
                ref8.parse(rm);
            }
            window.resources.setModels(rm);
            return rm;
        };

        ResourceParser.prototype.findTimeZoneOffset = function (timezone) {
            var storedTimezone;
            if (storedTimezone = this.timezones.findWhere({
                name: timezone.name
            })) {
                return storedTimezone.get('offset');
            } else {
                return timezone.offset;
            }
        };

        return ResourceParser;

    })();

}).call(this);
;
(function () {
    RG.Parsers.ResourceTypeParser = (function () {
        function ResourceTypeParser(resourceTypesJson, collection) {
            this.resourceTypesJson = resourceTypesJson;
            this.collection = collection;
        }

        ResourceTypeParser.prototype.parse = function () {
            var cf, cfm, cfo, cfom, i, j, k, len, len1, len2, ref, ref1, ref2, ref3, resourceTypeModels, rt, rtm;
            resourceTypeModels = [];
            ref = this.resourceTypesJson;
            for (i = 0, len = ref.length; i < len; i++) {
                rt = ref[i];
                rtm = new RG.Models.ResourceType({
                    id: rt.id,
                    name: rt.name
                });
                ref1 = rt.custom_fields;
                for (j = 0, len1 = ref1.length; j < len1; j++) {
                    cf = ref1[j];
                    cfm = new RG.Models.CustomField({
                        name: cf.name,
                        id: cf.id
                    });
                    ref2 = cf.custom_field_options;
                    for (k = 0, len2 = ref2.length; k < len2; k++) {
                        cfo = ref2[k];
                        cfom = new RG.Models.CustomFieldOption({
                            id: cfo.id,
                            name: cfo.value,
                            resourceType: rtm,
                            customField: cfm
                        });
                        cfm.customFieldOptions.add(cfom);
                    }
                    rtm.customFields.add(cfm);
                }
                resourceTypeModels.push(rtm);
            }
            if ((ref3 = this.collection) != null) {
                ref3.reset(resourceTypeModels);
            }
            return resourceTypeModels;
        };

        return ResourceTypeParser;

    })();

}).call(this);
;
(function () {
    RG.Parsers.SavedFilterParser = (function () {
        function SavedFilterParser(savedFiltersJson, collection) {
            this.savedFiltersJson = savedFiltersJson;
            this.collection = collection;
        }

        SavedFilterParser.prototype.parse = function () {
            var i, len, ref, ref1, savedFilterModels, sf;
            savedFilterModels = [];
            ref = this.savedFiltersJson;
            for (i = 0, len = ref.length; i < len; i++) {
                sf = ref[i];
                savedFilterModels.push(new RG.Models.SavedFilter({
                    id: sf.id,
                    name: sf.name,
                    filter_json: sf.filter_json
                }));
            }
            if ((ref1 = this.collection) != null) {
                ref1.reset(savedFilterModels);
            }
            return savedFilterModels;
        };

        return SavedFilterParser;

    })();

}).call(this);
;
(function () {
    RG.Utils.Range = (function () {
        function Range() { }

        Range.prototype.getStart = function () {
            throw 'Implement `getStart` in subclasses of Range';
        };

        Range.prototype.getEnd = function () {
            throw 'Implement `getEnd` in subclasses of Range';
        };

        Range.prototype.contains = function (other) {
            return this.getStart() <= other.getStart() && this.getEnd() >= other.getEnd();
        };

        Range.prototype.overlapsWith = function (other) {
            return this.getEnd() > other.getStart() && this.getStart() < other.getEnd();
        };

        Range.prototype.isTouching = function (other) {
            return this.getEnd() >= other.getStart() && this.getStart() <= other.getEnd();
        };

        Range.prototype.includes = function (value) {
            return value && this.getStart().valueOf() <= value.valueOf() && this.getEnd().valueOf() >= value.valueOf();
        };

        return Range;

    })();

}).call(this);
;
(function () {
    RG.Utils.getCurrentAccount = function () {
        return this._currentAccount != null ? this._currentAccount : this._currentAccount = new RG.Models.Account({
            subdomain: window.location.host.substr(0, window.location.host.indexOf(".")),
            downtimes: window.downtimes
        });
    };

}).call(this);
;
(function () {
    RG.Utils.AvailabilityManager = (function () {
        function AvailabilityManager(options) {
            _.extend(this, Backbone.Events);
            this._maxMinutesInUnit = {};
            this.availablePeriods = options.availablePeriods || new RG.Collections.AvailablePeriods;
            this.customAvailablePeriods = options.customAvailablePeriods || new RG.Collections.CustomAvailablePeriods;
            this.overtimes = options.overtimes || new RG.Collections.Overtimes;
            this.downtimes = options.downtimes || new RG.Collections.Downtimes;
            this.resource = options.resource;
            this.timeZone = options.timeZone || RG.Models.TimeZone.Current;
            this._minutesInDateRange = {};
            if (!options.ignoreEvents) {
                this.availablePeriods.on("add remove reset", (function (_this) {
                    return function () {
                        _this._clearMaxMinutesInUnit();
                        return _this.trigger('refreshUtilisation');
                    };
                })(this));
                this.customAvailablePeriods.on("add remove reset", (function (_this) {
                    return function () {
                        _this._clearMaxMinutesInUnit();
                        return _this.trigger('refreshUtilisation');
                    };
                })(this));
                this.downtimes.on("add remove change reset", (function (_this) {
                    return function () {
                        return _this._clearMaxMinutesInUnit();
                    };
                })(this));
                this.overtimes.on("add remove change reset", (function (_this) {
                    return function () {
                        _this._clearMaxMinutesInUnit();
                        return _this.trigger('refreshUtilisation');
                    };
                })(this));
                this.downtimes.on("add", (function (_this) {
                    return function (d) {
                        var dd;
                        dd = d.inTimeZone(_this.resource.get('timeZone'));
                        return _this.trigger('refresh', new RG.Utils.DateRange(dd.get('from'), dd.get('to')));
                    };
                })(this));
                this.downtimes.on("remove", (function (_this) {
                    return function (d) {
                        var dd;
                        dd = d.inTimeZone(_this.resource.get('timeZone'));
                        return _this.trigger('refresh', new RG.Utils.DateRange(dd.get('from'), dd.get('to')));
                    };
                })(this));
                this.downtimes.on("change", (function (_this) {
                    return function (d) {
                        var dd, old;
                        dd = d.inTimeZone(_this.resource.get('timeZone'));
                        _this.trigger('refresh', new RG.Utils.DateRange(dd.get('from'), dd.get('to')));
                        old = new RG.Models.Downtime(d.previousAttributes());
                        dd = old.inTimeZone(_this.resource.get('timeZone'));
                        return _this.trigger('refresh', new RG.Utils.DateRange(dd.get('from'), dd.get('to')));
                    };
                })(this));
                this.on('add remove reset', this._clearMaxMinutesInUnit);
                this.on('maxAvailabilityChanged', this._flushCache);
            }
        }

        AvailabilityManager.prototype.getOvertimeMinutesInDateRange = function (dateRange) {
            return this.overtimes.getMinutesAvailableInDateRange(dateRange);
        };

        AvailabilityManager.prototype.getMinutesAvailableForDate = function (date, timeRange) {
            var dateRange;
            if (timeRange == null) {
                timeRange = null;
            }
            dateRange = new RG.Utils.DateRange(date, date);
            return this.getMinutesAvailableInDateRange(dateRange, timeRange);
        };

        AvailabilityManager.prototype.getMinutesAvailableInDateRange = function (dateRange, timeRange) {
            var minutes, resource;
            if (timeRange == null) {
                timeRange = null;
            }
            if (this._minutesInDateRange[dateRange]) {
                return this._minutesInDateRange[dateRange];
            }
            minutes = 0;
            resource = this.resource;
            this.getDowntimeAndAvailablePeriodAggregateForDateRange(dateRange, timeRange).forEach(function (aggregate) {
                var downtimeTimeRanges, j, len, period, periodsTimeRanges, results1;
                downtimeTimeRanges = aggregate.downtimes.map(function (downtime) {
                    return downtime.getTimeRange(aggregate.date);
                });
                periodsTimeRanges = aggregate.periods;
                if (downtimeTimeRanges.length > 1) {
                    timeRange = downtimeTimeRanges.shift();
                    downtimeTimeRanges = timeRange.merge.apply(timeRange, downtimeTimeRanges);
                }
                if (periodsTimeRanges.length > 1) {
                    timeRange = periodsTimeRanges.shift();
                    periodsTimeRanges = timeRange.merge.apply(timeRange, periodsTimeRanges);
                }
                results1 = [];
                for (j = 0, len = periodsTimeRanges.length; j < len; j++) {
                    period = periodsTimeRanges[j];
                    if (downtimeTimeRanges.length) {
                        results1.push(minutes += period.subtractAll(downtimeTimeRanges));
                    } else {
                        results1.push(minutes += period.totalTime() | 0);
                    }
                }
                return results1;
            });
            return this._minutesInDateRange[dateRange] = minutes;
        };

        AvailabilityManager.prototype.getAvailableTimeRangesInDateRange = function (dateRange, timeRange) {
            var aggregate, downtime, downtimeTimeRanges, hasRemainingPeriod, j, k, l, len, len1, len2, len3, m, period, periodsTimeRanges, r, ranges, ref, ref1, resource;
            if (timeRange == null) {
                timeRange = null;
            }
            ranges = [];
            resource = this.resource;
            ref = this.getDowntimeAndAvailablePeriodAggregateForDateRange(dateRange, timeRange);
            for (j = 0, len = ref.length; j < len; j++) {
                aggregate = ref[j];
                downtimeTimeRanges = aggregate.downtimes.map(function (downtime) {
                    return downtime.getTimeRange(aggregate.date);
                });
                periodsTimeRanges = aggregate.periods;
                if (downtimeTimeRanges.length > 1) {
                    timeRange = downtimeTimeRanges.shift();
                    downtimeTimeRanges = timeRange.merge.apply(timeRange, downtimeTimeRanges);
                }
                if (periodsTimeRanges.length > 1) {
                    timeRange = periodsTimeRanges.shift();
                    periodsTimeRanges = timeRange.merge.apply(timeRange, periodsTimeRanges);
                }
                for (k = 0, len1 = periodsTimeRanges.length; k < len1; k++) {
                    period = periodsTimeRanges[k];
                    if (downtimeTimeRanges.length) {
                        hasRemainingPeriod = false;
                        for (l = 0, len2 = downtimeTimeRanges.length; l < len2; l++) {
                            downtime = downtimeTimeRanges[l];
                            if (period.overlapsWith(downtime)) {
                                ref1 = period.subtractOne(downtime);
                                for (m = 0, len3 = ref1.length; m < len3; m++) {
                                    r = ref1[m];
                                    ranges.push(r);
                                }
                                hasRemainingPeriod = true;
                            }
                        }
                        if (!hasRemainingPeriod) {
                            ranges.push(period);
                        }
                    } else {
                        ranges.push(period);
                    }
                }
            }
            return ranges;
        };

        AvailabilityManager.prototype.hasNoNormalAvailability = function () {
            return this.availablePeriods.length === 0;
        };

        AvailabilityManager.prototype.getMaxMinutesInUnit = function (dateRange, memoize) {
            var customMinutesAvailable, date, j, k, len, len1, minutes, period, periodMinutesAvailable, ref, ref1, somePeriods;
            if (memoize == null) {
                memoize = true;
            }
            if (memoize && this._maxMinutesInUnit[dateRange.toString()]) {
                return this._maxMinutesInUnit[dateRange.toString()];
            }
            minutes = 0;
            ref = dateRange.getDates();
            for (j = 0, len = ref.length; j < len; j++) {
                date = ref[j];
                customMinutesAvailable = this.customAvailablePeriods.calculator().sum(date);
                periodMinutesAvailable = this.availablePeriods.calculator().sum(date);
                if (customMinutesAvailable > periodMinutesAvailable) {
                    periodMinutesAvailable = customMinutesAvailable;
                }
                if (periodMinutesAvailable > minutes) {
                    minutes = periodMinutesAvailable;
                }
            }
            somePeriods = this.availablePeriods.some(function (period) {
                return period.isValidInDateRange(dateRange);
            });
            if (!somePeriods) {
                ref1 = this._getBackfilledAvailablePeriods(dateRange.startDate);
                for (k = 0, len1 = ref1.length; k < len1; k++) {
                    period = ref1[k];
                    periodMinutesAvailable = period.getMinutesAvailable();
                    if (periodMinutesAvailable > minutes) {
                        minutes = periodMinutesAvailable;
                    }
                }
            }
            return this._maxMinutesInUnit[dateRange.toString()] = minutes;
        };

        AvailabilityManager.prototype.inEarliestNormalAvailability = function (dateRange, timeRange) {
            var day, earliest, earliestOnDay, periods;
            if (timeRange == null) {
                timeRange = null;
            }
            day = dateRange.startDate.getDay();
            if (timeRange) {
                periods = this.availablePeriods.select(function (period) {
                    return period.getTimeRange().overlapsWith(timeRange);
                });
            } else {
                periods = this.availablePeriods.models;
            }
            earliest = _.min(periods, function (ap) {
                return ap.get('validFrom');
            });
            earliestOnDay = _.find(periods, function (ap) {
                return ap.get('weekDay') === day && RG.Utils.DateComparator.equalsYMD(ap.get('validFrom'), earliest.get('validFrom'));
            });
            return earliestOnDay && dateRange.startDate < earliest.get('validFrom') && !RG.Utils.DateComparator.equalsYMD(dateRange.startDate, earliest.get('validFrom'));
        };

        AvailabilityManager.prototype._clearMaxMinutesInUnit = function () {
            this._maxMinutesInUnit = {};
            this._minutesInDateRange = {};
        };

        AvailabilityManager.prototype._flushCache = function () {
            this._clearMaxMinutesInUnit();
            this.customAvailablePeriods._minutes = {};
        };

        AvailabilityManager.prototype.getOriginalPeriodsForDate = function (date) {
            var periods;
            periods = this.availablePeriods.models.filter(function (p) {
                return p.isValidOn(date);
            });
            if (periods.length) {
                return periods;
            } else if (!this._somePeriodsForDate(date)) {
                return this._getBackfilledAvailablePeriods(date);
            } else {
                return [];
            }
        };

        AvailabilityManager.prototype.getCustomPeriodsForDate = function (date) {
            return this.customAvailablePeriods.select(function (p) {
                return p.isValidOn(date);
            });
        };

        AvailabilityManager.prototype.getDowntimesForDateAndTimeRange = function (date, timeRange) {
            return this.downtimes.inTimeZone(this.getTimeZone()).forDate(date).filter(function (downtime) {
                var tRange;
                tRange = downtime.getTimeRange(date);
                return timeRange.overlapsWith(tRange);
            });
        };

        AvailabilityManager.prototype.getPeriodTimeRangesForDateAndTimeRange = function (date, timeRange) {
            var j, len, period, ref, results;
            results = [];
            ref = this.getPeriodsForDate(date);
            for (j = 0, len = ref.length; j < len; j++) {
                period = ref[j];
                if (timeRange.overlapsWith(period.getTimeRange())) {
                    results.push(period.getTimeRange());
                }
            }
            return results;
        };

        AvailabilityManager.prototype.getDowntimeAndAvailablePeriodAggregateForDateRange = function (dateRange, timeRange, year) {
            var aggregate, date, i, j, ref, sd;
            if (timeRange == null) {
                timeRange = new RG.Utils.TimeRange(0, 1440);
            }
            if (year == null) {
                year = null;
            }
            sd = dateRange.startDate;
            aggregate = [];
            for (i = j = 0, ref = dateRange.getNumberOfDays() - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
                date = new Date(sd.getFullYear(), sd.getMonth(), sd.getDate() + i);
                if (year) {
                    if (date.getFullYear() === year) {
                        aggregate.push({
                            downtimes: this.getDowntimesForDateAndTimeRange(date, timeRange),
                            periods: this.getPeriodTimeRangesForDateAndTimeRange(date, timeRange),
                            date: date
                        });
                    }
                } else {
                    aggregate.push({
                        downtimes: this.getDowntimesForDateAndTimeRange(date, timeRange),
                        periods: this.getPeriodTimeRangesForDateAndTimeRange(date, timeRange),
                        date: date
                    });
                }
            }
            return aggregate;
        };

        AvailabilityManager.prototype.getPeriodsForDate = function (date) {
            var customPeriods;
            customPeriods = this.getCustomPeriodsForDate(date);
            if (customPeriods.length) {
                return customPeriods;
            } else {
                return this.getOriginalPeriodsForDate(date);
            }
        };

        AvailabilityManager.prototype.getTimeZone = function () {
            return this.timeZone;
        };

        AvailabilityManager.prototype.getOvertimesForDate = function (date) {
            var j, len, o, overtimes, ref;
            overtimes = [];
            ref = this.overtimes.models;
            for (j = 0, len = ref.length; j < len; j++) {
                o = ref[j];
                if (o.isValidOn(date)) {
                    overtimes.push(o);
                }
            }
            return overtimes;
        };

        AvailabilityManager.prototype.isAvailableStartAndEndDate = function (dateRange) {
            var endDateRange, startDateRange;
            startDateRange = new RG.Utils.DateRange(dateRange.startDate, dateRange.startDate);
            endDateRange = new RG.Utils.DateRange(dateRange.endDate, dateRange.endDate);
            return this.isAvailableIn(startDateRange) && this.isAvailableIn(endDateRange);
        };

        AvailabilityManager.prototype.isAvailableIn = function (dateRange, timeRange) {
            if (timeRange == null) {
                timeRange = null;
            }
            return this.getMinutesAvailableInDateRange(dateRange, timeRange) > 0 || this.inEarliestNormalAvailability(dateRange, timeRange);
        };

        AvailabilityManager.prototype.intersectsWithDowntime = function (date, timeRange) {
            return this.downtimes.any((function (_this) {
                return function (downtime) {
                    return downtime.inTimeZone(_this.resource.get('timeZone')).getTimeRange(date).overlapsWith(timeRange);
                };
            })(this));
        };

        AvailabilityManager.prototype._getBackfilledAvailablePeriods = function (date) {
            var periods;
            periods = _.chain(this.availablePeriods.models).filter(function (ap) {
                return ap.isNewerThan(date);
            }).sort(function (ap) {
                var ref;
                return ((ref = ap.get('validFrom')) != null ? ref.valueOf() : void 0) || 0;
            }).value();
            if (periods.some(function (ap) {
                return ap.get('validUntil');
            })) {
                return this._getClosestOldestHistoricalPeriods(date);
            } else {
                if (this.availablePeriods.models.some(function (ap) {
                    return ap.get('validUntil') && ap.get('validUntil').valueOf() <= date.valueOf();
                })) {
                    return [];
                } else {
                    return periods.filter(function (p) {
                        return p.get('weekDay') === date.getDay();
                    });
                }
            }
        };

        AvailabilityManager.prototype._getClosestOldestHistoricalPeriods = function (date) {
            var periods, validFrom;
            periods = this.availablePeriods.models.filter(function (ap) {
                return ap.get('validUntil') && ap.get('weekDay') === date.getDay() && ap.isNewerThan(date);
            });
            periods = periods.sort(function (a, b) {
                if (a.get('validFrom').valueOf() < b.get('validFrom').valueOf()) {
                    return -1;
                } else if (a.get('validFrom').valueOf() === b.get('validFrom').valueOf()) {
                    return 0;
                }
                return 1;
            });
            validFrom = null;
            return periods.filter(function (ap) {
                if (validFrom == null) {
                    validFrom = periods[0].get('validFrom');
                }
                return RG.Utils.DateComparator.equalsYMD(ap.get('validFrom'), validFrom);
            });
        };

        AvailabilityManager.prototype._somePeriodsForDate = function (date) {
            return this.availablePeriods.some(function (ap) {
                return ap.isCoveringDate(date);
            });
        };

        return AvailabilityManager;

    })();

}).call(this);
;
(function () {
    RG.Utils.CalendarPermissionsAdapter = (function () {
        function CalendarPermissionsAdapter(currentUserId, userPermissions) {
            this.currentUserId = currentUserId;
            this.userPermissions = userPermissions != null ? userPermissions : {};
        }

        CalendarPermissionsAdapter.prototype.canManage = function (booking) {
            var ref;
            return window.userPermissions.bookingRights === "manage_all" || (window.userPermissions.bookingRights === "manage_own" && ((ref = booking.getBooker()) != null ? ref.id : void 0) === window.currentUserId);
        };

        CalendarPermissionsAdapter.prototype.canAddDowntime = function () {
            return this.userPermissions.downtimeRights === "manage_all" || this.userPermissions.downtimeRights === "manage_own";
        };

        CalendarPermissionsAdapter.prototype.canDeleteClashBooking = function (bookings) {
            return this.canMoveClashBookingToWaitingList(bookings);
        };

        CalendarPermissionsAdapter.prototype.canManageDowntime = function (downtime) {
            var ref;
            return this.userPermissions.downtimeRights === "manage_all" || (this.userPermissions.downtimeRights === "manage_own" && ((ref = downtime.getBooker()) != null ? ref.id : void 0) === this.currentUserId);
        };

        CalendarPermissionsAdapter.prototype.canMoveClashBookingToWaitingList = function (bookings) {
            var mayChangeBookings;
            mayChangeBookings = _.map(bookings, (function (_this) {
                return function (booking) {
                    return _this.canManage(booking);
                };
            })(this));
            return !_.contains(mayChangeBookings, false) && this.canAddDowntime();
        };

        return CalendarPermissionsAdapter;

    })();

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Utils.DashboardPermissionsAdapter = (function (superClass) {
        extend(DashboardPermissionsAdapter, superClass);

        function DashboardPermissionsAdapter() {
            return DashboardPermissionsAdapter.__super__.constructor.apply(this, arguments);
        }

        DashboardPermissionsAdapter.prototype.canAddDowntime = function () {
            return ['manage_all', 'manage_own', 'view'].indexOf(this.userPermissions.downtimeRights) !== -1;
        };

        DashboardPermissionsAdapter.prototype.canManageDowntime = function (downtime) {
            var ref;
            return this.userPermissions.downtimeRights === 'manage_all' || this.canAddDowntime() && ((ref = downtime.getBooker()) != null ? ref.id : void 0) === this.currentUserId;
        };

        DashboardPermissionsAdapter.prototype.canMoveClashBookingToWaitingList = function (bookings) {
            var mayChangeBookings;
            mayChangeBookings = _.map(bookings, (function (_this) {
                return function (booking) {
                    return _this.canManage(booking);
                };
            })(this));
            return !_.contains(mayChangeBookings, false) && this.canAddDowntime();
        };

        DashboardPermissionsAdapter.prototype.canDeleteClashBooking = function (bookings) {
            return this.canMoveClashBookingToWaitingList(bookings);
        };

        return DashboardPermissionsAdapter;

    })(RG.Utils.CalendarPermissionsAdapter);

}).call(this);
;
(function () {
    RG.Utils.DateComparator = {
        getDateParts: function (date) {
            return date && [date.getFullYear(), date.getMonth(), date.getDate()];
        },
        equalsYMD: function (date1, date2) {
            return date1.getFullYear() === date2.getFullYear() && date1.getMonth() === date2.getMonth() && date1.getDate() === date2.getDate();
        }
    };

    Date.prototype.cloneYMD = function () {
        return new Date(this.getFullYear(), this.getMonth(), this.getDate());
    };

}).call(this);
;
(function () {
    RG.Utils.DateFormatter = {
        months: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
        longMonths: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
        getShortDate: function (date) {
            return (date.getDate()) + " " + RG.Utils.DateFormatter.months[date.getMonth()];
        },
        getShortDateWithYear: function (date) {
            return (date.getDate()) + " " + RG.Utils.DateFormatter.months[date.getMonth()] + " " + (date.getFullYear());
        },
        getLongDateWithYear: function (date) {
            return (date.getDate()) + " " + RG.Utils.DateFormatter.longMonths[date.getMonth()] + " " + (date.getFullYear());
        },
        getISODate: function (date) {
            var d, m, y, zeroPad;
            zeroPad = function (number) {
                var s;
                s = number.toString();
                if (s.length === 1) {
                    s = "0" + s;
                }
                return s;
            };
            y = date.getFullYear();
            m = zeroPad(date.getMonth() + 1);
            d = zeroPad(date.getDate());
            return y + "-" + m + "-" + d;
        }
    };

    Date.prototype.getISODate = function () {
        return RG.Utils.DateFormatter.getISODate(this);
    };

    Date.prototype.getWeek = function () {
        var dayNr, firstThursday, target;
        target = new Date(this.valueOf());
        dayNr = (this.getDay() + 6) % 7;
        target.setDate(target.getDate() - dayNr + 3);
        firstThursday = target.valueOf();
        target.setMonth(0, 1);
        if (target.getDay() !== 4) {
            target.setMonth(0, 1 + ((4 - target.getDay()) + 7) % 7);
        }
        return 1 + Math.ceil((firstThursday - target) / 604800000);
    };

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Utils.DateRange = (function (superClass) {
        var months;

        extend(DateRange, superClass);

        months = RG.Utils.DateFormatter.months;

        function DateRange(startDate, endDate) {
            this.startDate = startDate;
            this.endDate = endDate;
        }

        DateRange.prototype.getStart = function () {
            return this.startDate;
        };

        DateRange.prototype.getEnd = function () {
            return this.endDate;
        };

        DateRange.prototype.getNumberOfDays = function () {
            return Math.round(((this.endDate.valueOf() - this.startDate.valueOf()) / 86400 / 1000) + 1);
        };

        DateRange.prototype.getDates = function () {
            var date, dates;
            date = new Date(this.startDate);
            dates = [];
            while (date.getTime() <= this.endDate.getTime()) {
                dates.push(new Date(date));
                date.setDate(date.getDate() + 1);
            }
            return dates;
        };

        DateRange.prototype.overlapsWith = function (other) {
            return this.getEnd() >= other.getStart() && this.getStart() <= other.getEnd();
        };

        DateRange.prototype.toString = function () {
            var firstMonthStr, firstYearStr, inSameMonth, inSameYear, secondMonthStr;
            if (RG.Utils.DateComparator.equalsYMD(this.startDate, this.endDate)) {
                return (this.startDate.getDate()) + " " + months[this.startDate.getMonth()] + " " + (this.endDate.getFullYear());
            } else {
                inSameMonth = this.startDate.getMonth() === this.endDate.getMonth();
                inSameYear = this.startDate.getFullYear() === this.endDate.getFullYear();
                firstMonthStr = !inSameMonth || !inSameYear ? months[this.startDate.getMonth()] + " " : "";
                firstYearStr = !inSameYear ? (this.startDate.getFullYear()) + " " : "";
                secondMonthStr = months[this.endDate.getMonth()];
                return (this.startDate.getDate()) + " " + firstMonthStr + firstYearStr + "- " + (this.endDate.getDate()) + " " + secondMonthStr + " " + (this.endDate.getFullYear());
            }
        };

        DateRange.prototype.getYears = function () {
            var endYear, i, results, startYear;
            startYear = this.startDate.getFullYear();
            endYear = this.endDate.getFullYear();
            return (function () {
                results = [];
                for (var i = startYear; startYear <= endYear ? i <= endYear : i >= endYear; startYear <= endYear ? i++ : i--) { results.push(i); }
                return results;
            }).apply(this);
        };

        DateRange.prototype.coversYear = function (year) {
            return _.include(this.getYears(), year);
        };

        DateRange.prototype.isValid = function () {
            return !!(this.startDate && this.endDate);
        };

        return DateRange;

    })(RG.Utils.Range);

}).call(this);
;
(function () {
    RG.Utils.DowntimeService = {
        createDowntime: function (downtime, params, callbacks) {
            return Q.Promise(function (resolve, reject, notify) {
                RG.Utils.BookingDataParser.expirePolls();
                return $.ajax((RG.getApiRoot()) + "/downtimes", {
                    method: "POST",
                    headers: {
                        "X-CSRF-Token": RG.Utils.getCSRFToken()
                    },
                    data: params,
                    dataType: 'json',
                    success: (function (_this) {
                        return function (data) {
                            RG.Utils.BookingDataParser.expirePolls();
                            downtime.set({
                                id: data.id
                            });
                            callbacks.successCallback(downtime);
                            return resolve("Downtime " + downtime.id + " created.");
                        };
                    })(this),
                    error: (function (_this) {
                        return function (xhr) {
                            var e, responseData;
                            responseData = null;
                            try {
                                responseData = JSON.parse(xhr.responseText);
                                RG.Utils.BookingDataParser.expirePolls();
                                callbacks.errorCallback(responseData);
                                return reject("Downtime not created.");
                            } catch (error) {
                                e = error;
                                return callbacks.saveErrorCallback(e, xhr);
                            }
                        };
                    })(this)
                });
            });
        },
        updateDowntime: function (id, params, callbacks) {
            params['_method'] = 'patch';
            return Q.Promise(function (resolve, reject, notify) {
                RG.Utils.BookingDataParser.expirePolls();
                return $.ajax((RG.getApiRoot()) + "/downtimes/" + id, {
                    method: "POST",
                    headers: {
                        "X-CSRF-Token": RG.Utils.getCSRFToken()
                    },
                    data: params,
                    dataType: 'json',
                    success: (function (_this) {
                        return function (data) {
                            RG.Utils.BookingDataParser.expirePolls();
                            callbacks.successCallback(data);
                            return resolve("Downtime " + id + " updated.");
                        };
                    })(this),
                    error: (function (_this) {
                        return function (xhr) {
                            var e, responseData;
                            responseData = null;
                            try {
                                responseData = JSON.parse(xhr.responseText);
                                RG.Utils.BookingDataParser.expirePolls();
                                callbacks.errorCallback(responseData);
                                return reject("Downtime " + id + " not updated.");
                            } catch (error) {
                                e = error;
                                return callbacks.saveErrorCallback(e, xhr);
                            }
                        };
                    })(this)
                });
            });
        },
        deleteSingleDate: function (downtime, date, callback) {
            var createRightDowntime, leftDowntime, leftDowntimeFromDate, leftDowntimeParams, leftDowntimeToDate, notStartOrEnd, options, rightDowntime, rightDowntimeFromDate, rightParams;
            if (RG.Utils.DateComparator.equalsYMD(date, downtime.get('from'))) {
                leftDowntimeFromDate = moment(date).add(1, 'days')._d;
                leftDowntimeToDate = downtime.get('to');
            } else if (RG.Utils.DateComparator.equalsYMD(date, downtime.get('to'))) {
                leftDowntimeFromDate = downtime.get('from');
                leftDowntimeToDate = moment(date).subtract(1, 'days')._d;
            } else {
                leftDowntimeFromDate = downtime.get('from');
                leftDowntimeToDate = moment(date).subtract(1, 'days')._d;
            }
            leftDowntimeParams = this._buildDowntimeParams(downtime, leftDowntimeFromDate, leftDowntimeToDate);
            leftDowntime = new RG.Models.Downtime(downtime.attributes);
            leftDowntime.set({
                from: leftDowntimeFromDate,
                to: leftDowntimeToDate,
                timeZone: downtime.get('timeZone')
            });
            notStartOrEnd = !RG.Utils.DateComparator.equalsYMD(date, downtime.get('from')) && !RG.Utils.DateComparator.equalsYMD(date, downtime.get('to'));
            if (notStartOrEnd) {
                rightDowntimeFromDate = moment(date).add(1, 'days')._d;
                rightDowntime = new RG.Models.Downtime(_.extend(_.clone(downtime.attributes), {
                    downtimeType: downtime.downtimeType,
                    id: null,
                    timeZone: downtime.getTimeZone(),
                    from: rightDowntimeFromDate,
                    to: downtime.get('to')
                }));
                rightParams = _.extend(_.clone(leftDowntimeParams), {
                    id: null,
                    from: RG.Utils.DateFormatter.getISODate(rightDowntimeFromDate),
                    to: downtime.get('to')
                });
            }
            options = this._buildOptions(downtime, leftDowntime, rightDowntime);
            createRightDowntime = (function (_this) {
                return function () {
                    if (notStartOrEnd) {
                        return RG.Utils.DowntimeService.createDowntime(rightDowntime, rightParams, options);
                    } else {
                        return Q.delay(0);
                    }
                };
            })(this);
            return RG.Utils.DowntimeService.updateDowntime(downtime.id, leftDowntimeParams, options).then(callback).then(createRightDowntime).then(window.update);
        },
        deleteDowntime: function (id, callback) {
            return Q.Promise(function (resolve, reject, notify) {
                return $.ajax((RG.getApiRoot()) + "/downtimes/" + id, {
                    method: 'DELETE',
                    timeout: 30000,
                    headers: {
                        "X-CSRF-Token": RG.Utils.getCSRFToken()
                    },
                    success: (function (_this) {
                        return function () {
                            if (typeof callback === "function") {
                                callback();
                            }
                            window.update();
                            return resolve("Downtime " + id + " deleted.");
                        };
                    })(this)
                });
            });
        },
        split: function (downtime, date, callback) {
            var leftDowntime, leftDowntimeParams, options, rightDowntime, rightParams, timezone, toDate;
            timezone = null;
            toDate = moment(date).subtract(1, 'days')._d;
            leftDowntimeParams = this._buildDowntimeParams(downtime, downtime.get('from'), toDate);
            leftDowntimeParams.end_time = 1440;
            leftDowntime = new RG.Models.Downtime(leftDowntimeParams);
            leftDowntime.set({
                from: downtime.get('from'),
                to: toDate,
                endTime: 1440
            });
            rightDowntime = new RG.Models.Downtime(_.extend(_.clone(downtime.attributes), {
                downtimeType: downtime.downtimeType,
                id: null,
                timeZone: downtime.get('timeZone'),
                from: date,
                to: downtime.get('to'),
                startTime: 0
            }));
            rightParams = _.extend(_.clone(leftDowntimeParams), {
                id: null,
                from: RG.Utils.DateFormatter.getISODate(date),
                to: RG.Utils.DateFormatter.getISODate(downtime.get('to')),
                start_time: 0
            });
            options = this._buildOptions(downtime, leftDowntime, rightDowntime);
            return RG.Utils.DowntimeService.updateDowntime(downtime.id, leftDowntimeParams, options).then(function () {
                return RG.Utils.DowntimeService.createDowntime(rightDowntime, rightParams, options);
            }).then(callback);
        },
        updateResources: (function (_this) {
            return function (downtime, leftDowntime, rightDowntime) {
                var affectedResources, i, len, resource, results, updatedDowntime;
                window.downtimes.add(rightDowntime);
                updatedDowntime = window.downtimes.findWhere({
                    id: downtime.id
                });
                updatedDowntime.set(leftDowntime.attributes);
                affectedResources = window.resources.select(function (resource) {
                    return _.include(downtime.get('resourceIds'), resource.id);
                });
                results = [];
                for (i = 0, len = affectedResources.length; i < len; i++) {
                    resource = affectedResources[i];
                    results.push(resource.refreshDowntimes());
                }
                return results;
            };
        })(this),
        _buildDowntimeParams: function (downtime, from, to) {
            var downtimeTimeZone, params;
            params = {
                resource_ids: downtime.get('resourceIds'),
                creator_id: window.currentUserId,
                from: RG.Utils.DateFormatter.getISODate(from),
                to: RG.Utils.DateFormatter.getISODate(to),
                start_time: downtime.get('startTime'),
                end_time: downtime.get('endTime'),
                details: downtime.get('details'),
                leave: downtime.get('leave'),
                downtime_type_id: downtime.get('downtimeTypeId')
            };
            downtimeTimeZone = downtime.getTimeZoneName();
            if (!downtime.isLocalTimeZone() && window.currentUserTimeZone !== downtimeTimeZone) {
                params.timezone = downtimeTimeZone;
            }
            return params;
        },
        _buildOptions: function (downtime, leftDowntime, rightDowntime) {
            return {
                successCallback: function () {
                    return RG.Utils.DowntimeService.updateResources(downtime, leftDowntime, rightDowntime);
                },
                errorCallback: function () { }
            };
        }
    };

}).call(this);
;
(function () {
    RG.Utils.isDifferentTimeZones = function (downtimeResources, currentUserTimeZone) {
        var flag;
        if (downtimeResources.length === 1) {
            return false;
        }
        flag = false;
        flag = _.any(downtimeResources, function (resource) {
            return resource.getTimeZoneName() !== currentUserTimeZone;
        });
        return flag;
    };

}).call(this);
;
(function () {
    RG.Utils.getDowntimeTypePriority = function (name) {
        var base;
        if ((base = RG.Variables).downtimeTypes == null) {
            base.downtimeTypes = _.values(RG.Variables.DowntimeType);
        }
        return _.indexOf(RG.Variables.downtimeTypes, name);
    };

}).call(this);
;
(function () {
    RG.Utils.select2Close = function (element, flag) {
        if ($('.filters.active.open').length || flag) {
            return window.requestAnimationFrame(function () {
                var select2Inputs;
                if (element) {
                    element.addClass('select2-active-filter-option');
                }
                select2Inputs = $("select.filter-option:not(.select2-active-filter-option)");
                if (select2Inputs.length) {
                    select2Inputs.select2('enable', false).select2('enable', true);
                }
                if (element) {
                    return element.removeClass('select2-active-filter-option');
                }
            });
        }
    };

    RG.Utils.getCSRFToken = function () {
        return $('meta[name="csrf-token"]').attr('content');
    };

}).call(this);
;
(function () {
    RG.Utils.PopoverManager = (function () {
        function PopoverManager() {
            this._nestedPopovers = [];
            this._rendererLocks = [];
        }

        PopoverManager.prototype.lock = function () {
            return this.locked = true;
        };

        PopoverManager.prototype.unlock = function () {
            this.clear();
            return this.locked = false;
        };

        PopoverManager.prototype.set = function (popoverView, removeCallback) {
            var ref;
            if (removeCallback == null) {
                removeCallback = null;
            }
            if (this.locked) {
                return;
            }
            RG.Utils.enableScrolling(false);
            if ((ref = this.popover) != null) {
                ref.remove();
            }
            this.removeCallback = removeCallback;
            this.toggle(popoverView, removeCallback);
            return this.popover;
        };

        PopoverManager.prototype._lockRenderer = function () {
            var lock;
            lock = new RG.Renderer.GlobalLock;
            this._rendererLocks.push(lock);
            return RG.renderer.lock(lock);
        };

        PopoverManager.prototype._unlockRenderer = function () {
            var i, len, lock, ref;
            ref = this._rendererLocks;
            for (i = 0, len = ref.length; i < len; i++) {
                lock = ref[i];
                RG.renderer.unlock(lock);
            }
            this._rendererLocks = [];
        };

        PopoverManager.prototype.nest = function (popover) {
            return this._nestedPopovers.push(popover);
        };

        PopoverManager.prototype.clearNest = function () {
            var i, len, p, ref;
            ref = this._nestedPopovers;
            for (i = 0, len = ref.length; i < len; i++) {
                p = ref[i];
                p.remove();
            }
            return this._nestedPopovers = [];
        };

        PopoverManager.prototype.setBody = function (bodyView) {
            this.popover.setBodyView(bodyView);
            return this.popover.render();
        };

        PopoverManager.prototype.clear = function () {
            var ref;
            if (this.locked) {
                return;
            }
            if ((ref = this.popover) != null) {
                ref.remove();
            }
            if (typeof this.removeCallback === "function") {
                this.removeCallback();
            }
            this.popover = null;
            this.removeCallback = null;
            this._unlockRenderer();
            return RG.Utils.enableScrolling(true);
        };

        PopoverManager.prototype.done = function () {
            this.popoverActive = false;
            this.removeCallback = null;
            return this.clear();
        };

        PopoverManager.prototype.replace = function (options) {
            if (options == null) {
                options = {};
            }
            if (this.locked) {
                return;
            }
            this.clear();
            this.popoverActive = false;
            if (options.popoverView) {
                return this.set(options.popoverView, options.removeCallback);
            }
        };

        PopoverManager.prototype.toggle = function (popoverView, removeCallback) {
            if (this.popoverActive || this.locked) {
                this.popoverActive = false;
                if (typeof removeCallback === "function") {
                    removeCallback();
                }
                this.removeCallback = null;
                this.clear();
                return;
            }
            this.popoverActive = true;
            this.popover = popoverView;
            this.popover.popup();
            return this._lockRenderer();
        };

        PopoverManager.prototype.popoverVisible = function () {
            var popoverElement;
            if (!this.popover) {
                return false;
            }
            popoverElement = $(this.popover.el);
            return popoverElement.length > 0 && popoverElement.parent().length > 0;
        };

        return PopoverManager;

    })();

}).call(this);
;
(function () {
    this.segmentAutolinker = function (string) {
        return Autolinker.link(_.escape(string).replace('!', '&excl;').replace(/\n/g, "<br />"));
    };

}).call(this);
;
(function () {
    RG.Utils.spinnerOptions = {
        lines: 9,
        length: 10,
        width: 5,
        radius: 15,
        corners: 1,
        rotate: 0,
        speed: 1,
        shadow: false,
        hwaccel: false,
        left: '50%',
        bottom: '-50%'
    };

}).call(this);
;
(function () {
    RG.Utils.spinnerOverlay = function (element) {
        var overlay;
        overlay = new RG.Views.Dialogs.Overlay({
            attachTo: element,
            className: "overlay",
            template: function () {
                return '';
            }
        });
        new Spinner(RG.Utils.spinnerOptions).spin(overlay.render().el);
        return overlay;
    };

}).call(this);
;
(function () {
    RG.Utils.TimeFormatter = {
        formatFixedTime: function (minuteOfDay) {
            var hour, minute, minuteStr, noonFlag;
            hour = Math.floor(minuteOfDay / 60);
            noonFlag = Math.floor(hour / 12) % 2 === 0 ? "am" : "pm";
            minute = minuteOfDay % 60;
            minuteStr = minute.toString();
            if (minuteStr.length === 1) {
                minuteStr = "0" + minuteStr;
            }
            if (hour > 12) {
                hour = hour % 12;
            }
            if (hour === 0) {
                hour = 12;
            }
            if (minuteStr === "00") {
                return "" + hour + noonFlag;
            } else {
                return hour + "." + minuteStr + noonFlag;
            }
        },
        formatMinutes: function (time) {
            var hours, minutes, minutesStr, showHours, showMinutes;
            hours = Math.floor(time / 60);
            minutes = time % 60;
            showHours = (hours === 0 && minutes === 0) || hours > 0;
            showMinutes = minutes > 0;
            time = "";
            if (showHours) {
                time = time + (hours + "h ");
            }
            if (showMinutes) {
                minutesStr = minutes + "m";
                if (minutesStr.length === 2) {
                    minutesStr = "0" + minutesStr;
                }
                time = time + minutesStr;
            }
            return time.trim();
        },
        formatMinutesOffset: function (time) {
            var hours, isNegative, minutes, minutesStr;
            isNegative = time < 0;
            hours = Math.floor(Math.abs(time) / 60);
            minutes = Math.abs(time) % 60;
            time = hours.toString();
            minutesStr = minutes.toString();
            if (minutes > 0) {
                minutesStr = minutes.toString();
                if (minutesStr.length === 1) {
                    minutesStr = "0" + minutesStr;
                }
                time = time + ":" + minutesStr;
            }
            time = isNegative ? "-" + time : "+" + time;
            return time;
        }
    };

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty,
        slice = [].slice;

    RG.Utils.TimeRange = (function (superClass) {
        extend(TimeRange, superClass);

        function TimeRange(startTime, endTime) {
            this.startTime = startTime;
            this.endTime = endTime;
        }

        TimeRange.prototype.getStart = function () {
            return this.startTime;
        };

        TimeRange.prototype.getEnd = function () {
            return this.endTime;
        };

        TimeRange.prototype.merge = function () {
            var currentRange, newRanges, ranges;
            ranges = 1 <= arguments.length ? slice.call(arguments, 0) : [];
            ranges.push(this);
            ranges = _.sortBy(ranges, 'endTime');
            ranges = _.sortBy(ranges, 'startTime');
            newRanges = [];
            currentRange = ranges.shift();
            while (ranges.length) {
                if (ranges[0] && currentRange.isTouching(ranges[0])) {
                    if (currentRange.endTime < ranges[0].endTime) {
                        currentRange.endTime = ranges[0].endTime;
                    }
                    ranges.shift();
                } else {
                    newRanges.push(currentRange);
                    currentRange = ranges.shift();
                }
            }
            newRanges.push(currentRange);
            return newRanges;
        };

        TimeRange.prototype.isEqual = function (other) {
            return this.endTime === other.endTime && this.startTime === other.startTime;
        };

        TimeRange.prototype.subtract = function (other) {
            var ranges;
            if (!this.overlapsWith(other)) {
                return this.totalTime();
            }
            if (this.contains(other)) {
                return this.totalTime() - other.totalTime();
            } else if (other.contains(this)) {
                return 0;
            } else if (this.overlapsWith(other)) {
                ranges = this.subtractOne(other);
                return ranges.reduce((function (acc, val) {
                    return acc + val.totalTime();
                }), 0);
            }
        };

        TimeRange.prototype.subtractOne = function (subtracted) {
            if (subtracted.startTime <= this.startTime && subtracted.endTime >= this.endTime) {
                return [];
            }
            if (subtracted.endTime <= this.startTime || subtracted.startTime >= this.endTime) {
                return [this];
            }
            if (subtracted.startTime > this.startTime && subtracted.endTime < this.endTime) {
                return [new RG.Utils.TimeRange(this.startTime, subtracted.startTime), new RG.Utils.TimeRange(subtracted.endTime, this.endTime)];
            }
            if (subtracted.startTime <= this.startTime && subtracted.endTime < this.endTime) {
                return [new RG.Utils.TimeRange(subtracted.endTime, this.endTime)];
            }
            if (subtracted.startTime > this.startTime && subtracted.endTime >= this.endTime) {
                return [new RG.Utils.TimeRange(this.startTime, subtracted.startTime)];
            }
            throw "Invalid subtraction";
        };

        TimeRange.prototype.totalTime = function () {
            return (this.endTime - this.startTime) | 0;
        };

        TimeRange.prototype.overlapsOneOClock = function () {
            return this.startTime < 780 && this.endTime > 780;
        };

        TimeRange.prototype.getAllowancePerDay = function () {
            if (this.overlapsOneOClock()) {
                return 1;
            } else {
                return 0.5;
            }
        };

        TimeRange.prototype.toString = function () {
            if (this.totalTime() === 1440) {
                return 'All day';
            }
            return (this._startMinutesToTime()) + " - " + (this._endMinutesToTime());
        };

        TimeRange.prototype._startMinutesToTime = function () {
            return RG.Utils.TimeFormatter.formatFixedTime(this.startTime);
        };

        TimeRange.prototype._endMinutesToTime = function () {
            return RG.Utils.TimeFormatter.formatFixedTime(this.endTime);
        };

        TimeRange.prototype.subtractAll = function (timeRanges) {
            var i, j, len, len1, newRanges, ranges, ref, splitRange, timeRange;
            ranges = [this];
            for (i = 0, len = timeRanges.length; i < len; i++) {
                timeRange = timeRanges[i];
                newRanges = [];
                for (j = 0, len1 = ranges.length; j < len1; j++) {
                    splitRange = ranges[j];
                    if (splitRange.overlapsWith(timeRange)) {
                        newRanges.push(splitRange.subtractOne(timeRange));
                    } else {
                        newRanges.push(splitRange);
                    }
                }
                ranges = (ref = []).concat.apply(ref, newRanges);
            }
            return ranges.reduce((function (acc, tr) {
                return acc + tr.totalTime();
            }), 0);
        };

        return TimeRange;

    })(RG.Utils.Range);

    RG.Utils.TimeRange.sum = function (ranges) {
        return ranges.reduce((function (acc, range) {
            return acc + range.totalTime();
        }), 0);
    };

}).call(this);
;
(function () {
    RG.Utils.UnitDurationConverter = (function () {
        function UnitDurationConverter(unitType) {
            this.unitType = unitType;
        }

        UnitDurationConverter.prototype.convertArray = function (durations, startDate, endDate) {
            var currentUnit, duration, durationsInUnit, earliest, latest, unit, unitDuration, unitDurations;
            if (durations.length === 0) {
                return [];
            }
            if (durations.length === 1 && RG.Utils.DateComparator.equalsYMD(startDate, endDate)) {
                duration = durations[0];
                unit = new this.unitType(duration.attributes.date);
                unitDuration = new RG.Models.UnitDuration;
                unitDuration.attributes = {
                    minutes: duration.getMinutes(),
                    minutesPerLine: unit.getMinutesPerUtilisationLine(),
                    date: unit.date,
                    waiting: duration.isWaiting() || false
                };
                return [unitDuration];
            }
            earliest = startDate || durations[0].attributes.date;
            latest = endDate || durations[durations.length - 1].attributes.date;
            unitDurations = [];
            currentUnit = new this.unitType(earliest);
            while (1) {
                durationsInUnit = this._getDurationsInUnit(durations, currentUnit);
                duration = new RG.Models.UnitDuration;
                duration.attributes = {
                    minutes: this.getMinutesInDurations(durationsInUnit),
                    minutesPerLine: currentUnit.getMinutesPerUtilisationLine(),
                    date: currentUnit.date,
                    waiting: durationsInUnit.some(function (d) {
                        return d.isWaiting();
                    })
                };
                unitDurations.push(duration);
                currentUnit = currentUnit.nextUnit();
                if (currentUnit.date > latest) {
                    break;
                }
            }
            return unitDurations;
        };

        UnitDurationConverter.prototype.convert = function (durations, startDate, endDate) {
            var collection, newDurations;
            if (durations.length === 0) {
                return new RG.Collections.UnitDurations;
            }
            newDurations = this.convertArray(durations, startDate, endDate);
            collection = new RG.Collections.UnitDurations;
            collection.models = newDurations;
            collection.models.forEach(function (d) {
                return d.collection = collection;
            });
            collection.length = newDurations.length;
            return collection;
        };

        UnitDurationConverter.prototype.getDurationMinutesInUnit = function (durations, unit) {
            var durationsInUnit;
            durationsInUnit = this._getDurationsInUnit(durations, unit);
            return this.getMinutesInDurations(durationsInUnit);
        };

        UnitDurationConverter.prototype.getMinutesInDurations = function (durations) {
            var d, i, len, minutes;
            minutes = 0;
            for (i = 0, len = durations.length; i < len; i++) {
                d = durations[i];
                minutes = minutes + d.getMinutes();
            }
            return minutes;
        };

        UnitDurationConverter.prototype._getDurationsInUnit = function (durations, unit) {
            var d, durationsInUnit, i, len;
            durationsInUnit = [];
            for (i = 0, len = durations.length; i < len; i++) {
                d = durations[i];
                if (unit.containsDate(d.attributes.date)) {
                    durationsInUnit.push(d);
                }
            }
            return durationsInUnit;
        };

        return UnitDurationConverter;

    })();

}).call(this);
;
(function () {
    Array.prototype.max = function () {
        return Math.max.apply(null, this);
    };

    Array.prototype.min = function () {
        return Math.min.apply(null, this);
    };

}).call(this);
;
(function () {
    var delegateEventSplitter, viewKeys,
        extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    delegateEventSplitter = /^(\S+)\s*(.*)$/;

    viewKeys = ['model', 'collection', 'el', 'id', 'className', 'tagName', 'events'];

    RG.Views.BaseView = (function (superClass) {
        extend(BaseView, superClass);

        function BaseView(options) {
            var i, key, len, value;
            options = options || {};
            this.cid = _.uniqueId('view');
            for (i = 0, len = viewKeys.length; i < len; i++) {
                key = viewKeys[i];
                value = options[key];
                if (value) {
                    this[key] = value;
                }
            }
            this._ensureElement();
            this.initialize.apply(this, arguments);
        }

        BaseView.prototype.delegateEvents = function (events) {
            var key, match, method;
            events || (events = this.events);
            if (!events) {
                return this;
            }
            this.undelegateEvents();
            for (key in events) {
                method = events[key];
                method = this[method];
                if (!method) {
                    continue;
                }
                match = key.match(delegateEventSplitter);
                this.delegate(match[1], match[2], method.bind(this));
            }
            return this;
        };

        BaseView.prototype._removeElement = function () {
            if (this.el.parentNode) {
                return this.el.parentNode.removeChild(this.el);
            }
        };

        BaseView.prototype.remove = function () {
            this.off();
            return BaseView.__super__.remove.apply(this, arguments);
        };

        BaseView.prototype.shrinkDropdown = function (event) {
            var chznBottomOffset, chznResults;
            chznResults = $(event.currentTarget.parentElement).find(".chzn-drop");
            chznBottomOffset = parseInt(chznResults != null ? chznResults.css("height") : void 0) + (chznResults != null ? chznResults.offset().top : void 0) - $(window).scrollTop();
            if (this._dropdownOutOfViewport(chznBottomOffset)) {
                return this._shrinkDropdownAndScrollToSelected(event);
            }
        };

        BaseView.prototype._dropdownOutOfViewport = function (bottomOffset) {
            return (bottomOffset - $(window).height()) > 0;
        };

        BaseView.prototype._shrinkDropdownAndScrollToSelected = function (el) {
            var chznResults, height, jWindow, selectedResult;
            chznResults = $(el.currentTarget.parentElement).find(".chzn-results");
            jWindow = $(window);
            height = (jWindow.height() + jWindow.scrollTop()) - chznResults.offset().top - 8;
            chznResults.css("height", _.min([parseInt(chznResults.css("height")), height]));
            selectedResult = chznResults.find(".result-selected");
            if (selectedResult.length > 0) {
                return chznResults.scrollTo(selectedResult, {
                    duration: 80
                });
            }
        };

        return BaseView;

    })(Backbone.View);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Support.CollectionView = (function (superClass) {
        extend(CollectionView, superClass);

        function CollectionView() {
            CollectionView.__super__.constructor.apply(this, arguments);
            if (this.collection === null) {
                throw "No collection given to CollectionView.";
            }
            this.listenTo(this.collection, 'add', this.addItem);
            this.listenTo(this.collection, 'remove', this.removeItem);
            this.listenTo(this.collection, 'reset', this.render);
            this.collectionViews = {};
        }

        CollectionView.prototype.forEach = function (fn) {
            var _, ref, view;
            ref = this.collectionViews;
            for (_ in ref) {
                view = ref[_];
                fn(view);
            }
        };

        CollectionView.prototype.addItem = function (model) {
            var view;
            view = this.createItemView({
                model: model
            });
            this.collectionViews[model.cid] = view;
            this._insertView(view, model);
            return view;
        };

        CollectionView.prototype._insertView = function (view, model) {
            var element;
            element = view.render().el;
            if (model === this.collection.models[0]) {
                return this.el.insertBefore(element, this.el.firstChild);
            } else {
                return this.el.appendChild(element);
            }
        };

        CollectionView.prototype.removeItem = function (model) {
            return this._removeViewByModelCid(model.cid);
        };

        CollectionView.prototype._postAnimate = function (element) { };

        CollectionView.prototype._preAnimate = function (element) { };

        CollectionView.prototype._removeViewByModelCid = function (cid) {
            this._removeView(this.collectionViews[cid]);
            return delete this.collectionViews[cid];
        };

        CollectionView.prototype._removeView = function (view) {
            view.remove();
            return typeof view.close === "function" ? view.close() : void 0;
        };

        CollectionView.prototype.remove = function () {
            var cid, ref, view;
            ref = this.collectionViews;
            for (cid in ref) {
                view = ref[cid];
                view.remove();
            }
            return CollectionView.__super__.remove.apply(this, arguments);
        };

        CollectionView.prototype.close = function () {
            var child, item, results;
            for (item in this.collectionViews) {
                this._removeViewByModelCid(item);
            }
            results = [];
            while ((child = this.el.firstChild)) {
                results.push(this.el.removeChild(child));
            }
            return results;
        };

        CollectionView.prototype.createItemView = function (options) {
            return new this.itemView({
                model: options.model
            });
        };

        CollectionView.prototype.render = function () {
            this._render();
            return this;
        };

        CollectionView.prototype._render = function () {
            var i, len, model, ref;
            this.close();
            ref = this.collection.models;
            for (i = 0, len = ref.length; i < len; i++) {
                model = ref[i];
                this.addItem(model);
            }
            return this;
        };

        return CollectionView;

    })(RG.Views.BaseView);

    RG.Support.ArrayView = (function (superClass) {
        extend(ArrayView, superClass);

        function ArrayView() {
            ArrayView.__super__.constructor.apply(this, arguments);
            this.collectionViews = {};
        }

        ArrayView.prototype.addItem = function (model) {
            var view;
            view = this.createItemView({
                model: model
            });
            this.collectionViews[model.cid] = view;
            this._insertView(view, model);
            return view;
        };

        ArrayView.prototype._insertView = function (view, model) {
            return this.el.appendChild(view.render().el);
        };

        ArrayView.prototype.removeItem = function (model) {
            return this._removeViewByModelCid(model.cid);
        };

        ArrayView.prototype._removeViewByModelCid = function (cid) {
            this._removeView(this.collectionViews[cid]);
            return delete this.collectionViews[cid];
        };

        ArrayView.prototype._removeView = function (view) {
            return view.remove();
        };

        ArrayView.prototype.remove = function () {
            var cid, ref, view;
            ref = this.collectionViews;
            for (cid in ref) {
                view = ref[cid];
                view.remove();
            }
            return ArrayView.__super__.remove.apply(this, arguments);
        };

        ArrayView.prototype.close = function () {
            var child, item, results;
            for (item in this.collectionViews) {
                this._removeViewByModelCid(item);
            }
            results = [];
            while ((child = this.el.firstChild)) {
                results.push(this.el.removeChild(child));
            }
            return results;
        };

        ArrayView.prototype.createItemView = function (options) {
            return new this.itemView({
                model: options.model
            });
        };

        ArrayView.prototype.render = function () {
            this._render();
            return this;
        };

        ArrayView.prototype._render = function () {
            var i, len, model, ref;
            this.close();
            ref = this.collection;
            for (i = 0, len = ref.length; i < len; i++) {
                model = ref[i];
                this.addItem(model);
            }
            return this;
        };

        return ArrayView;

    })(RG.Views.BaseView);

    RG.Support.SortedCollectionView = (function (superClass) {
        extend(SortedCollectionView, superClass);

        function SortedCollectionView() {
            return SortedCollectionView.__super__.constructor.apply(this, arguments);
        }

        SortedCollectionView.prototype._insertView = function (view, model) {
            var currentModelIndex, element, prevModel, prevView;
            element = view.render().el;
            this._preAnimate(element);
            if (model === this.collection.first()) {
                this.el.insertBefore(element, this.el.firstChild);
            } else if (model === this.collection.last()) {
                this.el.appendChild(element);
            } else {
                currentModelIndex = this.collection.indexOf(model);
                prevModel = this.collection.models[currentModelIndex - 1];
                prevView = this.collectionViews[prevModel.cid];
                if (prevView) {
                    this.el.insertBefore(element, prevView.el.nextElementSibling);
                } else {
                    this.el.appendChild(element);
                }
            }
            this._postAnimate(element);
            return element;
        };

        return SortedCollectionView;

    })(RG.Support.CollectionView);

    RG.Support.CachedCollectionView = (function (superClass) {
        extend(CachedCollectionView, superClass);

        function CachedCollectionView() {
            return CachedCollectionView.__super__.constructor.apply(this, arguments);
        }

        CachedCollectionView.prototype.addItem = function (model) {
            var view;
            if (view = this.collectionViews[model.cid]) {
                this.el.appendChild(view.el);
                return view.el.style.display = "";
            } else {
                return CachedCollectionView.__super__.addItem.apply(this, arguments);
            }
        };

        CachedCollectionView.prototype.clearInvisibleViews = function () {
            var cid, ref, view;
            ref = this.collectionViews;
            for (cid in ref) {
                view = ref[cid];
                if (!(view.el.style.display === "none")) {
                    continue;
                }
                view.remove();
                delete this.collectionViews[cid];
            }
        };

        CachedCollectionView.prototype.close = function () {
            var item, results;
            results = [];
            for (item in this.collectionViews) {
                results.push(this._removeViewByModelCid(item));
            }
            return results;
        };

        CachedCollectionView.prototype._removeViewByModelCid = function (cid) {
            return this._removeView(this.collectionViews[cid]);
        };

        CachedCollectionView.prototype._removeView = function (view) {
            return view.el.style.display = "none";
        };

        return CachedCollectionView;

    })(RG.Support.SortedCollectionView);

}).call(this);
;
(function () {
    RG.Support.ValidTags = (function () {
        function ValidTags() { }

        ValidTags.prototype.valid_html_tags = function () {
            return ["!--", "!DOCTYPE", "a", "abbr", "acronym", "address", "applet", "area", "article", "aside", "audio", "b", "base", "basefont", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "datalist", "dd", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "font", "footer", "form", "frame", "frameset", "head", "header", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "menu", "menuitem", "meta", "meter", "nav", "noframes", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"];
        };

        return ValidTags;

    })();

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Models.Base = (function (superClass) {
        extend(Base, superClass);

        function Base(attributes, options) {
            this.cid = _.uniqueId(this.cidPrefix);
            this.attributes = {};
            if (options) {
                this.collection = options.collection;
            }
            this.set(attributes || {});
            this.changed = {};
            this.initialize.apply(this, arguments);
        }

        return Base;

    })(Backbone.Model);

}).call(this);
;
(function () {
    var bind = function (fn, me) { return function () { return fn.apply(me, arguments); }; },
        extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty,
        indexOf = [].indexOf || function (item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

    RG.Models.ResourceInstance = (function (superClass) {
        extend(ResourceInstance, superClass);

        function ResourceInstance() {
            this.refreshDowntimes = bind(this.refreshDowntimes, this);
            return ResourceInstance.__super__.constructor.apply(this, arguments);
        }

        ResourceInstance.prototype.initialize = function (options) {
            this.account = options != null ? options.account : void 0;
            this.bookings = new RG.Collections.Bookings;
            this.bookings.resource = this;
            this.availablePeriods = new RG.Collections.AvailablePeriods;
            this.availablePeriods.resource = this;
            this.customAvailablePeriods = new RG.Collections.CustomAvailablePeriods;
            this.customAvailablePeriods.resource = this;
            this.overtimes = new RG.Collections.Overtimes;
            this.overtimes.resource = this;
            this.downtimes = new RG.Collections.Downtimes;
            this.downtimes.resource = this;
            window.downtimes.on("add:resource_id:" + this.id, (function (_this) {
                return function (d) {
                    return _this.downtimes.push(d.cloneWithBinding());
                };
            })(this));
            window.downtimes.on("remove:resource_id:" + this.id, (function (_this) {
                return function (d) {
                    var removedDowntime;
                    removedDowntime = _this.downtimes.findWhere({
                        id: d.id
                    });
                    return _this.downtimes.remove(removedDowntime);
                };
            })(this));
            this.downtimes.on("change", function (d) {
                var original;
                original = window.downtimes.findWhere({
                    id: d.id
                });
                return original.set(d.attributes);
            });
            this.availability = new RG.Factories.AvailabilityManager(this).create();
            this.customFieldOptions = new RG.Collections.CustomFieldOptions;
            this.customFieldOptions.resource = this;
            this.visible = this.get('bookable');
            return ResourceInstance.__super__.initialize.apply(this, arguments);
        };

        ResourceInstance.prototype.isAvailableIn = function (dateRange, timeRange) {
            if (timeRange == null) {
                timeRange = new RG.Utils.TimeRange(0, 1440);
            }
            return this.availability.isAvailableIn(dateRange, timeRange);
        };

        ResourceInstance.prototype.getFirstName = function () {
            var spacePos;
            if (this.get("human")) {
                spacePos = this.get('name').indexOf(' ');
                if (spacePos >= 0) {
                    return this.escape('name').substr(0, spacePos);
                } else {
                    return this.escape('name');
                }
            } else {
                return this.getName();
            }
        };

        ResourceInstance.prototype.getImage = function () {
            return this.get('imageUrl');
        };

        ResourceInstance.prototype.hasAvatar = function () {
            return true;
        };

        ResourceInstance.prototype.getName = function () {
            return this.escape('name');
        };

        ResourceInstance.prototype.getTimeZoneName = function () {
            return this.getTimeZone().getName();
        };

        ResourceInstance.prototype.getInitials = function () {
            var initials, names;
            names = this.get('name').split(" ");
            initials = names[0][0].toUpperCase();
            if (names.length !== 1 && names[names.length - 1][0]) {
                initials += names[names.length - 1][0].toUpperCase();
            }
            return initials;
        };

        ResourceInstance.prototype.getTimeZone = function () {
            return this.get('timeZone') || new RG.Models.TimeZone({
                name: "UTC",
                offset: 0
            });
        };

        ResourceInstance.prototype.getDisplayTimeZone = function () {
            return this.get('displayTimeZone') || new RG.Models.TimeZone({
                name: "UTC",
                offset: 0
            });
        };

        ResourceInstance.prototype.shouldDisplayTimeZone = function () {
            return this.getTimeZoneName() !== window.currentUserTimeZone;
        };

        ResourceInstance.prototype.hasCustomFieldOption = function (option) {
            return this.customFieldOptions.contains(option);
        };

        ResourceInstance.prototype.isBookable = function () {
            return typeof this.get("bookable") === "undefined" || this.get("bookable");
        };

        ResourceInstance.prototype.isBookedOnClient = function (client) {
            return _.contains(this.get('bookedClients'), client);
        };

        ResourceInstance.prototype.isBookedOnProject = function (project) {
            return _.contains(this.get('bookedProjects'), project);
        };

        ResourceInstance.prototype.isHuman = function () {
            return typeof this.get("human") !== "undefined" && this.get("human");
        };

        ResourceInstance.prototype.predictWaitingList = function () {
            return this.bookings.predictWaitingList();
        };

        ResourceInstance.prototype.typeName = function () {
            var ref;
            return (ref = this.get('resourceType')) != null ? ref.get('name') : void 0;
        };

        ResourceInstance.prototype.refreshDowntimes = function (silent) {
            if (silent == null) {
                silent = false;
            }
            if (this.hasDowntimes) {
                return;
            }
            this.hasDowntimes = true;
            return this.downtimes.reset(this.account.downtimes.forResource(this).map(function (downtime) {
                var d;
                d = downtime.clone();
                downtime.on('change', function () {
                    return d.set(downtime.attributes);
                });
                return d;
            }), {
                    silent: silent
                });
        };

        ResourceInstance.prototype.isDowntimesStale = function () {
            var array, currentDowntimes, i, j, len, len1, uniqArray, val;
            currentDowntimes = this.account.downtimes.forResource(this);
            if (this.downtimes.length !== currentDowntimes.length) {
                return true;
            } else {
                array = (currentDowntimes.map(function (downtime) {
                    return downtime.id;
                })).concat(this.downtimes.pluck('id'));
                uniqArray = [];
                for (i = 0, len = array.length; i < len; i++) {
                    val = array[i];
                    if (indexOf.call(uniqArray, val) < 0) {
                        uniqArray.push(val);
                    }
                }
                if (uniqArray.length !== this.downtimes.length) {
                    return true;
                } else {
                    array = (currentDowntimes.map(function (downtime) {
                        return downtime.attributes.updatedAt.getTime();
                    })).concat(this.downtimes.models.map(function (downtime) {
                        return downtime.attributes.updatedAt.getTime();
                    }));
                    uniqArray = [];
                    for (j = 0, len1 = array.length; j < len1; j++) {
                        val = array[j];
                        if (indexOf.call(uniqArray, val) < 0) {
                            uniqArray.push(val);
                        }
                    }
                    if (uniqArray.length !== this.downtimes.length) {
                        return true;
                    }
                }
            }
            return false;
        };

        ResourceInstance.prototype.getDowntimeText = function () {
            return "downtime";
        };

        ResourceInstance.prototype.getHeadingDowntimeText = function () {
            return "Downtime";
        };

        ResourceInstance.prototype._addDays = function (dateRange, timeRange, total, increment) {
            if (this.isAvailableIn(dateRange, timeRange)) {
                return total + increment;
            } else {
                return total;
            }
        };

        return ResourceInstance;

    })(RG.Models.Base);

}).call(this);
;
(function () {
    var date,
        extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Models.TimeZone = (function (superClass) {
        extend(TimeZone, superClass);

        function TimeZone() {
            return TimeZone.__super__.constructor.apply(this, arguments);
        }

        TimeZone.prototype.toString = function () {
            return "(GMT " + (RG.Utils.TimeFormatter.formatMinutesOffset(this.get('offset'))) + ") " + (this.get('name'));
        };

        TimeZone.prototype.getFormattedOffset = function () {
            var flag, formattedHours, formattedOffset, hours, offsetHours;
            offsetHours = (this.get('offset') / 60) * -1;
            hours = Math.abs(offsetHours);
            formattedHours = Math.floor(hours);
            if (hours <= 10) {
                formattedHours = "0" + formattedHours;
            }
            if (offsetHours % 1 !== 0) {
                formattedOffset = formattedHours + ":30";
            } else {
                formattedOffset = formattedHours + ":00";
            }
            flag = offsetHours >= 0 ? "+" : "-";
            return flag + formattedOffset;
        };

        TimeZone.prototype.getName = function () {
            return this.get('name');
        };

        TimeZone.prototype.getParamValue = function () {
            return this.getName();
        };

        return TimeZone;

    })(RG.Models.Base);

    RG.Models.TimeZone.UTC = new RG.Models.TimeZone({
        name: 'UTC',
        offset: 0
    });

    date = new Date();

    RG.Models.TimeZone.Current = new RG.Models.TimeZone({
        name: 'Current',
        offset: -date.getTimezoneOffset()
    });

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Models.AbstractTimeAllocation = (function (superClass) {
        extend(AbstractTimeAllocation, superClass);

        function AbstractTimeAllocation() {
            return AbstractTimeAllocation.__super__.constructor.apply(this, arguments);
        }

        AbstractTimeAllocation.prototype.isDowntime = function () {
            return false;
        };

        AbstractTimeAllocation.prototype.getDateRange = function () {
            return new RG.Utils.DateRange(this.getFirstAllocatedDate(), this.getLastAllocatedDate());
        };

        AbstractTimeAllocation.prototype.getFirstAllocatedDate = function () {
            throw "Implement getFirstAllocatedDate in subclasses";
        };

        AbstractTimeAllocation.prototype.getLastAllocatedDate = function () {
            throw "Implement getLastAllocatedDate in subclasses";
        };

        AbstractTimeAllocation.prototype.getTimeRange = function () {
            throw "Implement getTimeRange in subclasses";
        };

        AbstractTimeAllocation.prototype.getConfirmedMinutes = function () {
            return this.getTimeRange().totalTime();
        };

        AbstractTimeAllocation.prototype.getDurationCaption = function () {
            return this._getFirstDuration().getCaption();
        };

        AbstractTimeAllocation.prototype.getDurationRepeatCaption = function () {
            return this._getFirstDuration().getRepeatCaption();
        };

        AbstractTimeAllocation.prototype.getDurationLongRepeatCaption = function () {
            return this._getFirstDuration().getLongRepeatCaption();
        };

        AbstractTimeAllocation.prototype.getDraggingId = function () {
            return (RG.Utils.DateFormatter.getISODate(this.getFirstAllocatedDate())) + "-" + (RG.Utils.DateFormatter.getISODate(this.getLastAllocatedDate())) + "-dragged-booking";
        };

        AbstractTimeAllocation.prototype._getFirstDuration = function () {
            throw "Implement _getFirstDuration in subclasses";
        };

        AbstractTimeAllocation.prototype._getLastDuration = function () {
            throw "Implement _getLastDuration in subclasses";
        };

        AbstractTimeAllocation.prototype.getStartDate = function () {
            throw "Implement getStartDate in subclasses";
        };

        AbstractTimeAllocation.prototype.getEndDate = function () {
            throw "Implement getEndDate in subclasses";
        };

        AbstractTimeAllocation.prototype.singleDayBooking = function () {
            throw "Implement singleDayBooking in subclasses";
        };

        return AbstractTimeAllocation;

    })(RG.Models.Base);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Models.Account = (function (superClass) {
        extend(Account, superClass);

        function Account() {
            return Account.__super__.constructor.apply(this, arguments);
        }

        Account.prototype.initialize = function (options) {
            if (options == null) {
                options = {};
            }
            return this.downtimes = options.downtimes || new RG.Collections.Downtimes;
        };

        Account.prototype.getSubdomain = function () {
            return this.get("subdomain");
        };

        return Account;

    })(RG.Models.Base);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Models.AvailablePeriod = (function (superClass) {
        extend(AvailablePeriod, superClass);

        function AvailablePeriod() {
            return AvailablePeriod.__super__.constructor.apply(this, arguments);
        }

        AvailablePeriod.prototype.getMinutesAvailable = function () {
            return +this.get('endTime') - +this.get('startTime');
        };

        AvailablePeriod.prototype.isValidOn = function (date) {
            return this.get('weekDay') === date.getDay() && (typeof this.get('validUntil') === 'undefined' || this.get('validUntil').getTime() >= date.getTime()) && (this.get('validFrom') < date || RG.Utils.DateComparator.equalsYMD(this.get('validFrom'), date));
        };

        AvailablePeriod.prototype.isCoveringDate = function (date) {
            var comparedRange, dateRange;
            dateRange = new RG.Utils.DateRange(this.get('validFrom'), this.get('validUntil'));
            comparedRange = new RG.Utils.DateRange(date, date);
            return dateRange.overlapsWith(comparedRange);
        };

        AvailablePeriod.prototype.isValidInDateRange = function (dateRange) {
            var endDate, startDate, validFrom, validFromTime, validUntil, validUntilTime;
            validFrom = this.attributes.validFrom;
            validUntil = this.attributes.validUntil;
            validFromTime = validFrom.valueOf();
            validUntilTime = validUntil != null ? validUntil.valueOf() : void 0;
            startDate = dateRange.startDate.valueOf();
            endDate = dateRange.endDate.valueOf();
            return dateRange.includes(validFrom) || ((validFromTime <= startDate) && !validUntilTime) || ((validFromTime <= startDate) && (validUntilTime >= endDate)) || dateRange.includes(validUntil);
        };

        AvailablePeriod.prototype.isAllDay = function () {
            return this.getMinutesAvailable() === 1440;
        };

        AvailablePeriod.prototype.toString = function () {
            return (RG.Utils.TimeFormatter.formatFixedTime(+this.get('startTime'))) + " - " + (RG.Utils.TimeFormatter.formatFixedTime(+this.get('endTime')));
        };

        AvailablePeriod.prototype.differentPeriod = function (cap) {
            return +this.get('endTime') !== +cap.get('endTime') || +this.get('startTime') !== +cap.get('startTime');
        };

        AvailablePeriod.prototype.contains = function (timeRange) {
            return new RG.Utils.TimeRange(this.get('startTime'), this.get('endTime')).contains(timeRange);
        };

        AvailablePeriod.prototype.getTimeRange = function () {
            return new RG.Utils.TimeRange(this.get('startTime'), this.get('endTime'));
        };

        AvailablePeriod.prototype.isNewerThan = function (date) {
            return this.get('validFrom').valueOf() >= date.valueOf();
        };

        return AvailablePeriod;

    })(RG.Models.Base);

}).call(this);
;
(function () {
    var bind = function (fn, me) { return function () { return fn.apply(me, arguments); }; },
        extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Models.BaseDuration = (function (superClass) {
        extend(BaseDuration, superClass);

        function BaseDuration() {
            this.predictWaitingList = bind(this.predictWaitingList, this);
            return BaseDuration.__super__.constructor.apply(this, arguments);
        }

        BaseDuration.prototype.anyClashes = function () {
            return false;
        };

        BaseDuration.prototype.getDate = function () {
            return this.get('date');
        };

        BaseDuration.prototype.getLayer = function () {
            return this.collection.booking.layer;
        };

        BaseDuration.prototype.isConfirmed = function () {
            return !this.attributes.waiting;
        };

        BaseDuration.prototype.isWaiting = function () {
            return this.attributes.waiting;
        };

        BaseDuration.prototype.containsDate = function (date) {
            return RG.Utils.DateComparator.equalsYMD(this.get('date'), date);
        };

        BaseDuration.prototype._isValidInTimeRange = function (timeRange) {
            return true;
        };

        BaseDuration.prototype.predictWaitingList = function () {
            var am, confirmed, date, duration, durations, i, len, minutesAvailable, ref, ref1, ref2, ref3, resource, usedMinutes;
            resource = (ref = this.collection) != null ? (ref1 = ref.booking) != null ? (ref2 = ref1.collection) != null ? ref2.resource : void 0 : void 0 : void 0;
            if (!resource) {
                return;
            }
            am = resource.availability;
            date = this.attributes.date;
            minutesAvailable = am.getMinutesAvailableForDate(date);
            if (minutesAvailable === 0) {
                return;
            }
            usedMinutes = 0;
            durations = [];
            ref3 = resource.bookings.getDurationsForDate(date);
            for (i = 0, len = ref3.length; i < len; i++) {
                duration = ref3[i];
                if (!(duration !== this && duration.isConfirmed())) {
                    continue;
                }
                durations.push(duration);
                usedMinutes += duration.getMinutes();
            }
            if (this.get('waiting')) {
                confirmed = !this.anyClashes(durations) && (usedMinutes + this.getMinutes()) <= minutesAvailable && am.getAvailableTimeRangesInDateRange(new RG.Utils.DateRange(date, date)).some((function (_this) {
                    return function (r) {
                        return _this._isValidInTimeRange(r);
                    };
                })(this));
                this.set({
                    waiting: !confirmed
                });
            }
        };

        BaseDuration.prototype.removeAndUpdateBooking = function () {
            var booking, bookings, date, durations, resource;
            durations = this.collection;
            booking = durations != null ? durations.booking : void 0;
            if (!booking) {
                return;
            }
            bookings = booking.collection;
            resource = bookings.resource;
            date = this.get('date');
            durations.remove(this, {
                silent: true
            });
            if (durations.length === 0) {
                bookings.remove(booking);
                return;
            }
            if (resource.availability.getMinutesAvailableForDate(date) > 0) {
                booking.split(date);
            }
        };

        return BaseDuration;

    })(RG.Models.Base);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Models.Booker = (function (superClass) {
        extend(Booker, superClass);

        function Booker() {
            return Booker.__super__.constructor.apply(this, arguments);
        }

        return Booker;

    })(RG.Models.Base);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty,
        slice = [].slice;

    RG.Models.Booking = (function (superClass) {
        extend(Booking, superClass);

        function Booking() {
            Booking.__super__.constructor.apply(this, arguments);
            this.layer = 0;
            this.realBooking = this;
            this.durations = new RG.Collections.Durations;
            this.durations.booking = this;
            return;
        }

        Booking.prototype.deepEqual = function (other) {
            var myResource, otherResource, ref, ref1;
            myResource = (ref = this.collection) != null ? ref.resource : void 0;
            otherResource = (ref1 = other.collection) != null ? ref1.resource : void 0;
            return other.constructor === this.constructor && this.layer === other.layer && _.isEqual(this.attributes, other.attributes) && _.isEqual(this.durations.models.map(function (d) {
                return d.attributes;
            }), other.durations.models.map(function (d) {
                return d.attributes;
            })) && myResource === otherResource;
        };

        Booking.prototype.deepClone = function () {
            var b, clonedDurations;
            b = this.clone();
            clonedDurations = this.durations.models.map(function (d) {
                var dup;
                dup = new d.constructor;
                dup.attributes = _.clone(d.attributes);
                dup.id = d.id;
                return dup;
            });
            b.durations = new RG.Collections.Durations;
            b.durations.models = clonedDurations;
            b.durations.length = clonedDurations.length;
            b.durations.booking = b;
            return b;
        };

        Booking.prototype.getBookingTarget = function () {
            return this.get('client') || this.get('project') || new RG.Models.NullBookingTarget;
        };

        Booking.prototype.getProjectNameWithProjectCode = function () {
            return this.get('project') && this.get('project').getNameWithProjectCode();
        };

        Booking.prototype.getClientName = function () {
            if (this.get('client')) {
                return this.get('client').getName();
            } else if (this.get('project')) {
                return this.get('project').getClientName();
            }
        };

        Booking.prototype.getCaption = function () {
            var caption, durationCaption, separator;
            durationCaption = this.getDurationCaption();
            separator = "";
            caption = this.getBookingTarget().toString('short');
            if (this.isSeries()) {
                durationCaption = durationCaption + " " + (this.getDurationRepeatCaption());
            }
            if (caption.indexOf("|") === -1 && this.escape('notes').trim().length) {
                if (caption.length) {
                    caption = caption + " | ";
                }
                caption = caption + this.escape('notes').substr(0, 35).trim();
                if (this.escape('notes').length > 35) {
                    caption = caption + "...";
                }
            }
            if (caption.length && durationCaption.length) {
                separator = " | ";
            }
            return caption + separator + durationCaption;
        };

        Booking.prototype.getConfirmedMinutes = function () {
            var confirmedDurations;
            confirmedDurations = this.durations.filter(function (d) {
                return d.isConfirmed();
            });
            return confirmedDurations.map(function (d) {
                return d.getMinutes();
            }).reduce((function (a, b) {
                return a + b;
            }), 0);
        };

        Booking.prototype.getFirstAllocatedDate = function () {
            return this._getFirstDuration().get('date');
        };

        Booking.prototype.getLastAllocatedDate = function () {
            return this._getLastDuration().get('date');
        };

        Booking.prototype.getLongCaption = function () {
            var caption, durationCaption, longCaption, target;
            target = this.getBookingTarget();
            caption = "";
            durationCaption = this.getDurationCaption();
            if (this.isSeries()) {
                durationCaption = durationCaption + " " + (this.getDurationLongRepeatCaption());
            }
            caption = caption + ("<span class=\"label__time\">" + durationCaption + "</span>");
            if ((target != null) && target.constructor) {
                longCaption = "<br>" + (target.getLongCaption());
                caption = caption + (target.getLongCaption().length ? longCaption : "");
            }
            if (this.get('notes') && target.getLongCaption().indexOf("<br>") === -1) {
                caption = caption + ("<br>" + (this.escape('notes')));
            }
            return caption;
        };

        Booking.prototype.getSavedDateRange = function () {
            return new RG.Utils.DateRange(this.get('startDate'), this.get('endDate'));
        };

        Booking.prototype.getTitleCaption = function () {
            var caption, details, durationCaption, target, targetString;
            target = this.getBookingTarget();
            caption = [];
            if (targetString = target.toString()) {
                caption.push(targetString);
            }
            if (this.get('notes') && this.get('notes').length) {
                details = this.get('notes').replace(/\n/g, " ").substr(0, 300);
                details = details.length === 300 ? details.substr(0, 297) + "..." : details;
                caption.push(details);
            }
            durationCaption = this.getDurationCaption();
            if (this.isSeries) {
                durationCaption += " " + this.getDurationRepeatCaption();
            }
            caption.push(durationCaption);
            return caption.join(" | ");
        };

        Booking.prototype.getWaitingMinutes = function () {
            var waitingDurations;
            waitingDurations = this.durations.filter(function (d) {
                return d.isWaiting();
            });
            return _.reduce(_.map(waitingDurations, function (d) {
                return d.getMinutes();
            }), (function (a, b) {
                return a + b;
            }), 0);
        };

        Booking.prototype.cloneWithDurations = function () {
            var booking, durations, endDate, startDate;
            durations = 1 <= arguments.length ? slice.call(arguments, 0) : [];
            startDate = durations[0].get('date');
            endDate = _.last(durations).get('date');
            booking = this.clone();
            booking.set({
                startDate: startDate,
                endDate: endDate
            });
            booking.durations = new RG.Collections.Durations(durations);
            booking.collection = this.collection;
            booking.realBooking = this;
            return booking;
        };

        Booking.prototype.split = function (date) {
            var durations, leftDurations, rightBooking, rightDurations;
            leftDurations = this.durations.select(function (duration) {
                return duration.get('date').cloneYMD() < date.cloneYMD();
            });
            rightDurations = this.durations.select(function (duration) {
                return duration.get('date').cloneYMD() > date.cloneYMD();
            });
            if (leftDurations.length && rightDurations.length) {
                this.durations.reset(leftDurations);
                this.set({
                    startDate: leftDurations[0].get('date'),
                    endDate: _.last(leftDurations).get('date')
                });
                rightBooking = this.clone();
                rightBooking.set({
                    id: null,
                    startDate: rightDurations[0].get('date'),
                    endDate: _.last(rightDurations).get('date')
                });
                rightBooking.collection = this.collection;
                rightBooking.durations = new RG.Collections.Durations(rightDurations);
                rightBooking.durations.booking = rightBooking;
                return this.collection.add(rightBooking);
            } else {
                durations = leftDurations.concat(rightDurations);
                this.durations.reset(durations);
                return this.set({
                    startDate: durations[0].get('date'),
                    endDate: _.last(durations).get('date')
                });
            }
        };

        Booking.prototype.isBillable = function () {
            return !!this.get('billable');
        };

        Booking.prototype.isExclusivelyOnWaitingList = function () {
            return this.durations.models.filter(function (d) {
                return d.getMinutes() > 0;
            }).every(function (d) {
                return d.isWaiting();
            });
        };

        Booking.prototype.isSeries = function () {
            return this.durations.length > 1;
        };

        Booking.prototype.predictWaitingList = function () {
            return this.durations.predictWaitingList();
        };

        Booking.prototype.getFirstNonZeroDuration = function () {
            var duration, i, len, ref;
            ref = this.durations.models;
            for (i = 0, len = ref.length; i < len; i++) {
                duration = ref[i];
                if (duration.getMinutes() > 0) {
                    return duration;
                }
            }
            return new RG.Models.NullDuration;
        };

        Booking.prototype._getFirstDuration = function () {
            return this.durations.models[0] || new RG.Models.NullDuration;
        };

        Booking.prototype._getLastDuration = function () {
            return this.durations.models[this.durations.length - 1] || new RG.Models.NullDuration;
        };

        Booking.prototype.getBooker = function () {
            return this.get('booker');
        };

        Booking.prototype.getDurations = function () {
            return this.durations.models;
        };

        Booking.prototype.getStartDate = function () {
            return this._getFirstDuration().getDate();
        };

        Booking.prototype.getEndDate = function () {
            return this._getLastDuration().getDate();
        };

        Booking.prototype.hasNoDurations = function () {
            return this.durations.select(function (d) {
                return !d.transient;
            }).length === 0;
        };

        Booking.prototype.singleDayBooking = function () {
            return this.durations.length === 1 && this.get('startDate') && this.get('endDate') && RG.Utils.DateComparator.equalsYMD(this.get('startDate'), this.get('endDate'));
        };

        return Booking;

    })(RG.Models.AbstractTimeAllocation);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Models.CustomAvailablePeriod = (function (superClass) {
        extend(CustomAvailablePeriod, superClass);

        function CustomAvailablePeriod() {
            return CustomAvailablePeriod.__super__.constructor.apply(this, arguments);
        }

        CustomAvailablePeriod.prototype.initialize = function (options) {
            return CustomAvailablePeriod.__super__.initialize.apply(this, arguments);
        };

        CustomAvailablePeriod.prototype.isValidOn = function (date) {
            return RG.Utils.DateComparator.equalsYMD(this.get('date'), date);
        };

        CustomAvailablePeriod.prototype.isEditable = function () {
            return true;
        };

        return CustomAvailablePeriod;

    })(RG.Models.AvailablePeriod);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Models.CustomField = (function (superClass) {
        extend(CustomField, superClass);

        function CustomField() {
            return CustomField.__super__.constructor.apply(this, arguments);
        }

        CustomField.prototype.initialize = function () {
            this.customFieldOptions = new RG.Collections.CustomFieldOptions;
            return this.customFieldOptions.customField = this;
        };

        return CustomField;

    })(RG.Models.Base);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Models.CustomFieldOption = (function (superClass) {
        extend(CustomFieldOption, superClass);

        function CustomFieldOption() {
            return CustomFieldOption.__super__.constructor.apply(this, arguments);
        }

        return CustomFieldOption;

    })(RG.Models.Base);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Models.Downtime = (function (superClass) {
        extend(Downtime, superClass);

        function Downtime() {
            Downtime.__super__.constructor.apply(this, arguments);
            this.downtimeType = this.getDowntimeType();
            this._timeRanges = {};
            this._timeZoneConverted = {};
            this._boundClones = [];
            if (!this.attributes.updatedAt) {
                this.attributes.updatedAt = new Date;
            }
            this.on('change', this._resetCache, this);
            this.on('change', (function (_this) {
                return function () {
                    var d, i, len, ref, results;
                    ref = _this._boundClones;
                    results = [];
                    for (i = 0, len = ref.length; i < len; i++) {
                        d = ref[i];
                        results.push(d.set(_this.attributes));
                    }
                    return results;
                };
            })(this));
            return;
        }

        Downtime.prototype.deepEqual = function (other) {
            return this.constructor === other.constructor && this.layer === other.layer && _.isEqual(this.attributes, other.attributes);
        };

        Downtime.prototype.deepClone = function () {
            return this.clone();
        };

        Downtime.prototype._resetCache = function () {
            this._timeRanges = {};
            this._durations = null;
            return this._timeZoneConverted = {};
        };

        Downtime.prototype.isDowntime = function () {
            return true;
        };

        Downtime.prototype.isSeries = function () {
            return this.getDateRange().getNumberOfDays() > 1;
        };

        Downtime.prototype.clone = function () {
            return new this.constructor(this.attributes);
        };

        Downtime.prototype.cloneWithBinding = function () {
            var d;
            d = this.clone();
            this._boundClones.push(d);
            return d;
        };

        Downtime.prototype.getDowntimeType = function () {
            return this.get('downtimeType');
        };

        Downtime.prototype.getConfirmedMinutes = function () {
            var date, dateRange, i, len, ref, time, timeRange;
            dateRange = this.getDateRange();
            if (dateRange.getNumberOfDays() === 1) {
                timeRange = this.getTimeRange(dateRange.startDate);
                return timeRange.totalTime();
            } else {
                time = 0;
                ref = dateRange.getDates();
                for (i = 0, len = ref.length; i < len; i++) {
                    date = ref[i];
                    timeRange = this.getTimeRange(date);
                    time += timeRange.totalTime();
                }
                return time;
            }
        };

        Downtime.prototype.getSavedDateRange = function () {
            return this.getDateRange();
        };

        Downtime.prototype.getFirstAllocatedDate = function () {
            return this.attributes.from;
        };

        Downtime.prototype.getLastAllocatedDate = function () {
            return this.attributes.to;
        };

        Downtime.prototype.type = function () {
            var ref;
            return (ref = this.getDowntimeType()) != null ? ref.get('name') : void 0;
        };

        Downtime.prototype.inYear = function (year) {
            return this.getDateRange().coversYear(year);
        };

        Downtime.prototype.isValidOn = function (date) {
            return this.getDateRange().includes(date);
        };

        Downtime.prototype.inTimeZoneSimple = function (timeZone) {
            var from, offset, shift, shiftedEnd, shiftedEndDate, shiftedEndTime, shiftedStart, shiftedStartDate, shiftedStartTime, to;
            if (this.isLocalTimeZone()) {
                from = this.attributes.from;
                to = this.attributes.to;
                return {
                    startDate: from,
                    endDate: to,
                    startTime: this.attributes.startTime,
                    endTime: this.attributes.endTime,
                    getDateRange: function () {
                        return new RG.Utils.DateRange(from, to);
                    },
                    getStartDate: function () {
                        return from;
                    },
                    getEndDate: function () {
                        return to;
                    }
                };
            }
            offset = timeZone != null ? timeZone.get('offset') : void 0;
            shift = -this.get('timeZone').get('offset') + offset;
            from = this.get('from');
            to = this.get('to');
            shiftedStartTime = this.get('startTime') + shift;
            shiftedEndTime = this.get('endTime') + shift;
            shiftedStartDate = from.getTime();
            if (shiftedStartTime < 0) {
                shiftedStartDate -= 86400000;
            } else if (shiftedStartTime > 1440) {
                shiftedStartDate += 86400000;
            }
            shiftedEndDate = to.getTime();
            if (shiftedEndTime <= 0) {
                shiftedEndDate -= 86400000;
            } else if (shiftedEndTime > 1440) {
                shiftedEndDate += 86400000;
            }
            shiftedStart = new Date(shiftedStartDate);
            shiftedEnd = new Date(shiftedEndDate);
            return {
                startDate: shiftedStart,
                endDate: shiftedEnd,
                startTime: (shiftedStartTime + 1440) % 1440,
                endTime: ((shiftedEndTime + 1440) % 1440) || 1440,
                getDateRange: function () {
                    return new RG.Utils.DateRange(shiftedStart, shiftedEnd);
                },
                getStartDate: function () {
                    return shiftedStart;
                },
                getEndDate: function () {
                    return shiftedEnd;
                }
            };
        };

        Downtime.prototype.inTimeZone = function (timeZone) {
            var attributes, from, offset, resultDowntime, shift, shiftedDowntime, shiftedEnd, shiftedEndDate, shiftedEndTime, shiftedStart, shiftedStartDate, shiftedStartTime, to;
            offset = timeZone != null ? timeZone.get('offset') : void 0;
            if (this._timeZoneConverted[offset]) {
                return this._timeZoneConverted[offset];
            }
            if (this.isLocalTimeZone()) {
                resultDowntime = new RG.Models.Downtime;
                resultDowntime.attributes = _.clone(this.attributes);
                resultDowntime.id = this.attributes.id;
                return this._timeZoneConverted[offset] = resultDowntime;
            }
            shift = -this.get('timeZone').get('offset') + offset;
            from = this.get('from');
            to = this.get('to');
            shiftedStartTime = this.get('startTime') + shift;
            shiftedEndTime = this.get('endTime') + shift;
            shiftedStartDate = from.getTime();
            if (shiftedStartTime < 0) {
                shiftedStartDate -= 86400000;
            } else if (shiftedStartTime > 1440) {
                shiftedStartDate += 86400000;
            }
            shiftedEndDate = to.getTime();
            if (shiftedEndTime <= 0) {
                shiftedEndDate -= 86400000;
            } else if (shiftedEndTime > 1440) {
                shiftedEndDate += 86400000;
            }
            shiftedStart = new Date(shiftedStartDate);
            shiftedEnd = new Date(shiftedEndDate);
            attributes = {
                id: this.attributes.id,
                timeZone: timeZone,
                downtimeTypeId: this.attributes.downtimeTypeId,
                details: this.attributes.details,
                state: this.attributes.state,
                creatorId: this.attributes.creatorId,
                leave: this.attributes.leave,
                resourceIds: this.attributes.resourceIds,
                downtimeType: this.getDowntimeType(),
                from: shiftedStart,
                to: shiftedEnd,
                updatedAt: this.attributes.updatedAt,
                startTime: ((shiftedStartTime + 1440) % 1440) | 0,
                endTime: (((shiftedEndTime + 1440) % 1440) | 0) || 1440
            };
            shiftedDowntime = new RG.Models.Downtime;
            shiftedDowntime.attributes = attributes;
            shiftedDowntime.id = attributes.id;
            shiftedDowntime.layer = this.layer;
            return this._timeZoneConverted[timeZone] = shiftedDowntime;
        };

        Downtime.prototype.getRawTimeRange = function () {
            return new RG.Utils.TimeRange(this.get('startTime'), this.get('endTime'));
        };

        Downtime.prototype.getTimeRange = function (date) {
            var key;
            key = date.toString();
            if (this._timeRanges[key]) {
                return this._timeRanges[key];
            }
            return this._timeRanges[key] = RG.Utils.DateComparator.equalsYMD(date, this.get('from')) && RG.Utils.DateComparator.equalsYMD(date, this.get('to')) ? new RG.Utils.TimeRange(this.get('startTime'), this.get('endTime')) : RG.Utils.DateComparator.equalsYMD(date, this.get('from')) ? new RG.Utils.TimeRange(this.get('startTime'), 1440) : RG.Utils.DateComparator.equalsYMD(date, this.get('to')) ? new RG.Utils.TimeRange(0, this.get('endTime')) : this.get('from') > date || this.get('to') < date ? new RG.Utils.TimeRange(0, 0) : new RG.Utils.TimeRange(0, 1440);
        };

        Downtime.prototype.getType = function () {
            return this.type();
        };

        Downtime.prototype.getTypeIcon = function () {
            var ref;
            return (ref = this.getDowntimeType()) != null ? ref.typeIcon() : void 0;
        };

        Downtime.prototype.isVacation = function () {
            var ref;
            return (ref = this.getDowntimeType()) != null ? ref.isVacation() : void 0;
        };

        Downtime.prototype.getAllowancePerDay = function (date) {
            return this.getTimeRange(date).getAllowancePerDay();
        };

        Downtime.prototype.getTitleCaption = function () {
            var caption, details;
            caption = [];
            if (this.getType() && this.getType().length) {
                caption.push(this.type());
            }
            if (this.get('details') && this.get('details').length) {
                details = this.get('details').replace(/\n/g, " ").substr(0, 300);
                details = details.length === 300 ? details.substr(0, 297) + "..." : details;
                caption.push(details);
            }
            caption.push(this.getDateTimeString());
            return caption.join(" | ");
        };

        Downtime.prototype.getTimeZone = function () {
            return this.get('timeZone') || RG.Models.NullTimeZone.instance;
        };

        Downtime.prototype.getTimeZoneName = function () {
            return this.getTimeZone().getName();
        };

        Downtime.prototype.getDateTimeString = function (dateFormatter) {
            if (dateFormatter == null) {
                dateFormatter = RG.Utils.DateFormatter.getShortDate;
            }
            return new RG.Utils.DowntimePresenter(this).dateTimeString(dateFormatter);
        };

        Downtime.prototype._getFirstDuration = function () {
            return new RG.Models.Duration({
                date: this.get('from'),
                minutes: 0,
                waiting: false
            });
        };

        Downtime.prototype.getFirstNonZeroDuration = function () {
            return this._getFirstDuration();
        };

        Downtime.prototype._getLastDuration = function () {
            return new RG.Models.Duration({
                date: this.get('to'),
                minutes: 0,
                waiting: false
            });
        };

        Downtime.prototype.isExclusivelyOnWaitingList = function () {
            return false;
        };

        Downtime.prototype.getStartDate = function () {
            return this.attributes.from;
        };

        Downtime.prototype.getEndDate = function () {
            return this.attributes.to;
        };

        Downtime.prototype.getBooker = function () {
            return {
                id: this.get('creatorId')
            };
        };

        Downtime.prototype.getDurations = function (downtime) {
            var date, duration, durations, i, len, ref, timeRange;
            if (downtime == null) {
                downtime = this;
            }
            if (this._durations) {
                return this._durations;
            }
            durations = [];
            ref = this.getDateRange().getDates();
            for (i = 0, len = ref.length; i < len; i++) {
                date = ref[i];
                timeRange = this.getTimeRange(date);
                duration = new RG.Models.DowntimeDuration({
                    startTime: timeRange.startTime,
                    endTime: timeRange.endTime,
                    date: date
                });
                duration.downtime = downtime;
                durations.push(duration);
            }
            return this._durations = durations;
        };

        Downtime.prototype.addResource = function (resource) {
            var resourceIds;
            resourceIds = this.get('resourceIds');
            if (_.include(resourceIds, resource.id)) {
                return;
            }
            resourceIds.push(resource.id);
            return this.set({
                resourceIds: resourceIds
            });
        };

        Downtime.prototype.removeResource = function (resource) {
            var resourceIds;
            resourceIds = this.get('resourceIds');
            resourceIds = _.reject(resourceIds, function (id) {
                return id === resource.id;
            });
            return this.set({
                resourceIds: resourceIds
            });
        };

        Downtime.prototype.isLocalTimeZone = function () {
            return this.getTimeZone().toString() === '';
        };

        Downtime.prototype.singleDayBooking = function () {
            return this.get('from') && this.get('to') && RG.Utils.DateComparator.equalsYMD(this.get('from'), this.get('to'));
        };

        return Downtime;

    })(RG.Models.AbstractTimeAllocation);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Models.DowntimeType = (function (superClass) {
        extend(DowntimeType, superClass);

        function DowntimeType() {
            return DowntimeType.__super__.constructor.apply(this, arguments);
        }

        DowntimeType.prototype.getName = function () {
            return this.get('name');
        };

        DowntimeType.prototype.isVacation = function () {
            var name;
            name = this.getName();
            return name === RG.Variables.DowntimeType.vacation || name === RG.Variables.DowntimeType.personalHoliday;
        };

        DowntimeType.prototype.isPublicHoliday = function () {
            return this.getName() === RG.Variables.DowntimeType.publicHoliday;
        };

        DowntimeType.prototype.isSick = function () {
            return this.getName() === RG.Variables.DowntimeType.sick;
        };

        DowntimeType.prototype.isMaternity = function () {
            return this.getName() === RG.Variables.DowntimeType.maternity;
        };

        DowntimeType.prototype.isCompassionate = function () {
            return this.getName() === RG.Variables.DowntimeType.compassionate;
        };

        DowntimeType.prototype.typeIcon = function () {
            if (this.isVacation()) {
                return 'rg-icon--vacation';
            } else if (this.isPublicHoliday()) {
                return 'rg-icon--happy';
            } else if (this.isSick()) {
                return 'rg-icon--sick';
            } else if (this.isMaternity()) {
                return 'rg-icon--maternity';
            } else if (this.isCompassionate()) {
                return 'rg-icon--compassionate';
            } else {
                return '';
            }
        };

        return DowntimeType;

    })(RG.Models.Base);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Models.Duration = (function (superClass) {
        extend(Duration, superClass);

        function Duration() {
            return Duration.__super__.constructor.apply(this, arguments);
        }

        Duration.prototype.getCaption = function () {
            return RG.Utils.TimeFormatter.formatMinutes(this.realMinutes || this.getMinutes());
        };

        Duration.prototype.getMinutes = function () {
            return this.get('minutes');
        };

        Duration.prototype.getRepeatCaption = function () {
            return "p/d";
        };

        Duration.prototype.getLongRepeatCaption = function () {
            return "per day";
        };

        Duration.prototype.startsAfterTime = function (startTime) {
            return false;
        };

        Duration.prototype.endsBeforeTime = function (endTime) {
            return false;
        };

        Duration.prototype.isFixed = function () {
            return false;
        };

        Duration.prototype.getTimeRange = function () {
            return new RG.Utils.TimeRange(0, 0);
        };

        return Duration;

    })(RG.Models.BaseDuration);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Models.FilterOption = (function (superClass) {
        extend(FilterOption, superClass);

        function FilterOption() {
            return FilterOption.__super__.constructor.apply(this, arguments);
        }

        FilterOption.prototype.getName = function () {
            return this.escape("name");
        };

        return FilterOption;

    })(RG.Models.Base);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Models.FixedDuration = (function (superClass) {
        extend(FixedDuration, superClass);

        function FixedDuration() {
            return FixedDuration.__super__.constructor.apply(this, arguments);
        }

        FixedDuration.prototype.getCaption = function () {
            return this._getTimeFor(this.get('startTime')) + " - " + this._getTimeFor(this.get('endTime'));
        };

        FixedDuration.prototype.getMinutes = function () {
            return this.attributes.endTime - this.attributes.startTime;
        };

        FixedDuration.prototype.getRepeatCaption = function () {
            return "daily";
        };

        FixedDuration.prototype.getLongRepeatCaption = function () {
            return "every day";
        };

        FixedDuration.prototype._getTimeFor = function (minuteOfDay) {
            return RG.Utils.TimeFormatter.formatFixedTime(minuteOfDay);
        };

        FixedDuration.prototype.isFixed = function () {
            return true;
        };

        FixedDuration.prototype.startsAfterTime = function (endTime) {
            return endTime <= this.get('startTime');
        };

        FixedDuration.prototype.endsBeforeTime = function (startTime) {
            return startTime >= this.get('endTime');
        };

        FixedDuration.prototype.anyClashes = function (durations) {
            return durations.some((function (_this) {
                return function (duration) {
                    return _this.clash(duration);
                };
            })(this));
        };

        FixedDuration.prototype.clash = function (other) {
            return this.getTimeRange().overlapsWith(other.getTimeRange());
        };

        FixedDuration.prototype.within = function (ap) {
            return +this.get('startTime') >= +ap.get('startTime') && +this.get('endTime') <= +ap.get('endTime');
        };

        FixedDuration.prototype.getTimeRange = function () {
            return new RG.Utils.TimeRange(this.get('startTime'), this.get('endTime'));
        };

        FixedDuration.prototype._isValidInTimeRange = function (timeRange) {
            return this.getTimeRange().subtractOne(timeRange).length === 0;
        };

        return FixedDuration;

    })(RG.Models.BaseDuration);

    RG.Models.DowntimeDuration = (function (superClass) {
        extend(DowntimeDuration, superClass);

        function DowntimeDuration() {
            return DowntimeDuration.__super__.constructor.apply(this, arguments);
        }

        DowntimeDuration.prototype.getLayer = function () {
            return this.downtime.layer;
        };

        return DowntimeDuration;

    })(RG.Models.FixedDuration);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Models.HumanResourceInstance = (function (superClass) {
        extend(HumanResourceInstance, superClass);

        function HumanResourceInstance() {
            return HumanResourceInstance.__super__.constructor.apply(this, arguments);
        }

        HumanResourceInstance.prototype.hasAvatar = function () {
            var ref;
            return ((ref = this.get('imageUrl')) != null ? ref.indexOf("fallback") : void 0) === -1;
        };

        HumanResourceInstance.prototype.getDowntimeText = function () {
            return "time off";
        };

        HumanResourceInstance.prototype.getHeadingDowntimeText = function () {
            return "Time Off";
        };

        return HumanResourceInstance;

    })(RG.Models.ResourceInstance);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Models.NullTimeZone = (function (superClass) {
        extend(NullTimeZone, superClass);

        function NullTimeZone() {
            return NullTimeZone.__super__.constructor.apply(this, arguments);
        }

        NullTimeZone.prototype.toString = function () {
            return '';
        };

        NullTimeZone.prototype.getFormattedOffset = function () {
            return '';
        };

        NullTimeZone.prototype.getName = function () {
            return 'NullTimeZone';
        };

        NullTimeZone.prototype.getParamValue = function () {
            return null;
        };

        return NullTimeZone;

    })(RG.Models.TimeZone);

    RG.Models.NullTimeZone.instance = new RG.Models.NullTimeZone;

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Models.OptionGroup = (function (superClass) {
        extend(OptionGroup, superClass);

        function OptionGroup() {
            return OptionGroup.__super__.constructor.apply(this, arguments);
        }

        OptionGroup.prototype.initialize = function (options) {
            this.options = new RG.Collections.FilterOptions;
            return this.options.optionGroup = this;
        };

        OptionGroup.prototype.getName = function () {
            return this.get('name');
        };

        OptionGroup.prototype.getTagId = function () {
            var ref;
            return (ref = this.get('tag')) != null ? ref.id : void 0;
        };

        OptionGroup.prototype.getType = function () {
            var ref, ref1;
            return (ref = this.collection) != null ? (ref1 = ref.category) != null ? ref1.get('name') : void 0 : void 0;
        };

        return OptionGroup;

    })(RG.Models.Base);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Models.Overtime = (function (superClass) {
        extend(Overtime, superClass);

        function Overtime() {
            return Overtime.__super__.constructor.apply(this, arguments);
        }

        Overtime.prototype.getMinutesAvailable = function () {
            return this.get('duration');
        };

        return Overtime;

    })(RG.Models.CustomAvailablePeriod);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Models.ResourceType = (function (superClass) {
        extend(ResourceType, superClass);

        function ResourceType() {
            return ResourceType.__super__.constructor.apply(this, arguments);
        }

        ResourceType.prototype.initialize = function () {
            this.customFields = new RG.Collections.CustomFields;
            return this.customFields.resourceType = this;
        };

        ResourceType.prototype.getName = function () {
            return this.attributes.name;
        };

        return ResourceType;

    })(RG.Models.Base);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Calendar.Units.Day = (function (superClass) {
        extend(Day, superClass);

        function Day(date) {
            Day.__super__.constructor.apply(this, arguments);
            this.date = new Date(date.getFullYear(), date.getMonth(), date.getDate());
        }

        Day.prototype.containsDate = function (date) {
            return RG.Utils.DateComparator.equalsYMD(this.date, date);
        };

        Day.prototype.getDateRange = function () {
            return new RG.Utils.DateRange(this.date, this.date);
        };

        Day.prototype.getDaysPerUnit = function () {
            return 1;
        };

        Day.prototype.getName = function () {
            return new RG.Utils.DayName(this.date.getDay()).toString();
        };

        Day.prototype.getFormattedDate = function () {
            return this.date.getDate().toString();
        };

        Day.prototype.getMinutesPerUtilisationLine = function () {
            return 480;
        };

        Day.prototype.isCurrent = function () {
            return RG.Utils.DateComparator.equalsYMD(this.date, RG.Utils.BookingDataParser.getDateFromStr(window.currentUserDate.date));
        };

        Day.prototype.nextUnit = function () {
            var d;
            d = new Date(this.date.getFullYear(), this.date.getMonth(), this.date.getDate() + 1);
            return new RG.Calendar.Units.Day(d);
        };

        Day.prototype.previousUnit = function () {
            var d;
            d = new Date(this.date.getFullYear(), this.date.getMonth(), this.date.getDate() - 1);
            return new RG.Calendar.Units.Day(d);
        };

        Day.prototype.getWeek = function () {
            var ref;
            return (ref = this.date) != null ? ref.getWeek() : void 0;
        };

        return Day;

    })(RG.Models.Base);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Calendar.Units.DayUnitGrouping = (function (superClass) {
        extend(DayUnitGrouping, superClass);

        function DayUnitGrouping() {
            return DayUnitGrouping.__super__.constructor.apply(this, arguments);
        }

        DayUnitGrouping.prototype.initialize = function (dateRange) {
            this.dateRange = dateRange;
        };

        DayUnitGrouping.prototype.getUnits = function () {
            var date, day, i, j, ref, sd, ua;
            if (this._units != null) {
                return this._units;
            }
            this._units = new RG.Collections.Units();
            ua = [];
            for (i = j = 0, ref = this.dateRange.getNumberOfDays() - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
                sd = this.dateRange.startDate;
                date = new Date(sd.getFullYear(), sd.getMonth(), sd.getDate() + i);
                day = new RG.Calendar.Units.Day(date);
                ua.push(day);
            }
            this._units.reset(ua);
            return this._units;
        };

        DayUnitGrouping.prototype.toString = function () {
            return this.dateRange.toString();
        };

        return DayUnitGrouping;

    })(Backbone.Model);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Models.UnitDuration = (function (superClass) {
        extend(UnitDuration, superClass);

        function UnitDuration() {
            return UnitDuration.__super__.constructor.apply(this, arguments);
        }

        return UnitDuration;

    })(RG.Models.Base);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Models.Client = (function (superClass) {
        extend(Client, superClass);

        function Client() {
            return Client.__super__.constructor.apply(this, arguments);
        }

        Client.prototype.getTypeDescription = function () {
            return "Client";
        };

        Client.prototype.getLongCaption = function () {
            return this.getName();
        };

        Client.prototype.getLongDescription = function () {
            return this.getName();
        };

        Client.prototype.getName = function () {
            return this.escape('name');
        };

        Client.prototype.toString = function () {
            return this.getName();
        };

        return Client;

    })(RG.Models.Base);

}).call(this);
;
(function () {
    RG.Models.CurrentDate = (function () {
        function CurrentDate(date1) {
            this.date = date1;
            _.extend(this, Backbone.Events);
        }

        CurrentDate.prototype.set = function (date) {
            var changed;
            changed = this.date !== date;
            this.date = date;
            if (changed) {
                this.trigger('change', date);
            }
        };

        return CurrentDate;

    })();

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Models.DayAvailabilityAggregation = (function (superClass) {
        extend(DayAvailabilityAggregation, superClass);

        function DayAvailabilityAggregation() {
            return DayAvailabilityAggregation.__super__.constructor.apply(this, arguments);
        }

        DayAvailabilityAggregation.prototype.initialize = function (options) {
            if (options == null) {
                options = {};
            }
            this.set('availablePeriods', options.availablePeriods || {});
            this.set('originalAvailablePeriods', options.originalAvailablePeriods || {});
            this.set('durations', options.durations || {});
            this.set('overtimes', options.overtimes || {});
            return this.set('downtimes', options.downtimes || {});
        };

        DayAvailabilityAggregation.prototype.getLowestMinutesAvailable = function () {
            if (this.availabilityCleared) {
                return this.getCurrentMinutesAvailable();
            }
            return this.getAvailabilityWithoutDowntime();
        };

        DayAvailabilityAggregation.prototype.getAvailabilityWithoutDowntime = function () {
            var aggregate, dailyPeriods, i, j, k, len, len1, minutes, p, period, ref, v;
            dailyPeriods = [];
            ref = this.get('availablePeriods');
            for (k in ref) {
                v = ref[k];
                if (v.length > 0) {
                    dailyPeriods.concat(v);
                }
            }
            if (dailyPeriods.length === 1) {
                dailyPeriods = [this.getFirstAvailablePeriods().models];
            } else {
                dailyPeriods.push(this.getFirstAvailablePeriods().models);
            }
            aggregate = [];
            for (i = 0, len = dailyPeriods.length; i < len; i++) {
                period = dailyPeriods[i];
                minutes = 0;
                for (j = 0, len1 = period.length; j < len1; j++) {
                    p = period[j];
                    minutes += p.getMinutesAvailable();
                }
                aggregate.push(minutes);
            }
            return aggregate.min();
        };

        DayAvailabilityAggregation.prototype.getCurrentMinutesAvailable = function () {
            if (!this.downtimesConsistent()) {
                return null;
            }
            return this._totalMinutesFromPeriodsAndDowntimes(this.getFirstAvailablePeriods().models, this.getFirstDowntimes());
        };

        DayAvailabilityAggregation.prototype.getTotalMinutesAvailable = function () {
            var aggregate, dailyPeriods, downtimes;
            if (!this.downtimesConsistent()) {
                return null;
            }
            dailyPeriods = _.values(this.get('availablePeriods'));
            downtimes = this.getFirstDowntimes();
            aggregate = _.map(dailyPeriods, (function (_this) {
                return function (availablePeriods) {
                    return {
                        totalMinutes: _this._totalMinutesFromPeriodsAndDowntimes(availablePeriods, downtimes)
                    };
                };
            })(this));
            if (_.uniq(_.map(aggregate, function (p) {
                return p.totalMinutes;
            })).length === 1) {
                return aggregate[0].totalMinutes;
            }
            return null;
        };

        DayAvailabilityAggregation.prototype.getDates = function () {
            var _, date, ref, results;
            ref = this.get('availablePeriods');
            results = [];
            for (date in ref) {
                _ = ref[date];
                results.push(date);
            }
            return results;
        };

        DayAvailabilityAggregation.prototype.getMinutesAvailable = function () {
            var aggregate, dailyPeriods;
            dailyPeriods = _.values(this.get('availablePeriods'));
            aggregate = _.map(dailyPeriods, function (ps) {
                var totalMinutes;
                totalMinutes = _.reduce(ps, (function (acc, p) {
                    return acc + p.getMinutesAvailable();
                }), 0);
                return {
                    totalMinutes: totalMinutes,
                    availableTimes: _.map(ps, function (ap) {
                        return [ap.get('startTime'), ap.get('endTime')];
                    })
                };
            });
            if (_.all(_.rest(aggregate), function (a) {
                return _.isEqual(aggregate[0], a);
            })) {
                return aggregate[0].totalMinutes;
            }
            return null;
        };

        DayAvailabilityAggregation.prototype.getMinutesBooked = function () {
            var aggregate, durations;
            durations = _.values(this.get('durations'));
            aggregate = _.map(durations, function (ds) {
                return {
                    minutes: _.chain(ds).filter(function (d) {
                        return d.isConfirmed();
                    }).map(function (d) {
                        return d.getMinutes();
                    }).value()
                };
            });
            if (_.all(_.rest(aggregate), function (a) {
                return _.isEqual(aggregate[0], a);
            })) {
                return _.chain(durations[0]).map(function (d) {
                    return d.getMinutes();
                }).reduce((function (acc, m) {
                    return acc + m;
                }), 0).value();
            }
            return null;
        };

        DayAvailabilityAggregation.prototype.availabilityConsistent = function () {
            var mins;
            mins = this.getMinutesAvailable();
            return mins !== null && mins >= 0;
        };

        DayAvailabilityAggregation.prototype.totalAvailabilityConsistent = function () {
            var mins;
            mins = this.getTotalMinutesAvailable();
            return mins !== null && mins >= 0;
        };

        DayAvailabilityAggregation.prototype.bookingsConsistent = function () {
            var mins;
            mins = this.getMinutesBooked();
            return mins !== null && mins >= 0;
        };

        DayAvailabilityAggregation.prototype.downtimesConsistent = function () {
            var currentArray, date, downtimes, i, index, len, ref, timeRange, timeRangeArray;
            downtimes = _.values(this.get('downtimes'));
            if (downtimes.length === 0) {
                return true;
            }
            currentArray = downtimes[0];
            ref = this.get('downtimes');
            for (date in ref) {
                timeRangeArray = ref[date];
                if (currentArray.length !== timeRangeArray.length) {
                    return false;
                }
                for (index = i = 0, len = currentArray.length; i < len; index = ++i) {
                    timeRange = currentArray[index];
                    if (!timeRange.isEqual(timeRangeArray[index])) {
                        return false;
                    }
                }
                currentArray = timeRangeArray;
            }
            return true;
        };

        DayAvailabilityAggregation.prototype.overtimesConsistent = function () {
            var aggregate, overtimes;
            if (this.overtimeSet) {
                return true;
            }
            overtimes = _.values(this.get('overtimes'));
            if (overtimes.length === 0) {
                return true;
            }
            aggregate = _.map(overtimes, function (ot) {
                return {
                    minutes: _.chain(ot).map(function (o) {
                        return o.getMinutesAvailable();
                    }).value()
                };
            });
            return _.all(_.rest(aggregate), function (a) {
                return _.isEqual(aggregate[0], a);
            });
        };

        DayAvailabilityAggregation.prototype.totalAvailabilityAndBookingsConsistent = function () {
            return this.totalAvailabilityConsistent() && this.bookingsConsistent();
        };

        DayAvailabilityAggregation.prototype.totalAvailabilityAndDowntimeConsistent = function () {
            return this.totalAvailabilityConsistent() && this.downtimesConsistent();
        };

        DayAvailabilityAggregation.prototype.availabilityAndDowntimeConsistent = function () {
            return this.availabilityConsistent() && this.downtimesConsistent();
        };

        DayAvailabilityAggregation.prototype.variesFromNormalAvailability = function () {
            var currentPeriods, defaultPeriods;
            currentPeriods = this.getFirstAvailablePeriods().models;
            defaultPeriods = this.getFirstDefaultPeriods().models;
            if (currentPeriods.length !== defaultPeriods.length) {
                return true;
            }
            return defaultPeriods.some(function (period, index) {
                return !period.getTimeRange().isEqual(currentPeriods[index].getTimeRange());
            });
        };

        DayAvailabilityAggregation.prototype.getFirstAvailablePeriods = function () {
            var k, ref, v;
            if (this._aps) {
                return this._aps;
            }
            ref = this.get('availablePeriods');
            for (k in ref) {
                v = ref[k];
                this._aps = new RG.Collections.AvailablePeriods(this._deepCloneModels(v, RG.Models.CustomAvailablePeriod));
                this._aps.on("add remove reset", (function (_this) {
                    return function () {
                        return _this._aps.isDirty = true;
                    };
                })(this));
                return this._aps;
            }
            return new RG.Collections.AvailablePeriods;
        };

        DayAvailabilityAggregation.prototype.getFirstDefaultPeriods = function () {
            var k, ref, v;
            if (this._daps) {
                return this._daps;
            }
            ref = this.get('originalAvailablePeriods');
            for (k in ref) {
                v = ref[k];
                this._daps = new RG.Collections.AvailablePeriods(this._deepCloneModels(v, RG.Models.CustomAvailablePeriod));
                return this._daps;
            }
            return new RG.Collections.AvailablePeriods;
        };

        DayAvailabilityAggregation.prototype.getFirstDowntimes = function () {
            var k, ref, v;
            if (this._downtimes) {
                return this._downtimes;
            }
            ref = this.get('downtimes');
            for (k in ref) {
                v = ref[k];
                this._downtimes = v;
                return this._downtimes;
            }
            return this._downtimes = [];
        };

        DayAvailabilityAggregation.prototype.hasAvailabilityChanged = function () {
            return this.getFirstAvailablePeriods().isDirty;
        };

        DayAvailabilityAggregation.prototype.resetAvailability = function () {
            this.set('availablePeriods', this.get('originalAvailablePeriods'));
            this._aps = null;
            return this.hasAvailabilityChanged = function () {
                return true;
            };
        };

        DayAvailabilityAggregation.prototype.clearVaryingAvailability = function () {
            var k, ref, v;
            ref = this.get('availablePeriods');
            for (k in ref) {
                v = ref[k];
                this.get('availablePeriods')[k] = [];
            }
            this._aps = null;
            this._overtimes = null;
            this.availabilityCleared = true;
            return this.trigger('availabilityReset');
        };

        DayAvailabilityAggregation.prototype.getFirstOvertimes = function () {
            var k, ref, v;
            if (this._overtimes) {
                return this._overtimes;
            }
            ref = this.get('overtimes');
            for (k in ref) {
                v = ref[k];
                this._overtimes = new RG.Collections.Overtimes(this._deepCloneModels(v, RG.Models.Overtime));
                return this._overtimes;
            }
        };

        DayAvailabilityAggregation.prototype.overtime = function () {
            var ref, time;
            if (this.getFirstOvertimes().length > 0) {
                time = (ref = this.getFirstOvertimes().first()) != null ? ref.get('duration') : void 0;
            } else {
                time = 0;
            }
            return [time, this.getCurrentMinutesAvailable()].min();
        };

        DayAvailabilityAggregation.prototype.setOvertime = function (value) {
            this.overtimeSet = true;
            return this.getFirstOvertimes().each(function (model) {
                return model.set({
                    duration: value
                });
            });
        };

        DayAvailabilityAggregation.prototype.hasOvertimeChanged = function () {
            var aps, durationFunc, equalDurations, k, newDurations, originalDurations, ref;
            equalDurations = [];
            durationFunc = function (overtime) {
                return {
                    duration: overtime.get('duration')
                };
            };
            newDurations = this.getFirstOvertimes().map(durationFunc);
            ref = this.get('overtimes');
            for (k in ref) {
                aps = ref[k];
                originalDurations = _.map(aps, durationFunc);
                equalDurations.push(_.isEqual(originalDurations, newDurations));
            }
            return !_.all(equalDurations, function (x) {
                return x;
            });
        };

        DayAvailabilityAggregation.prototype.hasNoAvailability = function () {
            return this.getCurrentMinutesAvailable() <= 0;
        };

        DayAvailabilityAggregation.prototype.getDateRange = function () {
            return this.get('dateRange');
        };

        DayAvailabilityAggregation.prototype._deepCloneModels = function (models, klass) {
            var clonedModels, i, len, model;
            clonedModels = [];
            for (i = 0, len = models.length; i < len; i++) {
                model = models[i];
                clonedModels.push(new klass(model.attributes));
            }
            return clonedModels;
        };

        DayAvailabilityAggregation.prototype._totalMinutesFromPeriodsAndDowntimes = function (periods, downtimes) {
            if (downtimes.length === 0) {
                return this._totalMinutesFromPeriods(periods);
            }
            return _.reduce(periods, function (acc, ap) {
                return acc + ap.getTimeRange().subtractAll(downtimes);
            }, 0);
        };

        DayAvailabilityAggregation.prototype._totalMinutesFromPeriods = function (periods) {
            return _.reduce(periods, function (acc, ap) {
                return acc + ap.getMinutesAvailable();
            }, 0);
        };

        return DayAvailabilityAggregation;

    })(RG.Models.Base);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Models.FilterCategory = (function (superClass) {
        extend(FilterCategory, superClass);

        function FilterCategory() {
            return FilterCategory.__super__.constructor.apply(this, arguments);
        }

        FilterCategory.prototype.initialize = function (options) {
            this.optionGroups = new RG.Collections.OptionGroups;
            return this.optionGroups.category = this;
        };

        FilterCategory.prototype.getName = function () {
            return this.get("name");
        };

        return FilterCategory;

    })(RG.Models.Base);

}).call(this);
;
(function () {
    RG.Models.NullBookingTarget = (function () {
        function NullBookingTarget() { }

        NullBookingTarget.prototype.getTypeDescription = function () {
            return "";
        };

        NullBookingTarget.prototype.getLongCaption = function () {
            return "";
        };

        NullBookingTarget.prototype.getLongDescription = function () {
            return "";
        };

        NullBookingTarget.prototype.getName = function () {
            return "";
        };

        NullBookingTarget.prototype.toString = function () {
            return "";
        };

        return NullBookingTarget;

    })();

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Models.NullDuration = (function (superClass) {
        extend(NullDuration, superClass);

        function NullDuration() {
            return NullDuration.__super__.constructor.apply(this, arguments);
        }

        NullDuration.prototype.getCaption = function () {
            return "";
        };

        NullDuration.prototype.getMinutes = function () {
            return 0;
        };

        NullDuration.prototype.getRepeatCaption = function () {
            return "";
        };

        NullDuration.prototype.getLongRepeatCaption = function () {
            return "";
        };

        NullDuration.prototype.isConfirmed = function () {
            return true;
        };

        return NullDuration;

    })(RG.Models.Base);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Models.Project = (function (superClass) {
        var ZERO_WIDTH_SPACE;

        extend(Project, superClass);

        function Project() {
            return Project.__super__.constructor.apply(this, arguments);
        }

        ZERO_WIDTH_SPACE = "\u200B";

        Project.prototype.getTypeDescription = function () {
            return "Project";
        };

        Project.prototype.getLongDescription = function () {
            var caption;
            caption = this.getNameWithProjectCode();
            if (this.get('client') != null) {
                caption = caption + (" (" + (this.escape('client')) + ")");
            }
            return caption;
        };

        Project.prototype.getName = function () {
            return this.escape('name');
        };

        Project.prototype.getProjectCode = function () {
            if (this.get('project_code')) {
                return " (" + ZERO_WIDTH_SPACE + this.escape('project_code') + ZERO_WIDTH_SPACE + ")";
            } else {
                return "";
            }
        };

        Project.prototype.getClientName = function () {
            return this.get('client') && this.get('client').getName();
        };

        Project.prototype.getNameWithProjectCode = function () {
            return this.getName() + this.getProjectCode();
        };

        Project.prototype.isBillableByDefault = function () {
            return this.get('default_billable');
        };

        Project.prototype.getLongCaption = function () {
            var caption;
            caption = this.getNameWithProjectCode();
            if (this.get('client') != null) {
                caption = caption + "<br>" + this.get('client');
            }
            return caption;
        };

        Project.prototype.toString = function (type) {
            var name;
            name = type === 'short' ? this.getName() : this.getName() + this.getProjectCode();
            if (this.get('client') != null) {
                return name + " | " + this.get('client');
            } else {
                return name;
            }
        };

        return Project;

    })(RG.Models.Base);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Models.SavedFilter = (function (superClass) {
        extend(SavedFilter, superClass);

        function SavedFilter() {
            return SavedFilter.__super__.constructor.apply(this, arguments);
        }

        SavedFilter.prototype.urlRoot = function () {
            return (RG.getApiRoot()) + "/saved_filters";
        };

        SavedFilter.prototype.getFilter = function () {
            return JSON.parse(this.get("filter_json"));
        };

        return SavedFilter;

    })(Backbone.Model);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Models.VaryingAvailablePeriod = (function (superClass) {
        extend(VaryingAvailablePeriod, superClass);

        function VaryingAvailablePeriod() {
            return VaryingAvailablePeriod.__super__.constructor.apply(this, arguments);
        }

        VaryingAvailablePeriod.prototype.toString = function () {
            return 'Availability varies';
        };

        VaryingAvailablePeriod.prototype.isEditable = function () {
            return false;
        };

        return VaryingAvailablePeriod;

    })(Backbone.Model);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Collections.Base = (function (superClass) {
        extend(Base, superClass);

        function Base(models, options) {
            if (options) {
                this.model = options.model;
            }
            this._reset();
            this.initialize.apply(this, arguments);
            if (models) {
                this.reset(models, {
                    silent: true
                });
            }
        }

        Base.prototype.setModels = function (array) {
            return this.reset(array);
        };

        return Base;

    })(Backbone.Collection);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Collections.AbstractTimePeriods = (function (superClass) {
        extend(AbstractTimePeriods, superClass);

        function AbstractTimePeriods() {
            return AbstractTimePeriods.__super__.constructor.apply(this, arguments);
        }

        AbstractTimePeriods.prototype.calculator = function () {
            return this.calc != null ? this.calc : this.calc = new RG.Utils.TimePeriodsCalculator(this);
        };

        AbstractTimePeriods.prototype.getMinutesAvailableInDateRange = function (dateRange) {
            return this.calculator().availableMinutes(dateRange);
        };

        AbstractTimePeriods.prototype.removeForDate = function (date) {
            throw "Implement removeForDate in subclasses";
        };

        return AbstractTimePeriods;

    })(RG.Collections.Base);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Collections.AvailablePeriods = (function (superClass) {
        extend(AvailablePeriods, superClass);

        function AvailablePeriods() {
            return AvailablePeriods.__super__.constructor.apply(this, arguments);
        }

        return AvailablePeriods;

    })(RG.Collections.AbstractTimePeriods);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Collections.Bookers = (function (superClass) {
        extend(Bookers, superClass);

        function Bookers() {
            return Bookers.__super__.constructor.apply(this, arguments);
        }

        Bookers.prototype.comparator = function (b) {
            return b.get('name');
        };

        return Bookers;

    })(Backbone.Collection);

}).call(this);
;
(function () {
    var bind = function (fn, me) { return function () { return fn.apply(me, arguments); }; },
        extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Collections.Bookings = (function (superClass) {
        extend(Bookings, superClass);

        function Bookings() {
            this.predictWaitingList = bind(this.predictWaitingList, this);
            return Bookings.__super__.constructor.apply(this, arguments);
        }

        Bookings.prototype.initialize = function (options) {
            Bookings.__super__.initialize.apply(this, arguments);
            this._forDateDurations = {};
            this._overlapsDateBookings = {};
            return this.on('add remove reset change', (function (_this) {
                return function () {
                    _this._forDateDurations = {};
                    return _this._overlapsDateBookings = {};
                };
            })(this));
        };

        Bookings.prototype.forDate = function (date) {
            var booking, bookings, dateRange, i, len, ref;
            bookings = [];
            ref = this.models;
            for (i = 0, len = ref.length; i < len; i++) {
                booking = ref[i];
                dateRange = booking.getDateRange();
                if (dateRange.isValid() && dateRange.includes(date)) {
                    bookings.push(booking);
                }
            }
            return bookings;
        };

        Bookings.prototype.startsOnDate = function (date) {
            var booking, bookings, i, len, ref;
            bookings = [];
            ref = this.forDate(date);
            for (i = 0, len = ref.length; i < len; i++) {
                booking = ref[i];
                if (RG.Utils.DateComparator.equalsYMD(date, booking.getDateRange().startDate)) {
                    bookings.push(booking);
                }
            }
            return bookings;
        };

        Bookings.prototype.overlapsDate = function (date) {
            var key;
            key = date.toString();
            if (this._overlapsDateBookings[key]) {
                return this._overlapsDateBookings[key];
            }
            return this._overlapsDateBookings[key] = this.filter(function (booking) {
                var dateRange;
                dateRange = booking.getDateRange();
                return dateRange.startDate < date && dateRange.endDate >= date;
            });
        };

        Bookings.prototype.getDurationsForDate = function (date) {
            var b, bookings, d, durations, i, j, key, len, len1, ref;
            key = date.getTime();
            if (this._forDateDurations[key]) {
                return this._forDateDurations[key];
            }
            bookings = this.forDate(date);
            durations = [];
            for (i = 0, len = bookings.length; i < len; i++) {
                b = bookings[i];
                ref = b.durations.models;
                for (j = 0, len1 = ref.length; j < len1; j++) {
                    d = ref[j];
                    if (RG.Utils.DateComparator.equalsYMD(d.attributes.date, date)) {
                        durations.push(d);
                    }
                }
            }
            return this._forDateDurations[key] = durations;
        };

        Bookings.prototype.predictWaitingList = function () {
            this.models.forEach((function (_this) {
                return function (b) {
                    return RG.renderer.enqueue(new RG.Renderer.ResourceDateLock(_this.resource, b.getStartDate(), b.getEndDate()), function () {
                        return b.durations.predictWaitingList();
                    });
                };
            })(this));
            return RG.resizeCards();
        };

        Bookings.prototype.getLayerCount = function () {
            var layer;
            layer = this.map(function (b) {
                return b.layer;
            }).max();
            if (layer >= 0) {
                return layer + 1;
            } else {
                return 0;
            }
        };

        return Bookings;

    })(RG.Collections.Base);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Collections.CustomAvailablePeriods = (function (superClass) {
        extend(CustomAvailablePeriods, superClass);

        function CustomAvailablePeriods() {
            return CustomAvailablePeriods.__super__.constructor.apply(this, arguments);
        }

        CustomAvailablePeriods.prototype.removeForDate = function (date) {
            var models;
            models = this.select((function (_this) {
                return function (cap) {
                    return RG.Utils.DateComparator.equalsYMD(cap.get('date'), date);
                };
            })(this));
            return this.remove(models, {
                silent: true
            });
        };

        return CustomAvailablePeriods;

    })(RG.Collections.AbstractTimePeriods);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Collections.CustomFieldOptions = (function (superClass) {
        extend(CustomFieldOptions, superClass);

        function CustomFieldOptions() {
            return CustomFieldOptions.__super__.constructor.apply(this, arguments);
        }

        return CustomFieldOptions;

    })(Backbone.Collection);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Collections.CustomFields = (function (superClass) {
        extend(CustomFields, superClass);

        function CustomFields() {
            return CustomFields.__super__.constructor.apply(this, arguments);
        }

        return CustomFields;

    })(Backbone.Collection);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Collections.DowntimeTypes = (function (superClass) {
        extend(DowntimeTypes, superClass);

        function DowntimeTypes() {
            return DowntimeTypes.__super__.constructor.apply(this, arguments);
        }

        DowntimeTypes.prototype.model = RG.Models.DowntimeType;

        return DowntimeTypes;

    })(Backbone.Collection);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Collections.Downtimes = (function (superClass) {
        extend(Downtimes, superClass);

        function Downtimes() {
            return Downtimes.__super__.constructor.apply(this, arguments);
        }

        Downtimes.prototype.model = RG.Models.Downtime;

        Downtimes.prototype.initialize = function (options) {
            Downtimes.__super__.initialize.apply(this, arguments);
            this._forDateDowntimes = {};
            this._overlapsDateDowntimes = {};
            this._forResourceIndex = {};
            this._forDateInTimeZoneIndex = {};
            this.on('add remove reset change', (function (_this) {
                return function () {
                    _this._forDateDowntimes = {};
                    _this._overlapsDateDowntimes = {};
                    _this._forResourceIndex = {};
                    return _this._forDateInTimeZoneIndex = {};
                };
            })(this));
            this.on('add', function (d) {
                var i, len, ref, results, rid;
                if (d && d.get('resourceIds')) {
                    ref = d.get('resourceIds');
                    results = [];
                    for (i = 0, len = ref.length; i < len; i++) {
                        rid = ref[i];
                        results.push(this.trigger("add:resource_id:" + rid, d));
                    }
                    return results;
                }
            });
            return this.on('remove', function (d) {
                var i, len, ref, results, rid;
                if (d && d.get('resourceIds')) {
                    ref = d.get('resourceIds');
                    results = [];
                    for (i = 0, len = ref.length; i < len; i++) {
                        rid = ref[i];
                        results.push(this.trigger("remove:resource_id:" + rid, d));
                    }
                    return results;
                }
            });
        };

        Downtimes.prototype.forResource = function (resource) {
            var base, name;
            return (base = this._forResourceIndex)[name = resource.id] != null ? base[name] : base[name] = this.models.filter(function (downtime) {
                return downtime.get('resourceIds').indexOf(resource.id) !== -1;
            });
        };

        Downtimes.prototype.forYear = function (year) {
            return this.models.filter(function (downtime) {
                return downtime.inYear(year);
            });
        };

        Downtimes.prototype.forDate = function (date) {
            var key;
            key = date.toString();
            if (this._forDateDowntimes[key]) {
                return this._forDateDowntimes[key];
            }
            return this._forDateDowntimes[key] = this.models.filter(function (downtime) {
                return downtime.isValidOn(date);
            });
        };

        Downtimes.prototype.inTimeZone = function (timeZone) {
            var collection, downtimes;
            downtimes = this.models.map(function (downtime) {
                return downtime.inTimeZone(timeZone);
            });
            collection = new RG.Collections.Downtimes;
            collection.models = downtimes;
            collection.length = downtimes.length;
            return collection;
        };

        Downtimes.prototype.forDateInTimeZone = function (date, timeZone) {
            var base, name, offset;
            offset = (timeZone != null ? timeZone.attributes.offset : void 0) || -1;
            return (base = this._forDateInTimeZoneIndex)[name = [date.valueOf(), offset]] != null ? base[name] : base[name] = this.models.filter(function (downtime) {
                return downtime.inTimeZone(timeZone).isValidOn(date);
            });
        };

        Downtimes.prototype.durationsForDateInTimeZone = function (date, timeZone) {
            var downtime, duration, durations, i, j, len, len1, ref, ref1;
            durations = [];
            ref = this.forDateInTimeZone(date, timeZone);
            for (i = 0, len = ref.length; i < len; i++) {
                downtime = ref[i];
                ref1 = downtime.inTimeZone(timeZone).getDurations(downtime);
                for (j = 0, len1 = ref1.length; j < len1; j++) {
                    duration = ref1[j];
                    if (duration.containsDate(date)) {
                        durations.push(duration);
                    }
                }
            }
            return durations;
        };

        Downtimes.prototype.startsOnDateInTimeZone = function (date, timeZone) {
            var downtime, downtimes, i, len, ref;
            downtimes = [];
            ref = this.forDateInTimeZone(date, timeZone);
            for (i = 0, len = ref.length; i < len; i++) {
                downtime = ref[i];
                if (RG.Utils.DateComparator.equalsYMD(date, downtime.inTimeZone(timeZone).getDateRange().startDate)) {
                    downtimes.push(downtime);
                }
            }
            return downtimes;
        };

        Downtimes.prototype.startsOnDate = function (date) {
            var downtime, downtimes, i, len, ref;
            downtimes = [];
            ref = this.forDate(date);
            for (i = 0, len = ref.length; i < len; i++) {
                downtime = ref[i];
                if (RG.Utils.DateComparator.equalsYMD(date, downtime.getDateRange().startDate)) {
                    downtimes.push(downtime);
                }
            }
            return downtimes;
        };

        Downtimes.prototype.overlapsDateInTimeZone = function (date, timeZone) {
            var key;
            key = date.toString();
            if (this._overlapsDateDowntimes[key]) {
                return this._overlapsDateDowntimes[key];
            }
            return this._overlapsDateDowntimes[key] = this.filter(function (downtime) {
                var dateRange;
                dateRange = downtime.inTimeZone(timeZone).getDateRange();
                return dateRange.startDate < date && dateRange.endDate >= date;
            });
        };

        Downtimes.prototype.mergedTimeRangesForDate = function (date) {
            var timeRange, timeRanges;
            timeRanges = this.inTimeZone(this.resource.get('timeZone')).forDate(date).map(function (downtime) {
                return downtime.getTimeRange(date);
            });
            if (timeRanges.length < 2) {
                return timeRanges;
            }
            timeRange = timeRanges.pop();
            return timeRange.merge.apply(timeRange, timeRanges);
        };

        return Downtimes;

    })(RG.Collections.Base);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Collections.FilterOptions = (function (superClass) {
        extend(FilterOptions, superClass);

        function FilterOptions() {
            return FilterOptions.__super__.constructor.apply(this, arguments);
        }

        return FilterOptions;

    })(Backbone.Collection);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Collections.Overtimes = (function (superClass) {
        extend(Overtimes, superClass);

        function Overtimes() {
            return Overtimes.__super__.constructor.apply(this, arguments);
        }

        Overtimes.prototype.removeForDate = function (date) {
            var overtimes;
            overtimes = this.select(function (overtime) {
                return RG.Utils.DateComparator.equalsYMD(overtime.get('date'), date);
            });
            return this.remove(overtimes, {
                silent: true
            });
        };

        return Overtimes;

    })(RG.Collections.AbstractTimePeriods);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Collections.ResourceInstances = (function (superClass) {
        extend(ResourceInstances, superClass);

        function ResourceInstances() {
            return ResourceInstances.__super__.constructor.apply(this, arguments);
        }

        ResourceInstances.prototype.model = RG.Models.ResourceInstance;

        ResourceInstances.prototype.comparator = function (a, b) {
            var left, localeOptions, right;
            left = a.get('name') || '';
            right = b.get('name') || '';
            localeOptions = {
                sensitivity: 'base',
                numeric: true
            };
            return left.localeCompare(right, 'en', localeOptions);
        };

        ResourceInstances.prototype.setVisibleResources = function (resources) {
            this.models.forEach(function (ri) {
                return ri.visible = false;
            });
            resources.forEach(function (ri) {
                return ri.visible = true;
            });
            return this.trigger('change:visible');
        };

        return ResourceInstances;

    })(RG.Collections.Base);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Collections.ResourceTypes = (function (superClass) {
        extend(ResourceTypes, superClass);

        function ResourceTypes() {
            return ResourceTypes.__super__.constructor.apply(this, arguments);
        }

        return ResourceTypes;

    })(Backbone.Collection);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Collections.TimeZones = (function (superClass) {
        extend(TimeZones, superClass);

        function TimeZones() {
            return TimeZones.__super__.constructor.apply(this, arguments);
        }

        TimeZones.prototype.model = RG.Models.TimeZone;

        return TimeZones;

    })(Backbone.Collection);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Collections.Clients = (function (superClass) {
        extend(Clients, superClass);

        function Clients() {
            return Clients.__super__.constructor.apply(this, arguments);
        }

        Clients.prototype.comparator = function (c) {
            return c.toString().toLowerCase();
        };

        return Clients;

    })(Backbone.Collection);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Collections.DayAvailabilityAggregations = (function (superClass) {
        extend(DayAvailabilityAggregations, superClass);

        function DayAvailabilityAggregations() {
            return DayAvailabilityAggregations.__super__.constructor.apply(this, arguments);
        }

        DayAvailabilityAggregations.prototype.comparator = function (agg) {
            return agg.get('weekDay') || 2e308;
        };

        return DayAvailabilityAggregations;

    })(Backbone.Collection);

}).call(this);
;
(function () {
    var bind = function (fn, me) { return function () { return fn.apply(me, arguments); }; },
        extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Collections.Durations = (function (superClass) {
        extend(Durations, superClass);

        function Durations(options) {
            this.predictWaitingList = bind(this.predictWaitingList, this);
            Durations.__super__.constructor.apply(this, arguments);
            this._betweenDates = {};
            this.on('add remove reset change', (function (_this) {
                return function (ignore) {
                    var ref;
                    if (ignore === true) {
                        return;
                    }
                    _this._betweenDates = {};
                    if (_this.booking && !_this.booking.transient) {
                        if ((ref = _this.booking.collection) != null) {
                            ref.trigger('reset');
                        }
                    }
                };
            })(this));
            return;
        }

        Durations.prototype.forDate = function (date) {
            return this.filter(function (duration) {
                return RG.Utils.DateComparator.equalsYMD(duration.get("date"), date);
            });
        };

        Durations.prototype.betweenDates = function (startDate, endDate) {
            var durations, key, minutes, newerDate, olderDate;
            key = new RG.Utils.DateRange(startDate, endDate).toString();
            if (this._betweenDates[key]) {
                return this._betweenDates[key];
            }
            olderDate = false;
            newerDate = false;
            minutes = null;
            durations = this.filter(function (d) {
                if (!minutes) {
                    minutes = d.attributes.minutes;
                }
                if (!olderDate) {
                    olderDate = d.attributes.date < startDate;
                }
                if (!newerDate) {
                    newerDate = d.attributes.date > endDate;
                }
                return d.attributes.date >= startDate && d.attributes.date <= endDate;
            });
            if (durations.length === 0 && olderDate && newerDate) {
                durations = [this._anchorDuration(startDate, minutes), this._anchorDuration(endDate, minutes)];
            }
            return this._betweenDates[key] = durations;
        };

        Durations.prototype.setColor = function (color) {
            this.each(function (d) {
                return d.set({
                    color: color
                });
            });
        };

        Durations.prototype.predictWaitingList = function () {
            this.each(function (d) {
                return d.predictWaitingList();
            });
            return this.trigger('change', true);
        };

        Durations.prototype._anchorDuration = function (date, minutes) {
            var duration;
            duration = new RG.Models.Duration({
                minutes: 0,
                date: date,
                waiting: false
            });
            duration.transient = true;
            duration.realMinutes = minutes;
            duration.collection = this;
            return duration;
        };

        return Durations;

    })(RG.Collections.Base);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Collections.FilterCategories = (function (superClass) {
        extend(FilterCategories, superClass);

        function FilterCategories() {
            return FilterCategories.__super__.constructor.apply(this, arguments);
        }

        return FilterCategories;

    })(Backbone.Collection);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Collections.OptionGroups = (function (superClass) {
        extend(OptionGroups, superClass);

        function OptionGroups() {
            return OptionGroups.__super__.constructor.apply(this, arguments);
        }

        return OptionGroups;

    })(Backbone.Collection);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Collections.Projects = (function (superClass) {
        extend(Projects, superClass);

        function Projects() {
            return Projects.__super__.constructor.apply(this, arguments);
        }

        Projects.prototype.comparator = function (p) {
            return p.toString().toLowerCase();
        };

        return Projects;

    })(Backbone.Collection);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Collections.ResourceAvailabilityYears = (function (superClass) {
        extend(ResourceAvailabilityYears, superClass);

        function ResourceAvailabilityYears() {
            return ResourceAvailabilityYears.__super__.constructor.apply(this, arguments);
        }

        ResourceAvailabilityYears.prototype.model = RG.Models.ResourceAvailabilityYear;

        ResourceAvailabilityYears.prototype.totalUsedDays = function () {
            return _.reduce(this.models, function (memo, year) {
                return year.get('numberOfUsedDays');
            }, 0);
        };

        return ResourceAvailabilityYears;

    })(Backbone.Collection);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Collections.SavedFilters = (function (superClass) {
        extend(SavedFilters, superClass);

        function SavedFilters() {
            return SavedFilters.__super__.constructor.apply(this, arguments);
        }

        SavedFilters.prototype.comparator = function (sf) {
            var ref;
            return (ref = sf.get('name')) != null ? ref.toLowerCase() : void 0;
        };

        SavedFilters.prototype.initialize = function () {
            SavedFilters.__super__.initialize.apply(this, arguments);
            this.on("change:name", (function (_this) {
                return function () {
                    return _this.sort();
                };
            })(this));
        };

        return SavedFilters;

    })(Backbone.Collection);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Collections.UnitDurations = (function (superClass) {
        extend(UnitDurations, superClass);

        function UnitDurations() {
            return UnitDurations.__super__.constructor.apply(this, arguments);
        }

        UnitDurations.prototype.setColor = function (color) {
            var i, len, ref, ud;
            ref = this.models;
            for (i = 0, len = ref.length; i < len; i++) {
                ud = ref[i];
                ud.set({
                    color: color
                });
            }
        };

        return UnitDurations;

    })(Backbone.Collection);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Collections.UnitGroupings = (function (superClass) {
        extend(UnitGroupings, superClass);

        function UnitGroupings() {
            return UnitGroupings.__super__.constructor.apply(this, arguments);
        }

        UnitGroupings.prototype.initialize = function () {
            this.on('add', this.addToUnitCollection);
            this.on('remove', this.removeFromUnitCollection);
        };

        UnitGroupings.prototype.comparator = function (pg) {
            return pg.dateRange.startDate;
        };

        UnitGroupings.prototype.getUnitCollection = function () {
            var subUnits, units;
            if (this._units != null) {
                return this._units;
            }
            units = new RG.Collections.Units();
            subUnits = _.flatten(_.map(this.models, function (pg) {
                return pg.getUnits().models;
            }));
            units.reset(subUnits);
            return this._units = units;
        };

        UnitGroupings.prototype.addToUnitCollection = function (group) {
            var units;
            units = group.getUnits();
            if (this.getUnitCollection().models.length && units.models[0].date < this.getUnitCollection().models[0].date) {
                return this._eachUnitReverse(group, (function (_this) {
                    return function (unit) {
                        return _this.getUnitCollection().unshift(unit);
                    };
                })(this));
            } else {
                return this._eachUnit(group, (function (_this) {
                    return function (unit) {
                        return _this.getUnitCollection().add(unit);
                    };
                })(this));
            }
        };

        UnitGroupings.prototype.removeFromUnitCollection = function (group) {
            this._eachUnit(group, (function (_this) {
                return function (unit) {
                    _this.getUnitCollection().remove(unit);
                };
            })(this));
        };

        UnitGroupings.prototype._eachUnit = function (group, func) {
            group.getUnits().each(func);
        };

        UnitGroupings.prototype._eachUnitReverse = function (group, func) {
            var i, j, ref, units;
            units = group.getUnits().models;
            for (i = j = ref = units.length - 1; ref <= 0 ? j <= 0 : j >= 0; i = ref <= 0 ? ++j : --j) {
                func(units[i]);
            }
        };

        return UnitGroupings;

    })(Backbone.Collection);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Collections.Units = (function (superClass) {
        extend(Units, superClass);

        function Units() {
            return Units.__super__.constructor.apply(this, arguments);
        }

        Units.prototype.initialize = function () {
            this.on('add', this.notifyAppendOrPrepend);
        };

        Units.prototype.notifyAppendOrPrepend = function (model, collection, options) {
            if (this.models.length > 1 && model === this.models[0]) {
                this.trigger('prepend', model, collection, options);
            } else {
                this.trigger('append', model, collection, options);
            }
        };

        return Units;

    })(Backbone.Collection);

}).call(this);
;
(function () {
    RG.Utils.BookingCommandFactory = (function () {
        function BookingCommandFactory() { }

        BookingCommandFactory.prototype.createDragBookingCommand = function (resource, booking, originalResource, originalDurations, newDurations, dates, bookingDuration, originalAttributes, rendererLock) {
            var command;
            booking.set({
                startDate: dates[0],
                endDate: dates[dates.length - 1],
                saving: true
            });
            booking.durations.reset(newDurations);
            originalResource.bookings.remove(booking);
            resource.bookings.add(booking);
            originalResource.bookings.trigger('add');
            command = new RG.Commands.UpdateBookingCommand({
                booking: booking,
                resource: resource,
                startDate: dates[0],
                endDate: dates[dates.length - 1],
                bookingDuration: bookingDuration,
                successCallback: (function (_this) {
                    return function (data) {
                        var duration, i, len, ref, responseDuration;
                        $(".resources--cal-unit.drag-drop-target").removeClass("drag-drop-target");
                        booking.set({
                            startDate: RG.Utils.BookingMerger.getDateFromStr(data.start_date),
                            endDate: RG.Utils.BookingMerger.getDateFromStr(data.end_date),
                            refreshable: data.refreshable,
                            saving: false
                        });
                        ref = booking.durations.models;
                        for (i = 0, len = ref.length; i < len; i++) {
                            duration = ref[i];
                            responseDuration = _.find(data.durations, function (d) {
                                return d.date === RG.Utils.DateFormatter.getISODate(duration.get('date'));
                            });
                            if (responseDuration) {
                                duration.set({
                                    waiting: responseDuration.waiting
                                });
                            }
                        }
                        window.update();
                        RG.renderer.unlock(rendererLock);
                    };
                })(this)
            });
            command.removedDatesCallback = (function (_this) {
                return function (removedDates, callback) {
                    var removedDatesDialog;
                    removedDatesDialog = new RG.Views.Dialogs.RemovedAvailabilityDates({
                        resource: resource,
                        removedAvailabilityDates: removedDates
                    });
                    return _this._waitingPopover(resource, new Date(removedDates[0]), removedDatesDialog, callback);
                };
            })(this);
            command.waitingCallback = (function (_this) {
                return function (waitingDates) {
                    var waitingConfirmation;
                    waitingConfirmation = new RG.Views.Dialogs.WaitingListConfirmation({
                        resource: resource,
                        waitingDates: waitingDates,
                        duration: newDurations[0].getMinutes(),
                        startTime: newDurations[0].get('startTime'),
                        startDate: dates[0],
                        endDate: dates[dates.length - 1],
                        cancelCallback: function () {
                            booking.set(originalAttributes);
                            booking.durations.reset(originalDurations);
                            resource.bookings.remove(booking);
                            originalResource.bookings.add(booking);
                            resource.predictWaitingList();
                            if (originalResource !== resource) {
                                originalResource.predictWaitingList();
                            }
                            RG.renderer.unlock(rendererLock);
                        },
                        callback: function () {
                            var duration, i, len, ref;
                            ref = booking.durations.models;
                            for (i = 0, len = ref.length; i < len; i++) {
                                duration = ref[i];
                                if (waitingDates.indexOf(RG.Utils.DateFormatter.getISODate(duration.get('date'))) > -1) {
                                    duration.set({
                                        waiting: true
                                    });
                                }
                            }
                            command.forceWaiting = true;
                            command.execute();
                        }
                    });
                    _this._waitingPopover(resource, new Date(waitingDates[0]), waitingConfirmation);
                };
            })(this);
            command.archivedCallback = function (data) {
                RG.Utils.BookingService.reset(data, resource, booking, originalAttributes, originalDurations);
                resource.bookings.remove(booking);
                originalResource.bookings.add(booking);
            };
            return command;
        };

        BookingCommandFactory.prototype.createCopyBookingCommand = function (resource, booking, originalResource, originalDurations, newDurations, dates, bookingDuration, originalAttributes, rendererLock) {
            var command, dateRange, newBooking;
            newBooking = booking.clone();
            newBooking.set({
                id: null,
                startDate: dates[0],
                endDate: dates[dates.length - 1],
                saving: true
            });
            newBooking.durations.reset(newDurations);
            resource.bookings.add(newBooking);
            dateRange = new RG.Utils.DateRange(dates[0], dates[dates.length - 1]);
            bookingDuration = new RG.DTO.BookingDuration({
                startTime: newDurations[0].get('startTime'),
                duration: newDurations[0].getMinutes()
            });
            command = new RG.Commands.CreateBookingCommand({
                resource: resource,
                booker: booking.get('booker'),
                dateRange: dateRange,
                target: booking.getBookingTarget(),
                details: booking.get('notes'),
                bookingDuration: bookingDuration,
                billable: booking.get('billable'),
                successCallback: (function (_this) {
                    return function (data) {
                        newBooking.set({
                            id: data.id,
                            saving: false
                        });
                        RG.renderer.unlock(rendererLock);
                        window.update();
                    };
                })(this)
            });
            command.removedDatesCallback = (function (_this) {
                return function (removedDates, callback) {
                    var removedDatesDialog;
                    removedDatesDialog = new RG.Views.Dialogs.RemovedAvailabilityDates({
                        resource: resource,
                        removedAvailabilityDates: removedDates
                    });
                    return _this._waitingPopover(resource, new Date(removedDates[0]), removedDatesDialog, callback);
                };
            })(this);
            command.waitingCallback = (function (_this) {
                return function (waitingDates) {
                    var waitingConfirmation;
                    waitingConfirmation = new RG.Views.Dialogs.WaitingListConfirmation({
                        resource: resource,
                        waitingDates: waitingDates,
                        duration: newDurations[0].getMinutes(),
                        startTime: newDurations[0].get('startTime'),
                        startDate: dates[0],
                        endDate: dates[dates.length - 1],
                        cancelCallback: function () {
                            resource.bookings.remove(newBooking);
                            RG.renderer.unlock(rendererLock);
                        },
                        callback: function () {
                            var duration, i, len, ref;
                            ref = newBooking.durations.models;
                            for (i = 0, len = ref.length; i < len; i++) {
                                duration = ref[i];
                                if (waitingDates.indexOf(RG.Utils.DateFormatter.getISODate(duration.get('date'))) > -1) {
                                    duration.set({
                                        waiting: true
                                    });
                                }
                            }
                            command.forceWaiting = true;
                            command.execute();
                        }
                    });
                    _this._waitingPopover(resource, new Date(waitingDates[0]), waitingConfirmation);
                };
            })(this);
            command.archivedCallback = function (data) {
                RG.Utils.BookingService.reset(data, resource, newBooking, originalAttributes, originalDurations);
                resource.bookings.remove(newBooking);
            };
            return command;
        };

        BookingCommandFactory.prototype._waitingPopover = function (resource, date, waitingConfirmation, callback) {
            var placer, popover;
            if (callback == null) {
                callback = waitingConfirmation.cancelCallback;
            }
            placer = new RG.Utils.DatePopoverPlacer(resource, date);
            popover = new RG.Views.Dialogs.BookingClashPopover({
                removeAttachTo: true,
                attachTo: placer.createAnchor({
                    className: 'booking-clash-popover-anchor'
                }),
                body: waitingConfirmation,
                className: 'edit-booking-dropdown booking-clash-management-popover'
            });
            RG.Popovers.replace({
                popoverView: popover,
                removeCallback: callback
            });
        };

        return BookingCommandFactory;

    })();

}).call(this);
;
(function () {
    RG.Commands.CreateBookingCommand = (function () {
        function CreateBookingCommand(options) {
            this.account = options.account || RG.Utils.getCurrentAccount();
            this.resource = options.resource;
            this.booker = options.booker;
            this.dateRange = options.dateRange;
            this.target = options.target;
            this.billable = options.billable;
            this.details = options.details;
            this.bookingDuration = options.bookingDuration;
            this.waitingCallback = options.waitingCallback || function () { };
            this.successCallback = options.successCallback || function () { };
            this.removedDatesCallback = options.waitingCallback || function () { };
            this.errorCallback = options.errorCallback || function () { };
            this.archivedCallback = options.archivedCallback || function () { };
            this.forceWaiting = options.forceWaiting;
        }

        CreateBookingCommand.prototype.execute = function () {
            return Q.Promise((function (_this) {
                return function (resolve, reject, notify) {
                    RG.Utils.BookingDataParser.expirePolls();
                    //$.ajax("/v1/" + (_this.account.getSubdomain()) + "/bookings", {
                    $.ajax("http://localhost/EMRMAPI/bookings/POST", {
                        method: "POST",
                        headers: {
                            "X-CSRF-Token": RG.Utils.getCSRFToken()
                        },
                        data: _this._getParameters(),
                        dataType: 'json',
                        success: function (data) {
                            var data = {
                                "id": 10311639, "client_id": null, "project_id": null, "resource_id": 308777, "notes": "Welcome Message 1", "details": "Welcome Message 1", "start_date": "2017-12-12", "end_date": "2017-12-15", "billable": false,
                                "refreshable": false, "created_at": "2017-12-11T05:14:25.000Z", "updated_at": "2017-12-11T05:14:25.000Z", "booker": { "id": 147899, "name": "Viniston Arockiasamy", "email": "myprivcy2015@gmail.com", "color": null },
                                "durations": [{ "date": "2017-12-12", "duration": 480, "start_time": null, "end_time": null, "waiting": false }, { "date": "2017-12-13", "duration": 480, "start_time": null, "end_time": null, "waiting": false },
                                    { "date": "2017-12-14", "duration": 480, "start_time": null, "end_time": null, "waiting": false }, { "date": "2017-12-15", "duration": 480, "start_time": null, "end_time": null, "waiting": false }],
                                "removed_availability_dates": []
                            }

                            var action;
                            RG.Popovers.done();
                            action = function () {
                                var ref;
                                _this.successCallback(data);
                                if ((ref = data.removed_availability_dates) != null ? ref.length : void 0) {
                                    return setTimeout(function () {
                                        return _this.removedDatesCallback(data.removed_availability_dates, data.id);
                                    }, 0);
                                }
                            };
                            RG.Utils.BookingDataParser.expirePolls();
                            return RG.renderer.renderAfter([
                                {
                                    fn: action,
                                    lock: new RG.Renderer.GlobalLock
                                }
                            ]);
                        },
                        error: function (xhr) {
                            var data, e;
                            data = null;
                            try {
                                data = JSON.parse(xhr.responseText);
                                if (data.waiting) {
                                    _this.waitingCallback(data.waiting_dates);
                                } else {
                                    _this.archivedCallback(data);
                                }
                            } catch (error) {
                                e = error;
                                _this.errorCallback(e, xhr);
                            }
                            return RG.Utils.BookingDataParser.expirePolls();
                        }
                    });
                    return resolve();
                };
            })(this));
        };

        CreateBookingCommand.prototype._getParameters = function () {
            var data;
            data = {
                resource_id: this.resource.id,
                booker_id: this.booker.id,
                start_date: RG.Utils.DateFormatter.getISODate(this.dateRange.startDate),
                end_date: RG.Utils.DateFormatter.getISODate(this.dateRange.endDate),
                billable: this.billable,
                details: this.details,
                duration: this.bookingDuration.duration,
                start_time: this.bookingDuration.startTime,
                allow_waiting: this.forceWaiting
            };
            this._assignProjectOrClient(data);
            return data;
        };

        CreateBookingCommand.prototype._assignProjectOrClient = function (data) {
            if (this.target) {
                if (this.target.constructor === RG.Models.Client) {
                    data.client_id = this.target.id;
                } else if (this.target.constructor === RG.Models.Project) {
                    data.project_id = this.target.id;
                }
            }
        };

        return CreateBookingCommand;

    })();

}).call(this);
;
(function () {
    RG.Commands.CreateDowntimeCommand = (function () {
        function CreateDowntimeCommand(options) {
            this.timeZones = options.timeZones;
            this.account = options.account;
            this.resources = options.resources;
            this.booker = options.booker;
            this.dateTimeRange = options.dateTimeRange;
            this.timeZone = options.timeZone;
            this.details = options.details;
            this.leave = options.leave;
            this.type = options.type;
            this.preExecuteCallback = options.preExecuteCallback || function () { };
            this.successCallback = options.successCallback || function () { };
            this.errorCallback = options.errorCallback || function () { };
            this.dataDateRange = RG.Variables.dataDateRange || this.dateTimeRange.dateRange;
            this.saveErrorCallback = options.saveErrorCallback || function () { };
        }

        CreateDowntimeCommand.prototype.execute = function (options) {
            var callbacks, downtime, params;
            if (options == null) {
                options = {};
            }
            params = this._getParameters();
            if (options["delete"] !== void 0) {
                params.delete_invalid_bookings = options["delete"];
            }
            callbacks = {
                successCallback: this.successCallback,
                errorCallback: this.errorCallback,
                saveErrorCallback: this.saveErrorCallback
            };
            downtime = this._buildDowntime(params);
            this.preExecuteCallback(downtime, this.getClashingBookings(), params.delete_invalid_bookings);
            RG.Utils.DowntimeService.createDowntime(downtime, params, callbacks)["catch"](function (err) {
                console.log(err.message);
            });
        };

        CreateDowntimeCommand.prototype.getClashingBookingsFromServer = function (options) {
            var params, req;
            params = this._getParameters();
            req = $.ajax("/v1/" + (this.account.getSubdomain()) + "/downtimes/clashes", {
                method: "POST",
                headers: {
                    "X-CSRF-Token": RG.Utils.getCSRFToken()
                },
                data: params,
                dataType: 'json',
                success: (function (_this) {
                    return function (data) {
                        var bookings;
                        if (parseInt(data.length, 10) > 0) {
                            bookings = data.map(function (object) {
                                var duration;
                                duration = new RG.Models.Duration(object);
                                return duration.collection = {
                                    collection: {
                                        booking: {
                                            getBooker: function () {
                                                return window.bookers.findWhere({
                                                    id: duration.attributes.booker_id
                                                });
                                            }
                                        }
                                    }
                                };
                            });
                            _this._clashingBookings = bookings;
                            if (typeof options.success === "function") {
                                options.success(bookings);
                            }
                        } else {
                            if (typeof options.fail === "function") {
                                options.fail();
                            }
                        }
                    };
                })(this)
            });
            return req;
        };

        CreateDowntimeCommand.prototype.getClashingBookings = function () {
            var allDurations, availabilityManager, availableMinutes, clashes, confirmedDurations, date, dateRange, dates, downtime, duration, i, j, k, len, len1, len2, ref, resource, timeBooked;
            clashes = [];
            ref = this.resources;
            for (i = 0, len = ref.length; i < len; i++) {
                resource = ref[i];
                availabilityManager = new RG.Utils.AvailabilityManager({
                    resource: resource,
                    availablePeriods: resource.availablePeriods,
                    customAvailablePeriods: resource.customAvailablePeriods,
                    overtimes: resource.overtimes,
                    downtimes: new RG.Collections.Downtimes(resource.downtimes.map(function (downtime) {
                        return downtime.clone();
                    })),
                    timeZone: resource.getTimeZone(),
                    ignoreEvents: true
                });
                downtime = new RG.Models.Downtime({
                    resourcedIds: [resource.id],
                    from: this.dateTimeRange.dateRange.startDate,
                    to: this.dateTimeRange.dateRange.endDate,
                    timeZone: window.timeZones.findWhere({
                        name: this.timeZone
                    }),
                    startTime: this.dateTimeRange.timeRange.startTime,
                    endTime: this.dateTimeRange.timeRange.endTime
                }).inTimeZone(resource.getTimeZone());
                availabilityManager.downtimes.add(downtime);
                dateRange = downtime.getDateRange();
                dates = dateRange.getDates();
                for (j = 0, len1 = dates.length; j < len1; j++) {
                    date = dates[j];
                    allDurations = resource.bookings.getDurationsForDate(date);
                    confirmedDurations = allDurations.filter(function (d) {
                        return d.isConfirmed() && d.getMinutes() > 0;
                    }).sort(function (a, b) {
                        return a.getMinutes() - b.getMinutes();
                    });
                    availableMinutes = availabilityManager.getMinutesAvailableForDate(date);
                    timeBooked = 0;
                    for (k = 0, len2 = confirmedDurations.length; k < len2; k++) {
                        duration = confirmedDurations[k];
                        if ((duration.isFixed() && availabilityManager.intersectsWithDowntime(date, duration.getTimeRange())) || !this._fitsInFirstOrLastDate(duration, dateRange, date, downtime.startTime, downtime.endTime, availableMinutes, timeBooked)) {
                            clashes.push(duration);
                        } else {
                            timeBooked += duration.getMinutes();
                        }
                    }
                }
            }
            return this._clashingBookings = clashes;
        };

        CreateDowntimeCommand.prototype.willTouchBookings = function (options) {
            var clashes;
            if (options == null) {
                options = {};
            }
            this._buildDowntime(this._getParameters());
            if (this.outsideDataDateRange()) {
                this.getClashingBookingsFromServer(options);
            } else {
                clashes = this.getClashingBookings();
                if (clashes.length > 0) {
                    if (typeof options.success === "function") {
                        options.success(clashes);
                    }
                } else {
                    if (typeof options.fail === "function") {
                        options.fail();
                    }
                }
            }
        };

        CreateDowntimeCommand.prototype.outsideDataDateRange = function () {
            return !this.dataDateRange.contains(this.dateTimeRange.dateRange);
        };

        CreateDowntimeCommand.prototype._buildDowntime = function (options) {
            return this.downtime != null ? this.downtime : this.downtime = new RG.Models.Downtime({
                resourceIds: options.resource_ids,
                creatorId: options.creator_id,
                from: this.dateTimeRange.dateRange.startDate,
                to: this.dateTimeRange.dateRange.endDate,
                timeZone: this.timeZones.findWhere({
                    name: options.timezone
                }),
                startTime: options.start_time,
                endTime: options.end_time,
                details: options.details,
                leave: options.leave,
                downtimeType: this.type
            });
        };

        CreateDowntimeCommand.prototype._getParameters = function () {
            return this.params != null ? this.params : this.params = {
                resource_ids: _.map(this.resources, function (r) {
                    return r.id;
                }),
                creator_id: this.booker.id,
                from: RG.Utils.DateFormatter.getISODate(this.dateTimeRange.dateRange.startDate),
                to: RG.Utils.DateFormatter.getISODate(this.dateTimeRange.dateRange.endDate),
                start_time: this.dateTimeRange.timeRange.startTime,
                end_time: this.dateTimeRange.timeRange.endTime,
                details: this.details,
                leave: this.leave,
                timezone: this.timeZone,
                downtime_type_id: this.type ? this.type.id : null
            };
        };

        CreateDowntimeCommand.prototype._fitsInFirstOrLastDate = function (duration, dateRange, date, startTime, endTime, availableMinutes, timeBooked) {
            if (RG.Utils.DateComparator.equalsYMD(date, dateRange.startDate)) {
                return duration.endsBeforeTime(startTime) || timeBooked + duration.getMinutes() <= availableMinutes;
            } else if (RG.Utils.DateComparator.equalsYMD(date, dateRange.endDate)) {
                return duration.startsAfterTime(endTime) || timeBooked + duration.getMinutes() <= availableMinutes;
            } else {
                return false;
            }
        };

        return CreateDowntimeCommand;

    })();

}).call(this);
;
(function () {
    RG.Utils.DowntimeCommandFactory = (function () {
        function DowntimeCommandFactory() { }

        DowntimeCommandFactory.prototype.createUpdateCommand = function (downtime, account, resources, dateTimeRange, realDowntime, rendererLock) {
            return new RG.Commands.UpdateDowntimeCommand({
                downtime: downtime,
                account: account,
                booker: window.bookers.findWhere({
                    id: downtime.get('creatorId')
                }) || window.deletedBookers.findWhere({
                    id: downtime.get('creatorId')
                }) || {
                        id: window.currentUserId
                    },
                resources: resources,
                dateTimeRange: dateTimeRange,
                details: downtime.get('details'),
                timeZones: window.timeZones,
                timeZone: downtime.getTimeZone().getParamValue(),
                type: downtime.getDowntimeType(),
                preExecuteCallback: function (dTime, durations, shouldDelete) {
                    RG.Popovers.done();
                    RG.Popovers.popoverActive = false;
                    RG.Popovers.locked = false;
                },
                successCallback: (function (_this) {
                    return function (dTime) {
                        var action;
                        RG.renderer.unlock(rendererLock);
                        action = function () {
                            realDowntime.set({
                                saving: false
                            });
                            return window.update();
                        };
                        RG.renderer.renderAfter([
                            {
                                fn: action,
                                lock: new RG.Renderer.GlobalLock
                            }
                        ]);
                    };
                })(this)
            });
        };

        DowntimeCommandFactory.prototype.createCommand = function (account, resources, dateTimeRange, newDowntime, rendererLock) {
            return new RG.Commands.CreateDowntimeCommand({
                account: account,
                booker: window.currentUserId,
                resources: resources,
                dateTimeRange: dateTimeRange,
                details: newDowntime.get('details'),
                timeZones: window.timeZones,
                timeZone: newDowntime.getTimeZone().getParamValue(),
                type: newDowntime.getDowntimeType(),
                preExecuteCallback: function (dTime, durations, shouldDelete) {
                    RG.Popovers.locked = false;
                    RG.Popovers.popoverActive = false;
                    RG.Popovers.done();
                },
                successCallback: (function (_this) {
                    return function (dTime) {
                        newDowntime.set({
                            saving: false,
                            id: dTime.id
                        });
                        RG.renderer.unlock(rendererLock);
                        window.update();
                        RG.renderer.unlock(rendererLock);
                    };
                })(this)
            });
        };

        return DowntimeCommandFactory;

    })();

}).call(this);
;
(function () {
    RG.Commands.ResetToNormalAvailabilityCommand = (function () {
        function ResetToNormalAvailabilityCommand(options) {
            this.dates = options.dates;
            this.resourceInstanceId = options.resourceInstanceId;
        }

        ResetToNormalAvailabilityCommand.prototype.execute = function () {
            return Q.Promise((function (_this) {
                return function (resolve, reject, notify) {
                    return $.ajax((RG.getApiRoot()) + "/custom_available_periods/reset", {
                        method: 'DELETE',
                        timeout: 30000,
                        headers: {
                            "X-CSRF-Token": RG.Utils.getCSRFToken()
                        },
                        data: {
                            dates: _this.dates,
                            resource_instance_id: _this.resourceInstanceId
                        },
                        success: function () {
                            return resolve("Availability reset");
                        }
                    });
                };
            })(this));
        };

        return ResetToNormalAvailabilityCommand;

    })();

}).call(this);
;
(function () {
    RG.Commands.UpdateAvailabilityCommand = (function () {
        function UpdateAvailabilityCommand(options) {
            this.account = options.account;
            this.resource = options.resource;
            this.changedDays = options.changedDays;
            this.dateRange = options.dateRange;
            this.forceWaiting = options.forceWaiting;
            this.preExecuteCallback = options.preExecuteCallback || function () { };
            this.successCallback = options.successCallback || function () { };
            this.dataDateRange = RG.Variables.dataDateRange || this.dateRange;
        }

        UpdateAvailabilityCommand.prototype.execute = function (options) {
            var params;
            if (options == null) {
                options = {};
            }
            this.preExecuteCallback(this.getClashingBookings(), options);
            params = this._getParameters();
            if (options["delete"] !== void 0) {
                params.delete_invalid_bookings = options["delete"];
            }
            return $.ajax("/v1/" + (this.account.getSubdomain()) + "/custom_available_periods", {
                contentType: 'application/json',
                method: "POST",
                headers: {
                    "X-CSRF-Token": RG.Utils.getCSRFToken()
                },
                data: JSON.stringify(params),
                dataType: 'json',
                success: (function (_this) {
                    return function (data) {
                        return _this.successCallback(data);
                    };
                })(this)
            });
        };

        UpdateAvailabilityCommand.prototype.getClashingBookingsFromServer = function (options) {
            var params;
            params = this._getParameters();
            return $.ajax("/v1/" + (this.account.getSubdomain()) + "/custom_available_periods/clashes", {
                contentType: 'application/json',
                method: "POST",
                headers: {
                    "X-CSRF-Token": RG.Utils.getCSRFToken()
                },
                data: JSON.stringify(params),
                dataType: 'json',
                success: (function (_this) {
                    return function (data) {
                        if (data.length > 0) {
                            _this._clashingBookings = [];
                            return options.success(data.length);
                        } else {
                            return options.fail();
                        }
                    };
                })(this),
                error: (function (_this) {
                    return function (xhr) {
                        var responseData;
                        return responseData = JSON.parse(xhr.responseText);
                    };
                })(this)
            });
        };

        UpdateAvailabilityCommand.prototype.willTouchBookings = function (options) {
            if (options == null) {
                options = {};
            }
            if (this.outsideDataDateRange()) {
                return this.getClashingBookingsFromServer(options);
            } else {
                if (this.getClashingBookings().length > 0) {
                    return options.success();
                } else {
                    return options.fail();
                }
            }
        };

        UpdateAvailabilityCommand.prototype.outsideDataDateRange = function () {
            return !this.dataDateRange.contains(this.dateRange);
        };

        UpdateAvailabilityCommand.prototype.getClashingBookings = function () {
            var aggregate, allDurations, availableMinutes, clashes, confirmedDurations, date, duration, i, indexedDays, isClash, j, len, len1, ref, ref1, timeBooked;
            if (this._clashingBookings) {
                return this._clashingBookings;
            }
            if (this.changedDays.length === 0) {
                return [];
            }
            indexedDays = _.groupBy(this.changedDays, function (d) {
                return d.get('weekDay');
            });
            clashes = [];
            ref = this.dateRange.getDates();
            for (i = 0, len = ref.length; i < len; i++) {
                date = ref[i];
                aggregate = (ref1 = indexedDays[date.getDay()]) != null ? ref1[0] : void 0;
                if (!aggregate) {
                    continue;
                }
                availableMinutes = aggregate.getCurrentMinutesAvailable();
                allDurations = this.resource.bookings.getDurationsForDate(date);
                confirmedDurations = _.filter(allDurations, function (d) {
                    return d.isConfirmed();
                });
                timeBooked = 0;
                for (j = 0, len1 = confirmedDurations.length; j < len1; j++) {
                    duration = confirmedDurations[j];
                    isClash = false;
                    if (duration.isFixed()) {
                        isClash = !aggregate.getFirstAvailablePeriods().any(function (ap) {
                            return ap.contains(duration.getTimeRange());
                        });
                    }
                    if (isClash || timeBooked + duration.getMinutes() > availableMinutes) {
                        clashes.push(duration);
                    }
                    timeBooked += duration.getMinutes();
                }
            }
            return this._clashingBookings = clashes;
        };

        UpdateAvailabilityCommand.prototype._getParameters = function () {
            var data;
            data = {
                custom_available_periods: {
                    resource_instance_id: this.resource.id,
                    start_date: RG.Utils.DateFormatter.getISODate(this.dateRange.startDate),
                    end_date: RG.Utils.DateFormatter.getISODate(this.dateRange.endDate),
                    days: this._getTimeDaysParameters()
                }
            };
            return data;
        };

        UpdateAvailabilityCommand.prototype._getTimeDaysParameters = function () {
            var dayAggregate, days, i, len, ref, timeBlocks;
            days = {};
            ref = this.changedDays;
            for (i = 0, len = ref.length; i < len; i++) {
                dayAggregate = ref[i];
                timeBlocks = dayAggregate.getFirstAvailablePeriods().map(function (model) {
                    return {
                        start_time: model.get('startTime'),
                        end_time: model.get('endTime')
                    };
                });
                timeBlocks = _.select(timeBlocks, function (tb) {
                    return tb.start_time !== tb.end_time;
                });
                days[dayAggregate.get('weekDay').toString()] = {
                    time_blocks: timeBlocks
                };
            }
            return days;
        };

        return UpdateAvailabilityCommand;

    })();

}).call(this);
;
(function () {
    RG.Commands.UpdateBookingCommand = (function () {
        function UpdateBookingCommand(options) {
            this.account = options.account || RG.Utils.getCurrentAccount();
            this.booking = options.booking;
            this.booker = options.booker;
            this.startDate = options.startDate;
            this.endDate = options.endDate;
            this.resource = options.resource;
            this.target = options.target;
            this.clearTarget = options.clearTarget;
            this.details = options.details;
            this.billable = options.billable;
            this.bookingDuration = options.bookingDuration;
            this.forceWaiting = options.forceWaiting;
            this.waitingCallback = options.waitingCallback || function () { };
            this.removedDatesCallback = options.waitingCallback || function () { };
            this.successCallback = options.successCallback || function () { };
            this.errorCallback = options.errorCallback || function () { };
        }

        UpdateBookingCommand.prototype.execute = function () {
            RG.Utils.BookingDataParser.expirePolls();
            //return $.ajax("/v1/" + (this.account.getSubdomain()) + "/bookings/" + this.booking.id, {
            return $.ajax("http://localhost/EMRMAPI/v1/UpdateBookings/" + this.booking.id, {
                method: "POST",
                data: this._getParameters(),
                dataType: 'json',
                success: (function (_this) {
                    return function (data) {
                        data = { "id": 10308908, "client_id": null, "project_id": 666791, "resource_id": 308774, "notes": "", "details": "", "start_date": "2017-12-20", "end_date": "2017-12-29", "billable": true, "refreshable": false, "created_at": "2017-12-09T11:37:30.000Z", "updated_at": "2017-12-12T05:35:00.000Z", "booker": { "id": 147899, "name": "Viniston Arockiasamy", "email": "myprivcy2015@gmail.com", "color": "#FFB400" }, "durations": [{ "date": "2017-12-20", "duration": 480, "start_time": null, "end_time": null, "waiting": false }, { "date": "2017-12-21", "duration": 480, "start_time": null, "end_time": null, "waiting": false }, { "date": "2017-12-22", "duration": 480, "start_time": null, "end_time": null, "waiting": false }, { "date": "2017-12-25", "duration": 480, "start_time": null, "end_time": null, "waiting": false }, { "date": "2017-12-26", "duration": 480, "start_time": null, "end_time": null, "waiting": false }, { "date": "2017-12-27", "duration": 480, "start_time": null, "end_time": null, "waiting": false }, { "date": "2017-12-28", "duration": 480, "start_time": null, "end_time": null, "waiting": false }, { "date": "2017-12-29", "duration": 480, "start_time": null, "end_time": null, "waiting": false }], "removed_availability_dates": [] }
                        RG.Popovers.locked = false;
                        RG.Popovers.done();
                        _this.successCallback(data);
                        _this.resource.predictWaitingList();
                        if (data.removed_availability_dates.length) {
                            setTimeout(function () {
                                return _this.removedDatesCallback(data.removed_availability_dates);
                            }, 0);
                        }
                        return RG.Utils.BookingDataParser.expirePolls();
                    };
                })(this),
                error: (function (_this) {
                    return function (xhr) {
                        var data, e;
                        data = null;
                        try {
                            data = JSON.parse(xhr.responseText);
                            if (data.waiting) {
                                return _this.waitingCallback(data.waiting_dates);
                            } else {
                                return _this.archivedCallback(data);
                            }
                        } catch (error) {
                            e = error;
                            return _this.errorCallback(e, xhr);
                        }
                    };
                })(this)
            });
        };

        UpdateBookingCommand.prototype._getParameters = function () {
            var data;
            data = {};
            if (this.startDate) {
                data.start_date = RG.Utils.DateFormatter.getISODate(this.startDate);
            }
            if (this.endDate) {
                data.end_date = RG.Utils.DateFormatter.getISODate(this.endDate);
            }
            if (this.booker) {
                data.booker_id = this.booker.id;
            }
            if (this.resource) {
                data.resource_id = this.resource.id;
            }
            if (this.target && !this.clearTarget) {
                if (this.target.constructor === RG.Models.Project) {
                    data.project_id = this.target.id;
                } else if (this.target.constructor === RG.Models.Client) {
                    data.client_id = this.target.id;
                }
            }
            if (this.clearTarget) {
                data.project_id = null;
                data.client_id = null;
            }
            if (typeof this.billable !== "undefined") {
                data.billable = !!this.billable;
            }
            if (this.details || this.details === '') {
                data.details = this.details;
            }
            if (this.bookingDuration) {
                data.duration = this.bookingDuration.duration;
                if (this.bookingDuration.startTime === 0) {
                    data.start_time = 0;
                } else {
                    data.start_time = this.bookingDuration.startTime || null;
                }
                if (data.start_time !== null) {
                    data.start_time = "" + data.start_time;
                }
            }
            if (this.forceWaiting) {
                data.allow_waiting = true;
            }
            return data;
        };

        return UpdateBookingCommand;

    })();

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Commands.UpdateDowntimeCommand = (function (superClass) {
        extend(UpdateDowntimeCommand, superClass);

        function UpdateDowntimeCommand(options) {
            UpdateDowntimeCommand.__super__.constructor.apply(this, arguments);
            this.downtime = options.downtime;
        }

        UpdateDowntimeCommand.prototype.execute = function (options) {
            var params;
            if (options == null) {
                options = {};
            }
            params = this._getParameters();
            if (options["delete"] !== void 0) {
                params.delete_invalid_bookings = options["delete"];
            }
            options = {
                successCallback: this.successCallback,
                errorCallback: this.errorCallback,
                saveErrorCallback: this.saveErrorCallback
            };
            this.preExecuteCallback(this._buildDowntime(params), this.getClashingBookings(), params.delete_invalid_bookings);
            return RG.Utils.DowntimeService.updateDowntime(this.downtime.id, params, options);
        };

        UpdateDowntimeCommand.prototype._buildDowntime = function (options) {
            var ref;
            this.downtime.set({
                resourceIds: options.resource_ids,
                creatorId: options.creator_id,
                from: this.dateTimeRange.dateRange.startDate,
                to: this.dateTimeRange.dateRange.endDate,
                timeZone: this.timeZones.findWhere({
                    name: options.timezone
                }),
                startTime: options.start_time,
                endTime: options.end_time,
                details: options.details,
                leave: options.leave,
                downtimeTypeId: (ref = this.type) != null ? ref.id : void 0,
                downtimeType: this.type
            });
            return this.downtime;
        };

        return UpdateDowntimeCommand;

    })(RG.Commands.CreateDowntimeCommand);

}).call(this);
;
(function () {
    RG.Commands.UpdateNoticeCommand = (function () {
        function UpdateNoticeCommand(options) {
            this.data = {};
            this.data[options.dismissedField] = true;
        }

        UpdateNoticeCommand.prototype.execute = function () {
            return $.ajax("/v1/update_notice", {
                method: "PUT",
                data: this.data,
                dataType: 'json'
            });
        };

        return UpdateNoticeCommand;

    })();

}).call(this);
;
(function () {
    RG.Commands.UpdateOvertimeCommand = (function () {
        function UpdateOvertimeCommand(options) {
            this.account = options.account || RG.Utils.getCurrentAccount();
            this.resource = options.resource;
            this.changedDays = options.changedDays;
            this.dateRange = options.dateRange;
            this.forceWaiting = options.forceWaiting;
            this.successCallback = options.successCallback;
        }

        UpdateOvertimeCommand.prototype.execute = function () {
            RG.Popovers.done();
            return $.ajax("/v1/" + (this.account.getSubdomain()) + "/overtimes", {
                contentType: 'application/json',
                method: "POST",
                headers: {
                    "X-CSRF-Token": RG.Utils.getCSRFToken()
                },
                data: JSON.stringify(this._getParameters()),
                dataType: 'json',
                success: (function (_this) {
                    return function (data) {
                        return typeof _this.successCallback === "function" ? _this.successCallback(data) : void 0;
                    };
                })(this),
                error: (function (_this) {
                    return function (xhr) {
                        var responseData;
                        responseData = JSON.parse(xhr.responseText);
                        return typeof _this.waitingCallback === "function" ? _this.waitingCallback(responseData.waiting_dates) : void 0;
                    };
                })(this)
            });
        };

        UpdateOvertimeCommand.prototype._getParameters = function () {
            var data;
            data = {
                overtimes: {
                    resource_instance_id: this.resource.id,
                    start_date: RG.Utils.DateFormatter.getISODate(this.dateRange.startDate),
                    end_date: RG.Utils.DateFormatter.getISODate(this.dateRange.endDate),
                    days: this._getTimeDaysParameters()
                }
            };
            return data;
        };

        UpdateOvertimeCommand.prototype._getTimeDaysParameters = function () {
            var dayAggregate, days, i, len, ref;
            days = {};
            ref = this.changedDays;
            for (i = 0, len = ref.length; i < len; i++) {
                dayAggregate = ref[i];
                days[dayAggregate.get('weekDay').toString()] = dayAggregate.overtime();
            }
            return days;
        };

        return UpdateOvertimeCommand;

    })();

}).call(this);
;
(function () {
    RG.Controllers.DayUnitGroupings = (function () {
        function DayUnitGroupings(periodGroupings) {
            this.periodGroupings = periodGroupings;
            _.extend(this, Backbone.Events);
            this.htmlElement = document.querySelector("html");
            this.clientWidth = this.htmlElement.clientWidth;
            $(window).on("resize", (function (_this) {
                return function () {
                    return _this.clientWidth = _this.htmlElement.clientWidth;
                };
            })(this));
        }

        DayUnitGroupings.prototype.init = function (startDate, initDate) {
            var endDate, ug;
            this.initialDate = initDate;
            endDate = new Date(startDate.getFullYear(), startDate.getMonth(), startDate.getDate() + 6);
            ug = this._createUnitGroupingFromDates(startDate, endDate);
            this.periodGroupings.add(ug);
        };

        DayUnitGroupings.prototype.append = function (count) {
            var currentEndDate, endDate, i, j, ref, startDate, ug;
            if (count == null) {
                count = 1;
            }
            for (i = j = 1, ref = count; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {
                currentEndDate = this._endDate();
                startDate = new Date(currentEndDate.getFullYear(), currentEndDate.getMonth(), currentEndDate.getDate() + 1);
                endDate = new Date(startDate.getFullYear(), startDate.getMonth(), startDate.getDate() + 6);
                ug = this._createUnitGroupingFromDates(startDate, endDate);
                this.periodGroupings.add(ug);
            }
            while (this.periodGroupings.length > this._screenWidthPeriods()) {
                this.periodGroupings.remove(this.periodGroupings.models[0]);
            }
            this.updateUI();
            this.trigger('append');
        };

        DayUnitGroupings.prototype.prepend = function (count) {
            var currentStartDate, endDate, i, j, ref, startDate, ug;
            if (count == null) {
                count = 1;
            }
            for (i = j = 1, ref = count; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {
                currentStartDate = this._startDate();
                endDate = new Date(currentStartDate.getFullYear(), currentStartDate.getMonth(), currentStartDate.getDate() - 1);
                startDate = new Date(endDate.getFullYear(), endDate.getMonth(), endDate.getDate() - 6);
                ug = this._createUnitGroupingFromDates(startDate, endDate);
                this.periodGroupings.unshift(ug);
            }
            while (this.periodGroupings.length > this._screenWidthPeriods()) {
                this.periodGroupings.remove(this.periodGroupings.models[this._screenWidthPeriods()]);
            }
            this.updateUI();
            this.trigger('prepend');
        };

        DayUnitGroupings.prototype.scrollToDate = function (date) {
            var currentResource;
            currentResource = RG.getCurrentResource();
            if (currentResource) {
                window.rgStorage.set('lastResourceId', currentResource.id);
            }
            window.rgStorage.set('filterBarWasCollapsed', !$("nav ul.filters").hasClass("open"));
            $("#loader").show();
            $("#calendar").hide();
            setTimeout(function () {
                date = RG.Utils.DateFormatter.getISODate(date);
                window.location.hash = date;
                window.location.reload();
            }, 300);
            return true;
        };

        DayUnitGroupings.prototype.triggerChange = function () {
            this.periodGroupings.getUnitCollection().each(function (u) {
                u.trigger('change', u);
            });
            this.periodGroupings.getUnitCollection().trigger('change');
        };

        DayUnitGroupings.prototype.updateUI = function () {
            $("span#active-year").text(this.initialDate.getFullYear().toString());
            $("#jump-to-year-options li").removeClass("active");
            $("#jump-to-year-options li[data-year=" + (this.initialDate.getFullYear().toString()) + "]").addClass("active");
        };

        DayUnitGroupings.prototype._endDate = function () {
            return this.periodGroupings.models[this.periodGroupings.models.length - 1].dateRange.endDate;
        };

        DayUnitGroupings.prototype._startDate = function () {
            return this.periodGroupings.models[0].dateRange.startDate;
        };

        DayUnitGroupings.prototype._screenWidthPeriods = function () {
            return (Math.ceil(this.clientWidth / 280) + 3) | 0;
        };

        DayUnitGroupings.prototype._createUnitGroupingFromDates = function (startDate, endDate) {
            var dr;
            dr = new RG.Utils.DateRange(startDate, endDate);
            return new RG.Calendar.Units.DayUnitGrouping(dr);
        };

        return DayUnitGroupings;

    })();

}).call(this);
;
(function () {
    var LayerAllocation,
        bind = function (fn, me) { return function () { return fn.apply(me, arguments); }; };

    RG.Controllers.TimeAllocationLayers = (function () {
        function TimeAllocationLayers(bookingsCollection, downtimesCollection) {
            this.bookingsCollection = bookingsCollection;
            this.downtimesCollection = downtimesCollection;
            this.resetLayers = bind(this.resetLayers, this);
            this._bindEvents();
        }

        TimeAllocationLayers.prototype.layerFor = function (timeAllocation, timeAllocations) {
            var date, dv, i, j, k, len, overlappingTimeAllocations, ref, timeAllocationDateRange, usedLayers;
            if (timeAllocation.original.isExclusivelyOnWaitingList()) {
                return null;
            }
            timeAllocationDateRange = timeAllocation.modified.getDateRange();
            overlappingTimeAllocations = [];
            ref = timeAllocationDateRange.getDates();
            for (j = 0, len = ref.length; j < len; j++) {
                date = ref[j];
                dv = RG.Utils.DateFormatter.getISODate(date);
                overlappingTimeAllocations = overlappingTimeAllocations.concat(this.overlapIndex[dv]);
            }
            overlappingTimeAllocations = overlappingTimeAllocations.filter(function (ta) {
                return ta !== timeAllocation;
            });
            usedLayers = overlappingTimeAllocations.map(function (ta) {
                return ta.original.layer;
            });
            for (i = k = 0; k <= 1000; i = ++k) {
                if (usedLayers.indexOf(i) === -1) {
                    return i;
                }
            }
        };

        TimeAllocationLayers.prototype._indexOverlappingTimeAllocations = function (timeAllocations) {
            var base, date, dv, j, k, len, len1, ref, ta;
            this.overlapIndex = {};
            for (j = 0, len = timeAllocations.length; j < len; j++) {
                ta = timeAllocations[j];
                ref = ta.modified.getDateRange().getDates();
                for (k = 0, len1 = ref.length; k < len1; k++) {
                    date = ref[k];
                    dv = RG.Utils.DateFormatter.getISODate(date);
                    if ((base = this.overlapIndex)[dv] == null) {
                        base[dv] = [];
                    }
                    this.overlapIndex[dv].push(ta);
                }
            }
        };

        TimeAllocationLayers.prototype.resetLayers = function () {
            RG.backburner.deferOnce('layers', this, this._resetLayers);
        };

        TimeAllocationLayers.prototype._resetLayers = function () {
            var j, k, len, len1, timeAllocation, timeAllocations;
            this._unbindEvents();
            timeAllocations = this._getTimeAllocations();
            timeAllocations = this._tetrisSort(timeAllocations);
            for (j = 0, len = timeAllocations.length; j < len; j++) {
                timeAllocation = timeAllocations[j];
                timeAllocation.original.previousLayer = timeAllocation.original.layer;
                timeAllocation.original.layer = null;
            }
            this._indexOverlappingTimeAllocations(timeAllocations);
            for (k = 0, len1 = timeAllocations.length; k < len1; k++) {
                timeAllocation = timeAllocations[k];
                timeAllocation.original.layer = this.layerFor(timeAllocation, timeAllocations);
                if (timeAllocation.original.previousLayer && timeAllocation.original.layer !== timeAllocation.original.previousLayer) {
                    timeAllocation.original.trigger('change', timeAllocation.original);
                }
            }
            return this._bindEvents();
        };

        TimeAllocationLayers.prototype._bindEvents = function () {
            this.bookingsCollection.on('add', this.resetLayers);
            this.bookingsCollection.on('remove', this.resetLayers);
            this.bookingsCollection.on('change', this.resetLayers);
            this.bookingsCollection.on('reset', this.resetLayers);
            this.downtimesCollection.on('add', this.resetLayers);
            this.downtimesCollection.on('remove', this.resetLayers);
            this.downtimesCollection.on('change', this.resetLayers);
            this.downtimesCollection.on('reset', this.resetLayers);
        };

        TimeAllocationLayers.prototype._unbindEvents = function () {
            this.bookingsCollection.off('add', this.resetLayers);
            this.bookingsCollection.off('remove', this.resetLayers);
            this.bookingsCollection.off('change', this.resetLayers);
            this.bookingsCollection.off('reset', this.resetLayers);
            this.downtimesCollection.off('add', this.resetLayers);
            this.downtimesCollection.off('remove', this.resetLayers);
            this.downtimesCollection.off('change', this.resetLayers);
            this.downtimesCollection.off('reset', this.resetLayers);
        };

        TimeAllocationLayers.prototype.close = function () {
            this._unbindEvents();
        };

        TimeAllocationLayers.prototype._tetrisSort = function (timeAllocations) {
            timeAllocations = _.sortBy(timeAllocations, function (timeAllocation) {
                return -(timeAllocation.modified.getEndDate());
            });
            return _.sortBy(timeAllocations, function (timeAllocation) {
                return timeAllocation.modified.getStartDate();
            });
        };

        TimeAllocationLayers.prototype._getTimeAllocations = function () {
            var allocations, bookingCollectionModels, ref, timeZone;
            bookingCollectionModels = _.sortBy(this.bookingsCollection.models, function (booking) {
                return booking._getFirstDuration().get('startTime');
            });
            allocations = [].concat(bookingCollectionModels.map(function (b) {
                return new LayerAllocation(b, b);
            }));
            timeZone = (ref = this.downtimesCollection.resource) != null ? ref.get('timeZone') : void 0;
            allocations = allocations.concat(this.downtimesCollection.models.map(function (d) {
                return new LayerAllocation(d, d.inTimeZoneSimple(timeZone));
            }));
            return allocations;
        };

        return TimeAllocationLayers;

    })();

    LayerAllocation = (function () {
        function LayerAllocation(original, modified) {
            this.original = original;
            this.modified = modified;
        }

        return LayerAllocation;

    })();

}).call(this);
;
(function () {
    RG.FSM.BaseState = (function () {
        BaseState.prototype.startDrag = 'startDrag';

        BaseState.prototype.dragging = 'dragging';

        BaseState.prototype.dropped = 'dropped';

        function BaseState(options) {
            this.ui = options.ui;
            this.event = options.event;
            this.interaction = options.interaction;
            this.entered = false;
            this.exited = false;
        }

        BaseState.prototype.handleInput = function (input) {
            throw 'Not Implemented';
        };

        BaseState.prototype.enter = function () {
            this.entered = true;
            return this.exited = false;
        };

        BaseState.prototype.exit = function () {
            this.entered = false;
            return this.exited = true;
        };

        BaseState.prototype.update = function () {
            if (!this.entered) {
                return this.enter();
            }
        };

        return BaseState;

    })();

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.FSM.BookingState = (function (superClass) {
        extend(BookingState, superClass);

        function BookingState() {
            return BookingState.__super__.constructor.apply(this, arguments);
        }

        BookingState.prototype.handleInput = function (input) {
            if (input === this.startDrag) {
                return new RG.FSM.BookingStartDragState({
                    ui: this.ui,
                    event: this.event,
                    interaction: this.interaction
                });
            } else {
                throw "Input not implemented: " + input;
            }
        };

        return BookingState;

    })(RG.FSM.BaseState);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.FSM.DowntimeState = (function (superClass) {
        extend(DowntimeState, superClass);

        function DowntimeState() {
            return DowntimeState.__super__.constructor.apply(this, arguments);
        }

        DowntimeState.prototype.handleInput = function (input) {
            if (input === this.startDrag) {
                return new RG.FSM.DowntimeStartDragState({
                    ui: this.ui,
                    event: this.event,
                    interaction: this.interaction
                });
            } else {
                throw "Input not implemented";
            }
        };

        return DowntimeState;

    })(RG.FSM.BaseState);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.FSM.BookingDraggingState = (function (superClass) {
        extend(BookingDraggingState, superClass);

        function BookingDraggingState() {
            return BookingDraggingState.__super__.constructor.apply(this, arguments);
        }

        BookingDraggingState.prototype.handleInput = function (input) {
            if (input === this.dropped) {
                return new RG.FSM.BookingDroppedState({
                    ui: this.ui,
                    event: this.event,
                    interaction: this.interaction
                });
            } else if (input === this.dragging) {
                this.update();
                return this;
            } else {
                throw "Input not implemented";
            }
        };

        BookingDraggingState.prototype.enter = function () {
            BookingDraggingState.__super__.enter.apply(this, arguments);
            RG.Popovers.clear();
            return Q.delay(300).then(function () {
                return RG.Popovers.popoverActive = false;
            });
        };

        BookingDraggingState.prototype.update = function () {
            var bookingView, date, dropDates, ex, i, len, timeUnit;
            BookingDraggingState.__super__.update.apply(this, arguments);
            bookingView = this.interaction.bookingView;
            $(".resources--cal-unit.drag-drop-target").removeClass("drag-drop-target");
            window.getSelection().removeAllRanges();
            try {
                if (!RG.Utils.Permissions.canManage(bookingView.model) || RG.Popovers.locked) {
                    bookingView._calculator.targetDate = null;
                    bookingView._calculator.resource = null;
                    this.interaction.bookingViewEl.draggable("option", "revert", true);
                    $(".booking.ui-draggable-dragging").addClass("no-drop");
                    $("body").css({
                        cursor: "no-drop"
                    });
                    return;
                }
                bookingView._calculator.targetDate = RG.getDateAtClientX(this.event.clientX);
                bookingView._calculator.resource = RG.getResourceAtClientY(this.event.clientY);
                dropDates = bookingView._calculator.getNewDates();
                for (i = 0, len = dropDates.length; i < len; i++) {
                    date = dropDates[i];
                    timeUnit = $("#" + (RG.Utils.generateTimeUnitId(bookingView._calculator.resource.cid, date)));
                    timeUnit.addClass("drag-drop-target");
                }
                if (dropDates.length > 0) {
                    this.interaction.bookingViewEl.draggable("option", "revert", false);
                    $(".booking.ui-draggable-dragging").removeClass("no-drop");
                    $("body").css({
                        cursor: "move"
                    });
                } else {
                    this.interaction.bookingViewEl.draggable("option", "revert", true);
                    $(".booking.ui-draggable-dragging").addClass("no-drop");
                    $("body").css({
                        cursor: "no-drop"
                    });
                }
            } catch (error) {
                ex = error;
                bookingView._calculator.targetDate = null;
                bookingView._calculator.resource = null;
                this.interaction.bookingViewEl.draggable("option", "revert", true);
                $(".booking.ui-draggable-dragging").addClass("no-drop");
                return $("body").css({
                    cursor: "no-drop"
                });
            }
        };

        return BookingDraggingState;

    })(RG.FSM.BookingState);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.FSM.BookingDroppedState = (function (superClass) {
        extend(BookingDroppedState, superClass);

        function BookingDroppedState() {
            return BookingDroppedState.__super__.constructor.apply(this, arguments);
        }

        BookingDroppedState.prototype.enter = function () {
            var booking, bookingDuration, bookingView, command, date, dates, ex, i, initialDuration, j, len, len1, newDurations, originalAttributes, originalDurations, originalResource, resource;
            bookingView = this.interaction.bookingView;
            bookingView._stopPropagation(this.event);
            $(".resources--cal-unit.drag-drop-target").removeClass("drag-drop-target");
            $("body").css({
                cursor: ""
            });
            this.interaction.eventsOff();
            try {
                RG.Utils.BookingDataParser.expirePolls();
                resource = bookingView._calculator.resource;
                booking = bookingView.model.realBooking;
                originalResource = bookingView._getBookingResource();
                if (originalResource && resource && originalResource.get('id') !== resource.get('id')) {
                    originalResource.bookings.trigger('remove');
                }
                if (!resource || !bookingView._calculator.targetDate || bookingView.model.hasNoDurations() || (RG.Utils.DateComparator.equalsYMD(bookingView._calculator.sourceDate, bookingView._calculator.targetDate) && resource === originalResource && !this.event.shiftKey)) {
                    this.interaction.bookingViewEl.css({
                        opacity: ''
                    });
                    this.interaction.relatedBookings.forEach(function (b) {
                        return b.style.opacity = '';
                    });
                    RG.renderer.unlock(this.interaction.rendererLock);
                    return;
                }
                originalAttributes = {
                    startDate: booking.get('startDate'),
                    endDate: booking.get('endDate'),
                    saving: false
                };
                originalDurations = booking.durations.models;
                if (dates = bookingView._calculator.getNewDates()) {
                    if (this._datesUnchanged(dates, originalAttributes, originalResource, resource)) {
                        this.interaction.bookingViewEl.css({
                            opacity: ''
                        });
                        this.interaction.relatedBookings.forEach(function (b) {
                            return b.style.opacity = '';
                        });
                        return;
                    }
                    initialDuration = booking._getFirstDuration();
                    newDurations = [];
                    bookingDuration = new RG.DTO.BookingDuration({
                        startTime: initialDuration.get('startTime'),
                        duration: initialDuration.getMinutes()
                    });
                    if (!resource.isHuman() || initialDuration.constructor === RG.Models.FixedDuration) {
                        bookingDuration.startTime = bookingDuration.startTime || '0';
                        for (i = 0, len = dates.length; i < len; i++) {
                            date = dates[i];
                            newDurations.push(new RG.Models.FixedDuration({
                                date: date,
                                startTime: bookingDuration.startTime,
                                endTime: bookingDuration.startTime + bookingDuration.duration,
                                waiting: false
                            }));
                        }
                    } else if (initialDuration.constructor === RG.Models.Duration) {
                        for (j = 0, len1 = dates.length; j < len1; j++) {
                            date = dates[j];
                            newDurations.push(new RG.Models.Duration({
                                date: date,
                                minutes: bookingDuration.duration,
                                waiting: false
                            }));
                        }
                    }
                    command = null;
                    resource.predictWaitingList();
                    if (!this.event.shiftKey) {
                        command = this.commandFactory.createDragBookingCommand(resource, booking, originalResource, originalDurations, newDurations, dates, bookingDuration, originalAttributes, this.interaction.rendererLock);
                    } else {
                        command = this.commandFactory.createCopyBookingCommand(resource, booking, originalResource, originalDurations, newDurations, dates, bookingDuration, originalAttributes, this.interaction.rendererLock);
                    }
                    RG.renderer.unlock(this.interaction.rendererLock);
                    booking.trigger('change', booking);
                    command.execute();
                } else {
                    this.interaction.bookingViewEl.draggable("option", "revert", true);
                }
            } catch (error) {
                ex = error;
                RG.renderer.unlock(this.interaction.rendererLock);
                this.interaction.bookingViewEl.draggable("option", "revert", true);
                throw ex;
            }
            this.interaction.helperView.remove();
            RG.renderer.unlock(this.interaction.rendererLock);
        };

        BookingDroppedState.prototype._datesUnchanged = function (dates, originalAttributes, originalResource, resource) {
            if (dates.length === 0) {
                return true;
            }
            if (this.event.shiftKey || originalResource.id !== resource.id) {
                return false;
            }
            return RG.Utils.DateComparator.equalsYMD(dates[0], originalAttributes.startDate) && RG.Utils.DateComparator.equalsYMD(dates[dates.length - 1], originalAttributes.endDate);
        };

        return BookingDroppedState;

    })(RG.FSM.BookingState);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.FSM.BookingStartDragState = (function (superClass) {
        extend(BookingStartDragState, superClass);

        function BookingStartDragState() {
            return BookingStartDragState.__super__.constructor.apply(this, arguments);
        }

        BookingStartDragState.prototype.handleInput = function (input) {
            if (input === this.dragging) {
                return new RG.FSM.BookingDraggingState({
                    ui: this.ui,
                    event: this.event,
                    interaction: this.interaction
                });
            } else {
                throw "Input not implemented: " + input;
            }
        };

        BookingStartDragState.prototype.enter = function () {
            var duration, ex, offset;
            BookingStartDragState.__super__.enter.apply(this, arguments);
            try {
                window.getSelection().removeAllRanges();
                if (!this.event.shiftKey) {
                    this.interaction.bookingViewEl.css({
                        opacity: 0.5
                    });
                    this.interaction.relatedBookings.forEach(function (b) {
                        return b.style.opacity = 0.5;
                    });
                }
                this.interaction.helper = $(document.querySelectorAll(".booking.ui-draggable-dragging")[0]);
                this.interaction.eventsOn();
                this.interaction.keyEvent(this.event);
                duration = this.interaction.bookingView.getDurationAtOffset(this.event.pageX - this.interaction.bookingViewOffsetLeft);
                offset = 0;
                while (!duration) {
                    offset += 10;
                    duration = this.interaction.bookingView.getDurationAtOffset(this.event.pageX - this.interaction.bookingViewOffsetLeft - offset) || this.interaction.bookingView.getDurationAtOffset(this.event.pageX - this.interaction.bookingViewOffsetLeft + offset);
                }
                this._setBookingCalculator(duration);
            } catch (error) {
                ex = error;
                RG.renderer.unlock(this.interaction.rendererLock);
                throw ex;
            }
        };

        BookingStartDragState.prototype._setBookingCalculator = function (duration) {
            this.interaction.bookingView._calculator = new RG.Interactions.MoveBookingDates({
                booking: this.interaction.bookingView.model.realBooking,
                sourceDate: duration.get('date')
            });
        };

        return BookingStartDragState;

    })(RG.FSM.BookingState);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.FSM.DowntimeDraggingState = (function (superClass) {
        extend(DowntimeDraggingState, superClass);

        function DowntimeDraggingState() {
            return DowntimeDraggingState.__super__.constructor.apply(this, arguments);
        }

        DowntimeDraggingState.prototype.handleInput = function (input) {
            if (input === this.dropped) {
                return new RG.FSM.DowntimeDroppedState({
                    ui: this.ui,
                    event: this.event,
                    interaction: this.interaction
                });
            } else if (input === this.dragging) {
                this.update();
                return this;
            } else {
                throw "Input not implemented";
            }
        };

        DowntimeDraggingState.prototype.enter = function () {
            DowntimeDraggingState.__super__.enter.apply(this, arguments);
            RG.Popovers.clear();
            Q.delay(300).then(function () {
                return RG.Popovers.popoverActive = false;
            });
            return this.update();
        };

        DowntimeDraggingState.prototype.update = function () {
            var bookingView, date, dropDates, ex, i, len, timeUnit;
            DowntimeDraggingState.__super__.update.apply(this, arguments);
            bookingView = this.interaction.bookingView;
            $(".resources--cal-unit.drag-drop-target").removeClass("drag-drop-target");
            window.getSelection().removeAllRanges();
            try {
                if (!RG.Utils.Permissions.canManageDowntime(bookingView.model) || RG.Popovers.locked) {
                    bookingView._calculator.targetDate = null;
                    bookingView._calculator.resource = null;
                    this.interaction.bookingViewEl.draggable("option", "revert", true);
                    $(".booking.ui-draggable-dragging").addClass("no-drop");
                    $("body").css({
                        cursor: "no-drop"
                    });
                    return;
                }
                bookingView._calculator.targetDate = RG.getDateAtClientX(this.event.clientX);
                bookingView._calculator.resource = RG.getResourceAtClientY(this.event.clientY);
                dropDates = bookingView._calculator.getNewDates();
                for (i = 0, len = dropDates.length; i < len; i++) {
                    date = dropDates[i];
                    timeUnit = $("#" + (RG.Utils.generateTimeUnitId(bookingView._calculator.resource.cid, date)));
                    timeUnit.addClass("drag-drop-target");
                }
                this.interaction.bookingViewEl.draggable("option", "revert", false);
                $(".booking.ui-draggable-dragging").removeClass("no-drop");
                $("body").css({
                    cursor: "move"
                });
            } catch (error) {
                ex = error;
                bookingView._calculator.targetDate = null;
                bookingView._calculator.resource = null;
                this.interaction.bookingViewEl.draggable("option", "revert", true);
                $(".booking.ui-draggable-dragging").addClass("no-drop");
                return $("body").css({
                    cursor: "no-drop"
                });
            }
        };

        return DowntimeDraggingState;

    })(RG.FSM.BookingState);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.FSM.DowntimeDroppedState = (function (superClass) {
        extend(DowntimeDroppedState, superClass);

        function DowntimeDroppedState() {
            return DowntimeDroppedState.__super__.constructor.apply(this, arguments);
        }

        DowntimeDroppedState.prototype.enter = function () {
            var bookingView, command, dates, downtime, ex, originalAttributes, originalResource, resource;
            bookingView = this.interaction.bookingView;
            bookingView._stopPropagation(this.event);
            $(".resources--cal-unit.drag-drop-target").removeClass("drag-drop-target");
            $("body").css({
                cursor: ""
            });
            this.interaction.eventsOff();
            try {
                resource = bookingView._calculator.resource;
                downtime = bookingView.model.realBooking;
                originalResource = bookingView._getBookingResource();
                if (!resource || !bookingView._calculator.targetDate || (RG.Utils.DateComparator.equalsYMD(bookingView._calculator.sourceDate, bookingView._calculator.targetDate) && resource === originalResource && !this.event.shiftKey)) {
                    this.interaction.bookingViewEl.css({
                        opacity: ''
                    });
                    this.interaction.relatedBookings.forEach(function (b) {
                        return b.style.opacity = '';
                    });
                    RG.renderer.unlock(this.interaction.rendererLock);
                    return;
                }
                originalAttributes = {
                    from: downtime.get('from'),
                    to: downtime.get('to'),
                    resourceIds: downtime.get('resourceIds'),
                    saving: false
                };
                if (dates = bookingView._calculator.getNewDates()) {
                    if (dates.length === 0) {
                        this.interaction.bookingViewEl.css({
                            opacity: ''
                        });
                        this.interaction.relatedBookings.forEach(function (b) {
                            return b.style.opacity = '';
                        });
                        return;
                    }
                    command = null;
                    if (!this.event.shiftKey) {
                        this._dragDowntime(dates, downtime, resource, originalResource, originalAttributes);
                        return;
                    } else {
                        this._copyDowntime(dates, downtime, resource, originalResource);
                        return;
                    }
                } else {
                    this.interaction.bookingViewEl.draggable("option", "revert", true);
                    RG.renderer.unlock(this.interaction.rendererLock);
                }
            } catch (error) {
                ex = error;
                RG.renderer.unlock(this.interaction.rendererLock);
                this.interaction.bookingViewEl.draggable("option", "revert", true);
                throw ex;
            }
            this.interaction.helperView.remove();
            RG.renderer.unlock(this.interaction.rendererLock);
        };

        DowntimeDroppedState.prototype._dragDowntime = function (dates, downtime, resource, originalResource, originalAttributes) {
            var account, command, dateTimeRange, endDate, realDowntime, removeCallback, resourceIds, resources, startDate;
            startDate = dates[0];
            endDate = dates[dates.length - 1];
            downtime.set({
                from: dates[0],
                to: dates[dates.length - 1],
                saving: true
            });
            dateTimeRange = {
                dateRange: downtime.getDateRange(),
                timeRange: downtime.getRawTimeRange()
            };
            account = resource.account;
            resourceIds = downtime.get('resourceIds');
            resourceIds = resourceIds.filter(function (id) {
                return id !== originalResource.id;
            });
            resourceIds.push(resource.id);
            downtime.set('resourceIds', resourceIds);
            resources = window.resources.select(function (r) {
                return _.include(downtime.get('resourceIds'), r.id);
            });
            realDowntime = window.downtimes.findWhere({
                id: downtime.id
            });
            realDowntime.set(downtime.attributes);
            command = this.commandFactory.createUpdateCommand(downtime, account, resources, dateTimeRange, realDowntime, this.interaction.rendererLock);
            removeCallback = (function (_this) {
                return function () {
                    realDowntime.set(originalAttributes);
                    RG.Popovers.locked = false;
                    RG.renderer.unlock(_this.interaction.rendererLock);
                };
            })(this);
            command.willTouchBookings({
                success: function (bookings) {
                    var placer, popover, waitingConfirmation;
                    placer = new RG.Utils.DatePopoverPlacer(resource, bookings[0].attributes.date);
                    waitingConfirmation = new RG.Views.Dialogs.BookingClashManagement({
                        command: command,
                        clashBookingsCount: bookings != null ? bookings.length : void 0,
                        cancelCallback: removeCallback
                    });
                    popover = new RG.Views.Dialogs.BookingClashPopover({
                        attachTo: placer.createAnchor({
                            className: 'booking-clash-popover-anchor'
                        }),
                        removeAttachTo: true,
                        body: waitingConfirmation,
                        className: 'edit-booking-dropdown booking-clash-management-popover'
                    });
                    waitingConfirmation.on('cancelled', function () {
                        removeCallback();
                    });
                    window.setTimeout(function () {
                        return window.requestAnimationFrame(function () {
                            RG.Popovers.replace({
                                popoverView: popover,
                                removeCallback: removeCallback
                            });
                        });
                    }, 102);
                },
                fail: function () {
                    command.execute();
                }
            });
        };

        DowntimeDroppedState.prototype._copyDowntime = function (dates, downtime, resource, originalResource) {
            var account, command, dateTimeRange, newDowntime, removeCallback, resourceIds, resources;
            newDowntime = downtime.clone();
            newDowntime.set({
                id: null,
                from: dates[0],
                to: dates[dates.length - 1],
                saving: true
            });
            resourceIds = newDowntime.get('resourceIds');
            resourceIds = resourceIds.filter(function (id) {
                return id !== originalResource.id;
            });
            resourceIds.push(resource.id);
            newDowntime.set('resourceIds', resourceIds);
            dateTimeRange = {
                dateRange: newDowntime.getDateRange(),
                timeRange: newDowntime.getRawTimeRange()
            };
            account = resource.account;
            resources = window.resources.select(function (r) {
                return _.include(newDowntime.get('resourceIds'), r.id);
            });
            command = this.commandFactory.createCommand(account, resources, dateTimeRange, newDowntime, this.interaction.rendererLock);
            account.downtimes.add(newDowntime);
            if (newDowntime.get('resourceIds').indexOf(originalResource.id) === -1) {
                resource.bookings.predictWaitingList();
                resource.refreshDowntimes();
            }
            removeCallback = (function (_this) {
                return function () {
                    account.downtimes.remove(newDowntime);
                    RG.Popovers.locked = false;
                    RG.renderer.unlock(_this.interaction.rendererLock);
                };
            })(this);
            return command.willTouchBookings({
                success: function (bookings) {
                    var placer, popover, waitingConfirmation;
                    placer = new RG.Utils.DatePopoverPlacer(resource, bookings[0].attributes.date);
                    waitingConfirmation = new RG.Views.Dialogs.BookingClashManagement({
                        command: command,
                        clashBookingsCount: bookings != null ? bookings.length : void 0,
                        cancelCallback: removeCallback
                    });
                    popover = new RG.Views.Dialogs.BookingClashPopover({
                        attachTo: placer.createAnchor({
                            className: 'booking-clash-popover-anchor'
                        }),
                        removeAttachTo: true,
                        body: waitingConfirmation,
                        className: 'edit-booking-dropdown booking-clash-management-popover'
                    });
                    window.setTimeout(function () {
                        return window.requestAnimationFrame(function () {
                            RG.Popovers.replace({
                                popoverView: popover,
                                removeCallback: removeCallback
                            });
                        });
                    }, 102);
                },
                fail: function () {
                    command.execute();
                }
            });
        };

        return DowntimeDroppedState;

    })(RG.FSM.DowntimeState);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.FSM.DowntimeStartDragState = (function (superClass) {
        extend(DowntimeStartDragState, superClass);

        function DowntimeStartDragState() {
            return DowntimeStartDragState.__super__.constructor.apply(this, arguments);
        }

        DowntimeStartDragState.prototype.handleInput = function (input) {
            if (input === this.dragging) {
                return new RG.FSM.DowntimeDraggingState({
                    ui: this.ui,
                    event: this.event,
                    interaction: this.interaction
                });
            } else {
                throw "Input not implemented";
            }
        };

        DowntimeStartDragState.prototype._setBookingCalculator = function (duration) {
            this.interaction.bookingView._calculator = new RG.Interactions.MoveDowntimeDates({
                booking: this.interaction.bookingView.model.realBooking,
                sourceDate: duration.get('date')
            });
        };

        return DowntimeStartDragState;

    })(RG.FSM.BookingStartDragState);

}).call(this);
;
(function () {
    RG.FSM.Booking = (function () {
        function Booking(state) {
            this.state = state;
        }

        Booking.prototype.handleInput = function (input, stateChange) {
            var k, v;
            if (stateChange == null) {
                stateChange = {};
            }
            this.state.exit();
            this.state = this.state.handleInput(input);
            for (k in stateChange) {
                v = stateChange[k];
                this.state[k] = v;
            }
            return this.state.update();
        };

        return Booking;

    })();

}).call(this);
;
(function () {
    RG.Interactions.DragDropBooking = (function () {
        function DragDropBooking(bookingView) {
            var bookingState;
            this.bookingView = bookingView;
            bookingState = new RG.FSM.BookingState({
                interaction: this
            });
            this.bookingFSM = new RG.FSM.Booking(bookingState);
            this.bookingViewEl = this.bookingView.$el;
            this.commandFactory = new RG.Utils.BookingCommandFactory;
        }

        DragDropBooking.prototype.detach = function () {
            this.eventsOff();
            RG.Popovers.locked = false;
            RG.renderer.unlock(this.rendererLock);
        };

        DragDropBooking.prototype.eventsOff = function () {
            $(window).off('keydown', this.keyEvent);
            $(window).off('keyup', this.keyEvent);
        };

        DragDropBooking.prototype.eventsOn = function () {
            $(window).on('keydown', this.keyEvent);
            $(window).on('keyup', this.keyEvent);
        };

        DragDropBooking.prototype.attach = function () {
            var originalBooking;
            originalBooking = null;
            this.relatedBookings = null;
            this.helper = null;
            this.keyEvent = (function (_this) {
                return function (e) {
                    if (!e.shiftKey) {
                        _this.bookingViewEl.css({
                            opacity: 0.5
                        });
                        _this.relatedBookings.forEach(function (b) {
                            return b.style.opacity = 0.5;
                        });
                        _this.helper.removeClass("copying");
                    } else {
                        _this.bookingViewEl.css({
                            opacity: ''
                        });
                        _this.relatedBookings.forEach(function (b) {
                            return b.style.opacity = '';
                        });
                        _this.helper.addClass("copying");
                    }
                    $(window).trigger('mousemove');
                };
            })(this);
            this.bookingViewEl.draggable({
                addClasses: false,
                containment: "#resources",
                distance: 10,
                helper: (function (_this) {
                    return function () {
                        return _this._helper();
                    };
                })(this),
                cursor: 'no-drop',
                revert: true,
                start: (function (_this) {
                    return function (event, ui) {
                        _this.rendererLock = new RG.Renderer.GlobalLock;
                        RG.renderer.lock(_this.rendererLock);
                        _this.bookingFSM.handleInput('startDrag', {
                            event: event,
                            ui: ui
                        });
                    };
                })(this),
                drag: (function (_this) {
                    return function (event, ui) {
                        _this.bookingFSM.handleInput('dragging', {
                            event: event,
                            ui: ui
                        });
                    };
                })(this),
                stop: (function (_this) {
                    return function (event, ui) {
                        _this.bookingFSM.handleInput('dropped', {
                            event: event,
                            ui: ui,
                            commandFactory: _this.commandFactory
                        });
                    };
                })(this)
            });
        };

        DragDropBooking.prototype._helper = function () {
            var dateRange, firstVisibleDate, lastVisibleDate, offset, setWidth, widthStartDate;
            this.relatedBookings = Array.prototype.slice.call(document.querySelectorAll(".booking[data-booking-id='" + this.bookingView.model.id + "']"));
            this._buildHelperView();
            this.bookingViewOffsetLeft = this.bookingViewEl.offset().left;
            offset = this.bookingViewOffsetLeft - $(this.relatedBookings[0]).offset().left;
            if (offset > 0 && !this.bookingView.model.isDowntime()) {
                this.bookingViewEl.draggable("option", "cursorAt", {
                    left: offset
                });
            }
            this.helperView.render();
            dateRange = this.bookingView.model.realBooking.getDateRange();
            widthStartDate = dateRange.startDate;
            firstVisibleDate = RG.Utils.firstVisibleDate()._d;
            lastVisibleDate = RG.Utils.lastVisibleDate()._d;
            setWidth = false;
            if (firstVisibleDate > widthStartDate) {
                setWidth = true;
                widthStartDate = firstVisibleDate;
                dateRange = new RG.Utils.DateRange(firstVisibleDate, dateRange.endDate);
                window.requestAnimationFrame((function (_this) {
                    return function () {
                        $(_this.helperView.el).find('.unit span').hide();
                    };
                })(this));
            }
            if (dateRange.endDate > lastVisibleDate) {
                setWidth = true;
                dateRange = new RG.Utils.DateRange(dateRange.startDate, lastVisibleDate);
                window.requestAnimationFrame((function (_this) {
                    return function () {
                        $(_this.helperView.el).find('.unit span').hide();
                    };
                })(this));
            }
            if (setWidth) {
                this.helperView.el.style.width = ((RG.getUnitWidth() * dateRange.getNumberOfDays() / this.bookingView.unit.getDaysPerUnit()) + 1) + "px";
            }
            return this.helperView.el;
        };

        DragDropBooking.prototype._buildHelperView = function () {
            this.helperView = new RG.Views.Resource.Booking({
                dateController: window.dateController,
                bookingFormFactory: {
                    currentUserId: window.currentUserId
                },
                model: this.bookingView.model.realBooking,
                unit: this.bookingView.unit,
                availability: this.bookingView.availability,
                colorSource: this.bookingView._colorSource
            });
        };

        return DragDropBooking;

    })();

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Interactions.DragDropDowntime = (function (superClass) {
        extend(DragDropDowntime, superClass);

        function DragDropDowntime(bookingView) {
            var downtimeState;
            this.bookingView = bookingView;
            downtimeState = new RG.FSM.DowntimeState({
                interaction: this
            });
            this.bookingFSM = new RG.FSM.Booking(downtimeState);
            this.bookingViewEl = this.bookingView.$el;
            this.commandFactory = new RG.Utils.DowntimeCommandFactory;
        }

        DragDropDowntime.prototype._buildHelperView = function () {
            this.helperView = new RG.Views.Resource.Downtime({
                dateController: window.dateController,
                downtimeFormFactory: {
                    currentUserId: window.currentUserId
                },
                model: this.bookingView.model.realBooking,
                unit: this.bookingView.unit,
                availability: this.bookingView.availability,
                colorSource: this.bookingView._colorSource
            });
        };

        return DragDropDowntime;

    })(RG.Interactions.DragDropBooking);

}).call(this);
;
(function () {
    var bind = function (fn, me) { return function () { return fn.apply(me, arguments); }; };

    RG.Interactions.DragToCreate = (function () {
        function DragToCreate(line) {
            this.line = line;
            this._triggerDialog = bind(this._triggerDialog, this);
            this._setEndDate = bind(this._setEndDate, this);
            this._setStartDate = bind(this._setStartDate, this);
        }

        DragToCreate.prototype.attach = function () {
            this.line.$el.on('mousedown', this._setStartDate);
            $(window).on('mousemove', this._setEndDate);
            $(window).on('mouseup', this._triggerDialog);
        };

        DragToCreate.prototype.detach = function () {
            this.line.$el.off('mousedown', this._setStartDate);
            $(window).off('mousemove', this._setEndDate);
            $(window).off('mouseup', this._triggerDialog);
        };

        DragToCreate.prototype._addDragMarkers = function (dateRange) {
            var date, i, len, ref;
            if (dateRange == null) {
                dateRange = null;
            }
            ref = this._getDates(dateRange);
            for (i = 0, len = ref.length; i < len; i++) {
                date = ref[i];
                this.lastUnit = $("#" + (RG.Utils.generateTimeUnitId(this.line.model.cid, date)), this.line.$el).addClass("drag-drop-target");
            }
        };

        DragToCreate.prototype._getDateRange = function () {
            var dates;
            dates = _.sortBy([this._startDate, this._endDate], function (d) {
                return d;
            });
            return new RG.Utils.DateRange(dates[0], dates[1]);
        };

        DragToCreate.prototype._getDates = function (dateRange) {
            var date, dates, day, days, i, ref;
            if (dateRange == null) {
                dateRange = null;
            }
            if (dateRange) {
                return dateRange.getDates();
            }
            if (!this._hasValidDateRange()) {
                return [];
            }
            days = new RG.Utils.DateRange(this._startDate, this._endDate).getNumberOfDays();
            dates = [];
            for (day = i = 0, ref = days - 1; 0 <= ref ? i <= ref : i >= ref; day = 0 <= ref ? ++i : --i) {
                date = new Date(this._startDate);
                date.setDate(date.getDate() + day);
                dates.push(date);
            }
            return dates;
        };

        DragToCreate.prototype._hasValidDateRange = function () {
            return this._startDate && this._endDate;
        };

        DragToCreate.prototype._setStartDate = function (e) {
            var $target, validTarget;
            $target = $(e.target);
            validTarget = e.target.className.indexOf(RG.Views.Resource.TimeUnit.prototype.className) >= 0 || e.target.className.indexOf('bookings') >= 0 && e.target.className.indexOf('js-delete-bookings') <= 0;
            if (!validTarget || e.which !== 1 || !RG.Utils.Permissions.canAdd(this.line.model)) {
                if (!RG.Utils.Permissions.canAdd(this.line.model) && $(e.target).closest('.f-dropdown, .overlay').length === 0) {
                    RG.Popovers.clear();
                }
                return;
            }
            if (RG.Popovers.locked) {
                this._removeDragMarkers();
                return this._reset();
            }
            RG.Popovers.clear();
            this._isDragging = true;
            this._startDate = RG.getDateAtClientX(e.clientX);
            this._endDate = RG.getDateAtClientX(e.clientX);
        };

        DragToCreate.prototype._setEndDate = function (e) {
            if (!this._isDragging) {
                return;
            }
            if (RG.Popovers.locked) {
                this._removeDragMarkers();
                return this._reset();
            }
            RG.Popovers.clear();
            RG.Popovers.popoverActive = false;
            window.getSelection().removeAllRanges();
            this._resetDragMarkers();
            this._endDate = RG.getDateAtClientX(e.clientX);
        };

        DragToCreate.prototype._removeDragMarkers = function () {
            $(".resources--cal-unit.drag-drop-target", this.line.$el).removeClass("drag-drop-target");
        };

        DragToCreate.prototype._changeDragMarkers = function (dateRange) {
            this._removeDragMarkers();
            this._addDragMarkers(dateRange);
        };

        DragToCreate.prototype._reset = function () {
            this._startDate = null;
            this._endDate = null;
        };

        DragToCreate.prototype._resetDragMarkers = function () {
            this._removeDragMarkers();
            this._addDragMarkers();
        };

        DragToCreate.prototype._triggerDialog = function (e) {
            var anchor, dateRange, placer, popover;
            this._isDragging = false;
            if (!this._hasValidDateRange()) {
                return;
            }
            if (!$("#resources").find(e.target).length) {
                this._removeDragMarkers();
                return;
            }
            this._addDragMarkers();
            dateRange = this._getDateRange();
            if (dateRange.getNumberOfDays() > 1) {
                e.target = this.lastUnit;
            }
            placer = new RG.Utils.EventPopoverPlacer(e, 'booking');
            anchor = placer.createAnchor({
                className: 'new-booking-downtime'
            });
            popover = this.line._bookingFormDialogFactory.create({
                dateRange: dateRange,
                resource: this.line.model,
                attachTo: anchor,
                removeCallback: this._removeDragMarkers.bind(this),
                changeCallback: this._changeDragMarkers.bind(this)
            });
            RG.Popovers.set(popover, this._removeDragMarkers.bind(this));
            this._reset();
        };

        return DragToCreate;

    })();

}).call(this);
;
(function () {
    var bind = function (fn, me) { return function () { return fn.apply(me, arguments); }; },
        extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Interactions.DragToCreateCustomAvailability = (function (superClass) {
        extend(DragToCreateCustomAvailability, superClass);

        function DragToCreateCustomAvailability() {
            this._triggerDialog = bind(this._triggerDialog, this);
            this._setStartDate = bind(this._setStartDate, this);
            return DragToCreateCustomAvailability.__super__.constructor.apply(this, arguments);
        }

        DragToCreateCustomAvailability.prototype._addDragMarkers = function (dateRange) {
            var date, i, len, ref;
            if (dateRange == null) {
                dateRange = null;
            }
            ref = this._getDates(dateRange);
            for (i = 0, len = ref.length; i < len; i++) {
                date = ref[i];
                this.lastUnit = $("#" + (RG.Utils.generateTimeUnitId(this.line.model.cid, date)) + " .utilisation", this.line.$el).addClass("drag-drop-target");
            }
        };

        DragToCreateCustomAvailability.prototype._setStartDate = function (e) {
            var $target, validTarget;
            $target = $(e.target);
            validTarget = $target.closest(".utilisation").length > 0 && this._isNotActivePopover(e);
            if (!validTarget || e.which !== 1) {
                return;
            }
            if (RG.Popovers.locked) {
                this._removeDragMarkers();
                return this._reset;
            }
            RG.Popovers.clear();
            this._isDragging = true;
            this._startDate = RG.getDateAtClientX(e.clientX);
            this._endDate = RG.getDateAtClientX(e.clientX);
        };

        DragToCreateCustomAvailability.prototype._removeDragMarkers = function () {
            $('.resources--cal-unit .js-custom-availability').remove();
            $(".resources--cal-unit .utilisation.drag-drop-target", this.line.$el).removeClass("drag-drop-target");
        };

        DragToCreateCustomAvailability.prototype._isNotActivePopover = function (e) {
            return $(e.target).closest(".js-availability-popover-parent").length === 0;
        };

        DragToCreateCustomAvailability.prototype._triggerDialog = function (e) {
            var dateRange, placer, popover;
            if (!this._isDragging) {
                return;
            }
            if (!this._isNotActivePopover(e)) {
                return;
            }
            this._isDragging = false;
            if (!this._hasValidDateRange()) {
                return;
            }
            this._addDragMarkers();
            dateRange = this._getDateRange();
            if (dateRange.getNumberOfDays() > 1) {
                e.target = this.lastUnit;
            }
            placer = new RG.Utils.EventPopoverPlacer(e, 'utilisation', {
                topAdjustment: -6
            });
            popover = new RG.Views.Dialogs.CustomAvailabilityPopover({
                attachTo: placer.createAnchor({
                    className: 'custom-availability'
                }),
                removeAttachTo: true,
                callback: this._removeDragMarkers.bind(this),
                changeCallback: this._changeDragMarkers.bind(this),
                line: this.line,
                dateRange: dateRange,
                resource: this.line.model
            });
            RG.Popovers.set(popover, this._removeDragMarkers.bind(this));
            this._reset();
        };

        return DragToCreateCustomAvailability;

    })(RG.Interactions.DragToCreate);

}).call(this);
;
(function () {
    RG.Interactions.MoveBookingDates = (function () {
        function MoveBookingDates(options) {
            this._booking = options.booking;
            this.resource = options.resource;
            this.sourceDate = options.sourceDate;
            this.targetDate = options.targetDate;
            this.cachedResults = {};
        }

        MoveBookingDates.prototype.getNewDates = function () {
            var cacheKey, result;
            cacheKey = {
                source: this.sourceDate,
                target: this.targetDate,
                resource: this.resource
            };
            result = this.cachedResults[JSON.stringify(cacheKey)];
            if (result) {
                return result;
            }
            return this.newDates(cacheKey, this._booking.getDurations());
        };

        MoveBookingDates.prototype.newDates = function (cacheKey, durations) {
            var availability, date, options;
            availability = this.resource.availability;
            date = new Date(this.targetDate.getFullYear(), this.targetDate.getMonth(), this.targetDate.getDate());
            options = {
                date: date,
                dates: [],
                durations: durations.filter(function (d) {
                    return d.getMinutes() > 0;
                }),
                durationIndex: 0,
                availability: availability,
                noNormalAvailability: availability.hasNoNormalAvailability(),
                lastCap: availability.customAvailablePeriods.last(),
                firstCap: availability.customAvailablePeriods.first()
            };
            if (options.noNormalAvailability) {
                if (options.availability.customAvailablePeriods.length < options.durations.length) {
                    return [];
                } else {
                    if (options.date.valueOf() >= options.lastCap.get('date').valueOf()) {
                        options.durationIndex = options.durations.length - 1;
                    } else {
                        options = this._setDurationIndex(options);
                    }
                }
            } else {
                options = this._setDurationIndex(options);
            }
            options = this._moveLeft(options);
            options.date = new Date(this.targetDate.getFullYear(), this.targetDate.getMonth(), this.targetDate.getDate() + 1);
            options = this._moveRight(options);
            options = this._trimDates(options);
            options = this._ensureCapMatch(options);
            return this.cachedResults[JSON.stringify(cacheKey)] = options.dates;
        };

        MoveBookingDates.prototype._moveLeft = function (options) {
            var counter, dateRange, unshiftedDate;
            if (options.noNormalAvailability && options.firstCap.get('date').valueOf() >= options.date.valueOf()) {
                return options;
            }
            dateRange = new RG.Utils.DateRange(options.date, options.date);
            counter = 0;
            while (options.dates.length <= options.durationIndex) {
                if (options.availability.isAvailableIn(dateRange)) {
                    unshiftedDate = new Date(options.date.getFullYear(), options.date.getMonth(), options.date.getDate());
                    options.dates.unshift(unshiftedDate);
                }
                counter += 1;
                if (counter > 1000) {
                    options.dates = [];
                    return options;
                }
                options.date.setDate(options.date.getDate() - 1);
            }
            return options;
        };

        MoveBookingDates.prototype._moveRight = function (options) {
            var counter, dateRange, dateToPush;
            dateRange = new RG.Utils.DateRange(options.date, options.date);
            counter = 0;
            while (options.dates.length < options.durations.length) {
                if (options.availability.isAvailableIn(dateRange) || options.noNormalAvailability && options.lastCap.get('date').valueOf() <= options.date.valueOf()) {
                    dateToPush = new Date(options.date.getFullYear(), options.date.getMonth(), options.date.getDate());
                    options.dates.push(dateToPush);
                }
                counter += 1;
                if (counter > 1000) {
                    options.dates = [];
                    return options;
                }
                options.date.setDate(options.date.getDate() + 1);
            }
            return options;
        };

        MoveBookingDates.prototype._trimDates = function (options) {
            while (options.dates.length > options.durations.length) {
                options.dates.pop();
            }
            return options;
        };

        MoveBookingDates.prototype._setDurationIndex = function (options) {
            var duration;
            duration = _.find(options.durations, (function (_this) {
                return function (d) {
                    return RG.Utils.DateComparator.equalsYMD(_this.sourceDate, d.get('date'));
                };
            })(this));
            options.durationIndex = _.indexOf(options.durations, duration);
            return options;
        };

        MoveBookingDates.prototype._ensureCapMatch = function (options) {
            var periods;
            if (options.noNormalAvailability) {
                periods = options.availability.customAvailablePeriods.filter(function (cap) {
                    return options.dates.some(function (date) {
                        return date.valueOf() === cap.get('date').valueOf();
                    });
                });
                if (periods.length !== options.dates.length) {
                    options.dates = [];
                }
            }
            return options;
        };

        return MoveBookingDates;

    })();

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Interactions.MoveDowntimeDates = (function (superClass) {
        extend(MoveDowntimeDates, superClass);

        function MoveDowntimeDates(options) {
            MoveDowntimeDates.__super__.constructor.apply(this, arguments);
            this.offsetIndex = options.offsetIndex;
        }

        MoveDowntimeDates.prototype.newDates = function (cacheKey, durations) {
            var date, dateRange, dateToPush, dates, duration, durationIndex, unshiftedDate;
            duration = _.find(durations, (function (_this) {
                return function (d) {
                    return RG.Utils.DateComparator.equalsYMD(_this.sourceDate, d.get('date'));
                };
            })(this));
            durationIndex = _.indexOf(durations, duration);
            if (durationIndex === -1) {
                durationIndex = 0;
            }
            dates = [];
            date = new Date(this.targetDate.getFullYear(), this.targetDate.getMonth(), this.targetDate.getDate());
            dateRange = new RG.Utils.DateRange(date, date);
            while (dates.length <= durationIndex) {
                unshiftedDate = new Date(date.getFullYear(), date.getMonth(), date.getDate());
                dates.unshift(unshiftedDate);
                date.setDate(date.getDate() - 1);
            }
            date = new Date(this.targetDate.getFullYear(), this.targetDate.getMonth(), this.targetDate.getDate() + 1);
            dateRange = new RG.Utils.DateRange(date, date);
            while (dates.length < durations.length) {
                dateToPush = new Date(date.getFullYear(), date.getMonth(), date.getDate());
                dates.push(dateToPush);
                date.setDate(date.getDate() + 1);
            }
            while (dates.length > durations.length) {
                dates.pop();
            }
            return this.cachedResults[JSON.stringify(cacheKey)] = dates;
        };

        return MoveDowntimeDates;

    })(RG.Interactions.MoveBookingDates);

}).call(this);
;
(function () {
    RG.Interactions.ResizeBooking = (function () {
        function ResizeBooking(bookingView) {
            this.bookingView = bookingView;
        }

        ResizeBooking.prototype.detach = function () {
            RG.Popovers.locked = false;
            return RG.renderer.unlock(this.rendererLock);
        };

        ResizeBooking.prototype.attach = function () {
            var resize;
            resize = {
                leftAdjustmentDays: null,
                rightAdjustmentDays: null,
                startDate: null,
                endDate: null,
                dates: []
            };
            return this.bookingView.$el.resizable({
                handles: "e, w",
                start: (function (_this) {
                    return function () {
                        RG.Popovers.locked = false;
                        RG.Popovers.clear();
                        return _this._start(resize);
                    };
                })(this),
                resize: (function (_this) {
                    return function (event, ui) {
                        return _this._resize(resize, event, ui);
                    };
                })(this),
                stop: (function (_this) {
                    return function (event, ui) {
                        return _this._stop(resize, event, ui);
                    };
                })(this)
            });
        };

        ResizeBooking.prototype._start = function (resize) {
            this.bookingView.$el.find('.unit').hide();
            this.bookingView.$el.resizable("option", "minWidth", RG.getUnitWidth() - 2);
            this.offsetTop = this.bookingView.$el.offset().top + 40;
            this.bookingView.isInInteraction = true;
            resize.booking = this.bookingView.model.realBooking;
            resize.resource = this.bookingView._getBookingResource();
            this.rendererLock = new RG.Renderer.ResourceDateLock(resize.resource, new Date(resize.booking.getFirstAllocatedDate()), new Date(resize.booking.getLastAllocatedDate()));
            RG.renderer.lock(this.rendererLock);
            return RG.Popovers.lock();
        };

        ResizeBooking.prototype._resize = function (resize, event, ui) {
            var currentDate, day, days, i, leftAdjustment, ref, ref1, rightAdjustment, unitWidth, width, width_start_date;
            width = $(ui.element).width();
            unitWidth = RG.getUnitWidth();
            leftAdjustment = ui.position.left - ui.originalPosition.left;
            rightAdjustment = ui.size.width - ui.originalSize.width + leftAdjustment;
            resize.leftAdjustmentDays = Math.floor(leftAdjustment / RG.getUnitWidth());
            resize.rightAdjustmentDays = Math.ceil(rightAdjustment / RG.getUnitWidth());
            resize.startDate = new Date(resize.booking.getFirstAllocatedDate());
            resize.endDate = new Date(resize.booking.getLastAllocatedDate());
            resize.startDate.setDate(resize.startDate.getDate() + resize.leftAdjustmentDays);
            resize.endDate.setDate(resize.endDate.getDate() + resize.rightAdjustmentDays);
            days = new RG.Utils.DateRange(resize.startDate, resize.endDate).getNumberOfDays() - 1;
            width_start_date = resize.startDate;
            if (RG.Utils.firstVisibleDate()._d > width_start_date) {
                width_start_date = RG.Utils.firstVisibleDate()._d;
            }
            width = new RG.Utils.DateRange(width_start_date, resize.endDate).getNumberOfDays() - 1;
            $(ui.element).width(((width + 1) * RG.getUnitWidth()) - 1);
            $(ui.element).css({
                left: (RG.getUnitWidth() * resize.leftAdjustmentDays) - 1
            });
            resize.dates = [];
            for (day = i = ref = resize.startDate.getDate(), ref1 = resize.startDate.getDate() + days; ref <= ref1 ? i <= ref1 : i >= ref1; day = ref <= ref1 ? ++i : --i) {
                currentDate = new Date(resize.startDate);
                currentDate.setDate(day);
                if (this._isAvailableIn(resize.resource, currentDate)) {
                    resize.dates.push(currentDate);
                }
            }
            if (_.any(resize.dates, function (d) {
                return RG.Utils.DateComparator.equalsYMD(d, resize.startDate);
            }) && _.any(resize.dates, function (d) {
                return RG.Utils.DateComparator.equalsYMD(d, resize.endDate);
            })) {
                return $(ui.element).removeClass("no-drop");
            } else {
                return $(ui.element).addClass("no-drop");
            }
        };

        ResizeBooking.prototype._stop = function (resize, event, ui) {
            var booking, changed, command, date, duration, i, index, initialDuration, j, len, len1, newDurations, oldBookingDates, oldDate, originalAttributes, originalDurations, originalResource, ref, ref1, resource;
            resource = resize.resource;
            booking = resize.booking;
            oldBookingDates = booking.getDateRange().getDates();
            changed = resize.dates.length !== oldBookingDates.length;
            Q.delay(10).then(function () {
                return RG.Popovers.locked = false;
            });
            ref = resize.dates;
            for (index = i = 0, len = ref.length; i < len; index = ++i) {
                date = ref[index];
                if (!(!changed)) {
                    continue;
                }
                oldDate = oldBookingDates[index];
                changed = !oldDate || !RG.Utils.DateComparator.equalsYMD(date, oldDate);
            }
            if (resize.leftAdjustmentDays === 0 && resize.rightAdjustmentDays === 0 || !changed) {
                resource.bookings.remove(booking);
                resource.bookings.add(booking);
                RG.renderer.unlock(this.rendererLock);
                return;
            }
            originalAttributes = booking.attributes;
            originalDurations = booking.durations.models;
            initialDuration = originalDurations[0];
            newDurations = [];
            ref1 = resize.dates;
            for (j = 0, len1 = ref1.length; j < len1; j++) {
                date = ref1[j];
                duration = initialDuration.clone();
                duration.set({
                    date: date,
                    waiting: _.select(booking.durations.where({
                        waiting: true
                    }), function (d) {
                        return RG.Utils.DateComparator.equalsYMD(d.get('date'), date);
                    }).length > 0
                });
                newDurations.push(duration);
            }
            RG.renderer.enqueue(new RG.Renderer.ResourceDateLock(resource, resize.startDate, resize.endDate), function () {
                booking.set({
                    saving: true,
                    startDate: resize.startDate,
                    endDate: resize.endDate
                });
                booking.durations.reset(newDurations);
                resource.bookings.remove(booking);
                return resource.bookings.add(booking);
            });
            originalResource = resource;
            this.bookingView.$el.find('.unit').hide();
            this.bookingView.isInInteraction = false;
            RG.renderer.unlock(this.rendererLock);
            command = new RG.Commands.UpdateBookingCommand({
                booking: booking,
                resource: resource,
                startDate: resize.dates[0],
                endDate: resize.dates[resize.dates.length - 1],
                successCallback: function (data) {
                    return RG.renderer.enqueue(new RG.Renderer.ResourceDateLock(resource, resize.startDate, resize.endDate), function () {
                        var k, len2, ref2, responseDuration;
                        booking.set({
                            startDate: RG.Utils.BookingMerger.getDateFromStr(data.start_date),
                            endDate: RG.Utils.BookingMerger.getDateFromStr(data.end_date),
                            refreshable: data.refreshable,
                            saving: false
                        });
                        ref2 = booking.durations.models;
                        for (k = 0, len2 = ref2.length; k < len2; k++) {
                            duration = ref2[k];
                            responseDuration = _.find(data.durations, function (d) {
                                return d.date === RG.Utils.DateFormatter.getISODate(duration.get('date'));
                            });
                            if (responseDuration) {
                                duration.set({
                                    waiting: responseDuration.waiting
                                });
                            }
                        }
                        return window.update();
                    });
                }
            });
            command.removedDatesCallback = (function (_this) {
                return function (removedDates) {
                    var placer, popover, removedDatesDialog;
                    removedDatesDialog = new RG.Views.Dialogs.RemovedAvailabilityDates({
                        resource: resource,
                        removedAvailabilityDates: removedDates
                    });
                    placer = new RG.Utils.DatePopoverPlacer(resource, new Date(removedDates[0]), {
                        offsetTop: _this.offsetTop
                    });
                    popover = new RG.Views.Dialogs.BookingClashPopover({
                        removeAttachTo: true,
                        attachTo: placer.createAnchor({
                            className: 'booking-clash-popover-anchor'
                        }),
                        body: removedDatesDialog,
                        className: 'edit-booking-dropdown'
                    });
                    return RG.Popovers.replace({
                        popoverView: popover,
                        removeCallback: function () { }
                    });
                };
            })(this);
            command.waitingCallback = (function (_this) {
                return function (waitingDates) {
                    var waitingConfirmation;
                    RG.Popovers.unlock();
                    waitingConfirmation = new RG.Views.Dialogs.WaitingListConfirmation({
                        resource: resource,
                        waitingDates: waitingDates,
                        duration: newDurations[0].getMinutes(),
                        startDate: resize.dates[0],
                        endDate: resize.dates[resize.dates.length - 1],
                        cancelCallback: function () {
                            return RG.renderer.enqueue(new RG.Renderer.ResourceDateLock(resource, resize.startDate, resize.endDate), function () {
                                booking.set(originalAttributes);
                                booking.set({
                                    saving: false
                                });
                                booking.durations.reset(originalDurations);
                                resource.bookings.remove(booking, {
                                    silent: true
                                });
                                return resource.bookings.add(booking);
                            });
                        },
                        callback: function () {
                            return RG.renderer.enqueue(new RG.Renderer.ResourceDateLock(resource, resize.startDate, resize.endDate), function () {
                                var k, len2, ref2;
                                booking.set({
                                    saving: false
                                });
                                ref2 = booking.durations.models;
                                for (k = 0, len2 = ref2.length; k < len2; k++) {
                                    duration = ref2[k];
                                    if (waitingDates.indexOf(RG.Utils.DateFormatter.getISODate(duration.get('date'))) > -1) {
                                        duration.set({
                                            waiting: true
                                        });
                                    }
                                }
                                command.forceWaiting = true;
                                return command.execute();
                            });
                        }
                    });
                    _this._waitingPopover(resource, new Date(waitingDates[0]), waitingConfirmation);
                    return waitingConfirmation.on('addWaiting', function () {
                        return RG.Popovers.done();
                    });
                };
            })(this);
            command.archivedCallback = function (data) {
                return RG.Utils.BookingService.reset(data, resource, booking, originalAttributes, originalDurations);
            };
            return command.execute().then(function () {
                return RG.Popovers.unlock();
            });
        };

        ResizeBooking.prototype._isAvailableIn = function (resource, date) {
            if (this.availability == null) {
                this.availability = resource.availability;
            }
            return this.availability.isAvailableIn(new RG.Utils.DateRange(date, date));
        };

        ResizeBooking.prototype._waitingPopover = function (resource, date, waitingConfirmation, callback) {
            var placer;
            if (callback == null) {
                callback = waitingConfirmation.cancelCallback;
            }
            placer = new RG.Utils.DatePopoverPlacer(resource, date, {
                offsetTop: this.offsetTop
            });
            this.popover = new RG.Views.Dialogs.BookingClashPopover({
                removeAttachTo: true,
                attachTo: placer.createAnchor({
                    className: 'booking-clash-popover-anchor'
                }),
                body: waitingConfirmation,
                className: 'edit-booking-dropdown'
            });
            return RG.Popovers.replace({
                popoverView: this.popover,
                removeCallback: callback
            });
        };

        return ResizeBooking;

    })();

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Interactions.ResizeDowntime = (function (superClass) {
        extend(ResizeDowntime, superClass);

        function ResizeDowntime() {
            return ResizeDowntime.__super__.constructor.apply(this, arguments);
        }

        ResizeDowntime.prototype._start = function (resize) {
            this.bookingView.$el.resizable("option", "minWidth", RG.getUnitWidth() - 2);
            this.offsetTop = this.bookingView.$el.offset().top + 40;
            resize.resource = this.bookingView._getBookingResource();
            resize.booking = this.bookingView.model.realBooking.inTimeZone(resize.resource.getTimeZone());
            resize.initialTimeZone = this.bookingView.model.realBooking.getTimeZone();
            this.rendererLock = new RG.Renderer.ResourceDateLock(resize.resource, new Date(resize.booking.getFirstAllocatedDate()), new Date(resize.booking.getLastAllocatedDate()));
            RG.renderer.lock(this.rendererLock);
            return RG.Popovers.lock();
        };

        ResizeDowntime.prototype._stop = function (resize, event, ui) {
            var account, calendarUpdater, command, dateTimeRange, downtime, originalAttributes, originalResource, realDowntime, resizingLeft, resource, resourceDowntime, resources;
            resourceDowntime = resize.booking;
            downtime = window.downtimes.findWhere({
                id: resize.booking.id
            });
            resource = resize.resource;
            account = resource.account;
            if (resize.startDate < downtime.get('from')) {
                resizingLeft = true;
            }
            originalAttributes = {
                from: downtime.get('from'),
                to: downtime.get('to'),
                saving: false
            };
            downtime.set({
                saving: true,
                from: resize.startDate,
                to: resize.endDate
            });
            dateTimeRange = {
                dateRange: downtime.getDateRange(),
                timeRange: downtime.getRawTimeRange()
            };
            originalResource = resource;
            realDowntime = downtime;
            resources = window.resources.select(function (r) {
                return downtime.get('resourceIds').indexOf(r.id) !== -1;
            });
            calendarUpdater = new RG.Utils.DowntimeCalendarUpdater(window.currentUserId, account, window.resources, window.timeZones, resources);
            RG.renderer.enqueue(new RG.Renderer.ResourceDateLock(resource, resize.startDate, resize.endDate), function () {
                downtime.set({
                    saving: true,
                    from: resize.startDate,
                    to: resize.endDate
                });
                downtime = downtime.inTimeZone(resize.initialTimeZone);
                return resourceDowntime.set(downtime.attributes);
            });
            RG.renderer.unlock(this.rendererLock);
            command = new RG.Commands.UpdateDowntimeCommand({
                downtime: downtime,
                account: account,
                booker: window.bookers.findWhere({
                    id: downtime.get('creatorId')
                }),
                resources: resources,
                dateTimeRange: dateTimeRange,
                details: downtime.get('details'),
                timeZones: window.timeZones,
                timeZone: downtime.getTimeZone().getParamValue(),
                type: downtime.getDowntimeType(),
                preExecuteCallback: function (dTime, durations, shouldDelete) {
                    Q.delay(100).then(function () {
                        RG.Popovers.unlock();
                        return RG.Popovers.done();
                    });
                    return calendarUpdater.update(downtime, durations, shouldDelete);
                },
                successCallback: function (dTime) {
                    realDowntime.set({
                        saving: false
                    });
                    return window.update();
                }
            });
            return command.willTouchBookings({
                success: (function (_this) {
                    return function (bookings) {
                        var date, waitingConfirmation, wasCancelClicked;
                        RG.Popovers.locked = false;
                        wasCancelClicked = true;
                        waitingConfirmation = new RG.Views.Dialogs.BookingClashManagement({
                            command: command,
                            clashBookingsCount: bookings.length,
                            successCallback: function () {
                                return wasCancelClicked = false;
                            },
                            cancelCallback: function () {
                                RG.Popovers.locked = false;
                                if (wasCancelClicked) {
                                    realDowntime.set(originalAttributes);
                                    return calendarUpdater.updateAffectedResources();
                                }
                            }
                        });
                        date = dateTimeRange.dateRange.endDate;
                        if (resizingLeft) {
                            date = dateTimeRange.dateRange.startDate;
                        }
                        return setTimeout(function () {
                            return _this._waitingPopover(resource, date, waitingConfirmation);
                        }, 0);
                    };
                })(this),
                fail: function () {
                    command.execute();
                    return Q.delay(10).then(function () {
                        return RG.Popovers.locked = false;
                    });
                }
            });
        };

        ResizeDowntime.prototype._isAvailableIn = function (resource, date) {
            return true;
        };

        ResizeDowntime.prototype._getTimeAllocationAfterResize = function (resize) {
            return resize.booking.inTimeZone(resize.initialTimeZone);
        };

        return ResizeDowntime;

    })(RG.Interactions.ResizeBooking);

}).call(this);
;
(function () {
    RG.Interactions.RightClickDragToScroll = (function () {
        function RightClickDragToScroll(el1) {
            this.el = el1;
            this.isDragging = false;
            this._lastOffset = {};
            this.jEl = $(this.el);
        }

        RightClickDragToScroll.prototype.attach = function () {
            var isOldSafari, toggle, userAgent;
            userAgent = this._getNormalizedUserAgentString();
            isOldSafari = userAgent.indexOf("safari") !== -1 && userAgent.indexOf("chrome") === -1 && this.getSafariVersion() < 7;
            toggle = true;
            $(this.el).on('contextmenu', (function (_this) {
                return function (e) {
                    return _this._elementAllowsRightClick(e.target);
                };
            })(this));
            $(this.el).on('mousedown', (function (_this) {
                return function (e) {
                    if (e.which !== 3) {
                        return;
                    }
                    if (_this._elementAllowsRightClick(e.target)) {
                        return true;
                    }
                    _this.isDragging = true;
                    _this._lastOffset = {
                        x: e.clientX,
                        y: e.clientY
                    };
                    return false;
                };
            })(this));
            $(this.el).on('mouseup', (function (_this) {
                return function (e) {
                    if (e.which !== 3) {
                        return;
                    }
                    return _this.isDragging = false;
                };
            })(this));
            return $(this.el).on('mousemove', (function (_this) {
                return function (e) {
                    var moveX, moveY;
                    if (!_this.isDragging) {
                        return;
                    }
                    if (_this.animationQueued) {
                        return;
                    }
                    if (RG.Popovers.locked) {
                        _this.isDragging = false;
                        return;
                    }
                    _this.animationQueued = true;
                    moveX = e.clientX - _this._lastOffset.x;
                    moveY = e.clientY - _this._lastOffset.y;
                    if (isOldSafari) {
                        if (toggle) {
                            _this._lastOffset.x = e.clientX;
                            _this.jEl.scrollLeft(_this.jEl.scrollLeft() - moveX);
                        } else {
                            _this._lastOffset.y = e.clientY;
                            _this.jEl.scrollTop(_this.jEl.scrollTop() - moveY);
                        }
                        toggle = !toggle;
                    } else {
                        _this._lastOffset = {
                            x: e.clientX,
                            y: e.clientY
                        };
                        _this.jEl.scrollLeft(_this.jEl.scrollLeft() - moveX);
                        _this.jEl.scrollTop(_this.jEl.scrollTop() - moveY);
                    }
                    return _this.animationQueued = false;
                };
            })(this));
        };

        RightClickDragToScroll.prototype._getNormalizedUserAgentString = function () {
            return navigator.userAgent.toLowerCase();
        };

        RightClickDragToScroll.prototype._elementAllowsRightClick = function (el) {
            var $el;
            $el = $(el);
            return $el.closest("#resources").length === 0 || $el.closest(".f-dropdown").length !== 0;
        };

        RightClickDragToScroll.prototype.getSafariVersion = function () {
            var match, userAgent, versionPatt;
            userAgent = this._getNormalizedUserAgentString();
            versionPatt = /version\/(\d+)\.(\d+)/i;
            match = versionPatt.exec(userAgent);
            if (match) {
                return parseFloat(match[1] + "." + match[2]);
            } else {
                return 0;
            }
        };

        return RightClickDragToScroll;

    })();

}).call(this);
;
(function () {
    RG.DTO.BookingDuration = (function () {
        function BookingDuration(options) {
            this.duration = options.duration;
            this.startTime = options.startTime;
        }

        return BookingDuration;

    })();

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Routers.Calendar = (function (superClass) {
        extend(Calendar, superClass);

        function Calendar() {
            return Calendar.__super__.constructor.apply(this, arguments);
        }

        Calendar.prototype.initialize = function (options) {
            this.root = options.root;
            this.rendered = false;
            return this.dateController = null;
        };

        Calendar.prototype.routes = {
            '': 'index',
            ':year-:month-:day': 'scrollDate'
        };

        Calendar.prototype.index = function () {
            if (!this.rendered) {
                this._render();
            }
            return this.openAtUnit(".cal-unit.current");
        };

        Calendar.prototype.openAtUnit = function (selector) {
            return this.scrollToUnit(selector).then(function () {
                return $("#loader").hide();
            });
        };

        Calendar.prototype.scrollToUnit = function (selector) {
            var offsetLeft, scrollFunc;
            offsetLeft = $("aside").width() - 1;
            scrollFunc = function (resolve) {
                var element;
                element = $(selector);
                if (element.length > 0 && RG.Utils.unitsRendered()) {
                    return window.setTimeout(function () {
                        if (typeof newrelic !== "undefined" && newrelic !== null) {
                            newrelic.finished();
                        }
                        // Tracker.mark('ready');
                        return window.requestAnimationFrame(function () {
                            $("html, body").animate({
                                scrollLeft: element.first().offset().left - offsetLeft
                            });
                            return resolve();
                        });
                    }, 500);
                } else {
                    return setTimeout(function () {
                        return scrollFunc(resolve);
                    }, 100);
                }
            };
            return Q.promise(scrollFunc);
        };

        Calendar.prototype.scrollDate = function (year, month, date) {
            var browser, d, dd, klassName, m, y;
            if (this.rendered) {
                return true;
            }
            y = parseInt(year, 10);
            m = parseInt(month, 10);
            d = parseInt(date, 10);
            dd = new Date(y, m - 1, d);
            if (!this.rendered) {
                this._render(dd);
                browser = $('html').attr('class');
                klassName = '.cal-unit';
                if (browser.indexOf('ff') !== -1 || browser.indexOf('safari') !== -1) {
                    klassName = '.resources--cal-unit';
                }
                return this.openAtUnit(klassName + "[data-date=" + (RG.Utils.DateFormatter.getISODate(dd)) + "]:visible");
            } else {
                return this.dateController.scrollToDate(dd);
            }
        };

        Calendar.prototype._render = function (initialDate) {
            var $document, $window, colorBookingsBy, d, filterSource, initDate, layout, screenWidthPeriods;
            $window = $(window);
            $document = $(document);
            window.colorSource = new RG.Utils.ColorSource;
            colorBookingsBy = window.rgStorage.get('colorBookingsBy');
            if (colorBookingsBy) {
                window.colorSource.colorBy(colorBookingsBy);
            }
            window.ugc = new RG.Collections.UnitGroupings;
            window.dateController = new RG.Controllers.DayUnitGroupings(ugc);
            d = initialDate || new Date;
            screenWidthPeriods = $(window).width() / (7 * 40);
            initDate = new Date(d.getFullYear(), d.getMonth(), d.getDate() - d.getDay() + 1);
            dateController.init(initDate, d);
            dateController.prepend(2);
            dateController.append(screenWidthPeriods);
            this.dateController = dateController;
            if (window.clients == null) {
                window.clients = new RG.Collections.Clients;
            }
            if (window.projects == null) {
                window.projects = new RG.Collections.Projects;
            }
            if (window.resources == null) {
                window.resources = new RG.Collections.ResourceInstances;
            }
            if (window.resourceTypes == null) {
                window.resourceTypes = new RG.Collections.ResourceTypes;
            }
            if (window.bookers == null) {
                window.bookers = new RG.Collections.Bookers;
            }
            if (window.savedFilters == null) {
                window.savedFilters = new RG.Collections.SavedFilters;
            }
            if (window.currentUserDate == null) {
                window.currentUserDate = new RG.Models.CurrentDate(RG.Utils.getTodayISO());
            }
            filterSource = new RG.Utils.FilterSource(window.resourceTypes, window.resources, window.projects, window.clients);
            layout = new RG.Views.Calendar.Layout({
                dateController: this.dateController,
                initialDate: initialDate,
                periodGroupings: window.ugc,
                resources: window.resources,
                savedFilters: window.savedFilters,
                filterSource: filterSource,
                colorSource: window.colorSource,
                currentUserId: window.currentUserId,
                clients: window.clients,
                deletedClients: window.deletedClients,
                projects: window.projects,
                deletedProjects: window.deletedProjects,
                bookers: window.bookers,
                deletedBookers: window.deletedBookers,
                downtimeTypes: window.downtimeTypes,
                timeZones: window.timeZones,
                currentUserTimeZone: window.currentUserTimeZone,
                currentDate: window.currentUserDate
            });
            layout.render();
            if (window.rgStorage.get('zoomLevel') === "detailed") {
                layout.el.className = "daily detailed";
            } else {
                layout.el.className = "daily";
            }
            layout.el.style.display = "none";
            this.root.replaceWith(layout.el);
            layout._resize();
            this.dateController.updateUI();
            layout.setInitialFilters();
            layout.setInitialResource();
            return this.rendered = true;
        };

        return Calendar;

    })(Backbone.Router);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Renderer.ResourceDateLock = (function () {
        function ResourceDateLock(resource, startDate, endDate) {
            this.resource = resource;
            this.dateRange = new RG.Utils.DateRange(startDate, endDate);
        }

        ResourceDateLock.prototype.isLockedBy = function (lock) {
            if (lock.constructor === RG.Renderer.GlobalLock) {
                return true;
            }
            return this.dateRange.overlapsWith(lock.dateRange) && this.resource === lock.resource;
        };

        return ResourceDateLock;

    })();

    RG.Renderer.ResourcesDateLock = (function (superClass) {
        extend(ResourcesDateLock, superClass);

        function ResourcesDateLock() {
            return ResourcesDateLock.__super__.constructor.apply(this, arguments);
        }

        ResourcesDateLock.prototype.isLockedBy = function (lock) {
            if (lock.constructor === RG.Renderer.GlobalLock) {
                return true;
            }
            return this.dateRange.overlapsWith(lock.dateRange) && this.resources && this.resources.indexOf(lock.resource) !== -1;
        };

        return ResourcesDateLock;

    })(RG.Renderer.ResourceDateLock);

    RG.Renderer.GlobalLock = (function () {
        function GlobalLock() {
            setTimeout((function (_this) {
                return function () {
                    if (RG.renderer.locks.indexOf(_this) !== -1) {
                        return RG.renderer.unlock(_this);
                    }
                };
            })(this), 20000);
        }

        GlobalLock.prototype.isLockedBy = function (lock) {
            return true;
        };

        return GlobalLock;

    })();

}).call(this);
;
(function () {
    RG.Renderer.Renderer = (function () {
        function Renderer() {
            this.queue = [];
            this.locks = [];
        }

        Renderer.prototype.enqueue = function (lock, fn) {
            this.queue.push({
                lock: lock,
                fn: fn
            });
            return this.render();
        };

        Renderer.prototype.lock = function (lock) {
            return this.locks.push(lock);
        };

        Renderer.prototype.unlock = function (lock) {
            var index;
            index = this.locks.indexOf(lock);
            if (index > -1) {
                this.locks.splice(index, 1);
            }
            return this.render();
        };

        Renderer.prototype.isLocked = function (action) {
            var i, len, lock, ref;
            ref = this.locks;
            for (i = 0, len = ref.length; i < len; i++) {
                lock = ref[i];
                if (action.lock.isLockedBy(lock)) {
                    return true;
                }
            }
            return false;
        };

        Renderer.prototype.render = function (queue) {
            var action, i, index, j, len, len1, processedActionIndexes, results;
            if (queue == null) {
                queue = this.queue;
            }
            if (this.paused) {
                return;
            }
            processedActionIndexes = [];
            for (index = i = 0, len = queue.length; i < len; index = ++i) {
                action = queue[index];
                if (!this.isLocked(action)) {
                    action.fn();
                    processedActionIndexes.unshift(index);
                }
            }
            results = [];
            for (j = 0, len1 = processedActionIndexes.length; j < len1; j++) {
                index = processedActionIndexes[j];
                results.push(this.queue.splice(index, 1));
            }
            return results;
        };

        Renderer.prototype.renderAfter = function (queue) {
            if (!queue.some((function (_this) {
                return function (action) {
                    return _this.isLocked(action);
                };
            })(this))) {
                return this.render(queue);
            } else {
                return setTimeout((function (_this) {
                    return function () {
                        return _this.renderAfter(queue);
                    };
                })(this), 50);
            }
        };

        Renderer.prototype.pause = function () {
            return this.paused = true;
        };

        Renderer.prototype.unpause = function () {
            this.paused = false;
            return this.render();
        };

        Renderer.prototype.unlockAll = function () {
            var action, i, len, ref;
            ref = this.queue;
            for (i = 0, len = ref.length; i < len; i++) {
                action = ref[i];
                action.fn();
            }
            this.queue = [];
            return this.locks = [];
        };

        return Renderer;

    })();

}).call(this);
;
(function () {
    var bind = function (fn, me) { return function () { return fn.apply(me, arguments); }; },
        extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.Dialogs.NewDowntime = (function (superClass) {
        extend(NewDowntime, superClass);

        function NewDowntime() {
            this.toggleTimeZoneSelector = bind(this.toggleTimeZoneSelector, this);
            return NewDowntime.__super__.constructor.apply(this, arguments);
        }

        NewDowntime.prototype.template = templates.find('dialogs/new_downtime');

        NewDowntime.prototype.headerTemplate = templates.find('dialogs/new_downtime_header');

        NewDowntime.prototype.initialize = function (options) {
            this.currentUserId = options.currentUserId;
            this.resources = options.resources;
            this.resource = options.resource;
            this.interactedResource = options.resource;
            this.selectedResources = [this.resource];
            this.account = this.resource.account;
            this.bookers = options.bookers;
            this.dateRange = options.dateRange;
            this.timeRange = options.timeRange || new RG.Utils.TimeRange(0, 1440);
            this.downtimeTypes = options.downtimeTypes;
            this.timeZones = options.timeZones;
            this.currentUserTimeZone = options.currentUserTimeZone;
            this.successCallback = options.successCallback;
            this.renderHeader = options.renderHeader;
            this.spinnerAttachToEl = options.spinnerAttachToEl;
            return this.resourceSelector = new RG.Views.Downtimes.ResourceSelector({
                resources: this.resources,
                selected: this.selectedResources,
                itemClassName: 'multiselect-downtime-item',
                groupClassName: 'multiselect-downtime-group',
                onChange: this.toggleTimeZoneSelector
            });
        };

        NewDowntime.prototype.close = function () {
            if (typeof e !== "undefined" && e !== null) {
                e.stopPropagation();
            }
            return this.trigger("close");
        };

        NewDowntime.prototype.remove = function () {
            var ref, ref1, ref2, ref3;
            if ((ref = this.resourceSelector) != null) {
                ref.remove();
            }
            if ((ref1 = this.dateTimeRangeSelector) != null) {
                ref1.remove();
            }
            if ((ref2 = this.downtimeTypeSelector) != null) {
                ref2.remove();
            }
            if ((ref3 = this.vacationAllowance) != null) {
                ref3.remove();
            }
            return NewDowntime.__super__.remove.apply(this, arguments);
        };

        NewDowntime.prototype.render = function () {
            var html;
            html = [];
            if (this.renderHeader) {
                html.push(this.headerTemplate());
            }
            html.push(this.template());
            this.$el.html(html.join(""));
            this._fillValues();
            this._bindEvents();
            return this;
        };

        NewDowntime.prototype._bindEvents = function () {
            this.$el.on("click", ".chzn-single", (function (_this) {
                return function (e) {
                    return _this.trigger("shrinkDropdown", e);
                };
            })(this));
            this.$el.on("click", (function (_this) {
                return function (e) {
                    var ref;
                    if (!$(e.target).hasClass('js-tooltip')) {
                        return (ref = _this.vacationAllowance) != null ? ref.closeAllPopovers() : void 0;
                    }
                };
            })(this));
            this.$el.on("click", "#cancel", (function (_this) {
                return function (e) {
                    e.preventDefault();
                    e.stopPropagation();
                    return _this.close();
                };
            })(this));
            this.$el.on("click", "#add-downtime", (function (_this) {
                return function (e) {
                    _this.resourceSelector.searchBlur();
                    return Q.delay(15).then(function () {
                        e.preventDefault();
                        e.stopPropagation();
                        return _this.createDowntime();
                    });
                };
            })(this));
            this.$el.on("click", (function (_this) {
                return function () {
                    _this.$('.js-menu-options').hide();
                    RG.Utils.select2Close($(".select2-drop"), true);
                    return _this.resourceSelector.searchBlur();
                };
            })(this));
            return this.dateTimeRangeSelector.on('change', (function (_this) {
                return function (dateRange, timeRange) {
                    _this.dateRange = dateRange;
                    _this.timeRange = timeRange;
                    return _this.trigger('change', dateRange);
                };
            })(this));
        };

        NewDowntime.prototype.validate = function () {
            var flag;
            flag = true;
            if (this.timeZoneSelector) {
                flag = this.dateTimeRangeSelector.validate() & this.timeZoneSelector.validate() & this.resourceSelector.validate();
            } else {
                flag = this.dateTimeRangeSelector.validate() & this.resourceSelector.validate();
            }
            this.trigger('validate');
            return flag;
        };

        NewDowntime.prototype._adjustOverlayForDashboard = function (overlay) {
            var spinner;
            overlay.$el.css({
                left: "-488px",
                top: "14px"
            });
            spinner = overlay.$el.find(".spinner");
            return spinner.css({
                top: "50%",
                left: "50%"
            });
        };

        NewDowntime.prototype.toggleTimeZoneSelector = function () {
            this.selectedResources = this._getResources();
            this.resource = this.selectedResources[0];
            return this._composeTimezoneSelector();
        };

        NewDowntime.prototype.createDowntime = function () {
            var overlay, spinnerAttachToEl;
            spinnerAttachToEl = $(this.spinnerAttachToEl)[0] || $(this.el).closest('.js-booking-downtime-new')[0];
            overlay = RG.Utils.spinnerOverlay(spinnerAttachToEl);
            if (this.spinnerAttachToEl) {
                this._adjustOverlayForDashboard(overlay);
            }
            return Q.delay(20).then((function (_this) {
                return function () {
                    var command, dateTimeRange, resources;
                    dateTimeRange = _this.dateTimeRangeSelector.getValues();
                    resources = _this._getResources();
                    if (!_.any(resources, function (r) {
                        return _this.interactedResource.id === r.id;
                    })) {
                        _this.interactedResource = _this.resource;
                    }
                    if (_this.validate()) {
                        _this.rendererLock = new RG.Renderer.GlobalLock;
                        RG.renderer.lock(_this.rendererLock);
                        command = new RG.Commands.CreateDowntimeCommand({
                            account: _this.resource.account,
                            resources: _this._getResources(),
                            booker: _this._getBooker(),
                            dateTimeRange: dateTimeRange,
                            details: _this._getDetails(),
                            timeZones: _this.timeZones,
                            timeZone: _this._getTimeZone(),
                            type: _this._getType(),
                            preExecuteCallback: function (downtime, durations, shouldDelete) {
                                return RG.renderer.unlock(_this.rendererLock);
                            },
                            successCallback: function (downtime) {
                                RG.renderer.unlock(_this.rendererLock);
                                window.update().then(function () {
                                    RG.Popovers.popoverActive = false;
                                    return RG.Popovers.done();
                                });
                                return typeof _this.successCallback === "function" ? _this.successCallback() : void 0;
                            },
                            errorCallback: function (data) {
                                RG.renderer.unlock(_this.rendererLock);
                                overlay.close();
                                _this.optionView = new RG.Views.Dialogs.ErrorList({
                                    errors: data
                                });
                                return _this.trigger('changeOverlay', _this.optionView, {
                                    className: 'overlay availability-waiting'
                                });
                            },
                            saveErrorCallback: function (e, xhr) {
                                RG.renderer.unlock(_this.rendererLock);
                                overlay.close();
                                _this.$('.downtime-save-error').show();
                                return window.Raven.captureException(e, {
                                    extra: {
                                        account_id: _this.resource.account.id,
                                        resource_ids: _this.resourceSelector.getResourceIds(),
                                        booker_id: _this._getBooker().id,
                                        dateTimeRange: dateTimeRange,
                                        timeZones: _this.timeZones,
                                        timeZone: _this._getTimeZone(),
                                        type: _this._getType(),
                                        xhr: {
                                            responseText: xhr.responseText,
                                            responseStatus: xhr.status
                                        }
                                    }
                                });
                            }
                        });
                        return Q.delay(50).then(function () {
                            return command.willTouchBookings({
                                success: function (bookingsCount) {
                                    var cancelCallback;
                                    cancelCallback = function () {
                                        RG.renderer.unlock(_this.rendererLock);
                                        RG.Popovers.removeCallback = null;
                                        return _this.account.downtimes.remove(command.downtime);
                                    };
                                    _this.optionView = new RG.Views.Dialogs.BookingClashManagement({
                                        command: command,
                                        clashBookingsCount: bookingsCount,
                                        cancelCallback: cancelCallback,
                                        successCallback: function () {
                                            RG.renderer.unlock(_this.rendererLock);
                                            return RG.Popovers.removeCallback = null;
                                        },
                                        userPermissions: RG.Utils.Permissions
                                    });
                                    overlay.close();
                                    _this.trigger('changeOverlay', _this.optionView, {
                                        className: 'overlay availability-waiting'
                                    });
                                    return RG.Popovers.removeCallback = cancelCallback;
                                },
                                fail: function () {
                                    RG.renderer.unlock(_this.rendererLock);
                                    return command.execute();
                                }
                            });
                        });
                    } else {
                        return overlay.close();
                    }
                };
            })(this));
        };

        NewDowntime.prototype._getResourceIds = function () {
            return this.resourceSelector.getResourceIds();
        };

        NewDowntime.prototype._getResources = function () {
            var resourceIds;
            resourceIds = this.resourceSelector.getResourceIds();
            return this.resources.models.filter(function (r) {
                return resourceIds.indexOf(r.id) !== -1;
            });
        };

        NewDowntime.prototype._getBooker = function () {
            return this.bookerSelector.getBooker();
        };

        NewDowntime.prototype._getDetails = function () {
            return this.$('#downtime-details-value').val();
        };

        NewDowntime.prototype._getLeave = function () {
            var data;
            data = {};
            _.each(this.$('.js-vacation-allowance input'), function (input) {
                return data[$(input).attr('data-attribute-year')] = $(input).val();
            });
            return data;
        };

        NewDowntime.prototype._getTimeZone = function () {
            var ref, timeZone;
            timeZone = (ref = this.timeZoneSelector) != null ? ref.getTimeZone() : void 0;
            if (timeZone === "NullTimeZone") {
                timeZone = "";
            }
            return timeZone;
        };

        NewDowntime.prototype._getType = function () {
            var id;
            id = this.$("#downtime-type-options select").val();
            id = (id !== void 0 && id.length && +id) || null;
            return this.downtimeTypes.findWhere({
                id: id
            });
        };

        NewDowntime.prototype._fillValues = function () {
            var booker, dateTimeRange, ref;
            this._composeResourceSelector();
            this._composeDateRangeSelector();
            this._composeDownTimeTypes();
            this._composeTimezoneSelector();
            booker = this.bookers.find({
                id: (ref = this.downtime) != null ? ref.getBooker().id : void 0
            });
            this.bookerSelector = new RG.Views.Selectors.Booker({
                currentUserId: (booker != null ? booker.id : void 0) || this.currentUserId,
                bookers: this.bookers,
                booker: booker
            });
            this.$("dd.js-booker").html(this.bookerSelector.render().el);
            this.$(this.bookerSelector.el).find("select").chosen();
            this.$(this.downtimeTypeSelector.el).chosen();
            dateTimeRange = this.dateTimeRangeSelector.getValues();
            this.timeRange = dateTimeRange.timeRange;
            this.dateRange = dateTimeRange.dateRange;
            return this.$('#add-downtime').text("Add " + (this.resource.getHeadingDowntimeText()));
        };

        NewDowntime.prototype._composeResourceSelector = function () {
            this.$('.js-resource-selector').html(this.resourceSelector.render().el);
            return this.resourceSelector.setFilters([
                {
                    categoryName: 'Person',
                    options: [
                        {
                            matchType: 'any',
                            name: 'Name',
                            selectedOptions: [this.resource.id]
                        }
                    ]
                }
            ]);
        };

        NewDowntime.prototype._composeDateRangeSelector = function () {
            var dateRange;
            this.dateTimeRangeSelector = new RG.Views.Selectors.DateTimeRange({
                resource: this.resource,
                dateRange: this.dateRange,
                timeRange: this.timeRange,
                customValidations: new RG.Validators.DowntimeLengthValidator().validate
            });
            this.dateTimeRangeSelector.on("validate", (function (_this) {
                return function () {
                    return _this.trigger("validate");
                };
            })(this));
            dateRange = this.$(".downtime-date");
            return dateRange.html(this.dateTimeRangeSelector.render().el);
        };

        NewDowntime.prototype._composeDownTimeTypes = function () {
            this.downtimeTypeSelector = new RG.Views.Selectors.DowntimeTypeSelector({
                downtimeTypes: this.downtimeTypes
            });
            return this.$("#downtime-type-options").append(this.downtimeTypeSelector.render().el);
        };

        NewDowntime.prototype._composeTimezoneSelector = function () {
            var ref;
            if ((ref = this.timeZoneSelector) != null) {
                ref.remove();
            }
            this.timeZoneSelector = null;
            if (this._isDifferentTimeZones()) {
                this.$("dd.js-timezone-selector").show();
                this.$('.js-timezone-heading').text('Timezone').show();
                this.timeZoneSelector = new RG.Views.Selectors.TimeZoneSelector({
                    currentUserTimeZone: this.currentUserTimeZone,
                    selectedOption: this.selectedTimeZoneOption,
                    timeZones: this.timeZones
                });
                this.$("dd.js-timezone-selector").html(this.timeZoneSelector.render().el);
                return this.$(this.timeZoneSelector.el).find('select').chosen({
                    width: "100%"
                });
            } else {
                this.$("dd.js-timezone-selector").hide();
                return this.$('.js-timezone-heading').empty().hide();
            }
        };

        NewDowntime.prototype._selectedDowntimeType = function () {
            var ref;
            return (ref = this.downtimeTypes.findWhere({
                id: +this.downtimeTypeSelector.$el.val()
            })) != null ? ref.get('name') : void 0;
        };

        NewDowntime.prototype._isDifferentTimeZones = function () {
            return RG.Utils.isDifferentTimeZones(this.selectedResources, this.currentUserTimeZone);
        };

        return NewDowntime;

    })(RG.Views.BaseView);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.Dialogs.Popover = (function (superClass) {
        extend(Popover, superClass);

        function Popover() {
            return Popover.__super__.constructor.apply(this, arguments);
        }

        Popover.prototype.baseTemplate = templates.find('dialogs/popover');

        Popover.prototype.spinnerOptions = RG.Utils.spinnerOptions;

        Popover.prototype.initialize = function (options) {
            this.$el.on("click", (function (_this) {
                return function (e) {
                    _this._closeOpenDropdowns(e);
                    RG.Popovers.clearNest();
                    return e.stopPropagation();
                };
            })(this));
            this.attachTo = options.attachTo;
            this.bodyView = options.body;
            this.callback = options.callback;
            this.cssClass = options.cssClass || this.cssClass || this.cid;
            this.$el.addClass(options.className);
            this.removeAttachTo = options.removeAttachTo;
            return this._debouncedSetPosition = _.debounce((function (_this) {
                return function () {
                    return _this.setPosition({
                        animate: false
                    });
                };
            })(this), 50);
        };

        Popover.prototype.render = function () {
            this.$el.html(this.baseTemplate({
                cssClass: this.cssClass
            }));
            this._fillValues();
            return this;
        };

        Popover.prototype._closeOpenDropdowns = function (e) {
            var ref;
            return (ref = this.$el.find(".open")) != null ? ref.removeClass("open") : void 0;
        };

        Popover.prototype.remove = function () {
            var ref, ref1;
            $(window).off("resize", this._debouncedSetPosition);
            if (this.removeAttachTo) {
                $(this.attachTo).remove();
            }
            if ((ref = this.overlay) != null) {
                ref.remove();
            }
            if ((ref1 = this.bodyView) != null) {
                ref1.remove();
            }
            if (typeof this.callback === "function") {
                this.callback();
            }
            if ($(".dropdown-content").length === 0) {
                RG.Utils.enableScrolling(true);
            }
            return Popover.__super__.remove.apply(this, arguments);
        };

        Popover.prototype.popup = function () {
            var $attachTo;
            RG.closeAllSelections();
            this.render();
            $attachTo = $(this.attachTo);
            $attachTo.append(this.el);
            this.setPosition();
            $(window).on("resize", this._debouncedSetPosition);
            return RG.Popovers.locked = false;
        };

        Popover.prototype.setBodyView = function (view, options) {
            var content;
            if (options == null) {
                options = {
                    render: true
                };
            }
            if (this.removeFunc == null) {
                this.removeFunc = (function (_this) {
                    return function () {
                        _this.remove();
                        return RG.Popovers.popoverActive = false;
                    };
                })(this);
            }
            if (this.bodyView) {
                this.bodyView.remove();
            }
            this.bodyView = view;
            content = this._getContentPanel();
            while (content != null ? content.firstChild : void 0) {
                content.removeChild(content.firstChild);
            }
            if (options.className) {
                this.$el.addClass(options.className);
            }
            if (options.render) {
                this.bodyView.render();
            }
            if (content) {
                content.appendChild(this.bodyView.el);
            } else {
                this.render();
            }
            this.bodyView.on("shrinkDropdown", (function (_this) {
                return function (el) {
                    return _this.shrinkDropdown(el);
                };
            })(this));
            this.bodyView.on("hide", (function (_this) {
                return function () {
                    return _this.$el.hide();
                };
            })(this));
            this.bodyView.on("show", (function (_this) {
                return function () {
                    return _this.$el.show();
                };
            })(this));
            this.bodyView.on("close", this.removeFunc);
            this.bodyView.on("changeView", this.setBodyView, this, options);
            this.bodyView.on("changeOverlay", this.setOverlay, this);
            this.bodyView.on("changeView", this.setPosition, this);
            return this.bodyView.on("updatePosition", this._updateAndReposition, this);
        };

        Popover.prototype._updateAndReposition = function () {
            return window.requestAnimationFrame((function (_this) {
                return function () {
                    _this.setPosition();
                    return $(window).trigger('scroll');
                };
            })(this));
        };

        Popover.prototype._getContentPanel = function () {
            return this.el.querySelector(".dropdown-content");
        };

        Popover.prototype.setPosition = function (arg) {
            var animate, baseTopOffset, contentHeight, main, offset, scrollable, shadowMargin, shadowTopOffset, windowBottom;
            animate = (arg != null ? arg : {
                animate: true
            }).animate;
            this.$el.css('visibility', 'visible');
            this.$(".shadow-arrow").css({
                top: ""
            });
            this.$el.css({
                top: "",
                left: ""
            });
            this.$(".f-dropdown").removeClass("cdrop-left").removeClass("cdrop-right");
            this.$(".f-dropdown .dropdown-content").css({
                "max-height": $(window).height()
            });
            this.$(".f-dropdown .dropdown-content main").css({
                "max-height": $(window).height() - this.$(".f-dropdown .dropdown-content header, .f-dropdown .dropdown-content .tabs").height() - 130
            });
            this._setOpenDirection();
            baseTopOffset = -20;
            offset = this.$el.offset();
            windowBottom = $(window).scrollTop() + $(window).height();
            shadowMargin = parseInt(this.$(".shadow-arrow").css("margin-top"), 10);
            if (offset.top + shadowMargin > windowBottom - 40) {
                $(window).scrollTop($(window).scrollTop() + 40 + shadowMargin + offset.top - windowBottom);
            }
            windowBottom = $(window).scrollTop() + $(window).height();
            contentHeight = this.$el.children(0).outerHeight();
            if (windowBottom - contentHeight - $(window).scrollTop() - 20 < 0) {
                baseTopOffset = -offset.top + $(window).scrollTop() + 60;
            } else {
                baseTopOffset = _.min([-20, -(offset.top + contentHeight - windowBottom) + 20]);
            }
            shadowTopOffset = -baseTopOffset + 10;
            this.$(".shadow-arrow").css({
                top: shadowTopOffset
            });
            this.$el.css({
                position: 'absolute',
                top: baseTopOffset
            });
            this._scrollIntoHorizontalView(animate);
            main = this.el.querySelector(".f-dropdown .dropdown-content main");
            scrollable = !!(main && main.scrollHeight > main.offsetHeight) && main.querySelectorAll(".chzn-drop").length === 0;
            this.$el.toggleClass("is-scrollable", scrollable);
        };

        Popover.prototype.setOverlay = function (view, options) {
            var ref, removeFunc, removeOverlayClassFunc;
            if (options == null) {
                options = {
                    className: 'overlay'
                };
            }
            removeOverlayClassFunc = (function (_this) {
                return function () {
                    return _this.$el.removeClass("has-overlay");
                };
            })(this);
            removeFunc = function () {
                removeOverlayClassFunc();
                return typeof options.removeCallback === "function" ? options.removeCallback() : void 0;
            };
            if ((ref = this.overlay) != null) {
                ref.remove();
            }
            this.overlay = new RG.Views.Dialogs.Overlay({
                attachTo: this.el,
                template: function () {
                    return view.render().el;
                },
                className: options.className,
                removeCallback: removeFunc,
                bodyView: view
            });
            this.overlay.render();
            return this.$el.addClass("has-overlay");
        };

        Popover.prototype._fillValues = function () {
            if (this.bodyView) {
                return this.setBodyView(this.bodyView);
            }
        };

        Popover.prototype._setOpenDirection = function () {
            var droppingLeft, ref;
            droppingLeft = this._getOpenDirection() === "left";
            if (droppingLeft) {
                this._setOpenLeft();
            } else {
                this._setOpenRight();
            }
            return (ref = this.attachTo) != null ? typeof ref.callback === "function" ? ref.callback(false) : void 0 : void 0;
        };

        Popover.prototype._getOpenDirection = function () {
            var $window, offset, width, windowRight;
            $window = $(window);
            windowRight = $window.scrollLeft() + $window.width();
            offset = this.$el.offset();
            width = $(this.el.firstChild).outerWidth();
            if (this.openDirection === "left" || windowRight <= offset.left + width + RG.getUnitWidth() + 14) {
                return "left";
            } else {
                return "right";
            }
        };

        Popover.prototype._setOpenTop = function () {
            var topPosition;
            this.verticalDirection = "top";
            topPosition = $(this.el.firstChild).outerHeight();
            this.$el.css({
                top: -topPosition
            });
            return this.$(".f-dropdown").addClass("cdrop-top");
        };

        Popover.prototype._setOpenLeft = function () {
            var leftPosition;
            leftPosition = $(this.el.firstChild).outerWidth();
            this.$el.css({
                left: -leftPosition - 40
            });
            this.$(".f-dropdown").addClass("cdrop-left");
            return this.$(".f-dropdown").removeClass("cdrop-right");
        };

        Popover.prototype._setOpenRight = function () {
            this.$(".f-dropdown").addClass("cdrop-right");
            this.$(".f-dropdown").removeClass("cdrop-left");
            return this.$el.css({
                left: 27
            });
        };

        Popover.prototype._scrollIntoVerticalView = function () {
            var dropdownRect, elRect, offset;
            offset = this.$el.offset();
            elRect = this.el.getBoundingClientRect();
            if (elRect.top < 0) {
                $("html, body").animate({
                    scrollTop: offset.top - 10
                }, 300);
            }
            dropdownRect = this.el.querySelector(".f-dropdown").getBoundingClientRect();
            if (dropdownRect.bottom > $(window).height()) {
                return $("html, body").animate({
                    scrollTop: offset.top + (this.$(".f-dropdown").height() * 2) - $(window).height()
                }, 300);
            }
        };

        Popover.prototype._scrollIntoHorizontalView = function (animate) {
            var cardsWidth, offset, rect, scrollFunc, targetLeft;
            if (animate == null) {
                animate = true;
            }
            scrollFunc = function (left) {
                if (animate) {
                    return $("html, body").animate({
                        scrollLeft: left
                    }, 300);
                } else {
                    return $(window).scrollLeft(left);
                }
            };
            offset = this.$el.offset();
            try {
                rect = this.el.querySelector(".f-dropdown").getBoundingClientRect();
            } catch (error) {
                return;
            }
            cardsWidth = $("#calendar > aside").outerWidth();
            if (rect.left < cardsWidth || rect.right > $(window).width()) {
                if ($(".f-dropdown").hasClass("cdrop-right") && rect.left - cardsWidth < 0) {
                    scrollFunc(offset.left - cardsWidth - 40);
                }
                if (rect.left < 0) {
                    this._setOpenRight();
                    offset = this.$el.offset();
                    rect = this.el.querySelector(".f-dropdown").getBoundingClientRect();
                }
                if (rect.right > $(window).width()) {
                    targetLeft = offset.left + rect.width - $(window).width() + RG.getUnitWidth() + 40;
                    if (targetLeft + $(window).width() > $("#resources").width() + cardsWidth) {
                        this._setOpenLeft();
                        offset = this.$el.offset();
                        targetLeft = offset.left - 10;
                    }
                    return scrollFunc(targetLeft);
                }
            }
        };

        Popover.prototype._resetPosition = function () {
            if (this.verticalDirection === "top") {
                return this._setOpenTop();
            }
        };

        return Popover;

    })(RG.Views.BaseView);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.Dialogs.BookingClashManagement = (function (superClass) {
        extend(BookingClashManagement, superClass);

        function BookingClashManagement() {
            return BookingClashManagement.__super__.constructor.apply(this, arguments);
        }

        BookingClashManagement.prototype.template = templates.find('dialogs/booking_clash_management');

        BookingClashManagement.prototype.initialize = function (options) {
            var ref, ref1;
            this.command = options.command;
            this.clashBookingsCount = ((ref = options.clashBookingsCount) != null ? ref.length : void 0) || ((ref1 = this.command) != null ? ref1.getClashingBookings().length : void 0);
            this.cancelCallback = options.cancelCallback;
            this.successCallback = options.successCallback;
            return this.userPermissions = options.userPermissions || RG.Utils.Permissions;
        };

        BookingClashManagement.prototype.render = function () {
            this.$el.html(this.template());
            this._fillValues();
            this._removeDisallowedActions();
            this._bindEvents();
            return this;
        };

        BookingClashManagement.prototype.addToWaitingList = function (e) {
            var overlay;
            e.preventDefault();
            overlay = this._spinner();
            return Q.delay(50).then((function (_this) {
                return function () {
                    if (typeof _this.successCallback === "function") {
                        _this.successCallback();
                    }
                    return _this.command.execute({
                        "delete": false
                    }).then(function () {
                        overlay.close();
                        _this.trigger("close");
                        return RG.Popovers.done();
                    });
                };
            })(this));
        };

        BookingClashManagement.prototype.deleteBookings = function (e) {
            var overlay;
            e.preventDefault();
            overlay = this._spinner();
            return Q.delay(50).then((function (_this) {
                return function () {
                    if (typeof _this.successCallback === "function") {
                        _this.successCallback();
                    }
                    return _this.command.execute({
                        "delete": true
                    }).then(function () {
                        overlay.close();
                        _this.trigger("close");
                        return RG.Popovers.done();
                    });
                };
            })(this));
        };

        BookingClashManagement.prototype.cancel = function (e) {
            e.preventDefault();
            if (typeof this.cancelCallback === "function") {
                this.cancelCallback();
            }
            this.trigger("close");
            return e.stopPropagation();
        };

        BookingClashManagement.prototype._spinner = function () {
            var overlay, parentDropdown;
            parentDropdown = this.$el.closest('.dropdown-anchor').children();
            overlay = RG.Utils.spinnerOverlay(parentDropdown[0]);
            if (this._isRenderedAsOverlay(parentDropdown)) {
                this.$el.hide();
            } else {
                $(overlay.el).find('.dropdown-overlay-backdrop').css('height', parentDropdown.find('.f-dropdown').outerHeight());
                $(overlay.el).find('.spinner').css('margin-top', '-20px');
            }
            return overlay;
        };

        BookingClashManagement.prototype._isRenderedAsOverlay = function ($parent) {
            return $parent.find('.dropdown-overlay-backdrop').length > 1;
        };

        BookingClashManagement.prototype._fillValues = function () {
            this.$(".js-booking-count").text(this.clashBookingsCount + " booking" + (this.clashBookingsCount > 1 ? "s" : ""));
            return this.$(".js-fit-text").text("fit" + (this.clashBookingsCount > 1 ? "" : "s"));
        };

        BookingClashManagement.prototype._bindEvents = function () {
            this.$el.on('click', '.js-add-waiting', this.addToWaitingList.bind(this));
            this.$el.on('click', '.js-delete-bookings', this.deleteBookings.bind(this));
            return this.$el.on('click', '.js-cancel', this.cancel.bind(this));
        };

        BookingClashManagement.prototype._removeDisallowedActions = function () {
            var clashBookings;
            clashBookings = this.command._clashingBookings.map(function (duration) {
                return duration.collection.booking;
            });
            if (!this.userPermissions.canDeleteClashBooking(clashBookings)) {
                this.$(".js-delete-bookings").remove();
            }
            if (!this.userPermissions.canMoveClashBookingToWaitingList(clashBookings)) {
                this.$(".js-add-waiting").remove();
                this.$('.js-fit-text').remove();
                this.$('.js-booking-count').remove();
                this.$(".js-booking-clash-text").text('Some bookings within the date range clash with your time off. Please select dates when time is available instead.');
                return this.$('.js-cancel').text('OK');
            }
        };

        return BookingClashManagement;

    })(RG.Views.BaseView);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.Dialogs.Overlay = (function (superClass) {
        extend(Overlay, superClass);

        function Overlay() {
            return Overlay.__super__.constructor.apply(this, arguments);
        }

        Overlay.prototype.events = {
            "click .js-close": "close",
            "click": "_stopPropagation"
        };

        Overlay.prototype.initialize = function (options) {
            this.template = options.template;
            this.attachTo = options.attachTo;
            this.removeCallback = options.removeCallback;
            return this.bodyView = options.bodyView;
        };

        Overlay.prototype.render = function () {
            var offset;
            this.$el.css("position", "absolute");
            if (this.attachTo) {
                this.$el.width($(this.attachTo.firstChild).outerWidth() - 2);
                this.$el.height($(this.attachTo.firstChild).outerHeight() - 2);
                offset = $(this.attachTo.firstChild).offset();
            }
            this.$el.append(this._renderBackdrop());
            this.$el.append(this._renderModal().addClass("dropdown-overlay"));
            this._bindBodyClose();
            $(this.attachTo).append(this.el);
            if (this.attachTo) {
                this.$el.offset({
                    top: offset.top + 1,
                    left: offset.left + 1
                });
            }
            return this;
        };

        Overlay.prototype.close = function () {
            if (typeof this.removeCallback === "function") {
                this.removeCallback();
            }
            return this.remove();
        };

        Overlay.prototype._renderBackdrop = function () {
            var $backdrop;
            $backdrop = $(document.createElement("div"));
            $backdrop.width("100%");
            $backdrop.height("100%");
            $backdrop.addClass("dropdown-overlay-backdrop");
            return $backdrop;
        };

        Overlay.prototype._bindBodyClose = function () {
            if (this.bodyView) {
                return this.bodyView.on('close', (function (_this) {
                    return function () {
                        _this.bodyView.off();
                        _this.bodyView.remove();
                        return _this.close();
                    };
                })(this));
            }
        };

        Overlay.prototype._renderModal = function () {
            return $(this.template());
        };

        Overlay.prototype._stopPropagation = function (e) {
            return e.stopPropagation();
        };

        return Overlay;

    })(RG.Views.BaseView);

}).call(this);
;
(function () {
    RG.Views.Factories.NameSearch = (function () {
        function NameSearch(resources1) {
            this.resources = resources1;
        }

        NameSearch.prototype.create = function (options) {
            var allOptions, filterableResources, filteredOptions, menu, searchGroupModel, visibleResources;
            if (options == null) {
                options = {};
            }
            searchGroupModel = new RG.Models.OptionGroup;
            visibleResources = this.resources.filter(function (resource) {
                return resource.visible;
            });
            filterableResources = this._getFilterableResources(this.resources.models);
            allOptions = this._mapResources(filterableResources);
            filteredOptions = this._mapResources(visibleResources);
            searchGroupModel.options.reset(allOptions);
            if (options.showMenu) {
                menu = new RG.Views.Filters.QuickSearchMenu({
                    optionGroup: searchGroupModel,
                    filteredOptions: filteredOptions,
                    allResourceOptions: allOptions,
                    savedFilters: RG.Utils.getLastUsedFilters()
                });
                return new RG.Views.Filters.QuickSearchWithMenu({
                    menu: menu,
                    optionGroup: searchGroupModel,
                    cssClass: options.cssClass,
                    resourceSelector: options.resourceSelector
                });
            }
            return new RG.Views.Filters.QuickSearch({
                optionGroup: searchGroupModel,
                cssClass: options.cssClass,
                resourceSelector: options.resourceSelector
            });
        };

        NameSearch.prototype._getFilterableResources = function (resources) {
            return resources.filter(function (r) {
                return r.isBookable();
            });
        };

        NameSearch.prototype._mapResources = function (resources) {
            return resources.map(function (r) {
                return new RG.Models.FilterOption({
                    id: r.id,
                    name: r.get('name'),
                    tag: 'quick_search',
                    ref: r,
                    type: r.get('resourceType').getName()
                });
            });
        };

        return NameSearch;

    })();

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.Filters.OptionGroup = (function (superClass) {
        extend(OptionGroup, superClass);

        function OptionGroup() {
            return OptionGroup.__super__.constructor.apply(this, arguments);
        }

        OptionGroup.prototype.template = templates.find('filters/option_group');

        OptionGroup.prototype.className = "filter__options-container";

        OptionGroup.prototype.events = {
            "change select": "triggerChangeFilter",
            "select2-open select.filter-option": 'focus'
        };

        OptionGroup.prototype.clearSelection = function () {
            this.getFilterOptionSelect().val([]);
            this.getFilterOptionSelect().trigger("change");
            this.$(".filter-option .select2-search-field .select2-input").width("290px");
            return this.trigger("change:filter");
        };

        OptionGroup.prototype.getFilterOptionSelect = function () {
            return this.$("select.filter-option");
        };

        OptionGroup.prototype.getMatchType = function () {
            return this.switchValue;
        };

        OptionGroup.prototype.focus = function (e) {
            return $("select.filter-option").not(this.$("select.filter-option")).select2("close");
        };

        OptionGroup.prototype.focusMatchType = function () {
            return $("select.filter-option").select2("close");
        };

        OptionGroup.prototype.getOptions = function () {
            return {
                name: this.optionGroup.getName(),
                id: this.optionGroup.getTagId(),
                matchType: this.getMatchType(),
                selectedOptions: this.getFilterOptionSelect().val(),
                type: this.optionGroup.getType()
            };
        };

        OptionGroup.prototype.getSelectedOptions = function () {
            var selectedOptions, values;
            values = this.getFilterOptionSelect().val();
            if (!values) {
                return null;
            }
            selectedOptions = values.map((function (_this) {
                return function (id) {
                    return _this.optionGroup.options.findWhere({
                        id: parseInt(id, 10)
                    });
                };
            })(this));
            return {
                optionGroup: this.optionGroup,
                selectedOptions: selectedOptions,
                matchType: this.getMatchType()
            };
        };

        OptionGroup.prototype.initialize = function (options) {
            return this.optionGroup = options.optionGroup;
        };

        OptionGroup.prototype.render = function () {
            this.$el.html(this.template());
            this._fillValues();
            return this;
        };

        OptionGroup.prototype.setFilters = function (filters) {
            var category, filter, i, len, option, results;
            category = this.optionGroup.collection.category;
            results = [];
            for (i = 0, len = filters.length; i < len; i++) {
                filter = filters[i];
                if (category.get('name') === filter.categoryName) {
                    results.push((function () {
                        var j, len1, ref, results1;
                        ref = filter.options;
                        results1 = [];
                        for (j = 0, len1 = ref.length; j < len1; j++) {
                            option = ref[j];
                            if ((option.id && option.id === this.optionGroup.getTagId()) || ((option.id == null) && option.name === this.optionGroup.getName())) {
                                results1.push(this.getFilterOptionSelect().val(option.selectedOptions).trigger("change"));
                            }
                        }
                        return results1;
                    }).call(this));
                }
            }
            return results;
        };

        OptionGroup.prototype.triggerChangeFilter = function () {
            return this.trigger("change:filter", this.optionGroup, this.getSelectedOptions());
        };

        OptionGroup.prototype._createMatchAllOrAny = function () {
            var container, options;
            container = this.$('.match-type');
            container.append('any &nbsp;<span/>&nbsp; all');
            options = {
                mode: 'a-b',
                left: 'any',
                right: 'all'
            };
            this.switchValue = 'any';
            if (this.optionGroup.get("multiple")) {
                options.onChange = (function (_this) {
                    return function (val) {
                        _this.switchValue = val;
                        return _this.triggerChangeFilter();
                    };
                })(this);
            } else {
                options.selected = 'any';
                options.disabled = true;
            }
            return RGComponents.createSwitch(container.find('span').get(0), options);
        };

        OptionGroup.prototype._fillValues = function () {
            this.getFilterOptionSelect().html(this._getSelectOptions());
            this.getFilterOptionSelect().select2({
                placeholder: this._getPlaceholderText(),
                allowClear: true
            });
            return this._createMatchAllOrAny();
        };

        OptionGroup.prototype._getPlaceholderText = function () {
            return (this.optionGroup.getName()) + " - select one or more";
        };

        OptionGroup.prototype._getSelectOptions = function () {
            var html, i, len, option, ref;
            html = [];
            ref = this.optionGroup.options.models;
            for (i = 0, len = ref.length; i < len; i++) {
                option = ref[i];
                html.push("<option value=\"" + option.id + "\">" + (_.unescape(option.getName())) + "</option>");
            }
            return html.join("");
        };

        return OptionGroup;

    })(RG.Views.BaseView);

}).call(this);
;
(function () {
    var bind = function (fn, me) { return function () { return fn.apply(me, arguments); }; },
        extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.Filters.QuickSearch = (function (superClass) {
        extend(QuickSearch, superClass);

        function QuickSearch() {
            this.searchBlur = bind(this.searchBlur, this);
            this.searchFocused = bind(this.searchFocused, this);
            return QuickSearch.__super__.constructor.apply(this, arguments);
        }

        QuickSearch.prototype.resourceSelectorTemplate = templates.find('downtimes/resource_selector');

        QuickSearch.prototype.events = {
            "change select": "triggerChangeFilter",
            "focus .select2-input": 'searchFocused',
            "blur .select2-input": 'searchBlur'
        };

        QuickSearch.prototype.initialize = function (options) {
            var view;
            QuickSearch.__super__.initialize.apply(this, arguments);
            this.controls = options.controls;
            this.cssClass = options.cssClass;
            this.callback = options.callback;
            this.resourceSelector = options.resourceSelector;
            view = this;
            return $("#root nav").on('click', function (e) {
                return view.closeQuickSearch();
            });
        };

        QuickSearch.prototype._fillValues = function () {
            return this._renderOptions();
        };

        QuickSearch.prototype._renderOptions = function () {
            this.getFilterOptionSelect().html(this._getSelectOptions());
            return this.getFilterOptionSelect().select2({
                placeholder: this._getPlaceholderText(),
                formatResult: function (result, container, query, escapeMarkup) {
                    var markup;
                    markup = ["<div class=\"resource-quick-search-entry\" title=\"" + (escapeMarkup(this.text(result))) + "\">"];
                    window.Select2.util.markMatch(this.text(result), query.term, markup, escapeMarkup);
                    markup.push(['</div>']);
                    return markup.join("");
                }
            });
        };

        QuickSearch.prototype._getPlaceholderText = function () {
            return "Name Search";
        };

        QuickSearch.prototype.triggerChangeFilter = function (e) {
            this.focused = false;
            if (e.removed && this.getSelectedOptions() === null) {
                RG.spin(this.$('.select2-container')[0]);
                return window.requestAnimationFrame((function (_this) {
                    return function () {
                        return _this.bubbleChanges();
                    };
                })(this));
            } else {
                return this.bubbleChanges();
            }
        };

        QuickSearch.prototype.bubbleChanges = function () {
            this.validate();
            this.trigger("change:filter", this.optionGroup, this.getSelectedOptions());
            if (this.$('.select2-container-disabled').length) {
                return this.searchBlur();
            }
        };

        QuickSearch.prototype.searchFocused = function (e) {
            $('.select2-drop-active:not(#select2-drop)').hide();
            return window.requestAnimationFrame((function (_this) {
                return function () {
                    RG.Popovers.clear();
                    if (_this._isSearchFocused()) {
                        return;
                    }
                    return Q.delay(150).then(function () {
                        _this.$('.select2-input').focus();
                        _this.$('.select2-choices').click();
                        return RG.spin();
                    });
                };
            })(this));
        };

        QuickSearch.prototype.toggle = function (toggle) {
            if (toggle) {
                return $('#select2-drop-mask').trigger('click');
            } else {
                this.$("select.filter-option").select2('enable', true);
                return this.searchBlur();
            }
        };

        QuickSearch.prototype.searchBlur = function (e) {
            return window.requestAnimationFrame((function (_this) {
                return function () {
                    if ($("li." + _this.cssClass).length === 0) {
                        _this.focused = false;
                        _this.togglePlaceholder(false);
                        if (_this.isMultiple()) {
                            $(_this.el).removeClass('search-hover');
                            _this.addAllPill();
                        }
                    }
                    return _this.$('.select2-input').trigger('blur');
                };
            })(this));
        };

        QuickSearch.prototype.isMultiple = function () {
            return this.$('.select2-choices').find('li.select2-search-choice').length > 1;
        };

        QuickSearch.prototype.togglePlaceholder = function (focused) {
            var input, ref, ref1;
            if (((ref = $('html')) != null ? (ref1 = ref.attr('class')) != null ? ref1.indexOf('ie') : void 0 : void 0) === -1) {
                input = this.$('.select2-input');
                if (this.getFilterOptionSelect().val()) {
                    return input.attr('placeholder', '');
                } else {
                    if (focused) {
                        return input.attr('placeholder', 'Select one or more');
                    } else {
                        return input.attr('placeholder', this._getPlaceholderText());
                    }
                }
            }
        };

        QuickSearch.prototype.addAllPill = function () {
            var choices, html, plural, selected_options_length;
            if (this.$('.all-pill').length === 0) {
                html = [];
                choices = this.$('.select2-choices');
                selected_options_length = choices.find('li.select2-search-choice').length;
                plural = "resources";
                if (selected_options_length < 2) {
                    plural = "resource";
                }
                html.push("<li class='all-pill select2-search-choice'>");
                html.push("<div>" + selected_options_length + " " + plural + " selected</div>");
                html.push("<a href=\"#\" class=\"all-pill-remove select2-search-choice-close\" tabindex=\"-1\"></a>");
                html.push("</li>");
                choices.prepend(html.join(''));
                return this.bindAllPill();
            }
        };

        QuickSearch.prototype.bindAllPill = function () {
            if (!this.allPillBound) {
                this.$('.select2-choices').on('click', '.all-pill-remove', (function (_this) {
                    return function () {
                        return _this.clearAll();
                    };
                })(this));
                this.allPillBound = true;
            }
            this.$('.all-pill').off();
            return this.$('.all-pill').on('click', (function (_this) {
                return function (e) {
                    return _this.$('.select2-input').click();
                };
            })(this));
        };

        QuickSearch.prototype.clearAll = function () {
            window.rgStorage["delete"]('lastActiveFilterId');
            RG.spin(this.$('.select2-container')[0]);
            this.removeAllPill();
            this.$('.select2-choices li.select2-search-choice').hide();
            return this.clearSelection();
        };

        QuickSearch.prototype.clearSelection = function () {
            return setTimeout((function (_this) {
                return function () {
                    _this.getFilterOptionSelect().val([]).trigger('change');
                    return RG.spin(_this.$('.select2-container')[0]);
                };
            })(this), 16);
        };

        QuickSearch.prototype.removeAllPill = function () {
            return this.$('.all-pill').remove();
        };

        QuickSearch.prototype.getResourceIds = function () {
            var ref, selectedOptions;
            selectedOptions = (ref = this.getSelectedOptions()) != null ? ref.selectedOptions : void 0;
            if (!selectedOptions) {
                return [];
            }
            return _.collect(selectedOptions, function (so) {
                return so.id;
            });
        };

        QuickSearch.prototype._getOptions = function () {
            return _.groupBy(this.optionGroup.options.models, function (e) {
                return e.get('type');
            });
        };

        QuickSearch.prototype._getSelectOptions = function () {
            var categories, category, html, i, len, option, options;
            categories = this._getOptions();
            html = [];
            for (category in categories) {
                options = categories[category];
                if (options.length) {
                    html.push("<optgroup class='" + this.cssClass + "' label=\"" + category + "\">");
                    for (i = 0, len = options.length; i < len; i++) {
                        option = options[i];
                        html.push("<option value=\"" + option.id + "\">" + (option.getName()) + "</option>");
                    }
                    html.push("</optgroup>");
                }
            }
            return html.join("");
        };

        QuickSearch.prototype.setFilters = function (filters) {
            var filter, i, j, len, len1, option, ref, selectedOptions;
            selectedOptions = [];
            for (i = 0, len = filters.length; i < len; i++) {
                filter = filters[i];
                ref = filter.options;
                for (j = 0, len1 = ref.length; j < len1; j++) {
                    option = ref[j];
                    if (option.name === 'Name') {
                        selectedOptions.push(option.selectedOptions);
                    }
                }
            }
            return this.getFilterOptionSelect().val(_.flatten(_.compact(selectedOptions))).trigger("change");
        };

        QuickSearch.prototype.setSearchHeigth = function (e) {
            var options, ref;
            options = this.searchGroup.getSelectedOptions();
            this.quickSearchCount = options != null ? (ref = options.selectedOptions) != null ? ref.length : void 0 : void 0;
            return this.$('#quick-search').addClass('search-hover');
        };

        QuickSearch.prototype.setDropMaskOffset = function () {
            var offset;
            offset = 60 + (20 * this.getFilterOptionSelect().val().length);
            return $('#select2-drop-mask').offset({
                top: "" + offset
            });
        };

        QuickSearch.prototype.closeQuickSearch = function () {
            RG.closeAllSelections();
            this.focused = false;
            this.togglePlaceholder(false);
            if (this.isMultiple()) {
                this.addAllPill();
            }
            return $(this.el).removeClass('search-hover');
        };

        QuickSearch.prototype.remove = function () {
            return QuickSearch.__super__.remove.apply(this, arguments);
        };

        QuickSearch.prototype.render = function () {
            this.$el.html(this._template());
            this._fillValues();
            this.$(".match-type-select").select2({
                minimumResultsForSearch: 10
            });
            setTimeout((function (_this) {
                return function () {
                    return _this.searchBlur();
                };
            })(this), 1000);
            return this;
        };

        QuickSearch.prototype.validate = function () {
            if (this.getResourceIds().length > 0) {
                this.$el.find('.error').hide();
                return true;
            } else {
                this.$el.find('.error').show();
                return false;
            }
        };

        QuickSearch.prototype._template = function () {
            if (this.resourceSelector) {
                return this.resourceSelectorTemplate;
            }
            return this.template;
        };

        QuickSearch.prototype._isSearchFocused = function () {
            var ref, ref1;
            if (typeof this.callback === "function") {
                this.callback();
            }
            RG.closeAllDropdowns();
            if (this.focused) {
                return true;
            }
            this.removeAllPill();
            this.$el.addClass('search-hover');
            this.togglePlaceholder(true);
            this._scroll();
            this._bindDropMask();
            if ((ref = $(".match-type-select.select2-container-active")) != null) {
                if ((ref1 = ref.data('select2')) != null) {
                    ref1.close();
                }
            }
            this.focused = true;
            return false;
        };

        QuickSearch.prototype._bindDropMask = function () {
            return $("#select2-drop-mask").on("mousedown touchstart click", (function (_this) {
                return function (e) {
                    return _this.searchBlur(e);
                };
            })(this));
        };

        QuickSearch.prototype._scroll = function () {
            return $(document).trigger("scroll");
        };

        return QuickSearch;

    })(RG.Views.Filters.OptionGroup);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.Filters.QuickSearchMenu = (function (superClass) {
        extend(QuickSearchMenu, superClass);

        function QuickSearchMenu() {
            return QuickSearchMenu.__super__.constructor.apply(this, arguments);
        }

        QuickSearchMenu.prototype.template = templates.find('filters/quick_search_menu');

        QuickSearchMenu.prototype.initialize = function (options) {
            this.optionGroup = options.optionGroup;
            this.filteredOptions = options.filteredOptions;
            return this.allResourceOptions = options.allResourceOptions;
        };

        QuickSearchMenu.prototype.render = function () {
            this.$el.html(this.template());
            this._bindEvents();
            return this;
        };

        QuickSearchMenu.prototype._bindEvents = function () {
            this.$el.on("click", 'i', (function (_this) {
                return function (e) {
                    return _this._toggleMenu(e);
                };
            })(this));
            this.$el.on("click", '.js-clear-resources', (function (_this) {
                return function () {
                    return _this._clearAllSelectedOptions();
                };
            })(this));
            this.$el.on("click", '.js-currently-filtered', (function (_this) {
                return function () {
                    return _this._setToCurrentlyFilteredResources();
                };
            })(this));
            this.$el.on("click", '.js-all-people', (function (_this) {
                return function () {
                    return _this._setToAllPeople();
                };
            })(this));
            return this.$el.on("click", '.js-all-resources', (function (_this) {
                return function () {
                    return _this._setToAllResources();
                };
            })(this));
        };

        QuickSearchMenu.prototype._toggleMenu = function (e) {
            e.preventDefault();
            e.stopPropagation();
            this.trigger('menuClicked');
            return this.$('.js-menu-options').toggle();
        };

        QuickSearchMenu.prototype.hide = function () {
            return this.$('.js-menu-options').hide();
        };

        QuickSearchMenu.prototype._clearAllSelectedOptions = function () {
            return this.trigger('change', []);
        };

        QuickSearchMenu.prototype._setToAllPeople = function () {
            var filters, ids;
            this.optionGroup.options.reset(this.allResourceOptions);
            ids = _.chain(this.optionGroup.options.models).select(function (option) {
                return option.get('type') === 'Person';
            }).collect(function (option) {
                return option.id;
            }).value();
            filters = [
                {
                    categoryName: 'Person',
                    options: [
                        {
                            matchType: 'any',
                            name: 'Name',
                            selectedOptions: ids
                        }
                    ]
                }
            ];
            return this.trigger('change', filters);
        };

        QuickSearchMenu.prototype._setToCurrentlyFilteredResources = function () {
            this.optionGroup.options.reset(this.filteredOptions);
            return this._triggerChange();
        };

        QuickSearchMenu.prototype._setToAllResources = function () {
            this.optionGroup.options.reset(this.allResourceOptions);
            return this._triggerChange();
        };

        QuickSearchMenu.prototype._triggerChange = function () {
            var filters, ids;
            ids = this.optionGroup.options.collect(function (option) {
                return option.id;
            });
            filters = [
                {
                    categoryName: 'Person',
                    options: [
                        {
                            matchType: 'any',
                            name: 'Name',
                            selectedOptions: ids
                        }
                    ]
                }
            ];
            this.trigger('change', filters);
            return this.optionGroup.options.reset(this.allResourceOptions);
        };

        return QuickSearchMenu;

    })(RG.Views.BaseView);

}).call(this);
;
(function () {
    var bind = function (fn, me) { return function () { return fn.apply(me, arguments); }; },
        extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.Filters.QuickSearchWithMenu = (function (superClass) {
        extend(QuickSearchWithMenu, superClass);

        function QuickSearchWithMenu() {
            this.searchFocused = bind(this.searchFocused, this);
            return QuickSearchWithMenu.__super__.constructor.apply(this, arguments);
        }

        QuickSearchWithMenu.prototype.resourceSelectorTemplate = templates.find('downtimes/resource_selector');

        QuickSearchWithMenu.prototype.initialize = function (options) {
            QuickSearchWithMenu.__super__.initialize.apply(this, arguments);
            return this.menu = options.menu;
        };

        QuickSearchWithMenu.prototype._fillValues = function () {
            this.$('.filter__options-control').append(this.menu.render().el);
            this.menu.on('change', (function (_this) {
                return function (filters, reRender) {
                    if (reRender == null) {
                        reRender = false;
                    }
                    _this.trigger('displaySpinner');
                    return Q.delay(10).then(function () {
                        var ref;
                        _this._renderOptions();
                        _this.setFilters(filters);
                        return (ref = _this.overlay) != null ? ref.remove() : void 0;
                    });
                };
            })(this));
            this.menu.on('menuClicked', (function (_this) {
                return function () {
                    return _this.$el.click();
                };
            })(this));
            return QuickSearchWithMenu.__super__._fillValues.apply(this, arguments);
        };

        QuickSearchWithMenu.prototype._renderOptions = function () {
            var element;
            element = this.getFilterOptionSelect();
            element.html(this._getSelectOptions());
            window.view = this;
            element.select2({
                placeholder: this._getPlaceholderText(),
                closeOnSelect: false
            });
            return this.$('.select2-input').on('keyup', (function (_this) {
                return function (e) {
                    var currentIds, option, topMatch;
                    if (e.keyCode === 13) {
                        topMatch = $($('div.select2-result-label')[1]).text();
                        option = _this.optionGroup.options.findWhere({
                            name: topMatch
                        });
                        currentIds = _this.getResourceIds();
                        currentIds.push(option.id);
                        element.val(currentIds).trigger('change');
                        return Q.delay(20).then(function () {
                            _this.$('.select2-input').focus();
                            return _this.$('.select2-choices').click();
                        });
                    }
                };
            })(this));
        };

        QuickSearchWithMenu.prototype.setDropMaskOffset = function () {
            var offset;
            offset = 60 + (20 * this.getFilterOptionSelect().val().length);
            return $('#select2-drop-mask').offset({
                top: "" + offset
            });
        };

        QuickSearchWithMenu.prototype.remove = function () {
            RG.clearStaleDropdowns();
            this.menu.remove();
            return QuickSearchWithMenu.__super__.remove.apply(this, arguments);
        };

        QuickSearchWithMenu.prototype.searchFocused = function (e) {
            return this.menu.hide();
        };

        QuickSearchWithMenu.prototype.searchBlur = function (e) { };

        QuickSearchWithMenu.prototype.addAllPill = function () { };

        QuickSearchWithMenu.prototype.bindAllPill = function () { };

        QuickSearchWithMenu.prototype.removeAllPill = function () { };

        QuickSearchWithMenu.prototype._bindDropMask = function () { };

        return QuickSearchWithMenu;

    })(RG.Views.Filters.QuickSearch);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.Selectors.Booker = (function (superClass) {
        extend(Booker, superClass);

        function Booker() {
            return Booker.__super__.constructor.apply(this, arguments);
        }

        Booker.prototype.initialize = function (options) {
            var ref;
            this.bookers = options.bookers;
            this.booking = options.booking;
            this.currentUserId = options.currentUserId;
            return this.booker = options.booker || ((ref = this.booking) != null ? ref.get('booker') : void 0);
        };

        Booker.prototype.render = function () {
            var ref;
            if ((ref = this.selectBox) != null) {
                ref.remove();
            }
            this.selectBox = $("<select style='width: 288px'></select>").addClass("chzn-select");
            this._fillValues();
            this.$el.html(this.selectBox);
            this.setSelectedValue(this.getCurrentUserBooker().cid);
            return this;
        };

        Booker.prototype._fillValues = function () {
            var b, bookers, i, len, results;
            bookers = this.bookers.select((function (_this) {
                return function (b) {
                    var ref;
                    return !b.get('archived') || b.cid === ((ref = _this.booker) != null ? ref.cid : void 0);
                };
            })(this));
            results = [];
            for (i = 0, len = bookers.length; i < len; i++) {
                b = bookers[i];
                results.push(this.selectBox.append($("<option></option").val(b.cid).text(b.get('name'))));
            }
            return results;
        };

        Booker.prototype.getBooker = function () {
            var val;
            val = this.selectBox.trigger("liszt:updated").val();
            return this.bookers.find(function (b) {
                return b.cid === val;
            });
        };

        Booker.prototype.getCurrentUserBooker = function () {
            return this.bookers.findWhere({
                id: this.currentUserId
            });
        };

        Booker.prototype.setSelectedValue = function (cid) {
            return this.selectBox.val(cid).trigger("liszt:updated");
        };

        return Booker;

    })(RG.Views.BaseView);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.Selectors.DateRange = (function (superClass) {
        extend(DateRange, superClass);

        function DateRange() {
            return DateRange.__super__.constructor.apply(this, arguments);
        }

        DateRange.prototype.dateFormat = "d M yy";

        DateRange.prototype.template = templates.find('selectors/date_range');

        DateRange.prototype.initialize = function (options) {
            this.dateRange = options.dateRange;
            this.resource = options.resource;
            this.customTemplate = options.customTemplate;
            return this.customValidations = options.customValidations || function (view) {
                return true;
            };
        };

        DateRange.prototype.getDateRange = function () {
            var dateRange;
            return dateRange = new RG.Utils.DateRange(this._parseDateString(this._getStartDateEl().val()) || this.dateRange.startDate, this._parseDateString(this._getEndDateEl().val()) || this.dateRange.endDate);
        };

        DateRange.prototype._bindEvents = function () {
            this.$el.on("change", "input#booking-start-date", (function (_this) {
                return function () {
                    return _this._setMinDate();
                };
            })(this));
            this.$el.on("change", "input#booking-end-date", (function (_this) {
                return function () {
                    return _this._setMaxDate();
                };
            })(this));
            this.$el.on("change", "input.js-date-range-input", (function (_this) {
                return function () {
                    return _this.triggerValidate();
                };
            })(this));
            return this.$el.on("change", "input.js-date-range-input", (function (_this) {
                return function () {
                    return _this.triggerChange();
                };
            })(this));
        };

        DateRange.prototype.render = function () {
            var widget;
            if (!this.customTemplate) {
                this.$el.html(this.template());
            }
            this._fillValues();
            this._getStartDateEl().datepicker({
                dateFormat: this.dateFormat,
                firstDay: 1
            });
            widget = this._getStartDateEl().datepicker("widget");
            widget.off();
            widget.on("mousedown mouseup click", function (e) {
                return e.stopPropagation();
            });
            widget.hasStopPropagation = true;
            this._getEndDateEl().datepicker({
                minDate: this.dateRange.startDate,
                dateFormat: this.dateFormat,
                firstDay: 1
            });
            this._bindEvents();
            return this;
        };

        DateRange.prototype.stopPropagation = function (e) {
            return e.stopPropagation();
        };

        DateRange.prototype.toggleError = function (error) {
            return this.$(".help-inline").toggle(error);
        };

        DateRange.prototype.triggerChange = function () {
            return this.trigger("change", this.getDateRange());
        };

        DateRange.prototype.triggerValidate = function () {
            this.validate(true);
            return true;
        };

        DateRange.prototype.validate = function (trigger) {
            return this.customValidations(this) && this._validate(trigger);
        };

        DateRange.prototype._validate = function (trigger) {
            var dateRange, e, error, errors;
            dateRange = null;
            error = false;
            try {
                dateRange = new RG.Utils.DateRange(this._parseDateString(this._getStartDateEl().val()) || this.dateRange.endDate, this._parseDateString(this._getEndDateEl().val()) || this.dateRange.endDate);
            } catch (error1) {
                e = error1;
                error = true;
            }
            if (this._isDateRangeValid(dateRange) && this._isResourceAvailable(dateRange)) {
                error = false;
            } else {
                error = false;
                errors = [];
                if (!this._isDateRangeValid(dateRange)) {
                    errors.push("Please select a start and end date.");
                } else if (!this._isResourceAvailable(dateRange)) {
                    // errors.push("Sorry, you can't start or end a booking on a non-working day. Please change your dates.");
                }
                this._setErrorText(errors.join("<br>"));
            }
            this.toggleError(error);
            if (trigger) {
                this.trigger('validate');
            }
            return !error;
        };

        DateRange.prototype._fillValues = function () {
            this._getStartDateEl().val(this._getDateString(this.dateRange.startDate));
            this._getEndDateEl().val(this._getDateString(this.dateRange.endDate));
            return this.validate();
        };

        DateRange.prototype._getDateString = function (date) {
            return $.datepicker.formatDate(this.dateFormat, date);
        };

        DateRange.prototype._getEndDateEl = function () {
            return this.$("#booking-end-date");
        };

        DateRange.prototype._getStartDateEl = function () {
            return this.$("#booking-start-date");
        };

        DateRange.prototype._isDateRangeValid = function (dateRange) {
            return dateRange && dateRange.startDate && dateRange.endDate;
        };

        DateRange.prototype._isResourceAvailable = function (dateRange) {
            return this.resource.availability.isAvailableStartAndEndDate(dateRange);
        };

        DateRange.prototype._parseDateString = function (dateString) {
            try {
                return $.datepicker.parseDate(this.dateFormat, dateString);
            } catch (error1) {
                return null;
            }
        };

        DateRange.prototype._setErrorText = function (error) {
            return this.$(".help-inline").text(error);
        };

        DateRange.prototype._setMinDate = function () {
            var selectedRange;
            selectedRange = this.getDateRange();
            this._getEndDateEl().datepicker("destroy");
            this._getEndDateEl().datepicker({
                dateFormat: this.dateFormat,
                minDate: selectedRange.startDate,
                firstDay: 1
            });
            if (selectedRange.getNumberOfDays() < 1) {
                return this._getEndDateEl().val(this._getDateString(selectedRange.startDate));
            }
        };

        DateRange.prototype._setMaxDate = function () {
            var selectedRange;
            selectedRange = this.getDateRange();
            if (selectedRange.getNumberOfDays() < 1) {
                return this._getStartDateEl().val(this._getDateString(selectedRange.endDate));
            }
        };

        return DateRange;

    })(RG.Views.BaseView);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.Selectors.DateTimeRange = (function (superClass) {
        extend(DateTimeRange, superClass);

        function DateTimeRange() {
            return DateTimeRange.__super__.constructor.apply(this, arguments);
        }

        DateTimeRange.prototype.template = templates.find('selectors/date_time_range');

        DateTimeRange.prototype.initialize = function (options) {
            this.timeRange = options.timeRange;
            this.dateRange = options.dateRange;
            this.resource = options.resource;
            return this.customValidations = options.customValidations || function (view) {
                return true;
            };
        };

        DateTimeRange.prototype.render = function () {
            this.$el.html(this.template());
            this._fillValues();
            return this;
        };

        DateTimeRange.prototype.getValues = function () {
            return {
                dateRange: this.dateRangeSelector.getDateRange(),
                timeRange: this.timeRangeSelector.getTimeRange()
            };
        };

        DateTimeRange.prototype.validate = function () {
            var result;
            result = this.customValidations(this) && this.dateRangeSelector.validate() && this.timeRangeSelector.validate();
            this.trigger("validate");
            return result;
        };

        DateTimeRange.prototype._fillValues = function () {
            this._composeDateRangeSelector();
            this.dateRangeSelector.render();
            this._composeTimeRangeSelector();
            this._composeValidations();
            return this.timeRangeSelector.render();
        };

        DateTimeRange.prototype._composeDateRangeSelector = function () {
            this.dateRangeSelector = new RG.Views.Selectors.DateRange({
                customTemplate: true,
                dateRange: this.dateRange,
                resource: this.resource,
                el: this.el
            });
            this.dateRangeSelector._isResourceAvailable = function (dateRange) {
                return true;
            };
            return this.dateRangeSelector.on('change', (function (_this) {
                return function (dateRange) {
                    _this.dateRange = dateRange;
                    _this.trigger('change', dateRange, _this.timeRangeSelector.getTimeRange());
                    return _this.validate();
                };
            })(this));
        };

        DateTimeRange.prototype._composeTimeRangeSelector = function () {
            this.timeRangeSelector = new RG.Views.Selectors.TimeRange({
                customTemplate: true,
                startTime: this.timeRange.startTime,
                endTime: this.timeRange.endTime,
                typeName: this.resource.typeName(),
                el: this.el
            });
            this._overWriteTimeRangeValues();
            return this.timeRangeSelector.on('change', (function (_this) {
                return function (timeRange) {
                    _this.trigger('change', _this.dateRangeSelector.getDateRange(), timeRange);
                    return _this.validate();
                };
            })(this));
        };

        DateTimeRange.prototype._composeValidations = function () {
            var validate;
            validate = this.timeRangeSelector.validate.bind(this.timeRangeSelector);
            return this.timeRangeSelector.validate = (function (_this) {
                return function () {
                    if (_this.dateRangeSelector.getDateRange().getNumberOfDays() === 1) {
                        return validate(true);
                    } else {
                        return true;
                    }
                };
            })(this);
        };

        DateTimeRange.prototype._overWriteTimeRangeValues = function () {
            if (this.dateRange.getNumberOfDays() > 1) {
                return this.timeRangeSelector._fillValues = (function (_this) {
                    return function () {
                        var startTime;
                        startTime = _this.timeRangeSelector.$("#booking-start-time");
                        startTime.calendricalTime();
                        _this.timeRangeSelector.$("#booking-end-time").calendricalTime({
                            maxTime: {
                                hour: 24,
                                minute: 0
                            },
                            startDate: _this.dateRangeSelector.$('input#booking-start-date'),
                            endDate: _this.dateRangeSelector.$('input#booking-end-date')
                        });
                        _this.timeRangeSelector.$("#booking-start-time").val(_this.timeRangeSelector._minutesToTime(_this.timeRange.startTime));
                        return _this.timeRangeSelector.$("#booking-end-time").val(_this.timeRangeSelector._minutesToTime(_this.timeRange.endTime));
                    };
                })(this);
            }
        };

        return DateTimeRange;

    })(RG.Views.BaseView);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.Selectors.DowntimeTypeSelector = (function (superClass) {
        extend(DowntimeTypeSelector, superClass);

        function DowntimeTypeSelector() {
            return DowntimeTypeSelector.__super__.constructor.apply(this, arguments);
        }

        DowntimeTypeSelector.prototype.tagName = 'select';

        DowntimeTypeSelector.prototype.initialize = function (options) {
            if (options == null) {
                options = {};
            }
            this.downtimeTypes = options.downtimeTypes;
            return this.selectedOption = options.selectedOption;
        };

        DowntimeTypeSelector.prototype.render = function () {
            var child;
            while (child = this.el.firstChild) {
                this.el.removeChild(child);
            }
            this._fillValues();
            this._bindEvents();
            return this;
        };

        DowntimeTypeSelector.prototype.getSelectedDowntimeType = function () {
            return this.downtimeTypes.findWhere({
                id: +this.$el.val()
            });
        };

        DowntimeTypeSelector.prototype._bindEvents = function () {
            return this.$el.on("change", (function (_this) {
                return function () {
                    return _this.trigger('change', _this.getSelectedDowntimeType());
                };
            })(this));
        };

        DowntimeTypeSelector.prototype._fillValues = function () {
            this.$el.css("width", "288px");
            return this._createDowntimeTypes();
        };

        DowntimeTypeSelector.prototype._createDowntimeTypes = function () {
            var downtimeType, i, len, ref, results;
            this.$el.append('<option selected="selected" value="">&nbsp;</option>');
            ref = this.downtimeTypes.models;
            results = [];
            for (i = 0, len = ref.length; i < len; i++) {
                downtimeType = ref[i];
                results.push(this._createOption(downtimeType));
            }
            return results;
        };

        DowntimeTypeSelector.prototype._createOption = function (downtimeType) {
            var option, ref;
            option = $(document.createElement('option')).val(downtimeType.get('id')).text(downtimeType.get('name'));
            if (downtimeType.cid === ((ref = this.selectedOption) != null ? ref.cid : void 0)) {
                option.attr('selected', 'selected');
            }
            return this.$el.append(option);
        };

        return DowntimeTypeSelector;

    })(RG.Views.BaseView);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.Selectors.TimeRange = (function (superClass) {
        extend(TimeRange, superClass);

        function TimeRange() {
            return TimeRange.__super__.constructor.apply(this, arguments);
        }

        TimeRange.prototype.className = 'specific-time';

        TimeRange.prototype.template = templates.find('selectors/time_range');

        TimeRange.prototype.togglable = true;

        TimeRange.prototype.initialize = function (options) {
            if (typeof options.startTime === 'undefined') {
                this.startTime = 540;
            } else {
                this.startTime = options.startTime;
            }
            this.endTime = options.endTime || 1020;
            if (options.togglable !== void 0) {
                this.togglable = options.togglable;
            }
            this.storageTypeName = options.typeName;
            return this.customTemplate = options.customTemplate;
        };

        TimeRange.prototype.remove = function () {
            return TimeRange.__super__.remove.apply(this, arguments);
        };

        TimeRange.prototype.closeSelector = function () {
            return this.$("#booking-start-time, #booking-end-time").blur();
        };

        TimeRange.prototype.getBookingDurationDTO = function () {
            return new RG.DTO.BookingDuration({
                duration: this.getEndTime() - this.getStartTime(),
                startTime: this.getStartTime()
            });
        };

        TimeRange.prototype.getEndTime = function () {
            var time;
            if (this.getEndTimeStr() === "Start of day") {
                return 0;
            }
            if (this.isEndOfDay()) {
                return 1440;
            }
            time = this._timeToMinutes(this.getEndTimeStr());
            return time || 1440;
        };

        TimeRange.prototype.isEndOfDay = function () {
            return this.getEndTimeStr() === "End of day";
        };

        TimeRange.prototype.getEndTimeStr = function () {
            return this.$("#booking-end-time").val();
        };

        TimeRange.prototype.getStartTime = function () {
            if (this.isStartOfDay()) {
                return 0;
            }
            return this._timeToMinutes(this.getStartTimeStr());
        };

        TimeRange.prototype.getTimeRange = function () {
            return new RG.Utils.TimeRange(this.getStartTime(), this.getEndTime());
        };

        TimeRange.prototype.isStartOfDay = function () {
            return this.getStartTimeStr() === "Start of day";
        };

        TimeRange.prototype.getStartTimeStr = function () {
            return this.$("#booking-start-time").val();
        };

        TimeRange.prototype._bindEvents = function () {
            return this.$el.on("change", "input.js-time-range-input", (function (_this) {
                return function () {
                    return _this.triggerValidate();
                };
            })(this));
        };

        TimeRange.prototype.render = function () {
            if (!this.customTemplate) {
                this.$el.html(this.template());
                this.$(".alt-toggle").toggle(this.togglable);
            }
            this._fillValues();
            this._bindEvents();
            this.validate();
            return this;
        };

        TimeRange.prototype.setEndTime = function (endTime) {
            this.endTime = endTime;
            return this._fillValues();
        };

        TimeRange.prototype.setStartTime = function (startTime) {
            this.startTime = startTime;
            return this._fillValues();
        };

        TimeRange.prototype.toggleError = function (error) {
            return this.$(".help-inline").toggle(error);
        };

        TimeRange.prototype.triggerValidate = function () {
            if (!isNaN(+this.getEndTime())) {
                window.rgStorage.set("TimeRange:EndTime:" + this.storageTypeName, +this.getEndTime());
            }
            if (!isNaN(+this.getStartTime())) {
                window.rgStorage.set("TimeRange:StartTime:" + this.storageTypeName, +this.getStartTime());
            }
            this.validate(true);
            this.trigger('change', this.getTimeRange());
            return true;
        };

        TimeRange.prototype.validate = function (trigger) {
            var error;
            error = false;
            if (this._validated()) {
                error = false;
            } else {
                error = true;
            }
            this.toggleError(error);
            if (trigger) {
                this.trigger('validate', !error);
            }
            return !error;
        };

        TimeRange.prototype._validated = function () {
            var valid;
            this.$el.find('.error').text('Please select a valid start and end time.');
            valid = this.getStartTime() >= 0 && this.getEndTime() <= 1440;
            valid = valid && (!isNaN(this._timeToMinutes(this.$("#booking-end-time").val())) || this.isEndOfDay());
            valid = valid && this.getEndTime() > this.getStartTime();
            if (!valid) {
                this.$el.find('.error').text('Start time must be before end time');
            }
            return valid && this._validateTimeStringRange(this.getStartTimeStr(), false) && this._validateTimeStringRange(this.getEndTimeStr(), true);
        };

        TimeRange.prototype._fillValues = function () {
            this._calendrical || (this._calendrical = this.$("#booking-start-time, #booking-end-time").calendricalTimeRange());
            this.$("#booking-start-time").val(this._minutesToTime(this.startTime));
            return this.$("#booking-end-time").val(this._minutesToTime(this.endTime));
        };

        TimeRange.prototype._minutesToTime = function (minutes) {
            var flag, hour, minuteStr;
            hour = Math.floor(minutes / 60);
            minutes = minutes % 60;
            flag = hour >= 12 && hour !== 24 ? "pm" : "am";
            minuteStr = minutes.toString();
            if (minuteStr.length === 1) {
                minuteStr = "0" + minuteStr;
            }
            if (hour === 0 && minutes === 0) {
                return 'Start of day';
            }
            if (hour === 24 && minutes === 0) {
                return 'End of day';
            }
            if (hour > 12) {
                hour = hour - 12;
            }
            if (hour === 0) {
                hour = 12;
            }
            return hour + ":" + minuteStr + flag;
        };

        TimeRange.prototype._timeToMinutes = function (time) {
            var flag, hours, hoursStr, minutes;
            hoursStr = time.substr(0, time.indexOf(":"));
            hours = parseInt(hoursStr, 10);
            minutes = parseInt(time.substr(hoursStr.length + 1, 2), 10);
            flag = time.substr(time.length - 2, 2);
            if (hours >= 12) {
                hours -= 12;
            }
            if (flag.toLowerCase() !== "am") {
                hours += 12;
            }
            return (hours * 60) + minutes;
        };

        TimeRange.prototype._validateTimeStringRange = function (time, end_parameter) {
            var flag, hours, hoursStr, minutes, total_minutes;
            hoursStr = time.substr(0, time.indexOf(":"));
            hours = parseInt(hoursStr, 10);
            minutes = parseInt(time.substr(hoursStr.length + 1, 2), 10);
            if (time === "Start of day") {
                minutes = 0;
                hours = 0;
            }
            if (time === "End of day") {
                minutes = 0;
                hours = 24;
            }
            if (time === "Start of day") {
                flag = "AM";
            } else if (time === "End of day") {
                flag = "PM";
            } else {
                flag = time.substr(time.length - 2, 2);
            }
            if (flag.toLowerCase() !== "am" && flag.toLowerCase() !== "pm") {
                return false;
            }
            if (minutes >= 60 || minutes < 0) {
                return false;
            }
            if (flag.toLowerCase() === "am" && !end_parameter && hours >= 13) {
                return false;
            }
            if (flag.toLowerCase() === "am" && end_parameter && hours >= 13) {
                return false;
            }
            if (hours >= 12) {
                hours -= 12;
            }
            if (flag.toLowerCase() !== "am") {
                hours += 12;
            }
            total_minutes = (hours * 60) + minutes;
            if (flag.toLowerCase() === "am" && end_parameter && total_minutes > 1440) {
                return false;
            }
            if (flag.toLowerCase() === "am" && !end_parameter) {
                if (total_minutes < 0 || total_minutes >= 720) {
                    return false;
                }
            }
            if (flag.toLowerCase() === "pm" && end_parameter) {
                if (total_minutes > 1440 || total_minutes < 720) {
                    return false;
                }
            }
            return true;
        };

        return TimeRange;

    })(RG.Views.BaseView);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.Selectors.TimeZoneSelector = (function (superClass) {
        extend(TimeZoneSelector, superClass);

        function TimeZoneSelector() {
            return TimeZoneSelector.__super__.constructor.apply(this, arguments);
        }

        TimeZoneSelector.prototype.initialize = function (options) {
            this.timeZones = options.timeZones;
            this.selectedOption = options.selectedOption;
            this.resourceLocalTime = options.resourceLocalTime;
            return this.currentUserTimeZone = options.currentUserTimeZone;
        };

        TimeZoneSelector.prototype.render = function () {
            this.$el.append();
            this._fillValues();
            this.setTimeZone();
            return this;
        };

        TimeZoneSelector.prototype._fillValues = function () {
            var defaultOptionGroup, defaultOptions, errorElement, optionGroup, select;
            errorElement = $(document.createElement('span')).addClass('help-inline error').text('Please select a timezone - selected resources are in different zones').hide();
            select = $(document.createElement('select'));
            defaultOptionGroup = $(document.createElement('optgroup'));
            defaultOptionGroup.append($(document.createElement('option')).text('Select an option').attr('selected', !this.selectedOption).val('none'));
            defaultOptionGroup.append($(document.createElement('option')).text("Resource's local time").attr('selected', this._isLocalTimeZone()).val("NullTimeZone"));
            defaultOptions = [_.unescape(this.selectedOption), _.unescape(this.currentUserTimeZone), _.unescape(this.resourceLocalTime)];
            optionGroup = $(document.createElement('optgroup')).attr('label', '--------------');
            this.timeZones.each((function (_this) {
                return function (timeZone) {
                    var option;
                    option = $(document.createElement("option"));
                    option.text(timeZone.toString()).val(timeZone.getName());
                    if (_.include(defaultOptions, timeZone.getName())) {
                        if (_this.selectedOption === timeZone.getName()) {
                            option.attr('selected', 'selected');
                        }
                        return defaultOptionGroup.append(option);
                    } else {
                        return optionGroup.append(option);
                    }
                };
            })(this));
            select.append(defaultOptionGroup);
            select.append(optionGroup);
            this.$el.append(select);
            this.$el.append(errorElement);
            return this.$el.on('change', 'select', (function (_this) {
                return function () {
                    return _this.validate();
                };
            })(this));
        };

        TimeZoneSelector.prototype.getTimeZone = function () {
            return this.$('select').val();
        };

        TimeZoneSelector.prototype.setTimeZone = function () {
            if (this.selectedOption) {
                return this.$('select').val(this.selectedOption);
            }
        };

        TimeZoneSelector.prototype.validate = function () {
            if (this.getTimeZone() === 'none') {
                this.$el.find('.error').show();
                return false;
            } else {
                this.$el.find('.error').hide();
                return true;
            }
        };

        TimeZoneSelector.prototype._isLocalTimeZone = function () {
            return this.selectedOption === (new RG.Models.NullTimeZone).getName();
        };

        return TimeZoneSelector;

    })(RG.Views.BaseView);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.Calendar.ColorControl = (function (superClass) {
        extend(ColorControl, superClass);

        function ColorControl() {
            return ColorControl.__super__.constructor.apply(this, arguments);
        }

        ColorControl.prototype.tagName = 'li';

        ColorControl.prototype.className = 'color-by dropdown is-header-dropdown has-chevron';

        ColorControl.prototype.template = templates.find('calendar/color_control');

        ColorControl.prototype.events = {
            'click #color-by-project': 'colorByProject',
            'click #color-by-client': 'colorByClient',
            'click #color-by-booker': 'colorByBooker',
            'click #color-by-trigger': 'clearAllSelections'
        };

        ColorControl.prototype.initialize = function (options) {
            this.colorSource = options.colorSource;
            return this.listenTo(this.colorSource, 'change:mode', this._setActiveLink);
        };

        ColorControl.prototype.clearAllSelections = function () {
            return RG.closeAllSelections();
        };

        ColorControl.prototype.colorByClient = function (e) {
            e.preventDefault();
            return this._colorBy('client');
        };

        ColorControl.prototype.colorByProject = function (e) {
            e.preventDefault();
            return this._colorBy('project');
        };

        ColorControl.prototype.colorByBooker = function (e) {
            e.preventDefault();
            return this._colorBy('booker');
        };

        ColorControl.prototype.render = function () {
            this.$el.html(this.template());
            this._setActiveLink();
            return this;
        };

        ColorControl.prototype._colorBy = function (option) {
            window.rgStorage.set('colorBookingsBy', option);
            return this.colorSource.colorBy(option);
        };

        ColorControl.prototype._setActiveLink = function () {
            return window.requestAnimationFrame((function (_this) {
                return function () {
                    var modeStr;
                    _this.$("li").removeClass('active');
                    _this.$("a#color-by-" + _this.colorSource.mode).closest('li').addClass('active');
                    modeStr = _this.colorSource.mode.charAt(0).toUpperCase() + _this.colorSource.mode.slice(1);
                    return _this.$("#active-coloring").text("Color by " + modeStr);
                };
            })(this));
        };

        return ColorControl;

    })(RG.Views.BaseView);

}).call(this);
;
(function () {
    var bind = function (fn, me) { return function () { return fn.apply(me, arguments); }; },
        extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.Calendar.Controls = (function (superClass) {
        extend(Controls, superClass);

        function Controls() {
            this.searchChange = bind(this.searchChange, this);
            return Controls.__super__.constructor.apply(this, arguments);
        }

        Controls.prototype.template = templates.find('calendar/controls');

        Controls.prototype.tagName = 'header';

        Controls.prototype.events = {
            'click .filters a': 'toggleFilterBar',
            'click .js-toggle-availability': 'toggleAvailability',
            'click .js-zoom-toggle': 'toggleZoom',
            'click nav': 'closeAllDropdownsPopovers'
        };

        Controls.prototype.closeAllDropdownsPopovers = function (e) {
            $("#select2-drop-mask:visible").click();
            RG.closeSelectedOptions();
            return RG.Popovers.clear();
        };

        Controls.prototype.initialize = function (options) {
            this.dateControl = options.dateControl;
            this.colorControl = options.colorControl;
            this.filterBar = options.filterBar;
            this.searchGroup = options.searchGroup;
            this.searchGroup.on('change:filter', this.searchChange);
            this.filterBar.on('change:filter', (function (_this) {
                return function (ast) {
                    _this.searchGroup.off("change:filter");
                    _this.searchGroup.setFilters(_this.filterBar.getFilters());
                    _this.searchGroup.on('change:filter', _this.searchChange);
                    _this.emptySearchStyle();
                    return _this.searchGroup.searchBlur();
                };
            })(this));
            this.listenTo(this.filterBar, 'change:filter', this._setFilterActive);
            return this.zoomLevel = window.rgStorage.get('zoomLevel') || 'daily';
        };

        Controls.prototype.render = function () {
            this.$el.html(this.template());
            this._toggleAvailabilityButton();
            this._renderDateControl();
            this._renderColorControl();
            this._renderFilterBar();
            this._quickSearch();
            this._setZoomToolipTitles();
            this._initTooltips();
            return this;
        };

        Controls.prototype.toggleFilterBar = function (e) {
            return this.filterBar.resetFlyouts();
        };

        Controls.prototype.toggleAvailability = function (e) {
            var currentResource;
            e.preventDefault();
            currentResource = RG.getCurrentResource();
            this.availabilityToggle.toggle();
            this._toggleAvailabilityButton();
            this._setCurrentResource(currentResource);
            return false;
        };

        Controls.prototype._setCurrentResource = function (resource) {
            return setTimeout((function (_this) {
                return function () {
                    if (resource) {
                        return setTimeout(function () {
                            if (RG.Utils.unitsRendered()) {
                                return RG.setCurrentResource(resource);
                            } else {
                                return _this._setCurrentResource(resource);
                            }
                        }, 10);
                    }
                };
            })(this), 5);
        };

        Controls.prototype.setZoomDaily = function () {
            this.zoomLevel = 'daily';
            window.rgStorage.set("zoomLevel", this.zoomLevel);
            this.setZoom(function () {
                return $("#calendar").removeClass("detailed");
            });
            return false;
        };

        Controls.prototype.setZoomDetailed = function () {
            this.zoomLevel = 'detailed';
            window.rgStorage.set("zoomLevel", this.zoomLevel);
            this.setZoom(function () {
                return $("#calendar").addClass("detailed");
            });
            return false;
        };

        Controls.prototype.toggleZoom = function (e) {
            if (this.zoomLevel === "detailed") {
                this.setZoomDaily();
            } else {
                this.setZoomDetailed();
            }
            return this._setZoomToolipTitles();
        };

        Controls.prototype.setResourceCardSelectors = function () {
            return window.resources.collect(function (ri) {
                return {
                    card: $("aside .resource[data-resource-id=" + ri.cid + "]"),
                    line: $(".resource-line:not([style$='display: none;'])[data-resource-id=" + ri.cid + "]")
                };
            });
        };

        Controls.prototype.setZoom = function (callback) {
            var card_selectors, currentResource, leftRatio;
            leftRatio = this._getLeftRatio();
            currentResource = RG.getCurrentResource();
            RG.Popovers.popoverActive = false;
            RG.Popovers.clear();
            card_selectors = this.setResourceCardSelectors();
            callback();
            RG.resizeBookingWidths();
            card_selectors.forEach(function (selectors) {
                return selectors['card'].outerHeight(selectors['line'].outerHeight());
            });
            this._scrollLeftRatio(leftRatio);
            if ($(window).scrollLeft() + $(window).width() - $("#calendar > aside").width() > $("#resources").width()) {
                $(window).scrollLeft(0);
                $(window).scrollLeft($("#resources").width() - $(window).width() + $("#calendar > aside").width());
            }
            if (currentResource) {
                RG.setCurrentResource(currentResource);
            }
            return false;
        };

        Controls.prototype._toggleAvailabilityButton = function () {
            var toggleItem;
            toggleItem = this.$el.find('.js-toggle-availability');
            toggleItem.tooltip('destroy').tooltip({
                title: this.availabilityToggle.title
            });
            return toggleItem.toggleClass('active', this.availabilityToggle.shouldRenderUtilisation());
        };

        Controls.prototype._getLeftRatio = function () {
            return $(window).scrollLeft() / $("#resources .resource-line:visible").width();
        };

        Controls.prototype._getTopRatio = function () {
            return $(window).scrollTop() / $("#resources .resource-line:visible").height();
        };

        Controls.prototype._scrollLeftRatio = function (ratio) {
            return $(window).scrollLeft($("#resources .resource-line:visible").width() * ratio);
        };

        Controls.prototype._scrollTopRatio = function (ratio) {
            return $(window).scrollTop($("#resources .resource-line:visible").height() * ratio);
        };

        Controls.prototype._renderColorControl = function () {
            return this.$("#color-control").replaceWith(this.colorControl.render().el);
        };

        Controls.prototype._renderFilterBar = function () {
            return this.$("#filter-bar").replaceWith(this.filterBar.render().el);
        };

        Controls.prototype._setZoomToolipTitles = function () {
            var toggleItem;
            toggleItem = this.$(".zoom-toggle");
            if (this.zoomLevel === 'daily') {
                return toggleItem.tooltip('destroy').tooltip({
                    title: 'Zoom in'
                });
            } else if (this.zoomLevel === 'detailed') {
                return toggleItem.tooltip('destroy').tooltip({
                    title: 'Zoom out'
                });
            }
        };

        Controls.prototype._setFilterActive = function (tokens) {
            return this.$(".filters").toggleClass('active', tokens.length > 0);
        };

        Controls.prototype._quickSearch = function () {
            this.$('#quick-search').html(this.searchGroup.render().el);
            return this.emptySearchStyle();
        };

        Controls.prototype._initTooltips = function () {
            this.$el.find(".availability-toggle li").tooltip();
            return this.$el.find(".zoom-toggle").tooltip();
        };

        Controls.prototype._renderDateControl = function () {
            return this.$("nav").prepend(this.dateControl.render().el);
        };

        Controls.prototype.searchChange = function () {
            var categories, category, categoryFilter, filters, i, ids, j, len, len1, nameOption, nameOptions, options;
            filters = this.filterBar.getFilters();
            categories = _.collect(filters, function (c) {
                return c.categoryName;
            });
            for (i = 0, len = categories.length; i < len; i++) {
                category = categories[i];
                options = this.searchGroup.getSelectedOptions();
                categoryFilter = _.find(filters, function (filter) {
                    return filter['categoryName'] === category;
                });
                ids = [];
                if (options) {
                    ids = _.compact(_.map(options.selectedOptions, function (fo) {
                        if (fo.get('type') === category) {
                            return fo.id;
                        } else {
                            return null;
                        }
                    }));
                }
                if (categoryFilter) {
                    nameOptions = _.where(categoryFilter.options, {
                        name: 'Name',
                        id: void 0
                    });
                    for (j = 0, len1 = nameOptions.length; j < len1; j++) {
                        nameOption = nameOptions[j];
                        nameOption.selectedOptions = ids;
                    }
                }
            }
            this.filterBar.setFilters(filters);
            this.emptySearchStyle();
            return this.refocusQuickSearch();
        };

        Controls.prototype.emptySearchStyle = function () {
            if (this.searchGroup.getSelectedOptions() === null) {
                return this.$('#quick-search .select2-choices').addClass('no-choices');
            } else {
                return this.$('#quick-search .select2-choices').removeClass('no-choices');
            }
        };

        Controls.prototype.refocusQuickSearch = function () {
            this.searchGroup.searchFocused();
            return this.$('#quick-search .select2-choices').trigger('click');
        };

        return Controls;

    })(RG.Views.BaseView);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.Calendar.DateControl = (function (superClass) {
        extend(DateControl, superClass);

        function DateControl() {
            return DateControl.__super__.constructor.apply(this, arguments);
        }

        DateControl.prototype.tagName = "ul";

        DateControl.prototype.className = 'left-menu date-controls';

        DateControl.prototype.template = templates.find('calendar/date_control');

        DateControl.prototype.startYearPeriod = 2011;

        DateControl.prototype.endYearPeriod = function () {
            return new Date().getFullYear() + 7;
        };

        DateControl.prototype.events = {
            'click .js-current': 'goToCurrent',
            'click .js-previous': 'scrollLeft',
            'click .js-next': 'scrollRight',
            'click .months li': 'selectMonth',
            'click #jump-to-year-options li': 'selectYear',
            'click .year-scroller .js-scroll-year': 'scrollYear'
        };

        DateControl.prototype.initialize = function (options) {
            return this.initialDate = options.initialDate || new Date;
        };

        DateControl.prototype.goToCurrent = function (e) {
            e.preventDefault();
            return window.dateController.scrollToDate(RG.Utils.BookingDataParser.getDateFromStr(window.currentUserDate.date));
        };

        DateControl.prototype.scrollLeft = function (e) {
            e.preventDefault();
            $("html, body").animate({
                scrollLeft: $(window).scrollLeft() - RG.Utils.scrollSize()
            }, 500);
            if ($(window).scrollLeft() < 200) {
                RG.Variables.currentResource = RG.getCurrentResource();
                $(".large-controls .previous-timeperiods").addClass('loading');
                this.loadMoreBookings(this.scrollLeftCallback, 'left');
            }
        };

        DateControl.prototype.scrollLeftCallback = function () {
            var offset, referenceElement;
            referenceElement = $(document.elementFromPoint(295, 240)).closest(".resources--cal-unit");
            window.dateController.prepend(4);
            RG.updateLongBookings();
            $("#time-periods, #resources").css({
                width: window.ugc.getUnitCollection().length * RG.getUnitWidth()
            });
            $(".large-controls .previous-timeperiods").fadeOut().removeClass('loading');
            $(".booking-anchor.waitlist .waiting-list").removeClass("waiting-list");
            if (referenceElement && (offset = referenceElement.offset())) {
                $(window).scrollLeft(offset.left - 249 - referenceElement.width());
                $("html, body").animate({
                    scrollLeft: $(window).scrollLeft() - RG.Utils.scrollSize()
                });
            }
            if (RG.Variables.currentResource) {
                RG.setCurrentResource(RG.Variables.currentResource);
            }
            RG.Variables.currentResource = void 0;
        };

        DateControl.prototype.scrollRight = function (e) {
            e.preventDefault();
            if ((-1 * ($(window).scrollLeft() - $(document).width() + $(window).width())) < 200) {
                RG.Variables.currentResource = RG.getCurrentResource();
                $(".large-controls .next-timeperiods").addClass('loading');
                this.loadMoreBookings(this.scrollRightCallback, 'right');
            } else {
                $("html, body").animate({
                    scrollLeft: $(window).scrollLeft() + RG.Utils.scrollSize()
                }, 500);
            }
        };

        DateControl.prototype.scrollRightCallback = function () {
            var offset, referenceElement;
            referenceElement = $(document.elementFromPoint(251, 240)).closest(".resources--cal-unit");
            window.dateController.append(4);
            $("#time-periods, #resources").css({
                width: window.ugc.getUnitCollection().length * RG.getUnitWidth()
            });
            $(".large-controls .next-timeperiods").fadeOut().removeClass('loading');
            $(".booking-anchor.waitlist .waiting-list").removeClass("waiting-list");
            if (referenceElement && (offset = referenceElement.offset())) {
                $(window).scrollLeft(referenceElement.offset().left - 249);
                $("html, body").animate({
                    scrollLeft: $(window).scrollLeft() + RG.Utils.scrollSize()
                });
            }
            if (RG.Variables.currentResource) {
                RG.setCurrentResource(RG.Variables.currentResource);
            }
            RG.Variables.currentResource = void 0;
        };

        DateControl.prototype.loadMoreBookings = function (callback, direction) {
            var bookingPromise, data, date_end, date_start, downtimePromise, downtime_end, downtime_start;
            data = {
                calendar: 1
            };
            if (direction === 'left') {
                date_start = RG.Utils.firstVisibleDate();
                date_end = date_start.clone();
                date_start = date_start.subtract(56, 'days');
                data['start_date'] = encodeURIComponent(date_start.format('YYYY-MM-DD'));
                data['end_date'] = encodeURIComponent(date_end.format('YYYY-MM-DD'));
                downtime_start = date_start;
                downtime_end = RG.Utils.lastVisibleDate();
            } else {
                date_start = RG.Utils.lastVisibleDate().clone();
                date_end = date_start.clone().add(56, 'days');
                data['start_date'] = encodeURIComponent(date_start.format('YYYY-MM-DD'));
                data['end_date'] = encodeURIComponent(date_end.format('YYYY-MM-DD'));
                downtime_start = RG.Utils.firstVisibleDate();
                downtime_end = date_end;
            }
            bookingPromise = Q.Promise(function (resolve) {
                //return $.ajax("/v1/" + RG.Utils.BookingDataParser.host + "/bookings", {
                return $.ajax("http://localhost/EMRMAPI/schedule/resources/bootstrap",
                    {
                        data: data,
                        timeout: 30000,
                        success: function(response, status, xhr) {
                            response = [];
                            var endDate, startDate;
                            startDate = new Date(data['start_date']);
                            endDate = new Date(data['end_date']);
                            if (startDate < RG.Variables.dataDateRange.startDate) {
                                RG.Variables.dataDateRange.startDate = startDate;
                            }
                            if (endDate > RG.Variables.dataDateRange.endDate) {
                                RG.Variables.dataDateRange.endDate = endDate;
                            }
                            RG.Utils.BookingDataParser.processRawBookingData(response);
                            resolve();
                        }
                    });
            });
            downtimePromise = Q.Promise(function (resolve) {
                var dateRange;
                dateRange = new RG.Utils.DateRange(downtime_start, downtime_end);
                return RG.Utils.BookingDataParser.downtimesPoll((function () {
                    return false;
                }), dateRange).then(function () {
                    return resolve();
                });
            });
            Q.all([bookingPromise, downtimePromise]).then(Q.delay(500)).then(function () {
                return callback();
            });
        };

        DateControl.prototype.selectMonth = function (e) {
            var date, month, monthDrop, target, year, yearEl;
            target = this.$(e.target);
            if (target.closest('.months-dropdown').length > 0) {
                monthDrop = target.closest('.months-dropdown');
                yearEl = monthDrop.find(".year-scroller .current");
                year = parseInt(yearEl.text());
                month = parseInt(target.closest('li').data('month'));
            } else {
                year = parseInt(this.$("span#active-year").text(), 10);
                month = parseInt(target.closest('li').data('month'), 10);
            }
            date = new Date(year, month - 1, 1);
            return window.dateController.scrollToDate(date);
        };

        DateControl.prototype.selectYear = function (e) {
            var date;
            this.$("#jump-to-year-options li").removeClass("active");
            $(e.currentTarget).addClass("active");
            this.$("span#active-year").text($(e.currentTarget).text());
            date = RG.Utils.firstVisibleDate()._d;
            date = new Date(parseInt($(e.currentTarget).text(), 10), date.getMonth(), date.getDate() - 1);
            return window.dateController.scrollToDate(date);
        };

        DateControl.prototype.scrollYear = function (e) {
            var currentYearEl, target, year;
            e.preventDefault();
            e.stopPropagation();
            target = this.$(e.target);
            currentYearEl = this.$(".year-scroller .current");
            year = parseInt(currentYearEl.text());
            if (target.hasClass('next')) {
                year++;
            } else if (target.hasClass('previous')) {
                year--;
            }
            return currentYearEl.text(year);
        };

        DateControl.prototype.getYearRange = function () {
            var i, ref, ref1, results;
            return (function () {
                results = [];
                for (var i = ref = this.startYearPeriod, ref1 = this.endYearPeriod(); ref <= ref1 ? i <= ref1 : i >= ref1; ref <= ref1 ? i++ : i--) { results.push(i); }
                return results;
            }).apply(this).map(function (year) {
                return year;
            });
        };

        DateControl.prototype.render = function () {
            var yearRange;
            yearRange = this.getYearRange();
            this.$el.html(this.template({
                years: yearRange,
                activeYear: this.initialDate.getFullYear()
            }));
            this.$(".large-controls .next-timeperiods").click((function (_this) {
                return function (e) {
                    return _this.scrollRight(e);
                };
            })(this));
            this.$(".large-controls .previous-timeperiods").click((function (_this) {
                return function (e) {
                    return _this.scrollLeft(e);
                };
            })(this));
            return this;
        };

        return DateControl;

    })(RG.Views.BaseView);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.Calendar.FilterPanel = (function (superClass) {
        extend(FilterPanel, superClass);

        function FilterPanel() {
            return FilterPanel.__super__.constructor.apply(this, arguments);
        }

        FilterPanel.prototype.template = templates.find('calendar/filter_panel');

        FilterPanel.prototype.id = 'filter-bar';

        FilterPanel.prototype.className = 'dropdown-menu';

        FilterPanel.prototype.events = {
            "click .filter__save": "_collapsePopups",
            "click": "_cancelBubble"
        };

        FilterPanel.prototype.activateFilter = function (savedFilter) {
            return this.savedFilterView.activateFilter(savedFilter);
        };

        FilterPanel.prototype.clearSelection = function () {
            return this.filterCategoriesView.clearSelection();
        };

        FilterPanel.prototype.getFilters = function () {
            return this.filterCategoriesView.getFilters();
        };

        FilterPanel.prototype.getSelectedOptions = function () {
            return this.filterCategoriesView.getSelectedOptions();
        };

        FilterPanel.prototype.initialize = function (options) {
            this.filterCategories = options.filterCategories;
            return this.savedFilters = options.savedFilters;
        };

        FilterPanel.prototype.cleanup = function () {
            var ref, ref1;
            if ((ref = this.savedFilterView) != null) {
                ref.remove();
            }
            return (ref1 = this.filterCategoriesView) != null ? ref1.remove() : void 0;
        };

        FilterPanel.prototype.render = function () {
            this.cleanup();
            this.$el.html(this.template());
            this._fillValues();
            return this;
        };

        FilterPanel.prototype.resetFlyouts = function () {
            return this.filterCategoriesView.resetFlyouts();
        };

        FilterPanel.prototype.setFilters = function (filters) {
            this.filterCategoriesView.off("change:filter");
            this.filterCategoriesView.setFilters(filters);
            this._setFilterCategoriesEvent();
            return this.triggerFilterChange();
        };

        FilterPanel.prototype.triggerFilterChange = function () {
            this.savedFilterView.watchFilterChanges(this.getSelectedOptions());
            return this.trigger("change:filter", this.getSelectedOptions());
        };

        FilterPanel.prototype._cancelBubble = function (e) {
            e.cancelBubble = true;
            return e.stopPropagation();
        };

        FilterPanel.prototype._collapsePopups = function () {
            return this.filterCategoriesView.resetFlyouts();
        };

        FilterPanel.prototype._fillValues = function () {
            var valueSource;
            this.filterCategoriesView = new RG.Views.Filters.Categories({
                collection: this.filterCategories
            });
            this._setFilterCategoriesEvent();
            this._getFilterCategoriesContainer().replaceWith(this.filterCategoriesView.render().el);
            valueSource = (function (_this) {
                return function () {
                    return _this.getFilters();
                };
            })(this);
            this.savedFilterView = new RG.Views.Filters.SavedFilterPanel({
                savedFilters: this.savedFilters,
                valueSource: valueSource
            });
            this.savedFilterView.on("activate:filter", (function (_this) {
                return function (savedFilter) {
                    _this.setFilters(savedFilter.getFilter());
                    return window.rgStorage.set('lastActiveFilterId', savedFilter.id);
                };
            })(this));
            this._getSaveFiltersContainer().replaceWith(this.savedFilterView.render().el);
            return this.savedFilterView.watchFilterChanges(this.getSelectedOptions());
        };

        FilterPanel.prototype._getFilterCategoriesContainer = function () {
            return this.$(".filter-categories");
        };

        FilterPanel.prototype._getSaveFiltersContainer = function () {
            return this.$(".filter__save");
        };

        FilterPanel.prototype._setFilterCategoriesEvent = function () {
            return this.filterCategoriesView.on("change:filter", (function (_this) {
                return function () {
                    _this.triggerFilterChange();
                    return window.rgStorage["delete"]('lastActiveFilterId');
                };
            })(this));
        };

        return FilterPanel;

    })(RG.Views.BaseView);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.Calendar.Header = (function (superClass) {
        extend(Header, superClass);

        function Header() {
            return Header.__super__.constructor.apply(this, arguments);
        }

        Header.prototype.tagName = 'header';

        Header.prototype.template = templates.find('calendar/header');

        Header.prototype.className = 'cal-unit-grouping-header';

        Header.prototype.assignRegions = function () {
            return this.timePeriods = this.$("#time-periods");
        };

        Header.prototype.render = function () {
            this.$el.html(this.template());
            this.assignRegions();
            return this;
        };

        Header.prototype.setTimePeriods = function (element) {
            return this.timePeriods.replaceWith(element);
        };

        return Header;

    })(RG.Views.BaseView);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.Calendar.Layout = (function (superClass) {
        extend(Layout, superClass);

        function Layout() {
            return Layout.__super__.constructor.apply(this, arguments);
        }

        Layout.prototype.id = 'calendar';

        Layout.prototype.template = templates.find('calendar/layout');

        Layout.prototype.initialize = function (options) {
            $(document).on("click", (function (_this) {
                return function (e) {
                    _this._closeFilterPanelAndPopovers(e);
                };
            })(this));
            this.dateController = options.dateController;
            this.initialDate = options.initialDate || new Date;
            this.periodGroupings = options.periodGroupings;
            this.resources = options.resources;
            this.savedFilters = options.savedFilters;
            this.filterSource = options.filterSource;
            this.colorSource = options.colorSource;
            this.currentUserId = options.currentUserId;
            this.clients = options.clients || new RG.Collections.Clients;
            this.deletedClients = options.deletedClients || new RG.Collections.Clients;
            this.projects = options.projects || new RG.Collections.Projects;
            this.deletedProjects = options.deletedProjects || new RG.Collections.Projects;
            this.bookers = options.bookers || new RG.Collections.Bookers;
            this.deletedBookers = options.deletedBookers || new RG.Collections.Bookers;
            this.downtimeTypes = options.downtimeTypes || new RG.Collections.DowntimeTypes;
            this.timeZones = options.timeZones;
            this.currentUserTimeZone = options.currentUserTimeZone;
            this.currentDate = options.currentDate;
            this.listenTo(this.periodGroupings, 'add', this._resize);
            this.listenTo(this.periodGroupings, 'remove', this._resize);
            this.listenTo(this.periodGroupings.getUnitCollection(), 'change', this._resize);
        };

        Layout.prototype.getInitialLoadLimit = function () {
            var browser, limit;
            limit = 40;
            browser = $('html').attr('class');
            try {
                if (browser.indexOf('ff') !== -1 || browser.indexOf('ie') !== -1 || browser.indexOf('safari') !== -1) {
                    if (browser.indexOf('ie') === 0) {
                        RG.Variables.slowBrowser = true;
                    }
                    limit = 30;
                }
            } catch (error) {
                limit = 30;
            }
            return limit;
        };

        Layout.prototype.render = function () {
            var paginator, periodGroupsView, resourceLinesView;
            this.$el.html(this.template());
            paginator = new RG.Utils.ResourcePaginator(this.resources, this.getInitialLoadLimit());
            window.resourcePaginator = paginator;
            this.pagedResources = paginator.getPaginatedCollection();
            this.resourceFilter = new RG.Utils.ResourceFilter(this.filterSource.resourceTypes);
            this._cardsView = new RG.Views.Resource.Cards({
                collection: this.pagedResources
            });
            this._controlsView = this._createControlsView();
            this._headerView = new RG.Views.Calendar.Header().render();
            periodGroupsView = new RG.Views.Calendar.UnitGroupings({
                collection: this.periodGroupings,
                currentDate: this.currentDate
            });
            this._headerView.setTimePeriods(periodGroupsView.render().el);
            resourceLinesView = new RG.Views.Resource.Lines({
                dateController: this.dateController,
                collection: this.pagedResources,
                timeUnits: this.periodGroupings.getUnitCollection(),
                currentDate: this.currentDate,
                colorSource: this.colorSource,
                bookingFormDialogFactory: this._createBookingFormDialogFactory(),
                downtimeFormDialogFactory: this._createDowntimeFormDialogFactory()
            });
            this._controlsView.availabilityToggle = resourceLinesView.availabilityToggle;
            this.$("header").replaceWith(this._controlsView.render().el);
            this.$("aside").replaceWith(this._cardsView.render().el);
            this.$("section").append(this._headerView.el);
            this.$("section").append(resourceLinesView.render().el);
            this.resources.setVisibleResources(this.resourceFilter.filterBy(this.resources, []));
            this._moveLargeControls();
            this._attachEvents();
            this._attachRightClickDrag();
            this._resize();
            return this;
        };

        Layout.prototype._adjustHeaderAndCards = function () {
            this._cardsView.$el.css({
                top: -window.pageYOffset + this._headerView.$el.position().top
            });
            this._headerView.$el.scrollLeft(window.pageXOffset);
        };

        Layout.prototype._attachEvents = function () {
            $(window).scroll((function (_this) {
                return function () {
                    return _this._adjustHeaderAndCards();
                };
            })(this));
        };

        Layout.prototype._attachRightClickDrag = function () {
            var interaction;
            interaction = new RG.Interactions.RightClickDragToScroll(window);
            interaction.attach();
        };

        Layout.prototype._closeFilterPanelAndPopovers = function (e) {
            var $target;
            $target = $(e.target);
            if (!$target.closest("#" + RG.Views.Resource.Lines.prototype.id).length) {
                RG.Popovers.replace();
            }
        };

        Layout.prototype._createControlsView = function () {
            var colorControl, dateControl, quickSearch, view;
            window.categories = this.filterSource.getCategories();
            this.filterBar = new RG.Views.Calendar.FilterPanel({
                filterCategories: window.categories,
                savedFilters: this.savedFilters
            });
            this.filterBar.on('change:filter', (function (_this) {
                return function (ast, reRender) {
                    if (reRender == null) {
                        reRender = true;
                    }
                    window.rgStorage.set('lastFiltersAst', JSON.stringify(_this.filterBar.getFilters()));
                    if (reRender) {
                        _this.resources.setVisibleResources(_this.resourceFilter.filterBy(_this.resources, ast));
                    }
                    RG.resizeCards();
                };
            })(this));
            window.resources.on('change:booked', (function (_this) {
                return function () {
                    return RG.backburner.deferOnce('render', _this, _this._triggerFilterChange);
                };
            })(this));
            dateControl = new RG.Views.Calendar.DateControl({
                initialDate: this.initialDate
            });
            colorControl = new RG.Views.Calendar.ColorControl({
                colorSource: this.colorSource
            });
            quickSearch = new RG.Views.Factories.NameSearch(this.resources).create({
                cssClass: 'quick-search-group'
            });
            view = new RG.Views.Calendar.Controls({
                dateControl: dateControl,
                colorControl: colorControl,
                filterBar: this.filterBar,
                searchGroup: quickSearch
            });
            return view;
        };

        Layout.prototype._triggerFilterChange = function () {
            return RG.renderer.enqueue(new RG.Renderer.GlobalLock(), (function (_this) {
                return function () {
                    return _this.filterBar.trigger("change:filter", _this.filterBar.getSelectedOptions(), false);
                };
            })(this));
        };

        Layout.prototype._createBookingFormDialogFactory = function () {
            return new RG.Views.Dialogs.BookingFormFactory({
                clients: this.clients,
                deletedClients: this.deletedClients,
                projects: this.projects,
                deletedProjects: this.deletedProjects,
                resources: this.resources,
                bookers: this.bookers,
                deletedBookers: this.deletedBookers,
                downtimeTypes: this.downtimeTypes,
                currentUserId: this.currentUserId,
                timeZones: this.timeZones,
                currentUserTimeZone: this.currentUserTimeZone
            });
        };

        Layout.prototype._createDowntimeFormDialogFactory = function () {
            return new RG.Views.Dialogs.DowntimeFormFactory({
                resources: this.resources,
                bookers: this.bookers,
                deletedBookers: this.deletedBookers,
                downtimeTypes: this.downtimeTypes,
                currentUserId: this.currentUserId,
                timeZones: this.timeZones,
                currentUserTimeZone: this.currentUserTimeZone
            });
        };

        Layout.prototype._moveLargeControls = function () {
            var $controls;
            $controls = this.$(".large-controls").detach();
            this.$el.prepend($controls);
        };

        Layout.prototype._resize = function () {
            this.$("#time-periods, #resources").css({
                width: this.periodGroupings.getUnitCollection().models.length * RG.getUnitWidth()
            });
        };

        Layout.prototype.setInitialFilters = function () {
            var ex, keys, lastUsedFilter;
            try {
                if (window.rgStorage.get('lastActiveFilterId')) {
                    lastUsedFilter = this.savedFilters.findWhere({
                        id: parseInt(window.rgStorage.get('lastActiveFilterId'), 10)
                    });
                    this.filterBar.activateFilter(lastUsedFilter);
                } else if (window.rgStorage.get('lastFiltersAst')) {
                    this.filterBar.setFilters(JSON.parse(window.rgStorage.get('lastFiltersAst')));
                }
            } catch (error) {
                ex = error;
                keys = ['lastFilters', 'lastFilterString', 'lastActiveFilterId', 'lastFiltersAst', 'filterBarWasCollapsed'];
                keys.forEach((function (_this) {
                    return function (k) {
                        return window.rgStorage["delete"](k);
                    };
                })(this));
            }
        };

        Layout.prototype.setInitialResource = function () {
            Q.delay(100).then((function (_this) {
                return function () {
                    var lastResourceId, resource, selector;
                    lastResourceId = window.rgStorage.get('lastResourceId');
                    if (lastResourceId) {
                        resource = window.resources.findWhere({
                            id: parseInt(lastResourceId, 10)
                        });
                        selector = $(".resource[data-resource-id=" + resource.cid + "]");
                        if (selector.length) {
                            Q.delay(100).then(function () {
                                window.rgStorage["delete"]('lastResourceId');
                                RG.setCurrentResource(resource);
                            });
                        } else {
                            _this.setInitialResource();
                            return;
                        }
                    }
                };
            })(this));
        };

        return Layout;

    })(RG.Views.BaseView);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.Filters.SaveFilterForm = (function (superClass) {
        extend(SaveFilterForm, superClass);

        function SaveFilterForm() {
            return SaveFilterForm.__super__.constructor.apply(this, arguments);
        }

        SaveFilterForm.prototype.template = templates.find('filters/save_filter_form');

        SaveFilterForm.prototype.className = "filter__save-form";

        SaveFilterForm.prototype.events = {
            "click .btn.save": "saveFilter",
            "keyup input": "_validate",
            "keydown input": "_submitSaveOnEnter"
        };

        SaveFilterForm.prototype.initialize = function (options) {
            return this.valueSource = options.valueSource;
        };

        SaveFilterForm.prototype.focusInput = function () {
            return this.$("input[name=name]").focus();
        };

        SaveFilterForm.prototype.render = function () {
            this.$el.html(this.template());
            this._validate();
            return this;
        };

        SaveFilterForm.prototype.resetForm = function () {
            this._enableForm();
            return this.$("input").val("").focus();
        };

        SaveFilterForm.prototype.saveFilter = function () {
            var existingFilter, filter, mustOverwite, xhr;
            if (this.$(".btn.save").hasClass("disabled")) {
                return;
            }
            existingFilter = window.savedFilters.find((function (_this) {
                return function (sf) {
                    var ref;
                    return ((ref = sf.get('name')) != null ? ref.toLowerCase() : void 0) === _this._getName().toLowerCase();
                };
            })(this));
            filter = existingFilter || new RG.Models.SavedFilter;
            xhr = null;
            if (existingFilter) {
                mustOverwite = confirm("That name already exists. Do you want to replace the existing filter?");
                if (mustOverwite) {
                    filter.set({
                        name: this._getName(),
                        filter_json: JSON.stringify(this._getCurrentFilters())
                    });
                    xhr = filter.save();
                } else {
                    return;
                }
            } else {
                filter.set({
                    name: this._getName(),
                    filter_json: JSON.stringify(this._getCurrentFilters())
                });
                xhr = filter.save();
            }
            xhr.success((function (_this) {
                return function (data, status, xhr) {
                    _this.resetForm();
                    return _this.trigger("save:filter", filter);
                };
            })(this));
            xhr.error((function (_this) {
                return function (data) {
                    var errors;
                    errors = JSON.parse(data.responseText);
                    alert(errors['name']);
                    return _this._enableForm();
                };
            })(this));
            return this._disableForm();
        };

        SaveFilterForm.prototype._disableForm = function () {
            return this.$(".btn.save").addClass("disabled");
        };

        SaveFilterForm.prototype._enableForm = function () {
            return this.$(".btn").removeClass("disabled");
        };

        SaveFilterForm.prototype._getName = function () {
            return this.$("input[name=name]").val();
        };

        SaveFilterForm.prototype._getCurrentFilters = function () {
            return this.valueSource();
        };

        SaveFilterForm.prototype._submitSaveOnEnter = function (e) {
            if (e.keyCode === 13) {
                return this.saveFilter();
            }
        };

        SaveFilterForm.prototype._validate = function () {
            if (this._getName().length === 0) {
                return this._disableForm();
            } else {
                return this._enableForm();
            }
        };

        return SaveFilterForm;

    })(RG.Views.BaseView);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.Filters.SavedFilterPanel = (function (superClass) {
        extend(SavedFilterPanel, superClass);

        function SavedFilterPanel() {
            return SavedFilterPanel.__super__.constructor.apply(this, arguments);
        }

        SavedFilterPanel.prototype.template = templates.find('filters/saved_filter_panel');

        SavedFilterPanel.prototype.className = "filter__save";

        SavedFilterPanel.prototype.events = {
            "click .filter__save-link": "toggleSaveForm",
            "click .btn.cancel": "_cancelSaveForm"
        };

        SavedFilterPanel.prototype.initialize = function (options) {
            this.savedFilters = options.savedFilters;
            this.valueSource = options.valueSource;
            return this.listenTo(this.savedFilters, "add remove", this._setSavedFilterVisibility);
        };

        SavedFilterPanel.prototype.activateFilter = function (savedFilter) {
            return this.savedFilterListView.activateFilter(savedFilter);
        };

        SavedFilterPanel.prototype.isSaveFormOpen = function () {
            return this._getSaveFilterFormContainer().css("display") === "block";
        };

        SavedFilterPanel.prototype.render = function () {
            this.$el.html(this.template());
            this.saveFilterFormView = new RG.Views.Filters.SaveFilterForm({
                valueSource: this.valueSource
            });
            this.saveFilterFormView.on("save:filter", (function (_this) {
                return function (savedFilter) {
                    _this.savedFilters.add(savedFilter);
                    _this.savedFilterListView.activateFilter(savedFilter);
                    return _this.toggleSaveForm();
                };
            })(this));
            this._getSaveFilterFormContainer().replaceWith(this.saveFilterFormView.render().el);
            this.savedFilterListView = new RG.Views.Filters.SavedFilters({
                collection: this.savedFilters
            });
            this.savedFilterListView.on("activate:filter", (function (_this) {
                return function (savedFilter) {
                    return _this.trigger("activate:filter", savedFilter);
                };
            })(this));
            this._getSaveFilterListContainer().replaceWith(this.savedFilterListView.render().el);
            this._setSavedFilterVisibility();
            this.$('.filter__info-tooltip').tooltip();
            this.$(".filter__save-link").tooltip();
            return this;
        };

        SavedFilterPanel.prototype.toggleSaveForm = function () {
            if (!this.$(".filter__save-link").hasClass("is-disabled")) {
                this._getSaveFilterFormContainer().slideToggle('fast');
                return this.saveFilterFormView.focusInput();
            }
        };

        SavedFilterPanel.prototype.watchFilterChanges = function (selectedOptions) {
            var $saveFilterLink;
            this.savedFilterListView.removeActiveState();
            $saveFilterLink = this.$(".filter__save-link");
            if (selectedOptions.length === 0) {
                $saveFilterLink.addClass("is-disabled").tooltip();
                if (this.isSaveFormOpen()) {
                    return this.toggleSaveForm();
                }
            } else {
                return $saveFilterLink.removeClass("is-disabled").tooltip('destroy');
            }
        };

        SavedFilterPanel.prototype._cancelSaveForm = function () {
            this._getSaveFilterFormContainer().slideToggle(false);
            return this.saveFilterFormView.resetForm();
        };

        SavedFilterPanel.prototype._getSaveFilterFormContainer = function () {
            return this.$(".filter__save-form");
        };

        SavedFilterPanel.prototype._getSaveFilterListContainer = function () {
            return this.$(".filter__saved-filter-list");
        };

        SavedFilterPanel.prototype._setSavedFilterVisibility = function () {
            var visible;
            visible = this.savedFilters.length > 0;
            this.$(".filter__saved-filter-list").toggle(visible);
            return this.$("h3").toggle(visible);
        };

        return SavedFilterPanel;

    })(RG.Views.BaseView);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.Calendar.Unit = (function (superClass) {
        extend(Unit, superClass);

        function Unit() {
            return Unit.__super__.constructor.apply(this, arguments);
        }

        Unit.prototype.className = 'cal-unit';

        Unit.prototype.template = templates.find('calendar/unit');

        Unit.prototype.render = function () {
            this.$el.html(this.template());
            this._fillValues();
            return this;
        };

        Unit.prototype._fillValues = function () {
            this.$("span.name").text(this.model.getName());
            this.$("span.date").text(this.model.getFormattedDate());
            this.$el.attr('data-date', RG.Utils.DateFormatter.getISODate(this.model.date));
            this._setCurrent();
        };

        Unit.prototype._setCurrent = function () {
            this.$el.toggleClass("current", this.model.isCurrent());
        };

        return Unit;

    })(RG.Views.BaseView);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.Calendar.UnitGrouping = (function (superClass) {
        extend(UnitGrouping, superClass);

        function UnitGrouping() {
            return UnitGrouping.__super__.constructor.apply(this, arguments);
        }

        UnitGrouping.prototype.template = templates.find('calendar/unit_grouping');

        UnitGrouping.prototype.className = 'unit-group';

        UnitGrouping.prototype.render = function () {
            this.$el.html(this.template());
            this._fillValues();
            return this;
        };

        UnitGrouping.prototype._fillValues = function () {
            var units, unitsView;
            units = this.model.getUnits();
            unitsView = new RG.Views.Calendar.Units({
                collection: units
            });
            this.$('.units').replaceWith(unitsView.render().el);
            this.$('.date-period').text(this.model.toString());
            this._fillWeek(units);
        };

        UnitGrouping.prototype._fillWeek = function (units) {
            var unit;
            unit = units.first();
            return this.$('.week-period').text("W " + (unit.getWeek()));
        };

        return UnitGrouping;

    })(RG.Views.BaseView);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.Calendar.UnitGroupings = (function (superClass) {
        extend(UnitGroupings, superClass);

        function UnitGroupings() {
            return UnitGroupings.__super__.constructor.apply(this, arguments);
        }

        UnitGroupings.prototype.id = 'time-periods';

        UnitGroupings.prototype.itemView = RG.Views.Calendar.UnitGrouping;

        UnitGroupings.prototype.initialize = function (options) {
            UnitGroupings.__super__.initialize.apply(this, arguments);
            this.currentDate = options.currentDate;
            return this.listenTo(this.currentDate, 'change', (function (_this) {
                return function () {
                    return _this.render();
                };
            })(this));
        };

        UnitGroupings.prototype.addItem = function (model) {
            var target, view;
            view = this.createItemView({
                model: model
            });
            this.collectionViews[model.cid] = view;
            target = this.collectionTarget ? this.$(this.collectionTarget) : this.$el;
            if (this.collection.models[0] === model) {
                return target.prepend(view.render().el);
            } else {
                return target.append(view.render().el);
            }
        };

        return UnitGroupings;

    })(RG.Support.CollectionView);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.Calendar.Units = (function (superClass) {
        extend(Units, superClass);

        function Units() {
            return Units.__super__.constructor.apply(this, arguments);
        }

        Units.prototype.className = 'units';

        Units.prototype.itemView = RG.Views.Calendar.Unit;

        return Units;

    })(RG.Support.CollectionView);

}).call(this);
;
(function () {
    var slice = [].slice;

    RG.Views.Calendar.UtilisationBarFactory = {
        create: function () {
            var className, i, len, ratio, ratios, span, unit, width;
            width = arguments[0], className = arguments[1], ratios = 3 <= arguments.length ? slice.call(arguments, 2) : [];
            unit = document.createElement("div");
            unit.style.width = (width * 100) + "%";
            unit.className = className || "unit";
            for (i = 0, len = ratios.length; i < len; i++) {
                ratio = ratios[i];
                span = document.createElement(ratio.element || "span");
                span.style.width = (ratio.width * 100) + "%";
                span.style.backgroundColor = ratio.color || "#333";
                if (ratio.title) {
                    span.setAttribute("title", ratio.title);
                }
                span.className = ratio.className;
                unit.appendChild(span);
            }
            return unit;
        }
    };

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.CustomAvailability.TimeBlock = (function (superClass) {
        extend(TimeBlock, superClass);

        function TimeBlock() {
            return TimeBlock.__super__.constructor.apply(this, arguments);
        }

        TimeBlock.prototype.tagName = 'span';

        TimeBlock.prototype.className = 'availability-info__timeblock js-timeblock';

        TimeBlock.prototype.render = function () {
            this.$el.html(this.model.toString());
            return this;
        };

        return TimeBlock;

    })(RG.Views.BaseView);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.CustomAvailability.TimeBlocks = (function (superClass) {
        extend(TimeBlocks, superClass);

        function TimeBlocks() {
            return TimeBlocks.__super__.constructor.apply(this, arguments);
        }

        TimeBlocks.prototype.itemView = RG.Views.CustomAvailability.TimeBlock;

        TimeBlocks.prototype.className = "js-time-blocks availability-info__time";

        TimeBlocks.prototype.initialize = function (options) {
            TimeBlocks.__super__.initialize.apply(this, arguments);
            return this.variesFromDefault = options.varies;
        };

        TimeBlocks.prototype.render = function () {
            TimeBlocks.__super__.render.apply(this, arguments);
            this._renderIcon();
            return this;
        };

        TimeBlocks.prototype.addItem = function (model) {
            var e, element, elements, i, len, ref, split;
            if (model.get('startTime') === model.get('endTime')) {
                return;
            }
            TimeBlocks.__super__.addItem.apply(this, arguments);
            this.$(".text--small").remove();
            elements = this.$el.find('.js-timeblock');
            ref = elements.slice(1, +(elements.length - 1) + 1 || 9e9);
            for (i = 0, len = ref.length; i < len; i++) {
                element = ref[i];
                split = $(document.createElement("span"));
                split.addClass("text--small availability-info__time-break").text('Break');
                e = split[0];
                this.el.insertBefore(e, element);
            }
        };

        TimeBlocks.prototype._removeViewByModelCid = function () {
            var e, element, elements, i, len, ref, split;
            TimeBlocks.__super__._removeViewByModelCid.apply(this, arguments);
            this.$(".text--small").remove();
            elements = this.$el.find('.js-timeblock');
            ref = elements.slice(1, +(elements.length - 1) + 1 || 9e9);
            for (i = 0, len = ref.length; i < len; i++) {
                element = ref[i];
                split = $(document.createElement("span"));
                split.addClass("text--small").text('Break');
                e = split[0];
                this.el.insertBefore(e, element);
            }
        };

        TimeBlocks.prototype._renderIcon = function () {
            var element;
            if (this.variesFromDefault) {
                element = $(document.createElement('span'));
                element.attr({
                    'data-toggle': "tooltip",
                    'data-html': "true",
                    'data-placement': "left",
                    'data-original-title': 'The availability here differs from the <b>Normal Availability</b> assigned to this resource. You can reset it back to <b>Normal Availability</b> if you choose.'
                });
                element.addClass('filter__info-tooltip').tooltip();
                return this.$el.append(element);
            }
        };

        return TimeBlocks;

    })(RG.Support.CollectionView);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.CustomAvailability.AddTimeBlock = (function (superClass) {
        extend(AddTimeBlock, superClass);

        function AddTimeBlock() {
            return AddTimeBlock.__super__.constructor.apply(this, arguments);
        }

        AddTimeBlock.prototype.template = templates.find('availability/add_timeblock');

        AddTimeBlock.prototype.initialize = function (options) {
            this.newTimeBlockStartTime = options.newTimeBlockStartTime || 540;
            return this.newTimeBlockEndTime = _.min([this.newTimeBlockStartTime + 60, 1440]);
        };

        AddTimeBlock.prototype.render = function () {
            this.$el.html(this.template());
            this.$(".js-add-button").on("click", (function (_this) {
                return function (e) {
                    return _this.addTimeBlock(e);
                };
            })(this));
            this.$(".js-cancel-button").on("click", (function (_this) {
                return function (e) {
                    return _this.triggerClose(e);
                };
            })(this));
            this.timeRangeSelector = new RG.Views.Selectors.TimeRange({
                startTime: this.newTimeBlockStartTime,
                endTime: this.newTimeBlockEndTime,
                storageTypeName: 'AddTimeBlock',
                togglable: false
            });
            this.$el.on("click", "input.js-time-range-input", function (e) {
                return e.stopPropagation();
            });
            this.timeRangeSelector.on("validate", (function (_this) {
                return function (valid) {
                    if (valid) {
                        return _this.$(".js-add-button").attr('disabled', null);
                    } else {
                        return _this.$(".js-add-button").attr('disabled', 'disabled');
                    }
                };
            })(this));
            this.$(".js-time-range").append(this.timeRangeSelector.render().el);
            this.timeRangeSelector.triggerValidate();
            return this;
        };

        AddTimeBlock.prototype._getAvailablePeriod = function () {
            return new RG.Models.CustomAvailablePeriod({
                startTime: this.timeRangeSelector.getStartTime(),
                endTime: this.timeRangeSelector.getEndTime()
            });
        };

        AddTimeBlock.prototype._originalPeriod = function () {
            return new RG.Models.CustomAvailablePeriod({
                startTime: this.newTimeBlockStartTime,
                endTime: this.newTimeBlockEndTime
            });
        };

        AddTimeBlock.prototype.addTimeBlock = function (e) {
            this.trigger('remove', this._originalPeriod());
            this.trigger("add", this._getAvailablePeriod());
            return this.triggerClose();
        };

        AddTimeBlock.prototype.closeSelector = function () {
            return this.timeRangeSelector.closeSelector();
        };

        AddTimeBlock.prototype.remove = function () {
            var ref;
            this.$(".js-add-button").off();
            this.$(".js-cancel-button").off();
            if ((ref = this.timeRangeSelector) != null) {
                ref.remove();
            }
            return AddTimeBlock.__super__.remove.apply(this, arguments);
        };

        AddTimeBlock.prototype.triggerClose = function (e) {
            return this.trigger("close");
        };

        return AddTimeBlock;

    })(RG.Views.BaseView);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty,
        slice = [].slice;

    RG.Views.CustomAvailability.AvailabilityBreakdown = (function (superClass) {
        extend(AvailabilityBreakdown, superClass);

        function AvailabilityBreakdown() {
            return AvailabilityBreakdown.__super__.constructor.apply(this, arguments);
        }

        AvailabilityBreakdown.prototype.initialize = function (options) {
            this.bookedMinutes = options.bookedMinutes;
            this.availableMinutes = options.availableMinutes;
            return this.overtimeMinutes = options.overtimeMinutes;
        };

        AvailabilityBreakdown.prototype.render = function () {
            if (this.availableMinutes > 0) {
                this.$el.append(this._renderAvailabilityBar());
                this.$el.append(this._renderAvailabilityHours());
            }
            return this;
        };

        AvailabilityBreakdown.prototype._renderAvailabilityBar = function () {
            var bookedOvertimeMinutes, options, ref, title, unbookedAvailableMinutes, usedNormalMinutes;
            bookedOvertimeMinutes = this.overtimeMinutes > 0 && this.availableMinutes - this.bookedMinutes < this.overtimeMinutes ? Math.abs(this.availableMinutes - this.bookedMinutes - this.overtimeMinutes) : 0;
            usedNormalMinutes = this.bookedMinutes - bookedOvertimeMinutes;
            title = (RG.Utils.TimeFormatter.formatMinutes(usedNormalMinutes)) + " booked";
            options = [
                {
                    width: usedNormalMinutes / this.availableMinutes,
                    color: "#9F9F9F",
                    className: "progress-bar__bar",
                    title: title
                }
            ];
            if (this.overtimeMinutes) {
                if (this.availableMinutes - this.overtimeMinutes < this.bookedMinutes) {
                    title = (RG.Utils.TimeFormatter.formatMinutes(bookedOvertimeMinutes)) + " overtime booked";
                    options.push({
                        width: bookedOvertimeMinutes / this.availableMinutes,
                        color: '#B47972',
                        className: "progress-bar__bar",
                        title: title
                    });
                    if (this.bookedMinutes < this.availableMinutes) {
                        title = (RG.Utils.TimeFormatter.formatMinutes(this.availableMinutes - this.bookedMinutes)) + " overtime unused";
                        options.push({
                            width: (this.availableMinutes - this.bookedMinutes) / this.availableMinutes,
                            color: '#F7BCB5',
                            className: "progress-bar__bar",
                            title: title
                        });
                    }
                } else {
                    unbookedAvailableMinutes = this.availableMinutes - this.overtimeMinutes - this.bookedMinutes;
                    title = (RG.Utils.TimeFormatter.formatMinutes(unbookedAvailableMinutes)) + " free";
                    options.push({
                        width: unbookedAvailableMinutes / this.availableMinutes,
                        color: '#FFF',
                        className: "progress-bar__bar",
                        title: title
                    });
                    if (this.bookedMinutes < this.availableMinutes) {
                        title = (RG.Utils.TimeFormatter.formatMinutes(this.overtimeMinutes)) + " overtime unused";
                        options.push({
                            width: this.overtimeMinutes / this.availableMinutes,
                            color: '#F7BCB5',
                            className: "progress-bar__bar",
                            title: title
                        });
                    }
                }
            } else {
                unbookedAvailableMinutes = this._getFreeMinutes();
                title = (RG.Utils.TimeFormatter.formatMinutes(unbookedAvailableMinutes)) + " free";
                options.push({
                    width: unbookedAvailableMinutes / this.availableMinutes,
                    color: '#FFF',
                    className: "progress-bar__bar",
                    title: title
                });
            }
            return (ref = RG.Views.Calendar.UtilisationBarFactory).create.apply(ref, [1, "progress-bar"].concat(slice.call(options)));
        };

        AvailabilityBreakdown.prototype._renderAvailabilityHours = function () {
            var el;
            el = $("<div></div>").addClass("availability-info__hours");
            el.append($("<span></span>").addClass("pull--left").text((RG.Utils.TimeFormatter.formatMinutes(this.bookedMinutes)) + " booked"));
            el.append($("<span></span>").addClass("pull--right").text((RG.Utils.TimeFormatter.formatMinutes(this._getFreeMinutes())) + " free"));
            return el;
        };

        AvailabilityBreakdown.prototype._getFreeMinutes = function () {
            return Math.max(this.availableMinutes - this.bookedMinutes, 0);
        };

        return AvailabilityBreakdown;

    })(RG.Views.BaseView);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.CustomAvailability.DateRange = (function (superClass) {
        extend(DateRange, superClass);

        function DateRange() {
            return DateRange.__super__.constructor.apply(this, arguments);
        }

        DateRange.prototype.template = templates.find('availability/date_range');

        DateRange.prototype.className = "js-date-range-component";

        DateRange.prototype.initialize = function (options) {
            this.weekDay = options.weekDay;
            return DateRange.__super__.initialize.apply(this, arguments);
        };

        DateRange.prototype.render = function () {
            this.$el.html(this.template());
            this._fillValues();
            return this;
        };

        DateRange.prototype._fillValues = function () {
            this.$(".js-day-name").text(new RG.Utils.DayName(this.weekDay).toString());
            return this._setDateText();
        };

        DateRange.prototype._setDateText = function () {
            var date;
            if (this._hasMultipleDays()) {
                this.$(".js-date-range").text(this.model);
                return this._setMultipleDays();
            } else {
                date = _.find(this.model.getDates(), (function (_this) {
                    return function (date) {
                        return date.getDay() === _this.weekDay;
                    };
                })(this));
                this.$(".js-date-range").text(new RG.Utils.DateRange(date, date).toString());
                return this._setSingleDay();
            }
        };

        DateRange.prototype._hasMultipleDays = function () {
            return _.select(this.model.getDates(), (function (_this) {
                return function (date) {
                    return date.getDay() === _this.weekDay;
                };
            })(this)).length > 1;
        };

        DateRange.prototype._setMultipleDays = function () {
            this.$(".js-multiple-days-every").text("Every ");
            return this.$(".js-multiple-days-from").text("from ");
        };

        DateRange.prototype._setSingleDay = function () {
            this.$(".js-multiple-days-every").text("");
            return this.$(".js-multiple-days-from").text("");
        };

        return DateRange;

    })(RG.Views.BaseView);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.CustomAvailability.Day = (function (superClass) {
        extend(Day, superClass);

        function Day() {
            return Day.__super__.constructor.apply(this, arguments);
        }

        Day.prototype.template = templates.find('availability/day');

        Day.prototype.tagName = 'li';

        Day.prototype.className = 'custom-availability-day';

        Day.prototype.initialize = function (options) {
            this.dateRange = options.dateRange;
            this.date = this.collection.day.date;
            if (this.collection.dayOverlap) {
                return this.hours = 'varies';
            } else {
                return this.hours = this.collection.getMinutesAvailableForDate(this.date) / 60;
            }
        };

        Day.prototype.render = function () {
            var timeBlocksView;
            this.$el.html(this.template({
                day: this.collection.day,
                hours: this.hours,
                cid: this.cid,
                overtime: 5
            }));
            timeBlocksView = new RG.Views.CustomAvailability.TimeBlocks({
                collection: this.collection
            });
            this.$el.find(".js-day-details").replaceWith(timeBlocksView.el);
            this.removeBody();
            return this;
        };

        Day.prototype.renderBody = function () {
            var body, i, len, model, ref;
            this.$el.addClass('active');
            ref = this.collection.models;
            for (i = 0, len = ref.length; i < len; i++) {
                model = ref[i];
                this.addItem(model);
            }
            body = this.$el.find('.js-custom-availability-day-body');
            this.$el.find('.js-availability-overview').show();
            this.$el.find('.js-custom-availability-helper-text').show();
            if (this.collection.dayOverlap) {
                return this.$el.find('.js-availability-varies-text').show();
            }
        };

        Day.prototype.removeBody = function () {
            this.$el.removeClass('active');
            this.$el.find('.js-day-details').html('');
            this.$el.find('.js-availability-overview').hide();
            this.$el.find('.js-custom-availability-helper-text').hide();
            return this.$el.find('.js-availability-varies-text').hide();
        };

        return Day;

    })(RG.Views.BaseView);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.CustomAvailability.DayDetail = (function (superClass) {
        extend(DayDetail, superClass);

        function DayDetail() {
            return DayDetail.__super__.constructor.apply(this, arguments);
        }

        DayDetail.prototype.template = templates.find('availability/day_detail');

        DayDetail.prototype.className = "availability-info";

        DayDetail.prototype.initialize = function (options) {
            this.timeOffText = options.timeOffText;
            return this.listenTo(this.model.getFirstAvailablePeriods(), "remove reset", this.render);
        };

        DayDetail.prototype.render = function () {
            this.$el.html(this.template());
            this._fillValues();
            return this;
        };

        DayDetail.prototype.remove = function () {
            var ref, ref1, ref2, ref3;
            this.model.getFirstAvailablePeriods().off("remove reset", this.render);
            if ((ref = this.breakdown) != null) {
                ref.remove();
            }
            if ((ref1 = this.dateRangeView) != null) {
                ref1.remove();
            }
            if ((ref2 = this.timeBlocks) != null) {
                ref2.remove();
            }
            if ((ref3 = this.totalAvailabilityView) != null) {
                ref3.remove();
            }
            return DayDetail.__super__.remove.apply(this, arguments);
        };

        DayDetail.prototype._fillValues = function () {
            this._renderDateRange();
            this._renderTimeBlocks();
            this._renderAvailabilityText();
            return this._renderBreakdownBar();
        };

        DayDetail.prototype._renderDateRange = function () {
            var dateRange, dayName;
            dateRange = this.model.getDateRange();
            if (dateRange.getNumberOfDays() > 1) {
                dayName = new RG.Utils.DayName(this.model.get('weekDay'));
                this.dateRangeView = new RG.Views.CustomAvailability.DateRange({
                    weekDay: this.model.get('weekDay'),
                    model: dateRange
                });
                return this.$(".js-date-range-component").replaceWith(this.dateRangeView.render().el);
            }
        };

        DayDetail.prototype._renderTimeBlocks = function () {
            var collection;
            if (this.model.availabilityConsistent()) {
                collection = this.model.getFirstAvailablePeriods();
                this.timeBlocks = new RG.Views.CustomAvailability.TimeBlocks({
                    collection: collection,
                    varies: this.model.variesFromNormalAvailability()
                });
                return this.$(".js-time-blocks").replaceWith(this.timeBlocks.render().el);
            } else {
                return this.$(".js-time-blocks").remove();
            }
        };

        DayDetail.prototype._renderAvailabilityText = function () {
            if (this.model.availabilityAndDowntimeConsistent()) {
                this.totalAvailabilityView = new RG.Views.CustomAvailability.TotalAvailabilityText({
                    availabilityConsistent: this.model.totalAvailabilityAndDowntimeConsistent(),
                    availableMinutes: this.model.getCurrentMinutesAvailable(),
                    overtimeMinutes: this._getOvertimeMinutes(),
                    downtimes: this.model.getFirstDowntimes(),
                    timeOffText: this.timeOffText
                });
                return this.$(".js-availability-text").replaceWith(this.totalAvailabilityView.render().el);
            }
        };

        DayDetail.prototype._renderBreakdownBar = function () {
            if (this.model.totalAvailabilityAndBookingsConsistent()) {
                this.breakdown = new RG.Views.CustomAvailability.AvailabilityBreakdown({
                    availableMinutes: this.model.getTotalMinutesAvailable(),
                    bookedMinutes: _.reduce(this._getFirstDurations(), (function (acc, d) {
                        return acc + d.getMinutes();
                    }), 0),
                    overtimeMinutes: this._getOvertimeMinutes()
                });
                return this.$el.append(this.breakdown.render().el);
            } else {
                return this.$el.append($(document.createElement("em")).text("Availability and booked/free time vary over this time period.").addClass('availability-info__info'));
            }
        };

        DayDetail.prototype._getFirstDurations = function () {
            var k, ref, v;
            ref = this.model.get('durations');
            for (k in ref) {
                v = ref[k];
                return _.filter(v, function (d) {
                    return d.isConfirmed();
                });
            }
        };

        DayDetail.prototype._getOvertimeMinutes = function () {
            if (this.model.overtimesConsistent()) {
                return this.model.overtime();
            }
            return null;
        };

        DayDetail.prototype._getDowntimeMinutes = function () {
            return this.model.downtime();
        };

        DayDetail.prototype._setVarianceText = function (text) {
            return this.$(".js-variance-text").text(text);
        };

        return DayDetail;

    })(RG.Views.BaseView);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.CustomAvailability.DayDetailForm = (function (superClass) {
        extend(DayDetailForm, superClass);

        function DayDetailForm() {
            return DayDetailForm.__super__.constructor.apply(this, arguments);
        }

        DayDetailForm.prototype.className = "js-day-detail availability-info";

        DayDetailForm.prototype.events = {
            "click .js-text--edit-overtime": "popupOvertime"
        };

        DayDetailForm.prototype.initialize = function () {
            this.model.on('availabilityReset', this._rebindAps, this);
            return DayDetailForm.__super__.initialize.apply(this, arguments);
        };

        DayDetailForm.prototype._bindAps = function () {
            return this.model.getFirstAvailablePeriods().on("remove reset", this.render, this);
        };

        DayDetailForm.prototype._rebindAps = function () {
            this.model.getFirstAvailablePeriods().off("remove reset", this.render);
            return this._bindAps();
        };

        DayDetailForm.prototype.remove = function () {
            var ref;
            this.model.off('availabilityReset', this._rebindAps, this);
            this.closePopovers();
            if ((ref = this.timeBlock) != null) {
                ref.remove();
            }
            this._removeOvertimePopover();
            return DayDetailForm.__super__.remove.apply(this, arguments);
        };

        DayDetailForm.prototype._renderBreakdownBar = function () { };

        DayDetailForm.prototype._renderTimeBlocks = function () {
            var collection, dayName;
            if (this.model.availabilityConsistent()) {
                collection = this.model.getFirstAvailablePeriods();
                this.timeBlocks = new RG.Views.CustomAvailability.RemovableTimeBlocks({
                    collection: collection
                });
                this.timeBlocks.on("updatePosition", (function (_this) {
                    return function () {
                        return _this.trigger("updatePosition");
                    };
                })(this));
                this.$(".js-time-blocks").replaceWith(this.timeBlocks.render().el);
            } else {
                this.timeBlock = new RG.Views.CustomAvailability.RemovableTimeBlock({
                    model: new RG.Models.VaryingAvailablePeriod
                });
                this.timeBlock.on("remove", this.clearVaryingAvailability, this);
                dayName = new RG.Utils.DayName(this.model.get('weekDay'));
                this.$(".js-time-blocks").append($(document.createElement("p")).text("Availability varies within this date range. To change that, you can specify times below " + "to apply to every " + dayName.fullName() + " within the date range. If you make no changes, it " + "will remain varied on " + dayName.fullName() + "s."));
                this.$(".js-time-blocks").append(this.timeBlock.render().el);
            }
            return this._bindEvents();
        };

        DayDetailForm.prototype._bindEvents = function () {
            return this.on("openDropdown", (function (_this) {
                return function () {
                    var ref;
                    return (ref = _this.timeBlocks) != null ? ref.trigger("openDropdown") : void 0;
                };
            })(this));
        };

        DayDetailForm.prototype._renderAvailabilityText = function () {
            var availableMinutes, overtimeMinutes, ref;
            if ((ref = this.totalAvailabilityView) != null) {
                ref.remove();
            }
            overtimeMinutes = this._getOvertimeMinutes();
            availableMinutes = this.model.getCurrentMinutesAvailable();
            if (overtimeMinutes > availableMinutes) {
                overtimeMinutes = 0;
            }
            this.totalAvailabilityView = new RG.Views.CustomAvailability.TotalAvailabilityText({
                availabilityConsistent: this.model.totalAvailabilityConsistent(),
                availableMinutes: availableMinutes,
                overtimeConsistent: this.model.overtimesConsistent(),
                overtimeMinutes: overtimeMinutes,
                downtimes: this.model.getFirstDowntimes(),
                timeOffText: this.timeOffText,
                alwaysShowOvertime: true,
                className: 'availability-info__edit',
                overtimeClassName: 'text--edit-overtime js-text--edit-overtime'
            });
            return this.$el.append(this.totalAvailabilityView.render().el);
        };

        DayDetailForm.prototype.closePopovers = function () {
            var ref, ref1, ref2, ref3, ref4, ref5, ref6;
            if ((ref = this.overTimePopover) != null) {
                ref.remove();
            }
            if ((ref1 = this.timeBlocks) != null) {
                if ((ref2 = ref1.addTimeBlockView) != null) {
                    ref2.remove();
                }
            }
            if ((ref3 = this.timeBlocks) != null) {
                if ((ref4 = ref3.editTimeBlockView) != null) {
                    ref4.remove();
                }
            }
            if ((ref5 = this.timeBlocks) != null) {
                ref5.addTimeBlockView = null;
            }
            return (ref6 = this.timeBlocks) != null ? ref6.editTimeBlockView = null : void 0;
        };

        DayDetailForm.prototype.popupOvertime = function (e) {
            e.stopPropagation();
            this.trigger('editing:overtime');
            $(".dropdown").removeClass("open");
            this._removeOvertimePopover();
            this.overTimePopover = new RG.Views.Dialogs.EditOvertimePopover({
                availabilityConsistent: this.model.totalAvailabilityConsistent(),
                availableMinutes: this.model.getCurrentMinutesAvailable(),
                overtimeMinutes: this._getOvertimeMinutes(),
                attachTo: this.$(".js-availability-text-container")
            });
            this.overTimePopover.on("editing:overtime:done", (function (_this) {
                return function () {
                    return _this.trigger('editing:overtime:done');
                };
            })(this));
            this.overTimePopover.on('change', (function (_this) {
                return function (value) {
                    if (+value > 0 && _this.model.getFirstOvertimes().models.length === 0) {
                        _this.model.getFirstOvertimes().add(new RG.Models.Overtime({
                            resourceInstanceId: _this.model.collection.resourceId,
                            duration: value
                        }));
                    } else {
                        _this.model.setOvertime(value);
                    }
                    _this.overTimePopover = null;
                    return _this._renderAvailabilityText();
                };
            })(this));
            return this.overTimePopover.popup();
        };

        DayDetailForm.prototype._removeOvertimePopover = function () {
            var ref, ref1, ref2;
            if ((ref = this.overTimePopover) != null) {
                ref.off('change');
            }
            if ((ref1 = this.overTimePopover) != null) {
                ref1.off('editing:overtime:done');
            }
            if ((ref2 = this.overTimePopover) != null) {
                ref2.remove();
            }
            return this.trigger("overtime:popover:removed");
        };

        DayDetailForm.prototype.clearVaryingAvailability = function () {
            this.model.clearVaryingAvailability();
            this.trigger('availabilityCleared', this.model);
            return this.model.getFirstAvailablePeriods().trigger('reset');
        };

        return DayDetailForm;

    })(RG.Views.CustomAvailability.DayDetail);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.CustomAvailability.DayRange = (function (superClass) {
        extend(DayRange, superClass);

        function DayRange() {
            return DayRange.__super__.constructor.apply(this, arguments);
        }

        DayRange.prototype.className = 'availability-tabs';

        DayRange.prototype.events = {
            "click .js-edit-availability": "triggerEdit"
        };

        DayRange.prototype.initialize = function (options) {
            this.selectedDay = options.selectedDay || this.collection.models[0];
            return this.resource = options.resource;
        };

        DayRange.prototype.remove = function () {
            var ref, ref1;
            if ((ref = this.dayDetailView) != null) {
                ref.remove();
            }
            if ((ref1 = this.tabsView) != null) {
                ref1.remove();
            }
            return DayRange.__super__.remove.apply(this, arguments);
        };

        DayRange.prototype.render = function () {
            this.$el.empty();
            this._renderTabs();
            if (RG.Utils.Permissions.canManageResource(this.resource)) {
                this.$el.append('<a class="availability-tabs__edit js-edit-availability">Edit</a>');
            }
            this._renderDetail(this.selectedDay);
            return this;
        };

        DayRange.prototype.triggerEdit = function () {
            return this.trigger("edit");
        };

        DayRange.prototype._getTabs = function () {
            return this.collection;
        };

        DayRange.prototype._buildDayDetailView = function (model) {
            return this.dayDetailView = new RG.Views.CustomAvailability.DayDetail({
                model: model,
                timeOffText: this.resource.getDowntimeText()
            });
        };

        DayRange.prototype._renderDetail = function (model) {
            var ref, ref1;
            if ((ref = this.dayDetailView) != null) {
                ref.remove();
            }
            this._buildDayDetailView(model);
            this.$el.append(this.dayDetailView.render().el);
            this.selectedDay = model;
            this.trigger("change", model);
            return (ref1 = this.tabsView) != null ? ref1.setTab(model) : void 0;
        };

        DayRange.prototype._renderTabs = function () {
            if (this.collection.length > 1) {
                this.tabsView = new RG.Views.CustomAvailability.DayTabs({
                    collection: this._getTabs()
                });
                this.tabsView.on("change", (function (_this) {
                    return function (model) {
                        return _this._renderDetail(model);
                    };
                })(this));
                return this.$el.append(this.tabsView.render().el);
            }
        };

        return DayRange;

    })(RG.Views.BaseView);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.CustomAvailability.DayRangeForm = (function (superClass) {
        extend(DayRangeForm, superClass);

        function DayRangeForm() {
            return DayRangeForm.__super__.constructor.apply(this, arguments);
        }

        DayRangeForm.prototype.render = function () {
            this.$el.empty();
            this._renderTabs();
            this._renderDetail(this.selectedDay);
            this._bindEvents();
            return this;
        };

        DayRangeForm.prototype.closePopovers = function () {
            return this.dayDetailView.closePopovers();
        };

        DayRangeForm.prototype._bindEvents = function () {
            return this.on("openDropdown", (function (_this) {
                return function () {
                    var ref;
                    return (ref = _this.dayDetailView) != null ? ref.trigger("openDropdown") : void 0;
                };
            })(this));
        };

        DayRangeForm.prototype._buildDayDetailView = function (model) {
            this.dayDetailView = new RG.Views.CustomAvailability.DayDetailForm({
                model: model,
                timeOffText: this.resource.getDowntimeText()
            });
            this.dayDetailView.on('availabilityCleared', ((function (_this) {
                return function (model) {
                    return _this.trigger('change', model);
                };
            })(this)), this);
            this.dayDetailView.on("updatePosition", (function (_this) {
                return function () {
                    return _this.trigger("updatePosition");
                };
            })(this));
            this._bindOvertime();
            return this.dayDetailView;
        };

        DayRangeForm.prototype._rebindEditingOvertime = function () {
            this.dayDetailView.off('editing:overtime');
            this.dayDetailView.off('editing:overtime:done');
            return this._bindOvertime();
        };

        DayRangeForm.prototype._bindOvertime = function () {
            this.dayDetailView.on('editing:overtime', (function (_this) {
                return function () {
                    return _this.trigger('editing:overtime');
                };
            })(this));
            this.dayDetailView.on('editing:overtime:done', (function (_this) {
                return function () {
                    return _this.trigger('editing:overtime:done');
                };
            })(this));
            return this.dayDetailView.on('overtime:popover:removed', this._rebindEditingOvertime, this);
        };

        return DayRangeForm;

    })(RG.Views.CustomAvailability.DayRange);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.CustomAvailability.DayTab = (function (superClass) {
        extend(DayTab, superClass);

        function DayTab() {
            return DayTab.__super__.constructor.apply(this, arguments);
        }

        DayTab.prototype.tagName = 'li';

        DayTab.prototype.className = 'availability-tabs__title tab-title';

        DayTab.prototype.events = {
            'click': 'triggerChange'
        };

        DayTab.prototype.initialize = function () {
            this._bindAps();
            return this.model.on('availabilityReset', this.rebindAps, this);
        };

        DayTab.prototype.remove = function () {
            this.model.off('availabilityReset', this.rebindAps, this);
            this.aps.off("add remove reset", this.render, this);
            return DayTab.__super__.remove.apply(this, arguments);
        };

        DayTab.prototype.rebindAps = function () {
            this.aps.off('add remove reset', this.render, this);
            return this._bindAps();
        };

        DayTab.prototype._bindAps = function () {
            this.aps = this.model.getFirstAvailablePeriods();
            return this.aps.on("add remove reset", this.render, this);
        };

        DayTab.prototype.render = function () {
            var dayName;
            dayName = new RG.Utils.DayName(this.model.get('weekDay'));
            this.$el.html("<a>" + dayName + " <span>" + (this._getTimeString()) + "</span></a>");
            return this;
        };

        DayTab.prototype.activate = function () {
            return this.$el.addClass('active');
        };

        DayTab.prototype.deactivate = function () {
            return this.$el.removeClass('active');
        };

        DayTab.prototype.triggerChange = function () {
            return this.trigger("change", this.model);
        };

        DayTab.prototype._getTimeString = function () {
            var minutes;
            minutes = this.model.getAvailabilityWithoutDowntime();
            if (this.model.availabilityConsistent()) {
                return RG.Utils.TimeFormatter.formatMinutes(minutes);
            } else {
                return "Varied";
            }
        };

        return DayTab;

    })(RG.Views.BaseView);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.CustomAvailability.DayTabs = (function (superClass) {
        extend(DayTabs, superClass);

        function DayTabs() {
            return DayTabs.__super__.constructor.apply(this, arguments);
        }

        DayTabs.prototype.tagName = 'ul';

        DayTabs.prototype.className = 'tabs';

        DayTabs.prototype.itemView = RG.Views.CustomAvailability.DayTab;

        DayTabs.prototype.render = function () {
            var defaultModel, ref;
            DayTabs.__super__.render.apply(this, arguments);
            defaultModel = ((ref = this.currentTab) != null ? ref.model : void 0) || this.collection.models[0];
            if (defaultModel) {
                this.setTab(defaultModel);
            }
            return this;
        };

        DayTabs.prototype.remove = function () {
            var ref;
            if ((ref = this.currentTab) != null) {
                ref.remove();
            }
            this.currentTab = null;
            return DayTabs.__super__.remove.apply(this, arguments);
        };

        DayTabs.prototype.setTab = function (model) {
            var ref, ref1;
            if ((ref = this.currentTab) != null) {
                ref.deactivate();
            }
            this.currentTab = this.collectionViews[model.cid];
            return (ref1 = this.currentTab) != null ? ref1.activate() : void 0;
        };

        DayTabs.prototype._insertView = function (view) {
            DayTabs.__super__._insertView.apply(this, arguments);
            return view.on("change", (function (_this) {
                return function (model) {
                    _this.trigger("change", model);
                    return _this.setTab(view.model);
                };
            })(this));
        };

        DayTabs.prototype._removeView = function (view) {
            DayTabs.__super__._removeView.apply(this, arguments);
            return view.off("change");
        };

        return DayTabs;

    })(RG.Support.SortedCollectionView);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.CustomAvailability.EditTimeBlock = (function (superClass) {
        extend(EditTimeBlock, superClass);

        function EditTimeBlock() {
            return EditTimeBlock.__super__.constructor.apply(this, arguments);
        }

        EditTimeBlock.prototype.template = templates.find('availability/add_timeblock');

        EditTimeBlock.prototype.initialize = function (options) {
            this.newTimeBlockStartTime = options.newTimeBlockStartTime;
            return this.newTimeBlockEndTime = options.newTimeBlockEndTime;
        };

        EditTimeBlock.prototype.render = function () {
            EditTimeBlock.__super__.render.apply(this, arguments);
            this.$('.js-add-button').text('Update');
            this.$(".js-cancel-button").on("click", (function (_this) {
                return function (e) {
                    e.stopPropagation();
                    return _this.triggerClose(e);
                };
            })(this));
            this.$('h3').text('Edit Time Block');
            return this;
        };

        return EditTimeBlock;

    })(RG.Views.CustomAvailability.AddTimeBlock);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.CustomAvailability.RemovableTimeBlock = (function (superClass) {
        extend(RemovableTimeBlock, superClass);

        function RemovableTimeBlock() {
            return RemovableTimeBlock.__super__.constructor.apply(this, arguments);
        }

        RemovableTimeBlock.prototype.tagName = 'span';

        RemovableTimeBlock.prototype.className = 'availability-info__timeblock-edit js-timeblock';

        RemovableTimeBlock.prototype.events = {
            "click .js-close": "removeTimeBlock",
            "click": 'editTimeBlock'
        };

        RemovableTimeBlock.prototype.remove = function () {
            this.off();
            this.$el.off();
            return RemovableTimeBlock.__super__.remove.apply(this, arguments);
        };

        RemovableTimeBlock.prototype.render = function () {
            if (this.model.isEditable()) {
                this.$el.append($(document.createElement('a')).text(this.model.toString()).addClass('js-edit time-link'));
            } else {
                this.$el.html(this.model.toString());
            }
            this.$el.append('<span type="button" class="close js-close" aria-hidden="true">Ã—</span>');
            this.$el.on("click", (function (_this) {
                return function (e) {
                    return _this.editTimeBlock(e);
                };
            })(this));
            return this;
        };

        RemovableTimeBlock.prototype.editTimeBlock = function (e) {
            this.trigger('edit', this);
            return e.stopPropagation();
        };

        RemovableTimeBlock.prototype.removeTimeBlock = function (e) {
            this.trigger("remove", this.model);
            return e.stopPropagation();
        };

        return RemovableTimeBlock;

    })(RG.Views.CustomAvailability.TimeBlock);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.CustomAvailability.RemovableTimeBlocks = (function (superClass) {
        extend(RemovableTimeBlocks, superClass);

        function RemovableTimeBlocks() {
            return RemovableTimeBlocks.__super__.constructor.apply(this, arguments);
        }

        RemovableTimeBlocks.prototype.itemView = RG.Views.CustomAvailability.RemovableTimeBlock;

        RemovableTimeBlocks.prototype.className = 'availability-info__time';

        RemovableTimeBlocks.prototype.events = {
            "click .js-add-timeblock": "addTimeBlock"
        };

        RemovableTimeBlocks.prototype.remove = function () {
            var ref, ref1;
            this.off();
            this.$el.off();
            if ((ref = this.addTimeBlockView) != null) {
                ref.remove();
            }
            if ((ref1 = this.editTimeBlockView) != null) {
                ref1.remove();
            }
            return RemovableTimeBlocks.__super__.remove.apply(this, arguments);
        };

        RemovableTimeBlocks.prototype.render = function () {
            var addTimeblock, firstAvailablePeriod;
            RemovableTimeBlocks.__super__.render.apply(this, arguments);
            firstAvailablePeriod = this.collection.models[0];
            if (!firstAvailablePeriod || !firstAvailablePeriod.isAllDay()) {
                addTimeblock = $(document.createElement("div")).addClass("availability-info__timeblock-add js-add-timeblock").append("<a class='time-link'>Add time block</a>");
                this.$el.append(addTimeblock);
            }
            this._bindEvents();
            this._addLastTimeBlockClass();
            return this;
        };

        RemovableTimeBlocks.prototype._bindEvents = function () {
            return this.on("openDropdown", (function (_this) {
                return function () {
                    var ref, ref1;
                    if ((ref = _this.addTimeBlockView) != null) {
                        ref.remove();
                    }
                    return (ref1 = _this.editTimeBlockView) != null ? ref1.remove() : void 0;
                };
            })(this));
        };

        RemovableTimeBlocks.prototype._insertView = function (view, model) {
            RemovableTimeBlocks.__super__._insertView.apply(this, arguments);
            view.on("remove", (function (_this) {
                return function (model) {
                    return _this.collection.remove(model);
                };
            })(this));
            view.on("edit", (function (_this) {
                return function (view) {
                    return _this.editTimeBlock(view);
                };
            })(this));
            return view;
        };

        RemovableTimeBlocks.prototype._removeView = function (view) {
            this.trigger("updatePosition");
            view.off("remove");
            return RemovableTimeBlocks.__super__._removeView.apply(this, arguments);
        };

        RemovableTimeBlocks.prototype.editTimeBlock = function (view) {
            var newTimeBlockStartTime, ref, ref1, ref2;
            $(".dropdown").removeClass("open");
            if ((ref = this.addTimeBlockView) != null) {
                ref.remove();
            }
            if ((ref1 = this.editTimeBlockView) != null) {
                ref1.remove();
            }
            newTimeBlockStartTime = (ref2 = this.collection.last()) != null ? ref2.attributes.endTime : void 0;
            this.editTimeBlockView = new RG.Views.Dialogs.EditTimeBlockDropdown({
                attachTo: view.$el,
                newTimeBlockStartTime: view.model.get('startTime'),
                newTimeBlockEndTime: view.model.get('endTime')
            });
            this.editTimeBlockView.popup();
            this.editTimeBlockView.on("update", (function (_this) {
                return function (availablePeriod) {
                    return _this._update(availablePeriod);
                };
            })(this));
            return this.editTimeBlockView.on("remove", (function (_this) {
                return function (availablePeriod) {
                    return _this._remove(availablePeriod);
                };
            })(this));
        };

        RemovableTimeBlocks.prototype.addTimeBlock = function (e) {
            var newTimeBlockStartTime, ref, ref1, ref2;
            $(".dropdown").removeClass("open");
            if ((ref = this.addTimeBlockView) != null) {
                ref.remove();
            }
            if ((ref1 = this.editTimeBlockView) != null) {
                ref1.remove();
            }
            newTimeBlockStartTime = (ref2 = this.collection.last()) != null ? ref2.attributes.endTime : void 0;
            this.addTimeBlockView = new RG.Views.Dialogs.AddTimeBlockPopover({
                attachTo: this.$(".js-add-timeblock"),
                newTimeBlockStartTime: newTimeBlockStartTime
            });
            this.addTimeBlockView.popup();
            this.addTimeBlockView.on("add", (function (_this) {
                return function (availablePeriod) {
                    return _this._update(availablePeriod);
                };
            })(this));
            return e.stopPropagation();
        };

        RemovableTimeBlocks.prototype._convertToCustomAvailablePeriods = function () {
            var customAvailablePeriods;
            customAvailablePeriods = this.collection.map(function (ap) {
                return new RG.Models.CustomAvailablePeriod({
                    startTime: ap.get('startTime'),
                    endTime: ap.get('endTime'),
                    pending: true
                });
            });
            return this.collection.reset(customAvailablePeriods, {
                silent: true
            });
        };

        RemovableTimeBlocks.prototype._mergeOverlaps = function () {
            var customAvailablePeriods, timeRanges, tr;
            if (!this.collection.length) {
                return;
            }
            timeRanges = this.collection.map(function (ap) {
                return new RG.Utils.TimeRange(ap.get('startTime'), ap.get('endTime'));
            });
            tr = timeRanges.shift();
            timeRanges = tr.merge.apply(tr, timeRanges);
            customAvailablePeriods = _.map(timeRanges, function (tr) {
                return new RG.Models.CustomAvailablePeriod({
                    startTime: tr.startTime,
                    endTime: tr.endTime
                });
            });
            return this.collection.reset(customAvailablePeriods);
        };

        RemovableTimeBlocks.prototype._update = function (availablePeriod) {
            this._convertToCustomAvailablePeriods();
            this.collection.add(availablePeriod);
            this._mergeOverlaps();
            this._addLastTimeBlockClass();
            this.trigger("updatePosition");
            this.addTimeBlockView = null;
            return this.editTimeBlockView = null;
        };

        RemovableTimeBlocks.prototype._addLastTimeBlockClass = function () {
            return this.$('.js-timeblock:last').addClass('last-timeblock');
        };

        RemovableTimeBlocks.prototype._remove = function (availablePeriod) {
            var period;
            period = this.collection.findWhere({
                startTime: availablePeriod.get('startTime'),
                endTime: availablePeriod.get('endTime')
            });
            return this.collection.remove(period, {
                silent: true
            });
        };

        return RemovableTimeBlocks;

    })(RG.Views.CustomAvailability.TimeBlocks);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.CustomAvailability.TimeBlocksMenu = (function (superClass) {
        extend(TimeBlocksMenu, superClass);

        function TimeBlocksMenu() {
            return TimeBlocksMenu.__super__.constructor.apply(this, arguments);
        }

        TimeBlocksMenu.prototype.className = 'js-timeblocks-menu';

        TimeBlocksMenu.prototype.render = function () {
            return this;
        };

        return TimeBlocksMenu;

    })(RG.Views.BaseView);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.CustomAvailability.TotalAvailabilityText = (function (superClass) {
        extend(TotalAvailabilityText, superClass);

        function TotalAvailabilityText() {
            return TotalAvailabilityText.__super__.constructor.apply(this, arguments);
        }

        TotalAvailabilityText.prototype.alwaysShowOvertime = false;

        TotalAvailabilityText.prototype.overtimeClassName = 'text--warning';

        TotalAvailabilityText.prototype.initialize = function (options) {
            this.timeOffText = options.timeOffText;
            this.availabilityConsistent = options.availabilityConsistent;
            this.availableMinutes = options.availableMinutes;
            this.overtimeConsistent = options.overtimeConsistent;
            this.overtimeMinutes = options.overtimeMinutes;
            if (options.alwaysShowOvertime !== void 0) {
                this.alwaysShowOvertime = options.alwaysShowOvertime;
            }
            if (options.overtimeClassName) {
                this.overtimeClassName = options.overtimeClassName;
            }
            return this.downtimes = options.downtimes;
        };

        TotalAvailabilityText.prototype.render = function () {
            var child;
            while ((child = this.el.firstChild)) {
                this.el.removeChild(child);
            }
            this.availabilityEl = $(document.createElement("p")).addClass('js-availability-text-container');
            this.overtimeEl = $(document.createElement('em')).addClass('text--small');
            this._renderDeductions();
            this._renderAvailabilityBreakdown();
            this._renderInconsistentAvailability();
            this.availabilityEl.append(this.overtimeEl);
            this._renderNoLink();
            this.$el.append(this.availabilityEl);
            return this;
        };

        TotalAvailabilityText.prototype._renderDeductions = function () {
            var downtime, downtimeLessSpan, i, len, ref, results, timeRange;
            if (this.downtimes.length > 0) {
                ref = this.downtimes;
                results = [];
                for (i = 0, len = ref.length; i < len; i++) {
                    timeRange = ref[i];
                    downtime = $(document.createElement("p")).addClass('js-availability-deduction');
                    downtimeLessSpan = $(document.createElement("span")).addClass('downtime-less').text('Less');
                    downtime.text(" " + this.timeOffText + " - " + (timeRange.toString()));
                    downtime.prepend(downtimeLessSpan);
                    results.push(this.$el.append(downtime));
                }
                return results;
            }
        };

        TotalAvailabilityText.prototype._renderAvailabilityBreakdown = function () {
            var overtime, time;
            if (this.availabilityConsistent) {
                this.availabilityEl.text("Total availability - ");
                time = $(document.createElement("strong")).text(RG.Utils.TimeFormatter.formatMinutes(this.availableMinutes));
                this.availabilityEl.append(time);
                if (this.overtimeMinutes > 0 || (this.alwaysShowOvertime && this.overtimeMinutes === 0)) {
                    overtime = $(document.createElement("strong")).addClass(this.overtimeClassName).text((RG.Utils.TimeFormatter.formatMinutes(this.overtimeMinutes)) + " overtime");
                    this.overtimeEl.append(" (including ");
                    this.overtimeEl.append(overtime);
                    return this.overtimeEl.append(")");
                } else if (this.overtimeMinutes === null) {
                    return this.overtimeEl.append($(document.createElement("span")).addClass(this.overtimeClassName).text(" (overtime varies)"));
                }
            }
        };

        TotalAvailabilityText.prototype._renderInconsistentAvailability = function () {
            var overtime;
            if (!this.availabilityConsistent) {
                this.availabilityEl.text("Availability varies");
                overtime = $(document.createElement("strong")).addClass(this.overtimeClassName);
                this._renderOvertime(overtime);
                this.overtimeEl.append(" (including ");
                this.overtimeEl.append(overtime);
                return this.overtimeEl.append(")");
            }
        };

        TotalAvailabilityText.prototype._renderOvertime = function (overtime) {
            if (this.overtimeConsistent) {
                return overtime.text((RG.Utils.TimeFormatter.formatMinutes(this.overtimeMinutes)) + " overtime");
            }
            return overtime.text("varied overtime");
        };

        TotalAvailabilityText.prototype._renderNoLink = function () {
            var e, jsClasses;
            if (!(this.availableMinutes > 0)) {
                e = $(this.availabilityEl).find("." + (this.overtimeClassName.split(' ')[0]));
                jsClasses = _.select(this.overtimeClassName.split(' '), function (klassName) {
                    return klassName.match(/js-/);
                }).join(' ');
                e.removeClass(jsClasses);
                return e.addClass('no-link');
            }
        };

        return TotalAvailabilityText;

    })(RG.Views.BaseView);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.Dialogs.Dialog = (function (superClass) {
        extend(Dialog, superClass);

        function Dialog() {
            return Dialog.__super__.constructor.apply(this, arguments);
        }

        Dialog.prototype.template = templates.find('dialogs/dialog');

        Dialog.prototype.initialize = function (options) {
            if (options == null) {
                options = {};
            }
            this.headerView = options.header;
            this.bodyView = options.body;
            return this.footerView = options.footer;
        };

        Dialog.prototype.closeOpenOptions = function () {
            return this.$(".btn-group.open").toggleClass("open");
        };

        Dialog.prototype.render = function () {
            var i, len, ref, ref1, ref2, ref3, subView;
            this.$el.html(this.template());
            this.$("header").replaceWith((ref = this.headerView) != null ? ref.render().el : void 0);
            this.$("main").replaceWith((ref1 = this.bodyView) != null ? ref1.render().el : void 0);
            this.$("footer").replaceWith((ref2 = this.footerView) != null ? ref2.render().el : void 0);
            ref3 = [this.headerView, this.bodyView, this.footerView];
            for (i = 0, len = ref3.length; i < len; i++) {
                subView = ref3[i];
                if (subView != null) {
                    subView.on("all", (function (_this) {
                        return function () {
                            return _this.trigger.apply(_this, arguments);
                        };
                    })(this));
                }
            }
            this.$el.on('click', (function (_this) {
                return function () {
                    return _this.closeOpenOptions();
                };
            })(this));
            return this;
        };

        Dialog.prototype.remove = function () {
            var ref, ref1, ref2, ref3;
            if ((ref = this.footerView) != null) {
                ref.remove();
            }
            if ((ref1 = this.headerView) != null) {
                ref1.remove();
            }
            if ((ref2 = this.headerView) != null) {
                ref2.off();
            }
            if ((ref3 = this.bodyView) != null) {
                ref3.off();
            }
            return Dialog.__super__.remove.apply(this, arguments);
        };

        return Dialog;

    })(RG.Views.BaseView);

}).call(this);
;
(function () {
    var bind = function (fn, me) { return function () { return fn.apply(me, arguments); }; },
        extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.Dialogs.NewBooking = (function (superClass) {
        extend(NewBooking, superClass);

        function NewBooking() {
            this._selectedResourceChanged = bind(this._selectedResourceChanged, this);
            return NewBooking.__super__.constructor.apply(this, arguments);
        }

        NewBooking.prototype.template = templates.find('dialogs/new_booking');

        NewBooking.prototype.initialize = function (options) {
            this.currentUserId = options.currentUserId;
            this.dateRange = options.dateRange;
            this.originalDate = this.dateRange.startDate;
            this.projects = options.projects;
            this.deletedProjects = options.deletedProjects;
            this.clients = options.clients;
            this.deletedClients = options.deletedClients;
            this.resources = options.resources;
            this.resource = options.resource;
            this.bookers = options.bookers;
            this.selectingDuration = options.selectDuration;
            this.billableChecked = false;
            this.backpackErrorsFields = [
                {
                    mountpoint: '.booking-details-error',
                    label: 'details'
                }, {
                    mountpoint: '.booking-project-id-error',
                    label: 'project_id'
                }, {
                    mountpoint: '.booking-client-id-error',
                    label: 'client_id'
                }
            ];
            if (typeof this.selectingDuration === "undefined") {
                return this.setSelectingDuration(true);
            }
        };

        NewBooking.prototype.clearInteraction = function () {
            return this.undelegateEvents();
        };

        NewBooking.prototype.render = function () {
            this._clearOldViews();
            this.$el.html(this.template());
            this._composeViews();
            this._setDurationTypeVisibility();
            this.validate();
            this.$(".chzn-select").chosen().on('liszt:showing_dropdown', (function (_this) {
                return function (e) {
                    return _this.shrinkDropdown(e);
                };
            })(this));
            this.$("#booking-start-date, #booking-end-date").datepicker({
                dateFormat: 'd M yy',
                firstDay: 1
            });
            this._bindEvents();
            return this;
        };

        NewBooking.prototype.cancel = function () {
            return this.trigger("close");
        };

        NewBooking.prototype.close = function () {
            return this._clearOldViews();
        };

        NewBooking.prototype.clearClientOrProject = function () {
            return this.clientProjectSelector.setSelectedValue(null);
        };

        NewBooking.prototype.getBookingDurationDTO = function () {
            var selector;
            selector = this.selectingDuration ? this.durationSelector : this.timeRangeSelector;
            return selector.getBookingDurationDTO();
        };

        NewBooking.prototype.saveBooking = function () {
            var selectedResource;
            if (this.$("#add-booking").attr("disabled") === "disabled") {
                return;
            }
            selectedResource = this.resourceSelector.getSelectedResource();
            this._saveBookingToApi(selectedResource, this.bookerSelector.getBooker(), this.dateRangeSelector.getDateRange(), this.clientProjectSelector.getSelectedOption(true), this.billableChecked, this.$("#booking-details").val(), this.getBookingDurationDTO());
            return false;
        };

        NewBooking.prototype._saveBookingToApi = function (resource, booker, dateRange, targetClientOrProject, billable, details, bookingDuration) {
            var command, overlay;
            overlay = RG.Utils.spinnerOverlay($(this.el).closest('.js-booking-downtime-new')[0]);
            command = new RG.Commands.CreateBookingCommand({
                resource: resource,
                booker: booker,
                dateRange: dateRange,
                target: targetClientOrProject,
                billable: billable,
                details: details,
                bookingDuration: bookingDuration,
                errorCallback: (function (_this) {
                    return function (e, xhr) {
                        overlay.close();
                        _this.$('.booking-save-error').show();
                        return Raven.captureException(e, {
                            extra: {
                                resource_id: resource.id,
                                booker_id: booker.id,
                                start_date: RG.Utils.DateFormatter.getISODate(dateRange.startDate),
                                end_date: RG.Utils.DateFormatter.getISODate(dateRange.endDate),
                                billable: billable,
                                duration: bookingDuration.duration,
                                start_time: bookingDuration.startTime,
                                target: targetClientOrProject && targetClientOrProject.constructor.name + ": " + targetClientOrProject.id,
                                xhr: {
                                    responseText: xhr.responseText,
                                    responseStatus: xhr.status
                                }
                            }
                        });
                    };
                })(this),
                successCallback: (function (_this) {
                    return function (data) {
                        RG.renderer.unlockAll();
                        RG.backburner.run(function () {
                            RG.Utils.BookingMerger.merge(resource.bookings, [data]);
                            overlay.close();
                            _this.trigger('close');
                            return resource.bookings.predictWaitingList();
                        });
                        return window.update();
                    };
                })(this)
            });
            command.removedDatesCallback = (function (_this) {
                return function (removedDates, bookingId) {
                    var placer, popover, ref, removedDatesDialog;
                    removedDatesDialog = new RG.Views.Dialogs.RemovedAvailabilityDates({
                        resource: resource,
                        removedAvailabilityDates: removedDates
                    });
                    placer = new RG.Utils.DatePopoverPlacer(resource, _this.originalDate, {
                        offsetTop: ((ref = $(".booking[data-booking-id=" + bookingId + "]").offset()) != null ? ref.top : void 0) + 40
                    });
                    popover = new RG.Views.Dialogs.BookingClashPopover({
                        removeAttachTo: true,
                        attachTo: placer.createAnchor({
                            className: 'booking-clash-popover-anchor'
                        }),
                        body: removedDatesDialog,
                        className: 'edit-booking-dropdown'
                    });
                    return RG.Popovers.replace({
                        popoverView: popover,
                        removeCallback: function () { }
                    });
                };
            })(this);
            command.waitingCallback = (function (_this) {
                return function (waitingDates) {
                    _this.waitingConfirmation = new RG.Views.Dialogs.WaitingListConfirmation({
                        resource: resource,
                        waitingDates: waitingDates,
                        duration: command.bookingDuration.duration,
                        startTime: command.bookingDuration.startTime,
                        startDate: command.dateRange.startDate,
                        endDate: command.dateRange.endDate,
                        origin: _this,
                        callback: function () {
                            RG.Utils.BookingDataParser.expirePolls();
                            command.forceWaiting = true;
                            return command.execute();
                        }
                    });
                    overlay.close();
                    _this.waitingConfirmation.on('addWaiting', (function () {
                        return _this.trigger('close');
                    }), _this);
                    return _this.trigger("changeOverlay", _this.waitingConfirmation, {
                        className: 'overlay booking-waiting'
                    });
                };
            })(this);
            RG.Utils.BookingDataParser.expirePolls();
            command.execute();
            false;
            return command.archivedCallback = (function (_this) {
                return function (data) {
                    new RG.Utils.ErrorHandler(_this.el, _this.backpackErrorsFields, data).handleErrors();
                    return overlay.close();
                };
            })(this);
        };

        NewBooking.prototype.toggleDurationTypes = function () {
            this.selectingDuration = !this.selectingDuration;
            this._setDurationTypeVisibility();
            return this.validate();
        };

        NewBooking.prototype.setSelectingDuration = function (val) {
            this.selectingDuration = val;
            return this._setDurationTypeVisibility();
        };

        NewBooking.prototype.validate = function () {
            var currentSelector, valid;
            currentSelector = this.selectingDuration ? this.durationSelector : this.timeRangeSelector;
            valid = currentSelector.validate() && this.dateRangeSelector.validate();
            if (valid) {
                this.$("#add-booking").attr("disabled", null);
            } else {
                this.$("#add-booking").attr("disabled", "disabled");
            }
            this.trigger('updatePosition');
            return valid;
        };

        NewBooking.prototype._setDurationTypeVisibility = function () {
            if (!this.resource.isHuman()) {
                this.selectingDuration = false;
                this.$(".booking-time .alt-toggle").hide();
            }
            this.$(".hours-per-day").toggle(this.selectingDuration);
            this.$(".specific-time").toggle(!this.selectingDuration);
            if (this.selectingDuration) {
                return this.$(".booking-time-field").text("Hours per day");
            } else {
                return this.$(".booking-time-field").text("Time per day");
            }
        };

        NewBooking.prototype._stopPropagation = function (e) {
            e.stopPropagation();
            return false;
        };

        NewBooking.prototype._composeViews = function () {
            var ref, ref1, ref2;
            this.resourceSelector = new RG.Views.Selectors.Resource({
                resources: this.resources,
                selected: this.resource
            });
            this.$("dd.resource-instance-value").html(this.resourceSelector.render().el);
            this.resourceSelector.on('change', this._selectedResourceChanged);
            this.dateRangeSelector = new RG.Views.Selectors.DateRange({
                dateRange: this.dateRange,
                resource: this.resource
            });
            this.$("dd.booking-date").html(this.dateRangeSelector.render().el);
            this.durationSelector = new RG.Views.Selectors.Duration({
                duration: ((ref = this._dto) != null ? ref.duration : void 0) || window.rgStorage.get("Duration:" + (this.resource.typeName())),
                typeName: this.resource.typeName()
            });
            this.$("dd.booking-time").html(this.durationSelector.render().el);
            this.timeRangeSelector = new RG.Views.Selectors.TimeRange({
                startTime: ((ref1 = this._dto) != null ? ref1.startTime : void 0) || window.rgStorage.get("TimeRange:StartTime:" + (this.resource.typeName())),
                endTime: ((ref2 = this._dto) != null ? ref2.endTime : void 0) || window.rgStorage.get("TimeRange:EndTime:" + (this.resource.typeName())),
                typeName: this.resource.typeName()
            });
            this.$("dd.booking-time").append(this.timeRangeSelector.render().el);
            if (this.resource.shouldDisplayTimeZone()) {
                this.$("dd.booking-time").append($('<div class="timezone"></div>').text(this.resource.getTimeZone().toString()));
            }
            this.clientProjectSelector = new RG.Views.Selectors.ClientProject({
                clients: this.clients,
                projects: this.projects,
                selectedValue: this.initialClientOrProject,
                container: this,
                responseWithPermissions: window.responseWithPermissions,
                colorPicker: new RG.Views.Selectors.ColorPicker
            });
            this._sortProjectsAndClientsAlphabetically();
            this.$(".project-client").html(this.clientProjectSelector.render().el);
            this._createSwitchComponent(this.billableChecked);
            this.bookerSelector = new RG.Views.Selectors.Booker({
                currentUserId: this.currentUserId,
                bookers: this.bookers,
                booking: this.booking
            });
            return this.$("dd.booker").html(this.bookerSelector.render().el);
        };

        NewBooking.prototype._bindEvents = function () {
            if (this._eventsBound) {
                return;
            }
            this._eventsBound = true;
            this.$el.on("click", "#add-booking", (function (_this) {
                return function () {
                    return _this.saveBooking();
                };
            })(this));
            this.$el.on("click", "#cancel.btn", (function (_this) {
                return function () {
                    return _this.cancel();
                };
            })(this));
            this.$el.on("click", ".booking-time .alt-toggle a", (function (_this) {
                return function (e) {
                    e.preventDefault();
                    e.stopPropagation();
                    return _this.toggleDurationTypes();
                };
            })(this));
            this.dateRangeSelector.on('change', (function (_this) {
                return function (dateRange) {
                    _this.dateRange = dateRange;
                    return _this.trigger('change', dateRange);
                };
            })(this));
            this.dateRangeSelector.on('validate', this.validate, this);
            this.durationSelector.on('validate', this.validate, this);
            this.timeRangeSelector.on('validate', this.validate, this);
            this.clientProjectSelector.on('changeOverlay', (function (_this) {
                return function (view, options) {
                    return _this.trigger("changeOverlay", view, options);
                };
            })(this));
            this.clientProjectSelector.on('cancelled', (function (_this) {
                return function () {
                    return _this.clearClientOrProject();
                };
            })(this));
            return this.clientProjectSelector.on('change', this._setBillableFromProject.bind(this));
        };

        NewBooking.prototype._clearOldViews = function () {
            var ref, ref1, ref10, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9;
            if ((ref = this.waitingConfirmation) != null) {
                ref.remove();
            }
            if ((ref1 = this.resourceSelector) != null) {
                ref1.off();
            }
            if ((ref2 = this.dateRangeSelector) != null) {
                ref2.off();
            }
            if ((ref3 = this.timeRangeSelector) != null) {
                ref3.off();
            }
            if ((ref4 = this.durationSelector) != null) {
                ref4.off();
            }
            if ((ref5 = this.resourceSelector) != null) {
                ref5.remove();
            }
            if ((ref6 = this.dateRangeSelector) != null) {
                ref6.remove();
            }
            if ((ref7 = this.durationSelector) != null) {
                ref7.remove();
            }
            if ((ref8 = this.timeRangeSelector) != null) {
                ref8.remove();
            }
            if ((ref9 = this.clientProjectSelector) != null) {
                ref9.remove();
            }
            if ((ref10 = this.bookerSelector) != null) {
                ref10.remove();
            }
            return this.$('.booking-save-error').hide();
        };

        NewBooking.prototype._sortProjectsAndClientsAlphabetically = function () {
            this.clientProjectSelector.clients.sort();
            return this.clientProjectSelector.projects.sort();
        };

        NewBooking.prototype._selectedResourceChanged = function (resource) {
            var dto, endTime, startTime;
            this.resource = resource;
            if (resource && !resource.isHuman()) {
                dto = this.getBookingDurationDTO();
                startTime = dto.startTime || 540;
                endTime = startTime + dto.duration;
                this._dto = {
                    startTime: startTime,
                    endTime: endTime,
                    duration: dto.duration
                };
            }
            this.render();
            return delete this._dto;
        };

        NewBooking.prototype._createSwitchComponent = function (isChecked) {
            var selected;
            selected = isChecked ? 'Billable' : 'Non-billable';
            return window.RGComponents.createSwitch(this.$(".booking-billable-control")[0], {
                name: 'booking-billable',
                id: 'booking-billable',
                mode: 'a-b',
                labelLeft: 'Billable',
                labelRight: 'Non-billable',
                left: 'Billable',
                right: 'Non-billable',
                selected: isChecked ? 'Billable' : 'Non-billable',
                onChange: (function (_this) {
                    return function (checked) {
                        return _this.billableChecked = checked === 'Billable' ? true : false;
                    };
                })(this)
            });
        };

        NewBooking.prototype._setBillableFromProject = function (option) {
            if (!option || option.constructor !== RG.Models.Project) {
                this.billableChecked = false;
            }
            if (option) {
                if (option.constructor === RG.Models.Client) {
                    this.billableChecked = true;
                } else {
                    this.billableChecked = option.isBillableByDefault();
                }
            }
            return this._createSwitchComponent(this.billableChecked);
        };

        return NewBooking;

    })(RG.Views.BaseView);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.Dialogs.AddTimeBlockPopover = (function (superClass) {
        extend(AddTimeBlockPopover, superClass);

        function AddTimeBlockPopover() {
            return AddTimeBlockPopover.__super__.constructor.apply(this, arguments);
        }

        AddTimeBlockPopover.prototype.cssClass = 'add-timeblock-dropdown';

        AddTimeBlockPopover.prototype.events = {
            "click .js-cancel-button": "close",
            "click": "closeSelector"
        };

        AddTimeBlockPopover.prototype.initialize = function (options) {
            this.newTimeBlockStartTime = options.newTimeBlockStartTime;
            return AddTimeBlockPopover.__super__.initialize.apply(this, arguments);
        };

        AddTimeBlockPopover.prototype.close = function () {
            return this.trigger("close");
        };

        AddTimeBlockPopover.prototype.remove = function () {
            this.attachTo = null;
            return AddTimeBlockPopover.__super__.remove.apply(this, arguments);
        };

        AddTimeBlockPopover.prototype.setBodyView = function () {
            AddTimeBlockPopover.__super__.setBodyView.apply(this, arguments);
            return this.bodyView.on("add", (function (_this) {
                return function (ap) {
                    return _this.trigger("add", ap);
                };
            })(this));
        };

        AddTimeBlockPopover.prototype.closeSelector = function (e) {
            this.bodyView.closeSelector();
            if (e) {
                return e.stopPropagation();
            }
        };

        AddTimeBlockPopover.prototype.popup = function () {
            $(".js-text--edit-overtime").on("click", (function (_this) {
                return function () {
                    return _this.remove();
                };
            })(this));
            this.setBodyView(new RG.Views.CustomAvailability.AddTimeBlock({
                newTimeBlockStartTime: this.newTimeBlockStartTime
            }));
            return AddTimeBlockPopover.__super__.popup.apply(this, arguments);
        };

        return AddTimeBlockPopover;

    })(RG.Views.Dialogs.Popover);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.Dialogs.AllowanceBreakdown = (function (superClass) {
        extend(AllowanceBreakdown, superClass);

        function AllowanceBreakdown() {
            return AllowanceBreakdown.__super__.constructor.apply(this, arguments);
        }

        AllowanceBreakdown.prototype.template = templates.find('dialogs/allowance_breakdown');

        AllowanceBreakdown.prototype.tagName = 'span';

        AllowanceBreakdown.prototype.initialize = function (options) {
            return this.model = options.model;
        };

        AllowanceBreakdown.prototype.render = function () {
            this.$el.html(this.template({
                model: this.model
            }));
            this._fillValues();
            return this;
        };

        AllowanceBreakdown.prototype._fillValues = function () {
            this._renderResourceContext();
            this._renderNumberOfDays();
            this._renderNonWorkingDays();
            return this._renderHolidays();
        };

        AllowanceBreakdown.prototype._renderResourceContext = function () {
            var element;
            if (this.model.get('resourceName')) {
                element = $(document.createElement('span')).addClass('downtime-multiple-resource-explanation').text(" (based on " + (this.model.get('resourceName')) + "'s availability)");
                return this.$('.automated-calculation-heading').append(element);
            }
        };

        AllowanceBreakdown.prototype._renderNumberOfDays = function () {
            return this.$el.append($(document.createElement('p')).text("Days in timeframe: " + this.model.get('numberOfDaysBreakdown').length));
        };

        AllowanceBreakdown.prototype._renderHolidays = function () {
            var days, holiday, holidays, results;
            holidays = this.model.getHolidays();
            if (holidays.length !== 0) {
                results = [];
                for (holiday in holidays) {
                    days = holidays[holiday];
                    results.push(this.$el.append($(document.createElement('p')).text("less " + days + " " + holiday + " " + (this._pluralize(days)) + ".")));
                }
                return results;
            }
        };

        AllowanceBreakdown.prototype._renderNonWorkingDays = function () {
            var nonWorkingDays;
            nonWorkingDays = this.model.numberOfNonWorkingDays();
            if (nonWorkingDays.length !== 0) {
                return this.$el.append($(document.createElement('p')).text("less " + nonWorkingDays + " non working-" + (this._pluralize(nonWorkingDays)) + "."));
            }
        };

        AllowanceBreakdown.prototype._pluralize = function (amount) {
            if (amount > 1) {
                return "days";
            } else {
                return "day";
            }
        };

        return AllowanceBreakdown;

    })(RG.Views.BaseView);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.Dialogs.BookingClashPopover = (function (superClass) {
        extend(BookingClashPopover, superClass);

        function BookingClashPopover() {
            return BookingClashPopover.__super__.constructor.apply(this, arguments);
        }

        BookingClashPopover.prototype.popup = function () {
            var result;
            result = BookingClashPopover.__super__.popup.apply(this, arguments);
            RG.Popovers.locked = true;
            setTimeout(((function (_this) {
                return function () {
                    return _this._scrollIntoHorizontalView();
                };
            })(this)), 100);
            setTimeout(((function (_this) {
                return function () {
                    return _this._scrollIntoVerticalView();
                };
            })(this)), 120);
            return result;
        };

        return BookingClashPopover;

    })(RG.Views.Dialogs.Popover);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.Dialogs.BookingDetailsBody = (function (superClass) {
        extend(BookingDetailsBody, superClass);

        function BookingDetailsBody() {
            return BookingDetailsBody.__super__.constructor.apply(this, arguments);
        }

        BookingDetailsBody.prototype.template = templates.find('dialogs/booking_details_body');

        BookingDetailsBody.prototype.tagName = 'main';

        BookingDetailsBody.prototype.initialize = function (options) {
            this.booking = options.booking;
            return this.actions = options.actions;
        };

        BookingDetailsBody.prototype.render = function () {
            this.$el.html(this.template());
            this._fillValues();
            return this;
        };

        BookingDetailsBody.prototype.remove = function () {
            var ref;
            if ((ref = this.actions) != null) {
                ref.remove();
            }
            return BookingDetailsBody.__super__.remove.apply(this, arguments);
        };

        BookingDetailsBody.prototype.off = function () {
            var ref;
            if ((ref = this.actions) != null) {
                ref.off();
            }
            return BookingDetailsBody.__super__.off.apply(this, arguments);
        };

        BookingDetailsBody.prototype._fillValues = function () {
            var billableText, ref, ref1;
            this._renderActions();
            this._renderResources();
            this._renderBookingTargets();
            this.$(".js-booker-img").attr("src", (ref = this.booking.get('booker')) != null ? ref.get('imageUrl') : void 0);
            this.$(".js-booker-name").text((ref1 = this.booking.get('booker')) != null ? ref1.get('name') : void 0);
            this.$("#confirmed-hours").text((RG.Utils.TimeFormatter.formatMinutes(this.booking.getConfirmedMinutes())) + " confirmed");
            this.$("#billable").text(this._billableText());
            if (this.booking.get('notes') && this.booking.get('notes').length > 0) {
                this.$("#details-field").show();
                this.$("#details").show();
                this.$("#details").html(window.segmentAutolinker(this.booking.get('notes')));
            } else {
                this.$("#details-field").hide();
                this.$("#details").hide();
            }
            if (this.booking.getWaitingMinutes() > 0) {
                this.$("#waiting-list-hours").text("+ " + (RG.Utils.TimeFormatter.formatMinutes(this.booking.getWaitingMinutes())) + " on waiting list");
                this.$("#waiting-list-hours").show();
            } else {
                this.$("#waiting-list-hours").text("");
                this.$("#waiting-list-hours").hide();
            }
            if (this.booking.get('refreshable')) {
                this.$(".availability-changed").show();
            }
            billableText = this.booking.get('billable') ? "Yes" : "No";
            return this.el.querySelector("#billable").textContent = billableText;
        };

        BookingDetailsBody.prototype._renderActions = function () {
            var ref, ref1;
            this.$(".js-actions-container").append((ref = this.actions) != null ? ref.render().el : void 0);
            return (ref1 = this.actions) != null ? ref1.on("all", (function (_this) {
                return function () {
                    return _this.trigger.apply(_this, arguments);
                };
            })(this)) : void 0;
        };

        BookingDetailsBody.prototype._renderResources = function () {
            var resourceAvatar, resourceNameElement;
            if (this.booking.collection.resource.hasAvatar()) {
                resourceAvatar = new RG.Views.Resource.Avatar({
                    resource: this.booking.collection.resource
                });
                this.$("#booking-resources").append(resourceAvatar.render().el);
            }
            resourceNameElement = $(document.createElement("span")).addClass("resource-name");
            return this.$("#booking-resources").append(resourceNameElement.text(this.booking.collection.resource.get('name')));
        };

        BookingDetailsBody.prototype._toggleBookingTargets = function (labelSelector, nameSelector, title) {
            if (title) {
                this.$(labelSelector).show();
                return this.$(nameSelector).html(title).show();
            } else {
                this.$(labelSelector).hide();
                return this.$(nameSelector).text("").hide();
            }
        };

        BookingDetailsBody.prototype._renderBookingTargets = function () {
            var clientName, projectName;
            projectName = this.booking.getProjectNameWithProjectCode();
            clientName = this.booking.getClientName();
            this._toggleBookingTargets('#project-label', "#project-name", projectName);
            return this._toggleBookingTargets('#client-label', "#client-name", clientName);
        };

        BookingDetailsBody.prototype._billableText = function () {
            if (this.booking.get('billable')) {
                return "Yes";
            } else {
                return "No";
            }
        };

        return BookingDetailsBody;

    })(RG.Views.BaseView);

}).call(this);
;
(function () {
    RG.Views.Dialogs.BookingDetailsFactory = (function () {
        function BookingDetailsFactory(options) {
            this.bookingFormFactory = options.bookingFormFactory;
        }

        BookingDetailsFactory.prototype.create = function (options) {
            var actions, body, bodyView, footer, header;
            header = new RG.Views.Dialogs.BookingDetailsHeader({
                booking: options.booking
            });
            if (RG.Utils.Permissions.canManage(options.booking)) {
                if (options.booking.isSeries() && options.duration) {
                    actions = new RG.Views.Dialogs.BookingSeriesDetailsActions({
                        duration: options.duration,
                        booking: options.booking,
                        bookingFormFactory: this.bookingFormFactory
                    });
                } else {
                    actions = new RG.Views.Dialogs.SingleBookingDetailsActions({
                        duration: options.duration,
                        booking: options.booking,
                        bookingFormFactory: this.bookingFormFactory
                    });
                }
            }
            body = new RG.Views.Dialogs.BookingDetailsBody({
                booking: options.booking
            });
            footer = new RG.Views.Dialogs.TagWrapper({
                view: actions,
                tagName: 'footer'
            });
            bodyView = new RG.Views.Dialogs.Dialog({
                header: header,
                body: body,
                footer: footer,
                className: 'booking-details-dialog'
            });
            return new RG.Views.Dialogs.Popover({
                removeAttachTo: options.removeAttachTo,
                attachTo: options.attachTo,
                body: bodyView,
                className: 'edit-booking-dropdown js-edit-booking-popover'
            });
        };

        return BookingDetailsFactory;

    })();

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.Dialogs.BookingDetailsHeader = (function (superClass) {
        extend(BookingDetailsHeader, superClass);

        function BookingDetailsHeader() {
            return BookingDetailsHeader.__super__.constructor.apply(this, arguments);
        }

        BookingDetailsHeader.prototype.template = templates.find('dialogs/booking_details_header');

        BookingDetailsHeader.prototype.tagName = 'header';

        BookingDetailsHeader.prototype.initialize = function (options) {
            return this.booking = options.booking;
        };

        BookingDetailsHeader.prototype.render = function () {
            this.$el.html(this.template());
            this._fillValues();
            return this;
        };

        BookingDetailsHeader.prototype._fillValues = function () {
            var ref, ref1;
            this.$("#booking-duration").text(this.booking.getDurationCaption() + " ");
            if (this.booking.isSeries()) {
                this.$("#booking-duration").append($("<span></span>").text(this.booking.getDurationLongRepeatCaption()));
            }
            this.$("#booking-date").text(this.booking.getSavedDateRange().toString() + " ");
            if (((ref = this.booking) != null ? (ref1 = ref.collection) != null ? ref1.resource : void 0 : void 0) && this.booking.collection.resource.getTimeZone().get('name') !== window.currentUserTimeZone) {
                return this.$("#booking-date").append($("<span></span>").text(this.booking.collection.resource.getTimeZone()));
            }
        };

        return BookingDetailsHeader;

    })(RG.Views.BaseView);

}).call(this);
;
(function () {
    RG.Views.Dialogs.BookingPopoverFactory = (function () {
        function BookingPopoverFactory(options) {
            this.booking = options.booking;
            this.duration = options.duration;
            this.bookingAnchor = options.bookingAnchor;
            this.popoverType = options.popoverType;
            if (typeof options.removeAttachTo === 'undefined') {
                this.removeAttachTo = true;
            }
            this.bookingFormFactory = options.bookingFormFactory;
        }

        BookingPopoverFactory.prototype.popover = function () {
            var popover, view;
            if (this.popoverType === 'details') {
                return this._getDetailsDialogFactory().create({
                    removeAttachTo: this.removeAttachTo,
                    booking: this.booking,
                    attachTo: this.bookingAnchor,
                    duration: this.duration,
                    editSeries: function () {
                        return this.bookingFormFactory.createEdit({
                            booking: this.booking
                        });
                    }
                });
            } else if (this.popoverType === 'edit') {
                view = this.bookingFormFactory.createEdit({
                    booking: this.booking
                });
                return popover = new RG.Views.Dialogs.Popover({
                    attachTo: this.bookingAnchor,
                    body: view,
                    removeAttachTo: this.removeAttachTo,
                    className: 'edit-booking-dropdown'
                });
            }
        };

        BookingPopoverFactory.prototype._getDetailsDialogFactory = function () {
            return new RG.Views.Dialogs.BookingDetailsFactory({
                bookingFormFactory: this.bookingFormFactory
            });
        };

        return BookingPopoverFactory;

    })();

}).call(this);
;
(function () {
    RG.Views.Dialogs.BookingFormFactory = (function () {
        function BookingFormFactory(options) {
            this.currentUserId = options.currentUserId;
            this.resources = options.resources;
            this.projects = options.projects;
            this.deletedProjects = options.deletedProjects;
            this.clients = options.clients;
            this.deletedClients = options.deletedClients;
            this.bookers = options.bookers;
            this.downtimeTypes = options.downtimeTypes;
            this.deletedBookers = options.deletedBookers;
            this.timeZones = options.timeZones;
            this.currentUserTimeZone = options.currentUserTimeZone;
        }

        BookingFormFactory.prototype.create = function (options) {
            return new RG.Views.Dialogs.NewBookingDowntimePopover({
                currentUserId: this.currentUserId,
                resources: this.resources,
                projects: this.projects,
                deletedProjects: this.deletedProjects,
                clients: this.clients,
                deletedClients: this.deletedClients,
                bookers: this.bookers,
                downtimeTypes: this.downtimeTypes,
                deletedBookers: this.deletedBookers,
                dateRange: options.dateRange,
                resource: options.resource,
                attachTo: options.attachTo,
                removeCallback: options.removeCallback,
                changeCallback: options.changeCallback,
                timeZones: this.timeZones,
                currentUserTimeZone: this.currentUserTimeZone
            });
        };

        BookingFormFactory.prototype.createEdit = function (options) {
            return new RG.Views.Dialogs.EditBooking({
                currentUserId: this.currentUserId,
                resources: this.resources,
                projects: this.projects,
                deletedProjects: this.deletedProjects,
                clients: this.clients,
                deletedClients: this.deletedClients,
                bookers: this.bookers,
                deletedBookers: this.deletedBookers,
                booking: options.booking,
                callback: options.callback
            });
        };

        return BookingFormFactory;

    })();

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.Dialogs.BookingSeriesDetailsActions = (function (superClass) {
        extend(BookingSeriesDetailsActions, superClass);

        function BookingSeriesDetailsActions() {
            return BookingSeriesDetailsActions.__super__.constructor.apply(this, arguments);
        }

        BookingSeriesDetailsActions.prototype.tagName = 'ul';

        BookingSeriesDetailsActions.prototype.className = 'booking-actions';

        BookingSeriesDetailsActions.prototype.template = templates.find('dialogs/booking_series_details_actions');

        BookingSeriesDetailsActions.prototype.initialize = function (options) {
            this.duration = options.duration;
            this.booking = options.booking;
            return this.bookingFormFactory = options.bookingFormFactory;
        };

        BookingSeriesDetailsActions.prototype.render = function () {
            this.$el.html(this.template());
            this._fillValues();
            this.$('.dropdown-toggle').dropdown();
            this.$('.dropdown-toggle').on('click', (function (_this) {
                return function () {
                    return _this.$('.downtime-btn-group').toggleClass('dropup', _this._menuOpensUpwards());
                };
            })(this));
            this._bindEvents();
            return this;
        };

        BookingSeriesDetailsActions.prototype._bindEvents = function () {
            this.$el.on("click", "#delete-single-booking", (function (_this) {
                return function () {
                    return _this.deleteDuration();
                };
            })(this));
            this.$el.on("click", "#delete-series", (function (_this) {
                return function () {
                    return _this.deleteBooking();
                };
            })(this));
            this.$el.on("click", "#edit-series", (function (_this) {
                return function () {
                    return _this.editBooking();
                };
            })(this));
            this.$el.on("click", "#edit-single-booking", (function (_this) {
                return function () {
                    return _this.editDuration();
                };
            })(this));
            return this.$el.on("click", "#split-series", (function (_this) {
                return function () {
                    return _this.splitBooking();
                };
            })(this));
        };

        BookingSeriesDetailsActions.prototype.deleteDuration = function () {
            var collection, response;
            if (!this.onEdgeDay()) {
                response = confirm("This will break this booking series into two blocks.");
                if (!response) {
                    return false;
                }
            }
            RG.Popovers.clear();
            collection = this.booking.collection;
            RG.Utils.BookingService.deleteSingleDate(this.booking, this.duration.get('date'), (function (_this) {
                return function () {
                    _this.remove();
                    return collection.predictWaitingList();
                };
            })(this));
            return true;
        };

        BookingSeriesDetailsActions.prototype.onEdgeDay = function () {
            var durations;
            durations = this.booking.durations.models;
            return this.duration === durations[0] || this.duration === durations[durations.length - 1];
        };

        BookingSeriesDetailsActions.prototype.deleteBooking = function () {
            RG.Popovers.clear();
            RG.Utils.BookingService.deleteBooking(this.booking, (function (_this) {
                return function () {
                    return _this.remove();
                };
            })(this));
            return true;
        };

        BookingSeriesDetailsActions.prototype.editBooking = function () {
            var view;
            view = this.bookingFormFactory.createEdit({
                booking: this.booking
            });
            this.trigger("changeView", view);
            return true;
        };

        BookingSeriesDetailsActions.prototype.editDuration = function () {
            var booking, response;
            booking = this.booking.cloneWithDurations(this.duration);
            response = confirm("This will break this booking series into multiple blocks.");
            if (!response) {
                return;
            }
            this.trigger('hide');
            RG.Utils.BookingService.isolate(booking.realBooking, booking.get('startDate'), (function (_this) {
                return function (isolatedBooking) {
                    var view;
                    view = _this.bookingFormFactory.createEdit({
                        booking: isolatedBooking
                    });
                    _this.trigger('show');
                    return _this.trigger("changeView", view);
                };
            })(this));
            return true;
        };

        BookingSeriesDetailsActions.prototype.splitBooking = function () {
            var view;
            if (!this._canSplit()) {
                return false;
            }
            view = new RG.Views.Dialogs.SplitBooking({
                booking: this.booking,
                splitDate: this.duration.get('date')
            });
            this.trigger('changeView', view, {
                className: 'split-booking-popover',
                render: true
            });
            return false;
        };

        BookingSeriesDetailsActions.prototype._fillValues = function () {
            var date, title;
            date = this.duration.get('date');
            this.$("#edit-single-booking").text("Edit " + (RG.Utils.DateFormatter.getShortDate(date)) + " only");
            this.$("#delete-single-booking").text("Delete " + (RG.Utils.DateFormatter.getShortDate(date)) + " only");
            if (!this._canSplit()) {
                title = "You can't split a booking on the start date. Please select another date.";
                return this.$("#split-series").attr({
                    disabled: 'disabled',
                    title: title
                }).addClass('is-disabled');
            }
        };

        BookingSeriesDetailsActions.prototype._menuOpensUpwards = function () {
            return this.$el.offset().top - $(window).height() - $(window).scrollTop() > -130;
        };

        BookingSeriesDetailsActions.prototype._canSplit = function () {
            return !(this.duration.get('date') === this.booking.getDateRange().startDate);
        };

        return BookingSeriesDetailsActions;

    })(RG.Views.BaseView);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.Dialogs.CopyAvailabilityPopover = (function (superClass) {
        extend(CopyAvailabilityPopover, superClass);

        function CopyAvailabilityPopover() {
            return CopyAvailabilityPopover.__super__.constructor.apply(this, arguments);
        }

        CopyAvailabilityPopover.prototype.cssClass = "js-copy-availability-dropdown";

        CopyAvailabilityPopover.prototype.className = "copy-availability-dropdown-container";

        CopyAvailabilityPopover.prototype.initialize = function (options) {
            this.dailyAggregation = options.dailyAggregation;
            this.currentDay = options.currentDay;
            this.$el.on('click', '.js-cancel', (function (_this) {
                return function (e) {
                    e.preventDefault();
                    e.stopPropagation();
                    _this.$el.closest(".dropdown").removeClass("open");
                    return _this.remove();
                };
            })(this));
            return this.$el.on('click', '.js-copy', (function (_this) {
                return function (e) {
                    e.preventDefault();
                    e.stopPropagation();
                    _this.bodyView.copyAvailability();
                    _this.$el.closest(".dropdown").removeClass("open");
                    return _this.remove();
                };
            })(this));
        };

        CopyAvailabilityPopover.prototype.render = function () {
            CopyAvailabilityPopover.__super__.render.apply(this, arguments);
            this.$el.find('button.close').remove();
            this.$(".shadow-arrow").remove();
            this.$el.prepend($(document.createElement('span')).addClass('shadow-arrow'));
            this.$el.find('.f-dropdown').removeClass('f-dropdown');
            return this;
        };

        CopyAvailabilityPopover.prototype.setPosition = function () {
            this.$(".shadow-arrow").css({
                top: ""
            });
            this.$el.css({
                top: "",
                left: ""
            });
            this.$(".f-dropdown").removeClass("cdrop-left").removeClass("cdrop-right");
            this.$(".f-dropdown .dropdown-content").css({
                "max-height": $(window).height()
            });
            this.$(".f-dropdown .dropdown-content main").css({
                "max-height": $(window).height() - this.$(".f-dropdown .dropdown-content header, .f-dropdown .dropdown-content .tabs").height() - 70
            });
            this._setOpenDirection();
            this.width = this.dailyAggregation.length * 47;
            this.width = _.max([this.width, 200]);
            this.$(".shadow-arrow").css({
                top: 26,
                left: this.width - 13
            });
            this.$el.css({
                position: 'absolute',
                top: 22,
                width: this.width
            });
        };

        CopyAvailabilityPopover.prototype._setOpenDirection = function () {
            this._setOpenRight();
        };

        CopyAvailabilityPopover.prototype._setOpenRight = function () {
            this.$(".f-dropdown").addClass("cdrop-right");
            this.$el.css({
                left: this.width * 2
            });
        };

        CopyAvailabilityPopover.prototype.popup = function () {
            this.setBodyView(new RG.Views.CustomAvailability.CopyAvailability({
                dailyAggregation: this.dailyAggregation,
                currentDay: this.currentDay
            }));
            this.bodyView.$el.width(this.width);
            return CopyAvailabilityPopover.__super__.popup.apply(this, arguments);
        };

        return CopyAvailabilityPopover;

    })(RG.Views.Dialogs.Popover);

    RG.Views.CustomAvailability.CopyAvailability = (function (superClass) {
        extend(CopyAvailability, superClass);

        function CopyAvailability() {
            return CopyAvailability.__super__.constructor.apply(this, arguments);
        }

        CopyAvailability.prototype.template = templates.find('availability/copy_availability');

        CopyAvailability.prototype.className = 'copy-availability';

        CopyAvailability.prototype.initialize = function (options) {
            this.dailyAggregation = options.dailyAggregation;
            return this.currentDay = options.currentDay;
        };

        CopyAvailability.prototype.remove = function () {
            this._cleanup();
            return CopyAvailability.__super__.remove.apply(this, arguments);
        };

        CopyAvailability.prototype._cleanup = function () {
            var ref;
            return (ref = this.dayssSelector) != null ? ref.remove() : void 0;
        };

        CopyAvailability.prototype.render = function () {
            var days;
            this._cleanup();
            this.$el.html(this.template());
            days = this.dailyAggregation.map(function (a) {
                return a.get('weekDay');
            });
            days = _.reject(days, (function (_this) {
                return function (d) {
                    return d === _this.currentDay.get('weekDay');
                };
            })(this));
            this.daysSelector = new RG.Views.CustomAvailability.DaysSelector({
                days: days,
                selectedDays: [1, 2, 3, 4, 5]
            });
            this.daysSelector.on("change", (function (_this) {
                return function () {
                    return _this.validate();
                };
            })(this));
            this.$(".js-day-selection").replaceWith(this.daysSelector.render().el);
            return this;
        };

        CopyAvailability.prototype.validate = function () {
            return this.$(".js-copy").attr('disabled', this.daysSelector.getSelectedDays().length === 0 ? 'disabled' : null);
        };

        CopyAvailability.prototype.copyAvailability = function () {
            var day, days, i, len, models, selection;
            selection = this.daysSelector.getSelectedDays();
            days = this.dailyAggregation.select(function (d) {
                return selection.indexOf(d.get('weekDay')) !== -1;
            });
            models = this.currentDay.getFirstAvailablePeriods().models;
            for (i = 0, len = days.length; i < len; i++) {
                day = days[i];
                day.clearVaryingAvailability();
                day.getFirstAvailablePeriods().reset(models);
            }
        };

        return CopyAvailability;

    })(RG.Views.BaseView);

    RG.Views.CustomAvailability.DaysSelector = (function (superClass) {
        extend(DaysSelector, superClass);

        function DaysSelector() {
            return DaysSelector.__super__.constructor.apply(this, arguments);
        }

        DaysSelector.prototype.tagName = 'ul';

        DaysSelector.prototype.initialize = function (options) {
            this.days = options.days;
            return this.selectedDays = options.selectedDays;
        };

        DaysSelector.prototype.remove = function () {
            this.off();
            this.$el.off();
            this._cleanup();
            return DaysSelector.__super__.remove.apply(this, arguments);
        };

        DaysSelector.prototype._cleanup = function () {
            var i, len, ref, results, view;
            if (this.selectors && this.selectors.length) {
                ref = this.selectors;
                results = [];
                for (i = 0, len = ref.length; i < len; i++) {
                    view = ref[i];
                    results.push(view.remove());
                }
                return results;
            }
        };

        DaysSelector.prototype.render = function () {
            var day, dayName, i, len, ref;
            this._cleanup();
            this.selectors = [];
            ref = this.days;
            for (i = 0, len = ref.length; i < len; i++) {
                day = ref[i];
                dayName = new RG.Utils.DayName(day);
                day = new RG.Views.CustomAvailability.DaySelector({
                    dayName: dayName,
                    isSelected: this.selectedDays.indexOf(day) !== -1
                });
                day.on("change", (function (_this) {
                    return function () {
                        return _this.trigger("change");
                    };
                })(this));
                this.$el.append(day.render().el);
                this.selectors.push(day);
            }
            return this;
        };

        DaysSelector.prototype.getSelectedDays = function () {
            return _.chain(this.selectors).select(function (s) {
                return s.isChecked();
            }).map(function (s) {
                return s.dayName.dayNumber;
            }).value();
        };

        return DaysSelector;

    })(RG.Views.BaseView);

    RG.Views.CustomAvailability.DaySelector = (function (superClass) {
        extend(DaySelector, superClass);

        function DaySelector() {
            return DaySelector.__super__.constructor.apply(this, arguments);
        }

        DaySelector.prototype.tagName = 'li';

        DaySelector.prototype.events = {
            "click input": "_stopPropagation",
            "click": "toggle"
        };

        DaySelector.prototype.initialize = function (options) {
            this.dayName = options.dayName;
            return this.isSelected = options.isSelected;
        };

        DaySelector.prototype.remove = function () {
            this.off();
            this.$el.off();
            return DaySelector.__super__.remove.apply(this, arguments);
        };

        DaySelector.prototype.render = function () {
            this.$el.append('<input type="checkbox">');
            this.$el.append("<span>" + this.dayName + "</span>");
            this.$("input").prop("checked", this.isSelected);
            return this;
        };

        DaySelector.prototype.toggle = function (e) {
            if (e != null) {
                e.stopPropagation();
            }
            this.$("input").prop("checked", !this.isChecked());
            return this.trigger("change");
        };

        DaySelector.prototype._stopPropagation = function (e) {
            e.stopPropagation();
            return this.trigger("change");
        };

        DaySelector.prototype.isChecked = function () {
            return this.$("input").prop("checked");
        };

        return DaySelector;

    })(RG.Views.BaseView);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.Dialogs.CustomAvailability = (function (superClass) {
        extend(CustomAvailability, superClass);

        function CustomAvailability() {
            return CustomAvailability.__super__.constructor.apply(this, arguments);
        }

        CustomAvailability.prototype.template = templates.find('dialogs/custom_availability');

        CustomAvailability.prototype.className = 'js-custom-availability';

        CustomAvailability.prototype.initialize = function (options) {
            this.resource = options.resource;
            this.dateRange = options.dateRange;
            this.line = options.line;
            return this.dailyAggregation = options.dailyAggregation;
        };

        CustomAvailability.prototype.render = function () {
            this.$el.html(this.template({
                dateRange: this.dateRange,
                resource: this.resource
            }));
            if (!this.resource.shouldDisplayTimeZone()) {
                this.$('.js-timezone').hide();
            }
            this._renderDays();
            this._renderAvatar();
            return this;
        };

        CustomAvailability.prototype.remove = function () {
            if (this.days) {
                this.days.remove();
            }
            return CustomAvailability.__super__.remove.apply(this, arguments);
        };

        CustomAvailability.prototype.getSelectedDay = function () {
            return this._selectedDay;
        };

        CustomAvailability.prototype._renderAvatar = function () {
            var avatar;
            if (this.resource.hasAvatar()) {
                avatar = new RG.Views.Resource.Avatar({
                    resource: this.resource
                });
                return this.$(".js-resource-avatar").replaceWith(avatar.render().el);
            }
        };

        CustomAvailability.prototype._renderDays = function () {
            this.days = new RG.Views.CustomAvailability.DayRange({
                collection: this.dailyAggregation,
                resource: this.resource
            });
            this.days.on("edit", (function (_this) {
                return function () {
                    return _this.trigger("edit");
                };
            })(this));
            this.days.on("change", (function (_this) {
                return function (model) {
                    return _this._selectedDay = model;
                };
            })(this));
            return this.$el.find('.availability-tabs').replaceWith(this.days.render().el);
        };

        return CustomAvailability;

    })(RG.Views.BaseView);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.Dialogs.CustomAvailabilityForm = (function (superClass) {
        extend(CustomAvailabilityForm, superClass);

        function CustomAvailabilityForm() {
            return CustomAvailabilityForm.__super__.constructor.apply(this, arguments);
        }

        CustomAvailabilityForm.prototype.template = templates.find('dialogs/custom_availability_form');

        CustomAvailabilityForm.prototype.menuTemplate = templates.find('availability/popover_menu');

        CustomAvailabilityForm.prototype.className = 'js-custom-availability';

        CustomAvailabilityForm.prototype.events = {
            "click .dropdown-toggle": "togglePopover",
            "click .js-update": "updateAvailability",
            "click .js-cancel": "close",
            "click": "_closePopover",
            "click .js-reset-availability": "resetAvailability",
            "click .js-copy-availability": "copyAvailability"
        };

        CustomAvailabilityForm.prototype.initialize = function (options) {
            this.dateRange = options.dateRange;
            this.selectedDay = options.selectedDay;
            this.dailyAggregation = options.dailyAggregation;
            this.resource = options.resource;
            return this.popover = options.popover;
        };

        CustomAvailabilityForm.prototype.remove = function () {
            this._cleanup();
            return CustomAvailabilityForm.__super__.remove.apply(this, arguments);
        };

        CustomAvailabilityForm.prototype._cleanup = function () {
            var ref, ref1, ref2, ref3;
            this.off();
            this.$el.off();
            if ((ref = this.days) != null) {
                ref.remove();
            }
            if ((ref1 = this.dateRangeSelector) != null) {
                ref1.remove();
            }
            if ((ref2 = this.optionView) != null) {
                ref2.remove();
            }
            if ((ref3 = this.copyAvailabilityPopup) != null) {
                ref3.remove();
            }
            return this.days = null;
        };

        CustomAvailabilityForm.prototype._renderDays = function () {
            this.days = new RG.Views.CustomAvailability.DayRangeForm({
                collection: this.dailyAggregation,
                selectedDay: this.selectedDay,
                resource: this.resource
            });
            this.days.on("edit", (function (_this) {
                return function () {
                    return _this.trigger("edit");
                };
            })(this));
            this.days.on("change", (function (_this) {
                return function (model) {
                    _this.selectedDay = model;
                    return _this.toggleCopyAvailability();
                };
            })(this));
            this.days.on("updatePosition", (function (_this) {
                return function () {
                    return _this.trigger("updatePosition");
                };
            })(this));
            this.days.render();
            this._renderAvailabilityMenu();
            return this.days.$el;
        };

        CustomAvailabilityForm.prototype._renderDateRangeSelector = function () {
            this.dateRangeSelector = new RG.Views.Selectors.DateRange({
                dateRange: new RG.Utils.DateRange(new Date(this.dateRange.startDate), new Date(this.dateRange.endDate)),
                customValidations: new RG.Validators.CustomAvailabilityLengthValidator().validate,
                tagName: 'span'
            });
            this.dateRangeSelector._isResourceAvailable = function () {
                return true;
            };
            this.dateRangeSelector.on("change", (function (_this) {
                return function (dateRange) {
                    if (_this.dateRangeSelector.customValidations(_this.dateRangeSelector) && dateRange.getNumberOfDays() > 0) {
                        _this.dateRange = dateRange;
                        return _this.trigger("change:dateRange", dateRange);
                    }
                };
            })(this));
            this.$(".js-daterange").append(this.dateRangeSelector.render().el);
            this.dateRangeSelector.toggleError(false);
            return this.dateRangeSelector.validate();
        };

        CustomAvailabilityForm.prototype._renderAvailabilityMenu = function () {
            return $(this.menuTemplate()).insertBefore(this.days.$(".js-day-detail"));
        };

        CustomAvailabilityForm.prototype.toggleCopyAvailability = function () {
            if (this.dailyAggregation.length === 1 || !this.selectedDay.availabilityConsistent()) {
                return this.$(".js-copy-availability").hide();
            } else {
                return this.$(".js-copy-availability").show();
            }
        };

        CustomAvailabilityForm.prototype.render = function () {
            var daysEl;
            this.$el.html(this.template());
            this.$(".filter__availability-form").tooltip();
            this._renderDateRangeSelector();
            daysEl = this._renderDays();
            this.$el.append(daysEl);
            this.$el.append(this._renderFooter());
            this.toggleCopyAvailability();
            return this;
        };

        CustomAvailabilityForm.prototype.copyAvailability = function (e) {
            var ref;
            if (e != null) {
                e.stopPropagation();
            }
            if ((ref = this.copyAvailabilityPopup) != null) {
                ref.remove();
            }
            this.copyAvailabilityPopup = new RG.Views.Dialogs.CopyAvailabilityPopover({
                attachTo: this.$(".js-copy-availability"),
                dailyAggregation: this.dailyAggregation,
                currentDay: this.selectedDay
            });
            this.copyAvailabilityPopup.popup();
            return this.$(".js-copy-availability").append(this.copyAvailabilityPopup.$el);
        };

        CustomAvailabilityForm.prototype.resetAvailability = function () {
            this.selectedDay.resetAvailability();
            this.days.render();
            this._renderAvailabilityMenu();
            return this.toggleCopyAvailability();
        };

        CustomAvailabilityForm.prototype.togglePopover = function (e) {
            var ref;
            if ((ref = this.days) != null) {
                ref.trigger("openDropdown");
            }
            $(e.target).closest(".dropdown").toggleClass("open");
            return e.stopPropagation();
        };

        CustomAvailabilityForm.prototype.updateAvailability = function (e) {
            var changedAvailabilityDays, changedDays, changedOvertimeDays, overtimeCommand, resetAvailabilityDays, resetPromise, updateAvailabilityPromise;
            e.preventDefault();
            if (!this.dateRangeSelector.validate()) {
                return;
            }
            changedAvailabilityDays = this.dailyAggregation.select(function (d) {
                return d.hasAvailabilityChanged() && d.variesFromNormalAvailability();
            });
            resetAvailabilityDays = this.dailyAggregation.select(function (d) {
                return d.hasAvailabilityChanged() && !d.variesFromNormalAvailability();
            });
            changedOvertimeDays = this.dailyAggregation.select(function (d) {
                return d.hasOvertimeChanged();
            });
            changedDays = this.dailyAggregation.select(function (d) {
                return d.hasAvailabilityChanged() || d.hasOvertimeChanged();
            });
            resetPromise = this._resetServerAvailability(resetAvailabilityDays);
            updateAvailabilityPromise = Q.promise((function (_this) {
                return function (resolve) {
                    var command;
                    if (changedAvailabilityDays.length === 0) {
                        return Q.delay(0).then(resolve);
                    }
                    command = new RG.Commands.UpdateAvailabilityCommand({
                        account: _this.resource.account,
                        dateRange: _this.dateRange,
                        resource: _this.resource,
                        changedDays: changedAvailabilityDays,
                        successCallback: function () {
                            return resolve();
                        }
                    });
                    return command.willTouchBookings({
                        success: function (bookingsCount) {
                            _this.optionView = new RG.Views.Dialogs.BookingClashManagement({
                                command: command,
                                clashBookingsCount: bookingsCount
                            });
                            return _this.trigger('changeOverlay', _this.optionView, {
                                className: 'overlay availability-waiting'
                            });
                        },
                        fail: function () {
                            _this.trigger('updating');
                            return window.setTimeout(function () {
                                return command.execute();
                            }, 50);
                        }
                    });
                };
            })(this));
            overtimeCommand = new RG.Commands.UpdateOvertimeCommand({
                dateRange: this.dateRange,
                resource: this.resource,
                changedDays: changedOvertimeDays,
                successCallback: (function (_this) {
                    return function () {
                        return window.update().then(function () {
                            return setTimeout(function () {
                                return _this.resource.availability.trigger('maxAvailabilityChanged');
                            }, 750);
                        });
                    };
                })(this)
            });
            return updateAvailabilityPromise.then(resetPromise).then((function (_this) {
                return function () {
                    _this.close();
                    return overtimeCommand.execute();
                };
            })(this));
        };

        CustomAvailabilityForm.prototype._resetServerAvailability = function (aggregations) {
            var command, dates;
            dates = _.flatten(aggregations.map(function (a) {
                return a.getDates();
            }));
            if (dates.length === 0) {
                return Q.delay(0);
            }
            command = new RG.Commands.ResetToNormalAvailabilityCommand({
                resourceInstanceId: this.resource.id,
                dates: dates
            });
            return command.execute.bind(command);
        };

        CustomAvailabilityForm.prototype.close = function (e) {
            if (e != null) {
                e.stopPropagation();
            }
            return this.trigger("close");
        };

        CustomAvailabilityForm.prototype._closePopover = function (e) {
            var ref, ref1;
            if (!$(e.target).hasClass('hasDatepicker')) {
                this.dateRangeSelector.$('input').trigger('blur');
            }
            if ((ref = this.days) != null) {
                ref.closePopovers();
            }
            if ((ref1 = this.copyAvailabilityPopup) != null) {
                ref1.remove();
            }
            return this.$(".dropdown").removeClass("open");
        };

        CustomAvailabilityForm.prototype._disableControls = function () {
            this.$el.find('.js-update, .js-cancel').attr('disabled', 'disabled');
            this.$el.find('.js-daterange input').attr('disabled', 'disabled');
            this.$el.find('.js-reset-availability').hide();
            this.$el.find('.js-add-timeblock').hide();
            this.$el.find('.js-timeblock span').hide();
            this.$el.find('.js-edit-timeblock').hide();
            return this.$el.find('.availability-tabs__menu').hide();
        };

        CustomAvailabilityForm.prototype._enableControls = function () {
            this.$el.find('.js-update, .js-cancel').attr('disabled', null);
            this.$el.find('.js-daterange input').attr('disabled', null);
            this.$el.find('.js-reset-availability').show();
            this.$el.find('.js-add-timeblock').show();
            this.$el.find('.js-timeblock span').show();
            this.$el.find('.js-edit-timeblock').show();
            return this.$el.find('.availability-tabs__menu').show();
        };

        CustomAvailabilityForm.prototype._renderFooter = function () {
            var footer;
            footer = $(document.createElement("footer"));
            footer.append($(document.createElement("button")).addClass("btn btn-guru js-update").text("Update"));
            footer.append("\n");
            footer.append($(document.createElement("button")).addClass("btn js-cancel").text("Cancel"));
            return footer;
        };

        return CustomAvailabilityForm;

    })(RG.Views.BaseView);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.Dialogs.CustomAvailabilityPopover = (function (superClass) {
        extend(CustomAvailabilityPopover, superClass);

        function CustomAvailabilityPopover() {
            return CustomAvailabilityPopover.__super__.constructor.apply(this, arguments);
        }

        CustomAvailabilityPopover.prototype.className = 'availability js-availability-dropdown-parent';

        CustomAvailabilityPopover.prototype.cssClass = 'custom-availability-dropdown';

        CustomAvailabilityPopover.prototype.onboardTemplate = templates.find('availability/onboard');

        CustomAvailabilityPopover.prototype.initialize = function (options) {
            CustomAvailabilityPopover.__super__.initialize.apply(this, arguments);
            this.line = options.line;
            this.dateRange = options.dateRange;
            this.resource = options.resource;
            return this.changeCallback = options.changeCallback;
        };

        CustomAvailabilityPopover.prototype._closeOpenPopovers = function (e) {
            CustomAvailabilityPopover.__super__._closeOpenPopovers.apply(this, arguments);
            if (!$(e.target).hasClass('hasDatepicker')) {
                return this.$('input').trigger('blur');
            }
        };

        CustomAvailabilityPopover.prototype.popup = function () {
            var aggregation, view;
            aggregation = this._getDailyAggregation();
            view = new RG.Views.Dialogs.CustomAvailability({
                line: this.line,
                dateRange: this.dateRange,
                resource: this.resource,
                dailyAggregation: aggregation
            });
            this.setBodyView(view);
            CustomAvailabilityPopover.__super__.popup.apply(this, arguments);
            view.on("edit", (function (_this) {
                return function () {
                    _this.setBodyView(_this._createFormView(view.getSelectedDay()));
                    return _this.setPosition();
                };
            })(this));
            return this._displayOnboardingOverlay();
        };

        CustomAvailabilityPopover.prototype.remove = function () {
            var ref, ref1;
            if ((ref = this.editView) != null) {
                ref.remove();
            }
            if ((ref1 = this.overlay) != null) {
                ref1.remove();
            }
            return CustomAvailabilityPopover.__super__.remove.apply(this, arguments);
        };

        CustomAvailabilityPopover.prototype._createFormView = function (selectedDay) {
            var aggregation, day, i, len, newSelectedDay, ref, ref1, ref2, ref3;
            aggregation = this._getDailyAggregation();
            ref = aggregation.models;
            for (i = 0, len = ref.length; i < len; i++) {
                day = ref[i];
                day.getFirstAvailablePeriods().on("reset", (function (_this) {
                    return function () {
                        return _this._resetPosition();
                    };
                })(this));
            }
            newSelectedDay = aggregation.findWhere({
                weekDay: selectedDay.get('weekDay')
            });
            if ((ref1 = this.editView) != null) {
                ref1.remove();
            }
            $('#ui-datepicker-div').remove();
            this.editView = new RG.Views.Dialogs.CustomAvailabilityForm({
                dateRange: this.dateRange,
                selectedDay: newSelectedDay,
                dailyAggregation: aggregation,
                resource: this.resource,
                popover: this
            });
            this.editView.on("change:dateRange", (function (_this) {
                return function (dateRange) {
                    _this.trigger('changeOverlay', _this._spinnerView(dateRange), {
                        className: 'overlay availability-waiting'
                    });
                    return window.setTimeout(function () {
                        return window.requestAnimationFrame(function () {
                            return _this.setPosition();
                        });
                    }, 10);
                };
            })(this));
            this.editView.on('updating', (function (_this) {
                return function () {
                    return _this.trigger('changeOverlay', _this._spinnerView(), {
                        className: 'overlay availability-waiting'
                    });
                };
            })(this));
            if ((ref2 = this.spinner) != null) {
                ref2.stop();
            }
            if ((ref3 = this.overlay) != null) {
                ref3.remove();
            }
            return this.editView.render();
        };

        CustomAvailabilityPopover.prototype._getDailyAggregation = function () {
            var aggregation, collection, date, i, len, name, ref, today;
            aggregation = {};
            ref = this.dateRange.getDates();
            for (i = 0, len = ref.length; i < len; i++) {
                date = ref[i];
                today = aggregation[name = date.getDay()] != null ? aggregation[name] : aggregation[name] = new RG.Models.DayAvailabilityAggregation({
                    weekDay: date.getDay(),
                    dateRange: this.dateRange
                });
                today.get('availablePeriods')[date.getISODate()] = this.resource.availability.getPeriodsForDate(date);
                today.get('overtimes')[date.getISODate()] = this.resource.availability.getOvertimesForDate(date);
                today.get('durations')[date.getISODate()] = this.resource.bookings.getDurationsForDate(date);
                today.get('downtimes')[date.getISODate()] = this.resource.downtimes.mergedTimeRangesForDate(date);
                today.get('originalAvailablePeriods')[date.getISODate()] = this.resource.availability.getOriginalPeriodsForDate(date);
            }
            collection = new RG.Collections.DayAvailabilityAggregations(_.values(aggregation));
            collection.resourceId = this.resource.id;
            return collection;
        };

        CustomAvailabilityPopover.prototype._spinnerView = function (dateRange) {
            $('#ui-datepicker-div').hide();
            this.overlay = new RG.Views.Dialogs.Overlay({
                attachTo: this.el,
                className: "overlay",
                template: function () {
                    return '';
                }
            });
            this.overlay.render();
            this.spinner = new Spinner(this.spinnerOptions).spin(this.overlay.el);
            if (dateRange) {
                return window.setTimeout((function (_this) {
                    return function () {
                        return window.requestAnimationFrame(function () {
                            _this.dateRange = dateRange;
                            if (typeof _this.changeCallback === "function") {
                                _this.changeCallback(dateRange);
                            }
                            _this.setBodyView(_this._createFormView(_this.editView.selectedDay));
                            return $('#ui-datepicker-div').hide();
                        });
                    };
                })(this), 8);
            }
        };

        CustomAvailabilityPopover.prototype._displayOnboardingOverlay = function () {
            var selectedDay;
            if (!window.onboardingNotice.dismissed_custom_availability) {
                selectedDay = this.bodyView.getSelectedDay();
                this.$el.addClass('onboarding-notice-open');
                this.overlay = new RG.Views.Dialogs.Overlay({
                    attachTo: this.el,
                    template: this.onboardTemplate,
                    className: "overlay",
                    removeCallback: (function (_this) {
                        return function () {
                            var command;
                            _this.$el.removeClass('onboarding-notice-open');
                            window.onboardingNotice.dismissed_custom_availability = true;
                            command = new RG.Commands.UpdateNoticeCommand({
                                dismissedField: 'dismissed_custom_availability'
                            });
                            return command.execute();
                        };
                    })(this)
                });
                return this.overlay.render();
            }
        };

        return CustomAvailabilityPopover;

    })(RG.Views.Dialogs.Popover);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.Dialogs.DowntimeDetailsActions = (function (superClass) {
        extend(DowntimeDetailsActions, superClass);

        function DowntimeDetailsActions() {
            return DowntimeDetailsActions.__super__.constructor.apply(this, arguments);
        }

        DowntimeDetailsActions.prototype.tagName = 'ul';

        DowntimeDetailsActions.prototype.className = 'booking-actions';

        DowntimeDetailsActions.prototype.template = templates.find('dialogs/downtime_details_actions');

        DowntimeDetailsActions.prototype.deleteTemplate = templates.find('dialogs/downtime_details_actions_delete_single');

        DowntimeDetailsActions.prototype.deleteMenuTemplate = templates.find('dialogs/downtime_details_actions_delete_series');

        DowntimeDetailsActions.prototype.initialize = function (options) {
            this.account = options.account;
            this.resources = options.resources;
            this.duration = options.duration;
            this.downtime = options.downtime;
            return this.downtimeFormFactory = options.downtimeFormFactory;
        };

        DowntimeDetailsActions.prototype.render = function () {
            this.$el.html(this.template());
            this._fillValues();
            this._bindEvents();
            return this;
        };

        DowntimeDetailsActions.prototype._bindEvents = function () {
            this.$el.on("click", "#delete-duration", (function (_this) {
                return function (e) {
                    return _this.deleteDuration(e);
                };
            })(this));
            this.$el.on("click", "#delete-downtime", (function (_this) {
                return function (e) {
                    return _this.deleteDowntime(e);
                };
            })(this));
            this.$el.on("click", "#edit-downtime", (function (_this) {
                return function (e) {
                    return _this.editDowntime(e);
                };
            })(this));
            return this.$el.on("click", "#split-downtime", (function (_this) {
                return function (e) {
                    return _this.splitDowntime(e);
                };
            })(this));
        };

        DowntimeDetailsActions.prototype._onEdgeDay = function () {
            return RG.Utils.DateComparator.equalsYMD(this.duration.get('date'), this.downtime.get('to')) || RG.Utils.DateComparator.equalsYMD(this.duration.get('date'), this.downtime.get('from'));
        };

        DowntimeDetailsActions.prototype.deleteDuration = function (e) {
            var overlay, response;
            if (e != null) {
                e.preventDefault();
            }
            if (!this._onEdgeDay()) {
                response = confirm("This will break this series of events into two blocks.");
                if (!response) {
                    return false;
                }
            }
            overlay = RG.Utils.spinnerOverlay($(this.el).closest('.js-edit-downtime-popover')[0]);
            return Q.delay(10).then((function (_this) {
                return function () {
                    RG.Utils.DowntimeService.deleteSingleDate(_this.downtime, _this.duration.get('date'), function () {
                        RG.Popovers.clear();
                        RG.Popovers.popoverActive = false;
                        return _this.remove();
                    });
                    return true;
                };
            })(this));
        };

        DowntimeDetailsActions.prototype.deleteDowntime = function (e) {
            var overlay;
            if (e != null) {
                e.preventDefault();
            }
            overlay = RG.Utils.spinnerOverlay($(this.el).closest('.js-edit-downtime-popover')[0]);
            return Q.delay(10).then((function (_this) {
                return function () {
                    var downtime;
                    downtime = _this.account.downtimes.findWhere({
                        id: _this.downtime.id
                    });
                    _this.account.downtimes.remove(downtime.id);
                    RG.Popovers.clear();
                    RG.Popovers.popoverActive = false;
                    _this.remove();
                    RG.Utils.DowntimeService.deleteDowntime(downtime.id);
                    return true;
                };
            })(this));
        };

        DowntimeDetailsActions.prototype.editDowntime = function (e) {
            var view;
            if (e != null) {
                e.preventDefault();
            }
            view = this.downtimeFormFactory.createEdit({
                downtime: this.downtime
            });
            this.trigger("changeView", view);
            return true;
        };

        DowntimeDetailsActions.prototype.splitDowntime = function (e) {
            var view;
            if (e != null) {
                e.preventDefault();
            }
            if (!this._canSplit()) {
                return false;
            }
            view = new RG.Views.Dialogs.SplitDowntime({
                account: this.account,
                resources: this.resources,
                downtime: this.downtime,
                splitDate: this.duration.get('date')
            });
            this.trigger('changeView', view, {
                className: 'split-booking-popover',
                render: true
            });
            return false;
        };

        DowntimeDetailsActions.prototype._fillValues = function () {
            var date;
            if (this.downtime.isSeries() && !this.downtime.isVacation() && this.duration) {
                this.$('.js-delete-button').html(this.deleteMenuTemplate());
                this.$('.dropdown-toggle').dropdown();
                this.$('.dropdown-toggle').on('click', (function (_this) {
                    return function () {
                        return _this.$('.downtime-btn-group').toggleClass('dropup', _this._menuOpensUpwards());
                    };
                })(this));
                date = this.duration.get('date');
                this.$("#delete-duration").text("Delete " + (RG.Utils.DateFormatter.getShortDate(date)) + " only");
            } else {
                this.$('.js-delete-button').html(this.deleteTemplate());
            }
            if (!this._canSplit()) {
                return this._hideOrGreySplitIcon();
            }
        };

        DowntimeDetailsActions.prototype._hideOrGreySplitIcon = function () {
            if (this.downtime.isSeries()) {
                return this.$(".js-split-button a").attr({
                    disabled: 'disabled',
                    title: this._cantSplitTitle()
                }).addClass('is-disabled');
            } else {
                return this.$(".js-split-button").hide();
            }
        };

        DowntimeDetailsActions.prototype._menuOpensUpwards = function () {
            return this.$el.offset().top - $(window).height() - $(window).scrollTop() > -130;
        };

        DowntimeDetailsActions.prototype._canSplit = function () {
            return !this.downtime.isVacation() && this.duration && this.downtime.getDateRange().getNumberOfDays() > 1 && !RG.Utils.DateComparator.equalsYMD(this.duration.get('date'), this.downtime.getDateRange().startDate);
        };

        DowntimeDetailsActions.prototype._cantSplitTitle = function () {
            if (this.downtime.isVacation()) {
                return "You can't split a vacation Time Off.";
            }
            return "Sorry, you can't split this item on the start date. Please select another date.";
        };

        return DowntimeDetailsActions;

    })(RG.Views.BaseView);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.Dialogs.DowntimeDetailsBody = (function (superClass) {
        extend(DowntimeDetailsBody, superClass);

        function DowntimeDetailsBody() {
            return DowntimeDetailsBody.__super__.constructor.apply(this, arguments);
        }

        DowntimeDetailsBody.prototype.template = templates.find('dialogs/downtime_details_body');

        DowntimeDetailsBody.prototype.initialize = function (options) {
            this.downtime = options.downtime;
            this.actions = options.actions;
            this.booker = options.booker;
            return this.resources = options.resources;
        };

        DowntimeDetailsBody.prototype.render = function () {
            this.$el.html(this.template());
            this._fillValues();
            return this;
        };

        DowntimeDetailsBody.prototype.remove = function () {
            var ref;
            if ((ref = this.actions) != null) {
                ref.remove();
            }
            return DowntimeDetailsBody.__super__.remove.apply(this, arguments);
        };

        DowntimeDetailsBody.prototype.off = function () {
            var ref;
            if ((ref = this.actions) != null) {
                ref.off();
            }
            return DowntimeDetailsBody.__super__.off.apply(this, arguments);
        };

        DowntimeDetailsBody.prototype._fillValues = function () {
            var downtimeType;
            this._renderActions();
            this._renderResources();
            if (downtimeType = this.downtime.getType()) {
                this.$("#booking-target-field").show();
                this.$("#booking-target").show();
                this.$("#booking-target").text(downtimeType);
            } else {
                this.$("#booking-target-field").hide();
                this.$("#booking-target").hide();
            }
            this.$(".js-booker-img").attr("src", this.booker.get('imageUrl'));
            this.$(".js-booker-name").text(this.booker.get('name'));
            this.$("#confirmed-hours").text((RG.Utils.TimeFormatter.formatMinutes(this.downtime.getConfirmedMinutes())) + " confirmed");
            if (this.downtime.get('details') && this.downtime.get('details').length > 0) {
                this.$("#details-field").show();
                this.$("#details").show();
                return this.$("#details").html(window.segmentAutolinker(this.downtime.get('details')));
            } else {
                this.$("#details-field").hide();
                return this.$("#details").hide();
            }
        };

        DowntimeDetailsBody.prototype._renderActions = function () {
            var ref, ref1;
            this.$(".js-actions-container").append((ref = this.actions) != null ? ref.render().el : void 0);
            return (ref1 = this.actions) != null ? ref1.on("all", (function (_this) {
                return function () {
                    return _this.trigger.apply(_this, arguments);
                };
            })(this)) : void 0;
        };

        DowntimeDetailsBody.prototype._renderResources = function () {
            if (this.resources.length === 1) {
                this.$("#booking-resources-field").text("Resource");
            }
            this.resourcesView = new RG.Views.Downtimes.Resources({
                resources: this.resources
            });
            return this.$("#booking-resources").html(this.resourcesView.render().el);
        };

        return DowntimeDetailsBody;

    })(RG.Views.BaseView);

}).call(this);
;
(function () {
    RG.Views.Dialogs.DowntimeDetailsFactory = (function () {
        function DowntimeDetailsFactory(options) {
            this.downtimeFormFactory = options.downtimeFormFactory;
        }

        DowntimeDetailsFactory.prototype.create = function (options) {
            var actions, body, bodyView, booker, footer, header, resources, timeOffText;
            booker = window.bookers.findWhere({
                id: options.downtime.get('creatorId')
            });
            if (!booker) {
                booker = window.deletedBookers.findWhere({
                    id: options.downtime.get('creatorId')
                });
            }
            timeOffText = 'Downtime';
            resources = window.resources.select(function (resource) {
                return _.include(options.downtime.get('resourceIds'), resource.id);
            });
            if (_.any(resources, function (resource) {
                return resource.constructor === RG.Models.HumanResourceInstance;
            })) {
                timeOffText = 'Time Off';
            }
            header = new RG.Views.Dialogs.DowntimeDetailsHeader({
                timeOffText: timeOffText,
                downtime: options.downtime,
                duration: options.duration,
                currentUserTimeZone: window.currentUserTimeZone,
                resources: resources
            });
            if (RG.Utils.Permissions.canManageDowntime(options.downtime)) {
                actions = new RG.Views.Dialogs.DowntimeDetailsActions({
                    account: RG.Utils.getCurrentAccount(),
                    resources: resources,
                    duration: options.duration,
                    downtime: options.downtime,
                    downtimeFormFactory: this.downtimeFormFactory
                });
            }
            body = new RG.Views.Dialogs.DowntimeDetailsBody({
                downtime: options.downtime,
                booker: booker,
                resources: resources
            });
            footer = new RG.Views.Dialogs.TagWrapper({
                view: actions,
                tagName: 'footer'
            });
            bodyView = new RG.Views.Dialogs.Dialog({
                header: header,
                body: body,
                footer: footer,
                className: "downtime-details-dialog"
            });
            return new RG.Views.Dialogs.Popover({
                removeAttachTo: options.removeAttachTo,
                attachTo: options.attachTo,
                body: bodyView,
                className: 'edit-booking-dropdown js-edit-downtime-popover'
            });
        };

        return DowntimeDetailsFactory;

    })();

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.Dialogs.DowntimeDetailsHeader = (function (superClass) {
        extend(DowntimeDetailsHeader, superClass);

        function DowntimeDetailsHeader() {
            return DowntimeDetailsHeader.__super__.constructor.apply(this, arguments);
        }

        DowntimeDetailsHeader.prototype.template = templates.find('dialogs/downtime_details_header');

        DowntimeDetailsHeader.prototype.tagName = 'header';

        DowntimeDetailsHeader.prototype.initialize = function (options) {
            this.timeOffText = options.timeOffText;
            this.downtime = options.downtime;
            this.duration = options.duration;
            this.currentUserTimeZone = options.currentUserTimeZone;
            return this.resources = options.resources;
        };

        DowntimeDetailsHeader.prototype.render = function () {
            this.$el.html(this.template());
            this._fillValues();
            return this;
        };

        DowntimeDetailsHeader.prototype._fillValues = function () {
            var dateRange, icon, multipleResources, time, timezone;
            dateRange = this.downtime.getDateRange();
            timezone = this.downtime.getTimeZone();
            icon = $(document.createElement('i')).addClass(this.downtime.getTypeIcon());
            this.$("#popover-header").text(this.timeOffText).prepend(icon);
            if (this.downtime.get('resourceIds').length > 1) {
                multipleResources = $(document.createElement('i')).addClass('rg-icon--contacts');
                this.$("#popover-header").prepend(multipleResources);
            }
            time = this.$("#downtime-duration");
            if (dateRange.getNumberOfDays() > 1) {
                this.$(".downtime-details-date").remove();
                time.text(this.downtime.getDateTimeString(RG.Utils.DateFormatter.getShortDateWithYear));
                time.addClass('downtime-details-date');
            } else {
                this.$("#downtime-duration").text(this.downtime.getDateTimeString());
                time = this.$(".downtime-details-date");
                time.text(dateRange.toString());
            }
            if (this._isTimeZoneDifferent()) {
                time.append(" ");
                return time.append($("<span></span>").text(timezone));
            }
        };

        DowntimeDetailsHeader.prototype._isTimeZoneDifferent = function () {
            return RG.Utils.isDifferentTimeZones(this.resources, this.currentUserTimeZone);
        };

        return DowntimeDetailsHeader;

    })(RG.Views.BaseView);

}).call(this);
;
(function () {
    RG.Views.Dialogs.DowntimeFormFactory = (function () {
        function DowntimeFormFactory(options) {
            this.currentUserId = options.currentUserId;
            this.resources = options.resources;
            this.bookers = options.bookers;
            this.downtimeTypes = options.downtimeTypes;
            this.deletedBookers = options.deletedBookers;
            this.currentUserTimeZone = options.currentUserTimeZone;
            this.timeZones = options.timeZones;
        }

        DowntimeFormFactory.prototype.createEdit = function (options) {
            var resourceSelector, selectedResources;
            selectedResources = this.resources.select((function (_this) {
                return function (resource) {
                    return _.include(options.downtime.get('resourceIds'), resource.id);
                };
            })(this));
            resourceSelector = new RG.Views.Factories.NameSearch(this.resources).create({
                showMenu: true,
                cssClass: 'js-downtime-resource-selector',
                resourceSelector: true
            });
            return new RG.Views.Dialogs.EditDowntime({
                downtime: options.downtime,
                currentUserId: this.currentUserId,
                currentUserTimeZone: window.currentUserTimeZone,
                resources: this.resources,
                selectedResources: selectedResources,
                resourceSelector: resourceSelector,
                bookers: this.bookers,
                downtimeTypes: this.downtimeTypes,
                currentUserTimeZone: this.currentUserTimeZone,
                timeZones: this.timeZones
            });
        };

        return DowntimeFormFactory;

    })();

}).call(this);
;
(function () {
    RG.Views.Dialogs.DowntimePopoverFactory = (function () {
        function DowntimePopoverFactory(options) {
            this.downtime = options.downtime;
            this.duration = options.duration;
            this.downtimeAnchor = options.downtimeAnchor;
            this.popoverType = options.popoverType;
            if (typeof options.removeAttachTo === 'undefined') {
                this.removeAttachTo = true;
            }
            this.downtimeFormFactory = options.downtimeFormFactory;
        }

        DowntimePopoverFactory.prototype.popover = function () {
            var view;
            if (this.popoverType === 'details') {
                return this._getDetailsDialogFactory().create({
                    removeAttachTo: this.removeAttachTo,
                    downtime: this.downtime,
                    attachTo: this.downtimeAnchor,
                    duration: this.duration,
                    editSeries: function () {
                        return this.downtimeFormFactory.createEdit({
                            downtime: this.downtime
                        });
                    }
                });
            } else if (this.popoverType === 'edit') {
                view = this.downtimeFormFactory.createEdit({
                    downtime: this.downtime
                });
                return new RG.Views.Dialogs.Popover({
                    attachTo: this.downtimeAnchor,
                    body: view,
                    removeAttachTo: this.removeAttachTo,
                    className: 'edit-booking-dropdown'
                });
            }
        };

        DowntimePopoverFactory.prototype._getDetailsDialogFactory = function () {
            return new RG.Views.Dialogs.DowntimeDetailsFactory({
                downtimeFormFactory: this.downtimeFormFactory
            });
        };

        return DowntimePopoverFactory;

    })();

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.Dialogs.EditBooking = (function (superClass) {
        extend(EditBooking, superClass);

        function EditBooking() {
            return EditBooking.__super__.constructor.apply(this, arguments);
        }

        EditBooking.prototype.headerTemplate = templates.find('dialogs/edit_booking_header');

        EditBooking.prototype.initialize = function (options) {
            this.currentUserId = options.currentUserId;
            this.resources = options.resources;
            this.projects = options.projects;
            this.deletedProjects = options.deletedProjects;
            this.deletedClients = options.deletedClients;
            this.clients = options.clients;
            this.bookers = options.bookers;
            this.deletedBookers = options.deletedBookers;
            this.booking = options.booking;
            if (options.el) {
                this.el = options.el;
            }
            this.dateRange = this.booking.getDateRange();
            this.originalDate = this.dateRange.startDate;
            this.resource = this.booking.collection.resource;
            this.billableChecked = this.booking.get('billable');
            this.projectExists = false;
            this.clientExists = false;
            if (this.booking.attributes.project) {
                this.projectExists = this.projects.findWhere({
                    id: this.booking.attributes.project.attributes.id
                });
            }
            if (this.booking.attributes.client) {
                this.clientExists = this.clients.findWhere({
                    id: this.booking.attributes.client.attributes.id
                });
            }
            if (this.booking.attributes.project) {
                this.deletedProjectExists = this.deletedProjects.findWhere({
                    id: this.booking.attributes.project.attributes.id
                });
            }
            if (this.booking.attributes.client) {
                this.deletedClientExists = this.deletedClients.findWhere({
                    id: this.booking.attributes.client.attributes.id
                });
            }
            this.booker_exists = this.bookers.findWhere({
                id: this.booking.attributes.booker.attributes.id
            });
            if (!this.booker_exists) {
                this.bookers.unshift(this.booking.attributes.booker);
                this.bookers.sort(function (b) {
                    return b.get('name');
                });
            }
            return this.backpackErrorsFields = [
                {
                    mountpoint: '.booking-details-error',
                    label: 'details'
                }, {
                    mountpoint: '.booking-project-id-error',
                    label: 'project_id'
                }, {
                    mountpoint: '.booking-client-id-error',
                    label: 'client_id'
                }
            ];
        };

        EditBooking.prototype.render = function () {
            EditBooking.__super__.render.apply(this, arguments);
            this.$el.prepend(this.headerTemplate());
            return this;
        };

        EditBooking.prototype.clearClientOrProject = function () {
            this.bookerSelector.setSelectedValue(this.bookerSelector.getCurrentUserBooker().cid);
            return this.clientProjectSelector.setSelectedValue(this.clientProjectSelector._originalValue);
        };

        EditBooking.prototype.toggleDurationTypes = function () {
            var duration, end_time, start_time;
            EditBooking.__super__.toggleDurationTypes.apply(this, arguments);
            if (!this.selectingDuration) {
                duration = this.booking.durations.models[0].get('minutes');
                start_time = 540;
                end_time = +duration + start_time;
                if (end_time <= 1440) {
                    this.timeRangeSelector.setStartTime(start_time);
                    return this.timeRangeSelector.setEndTime(end_time);
                } else if (end_time <= 1380) {
                    this.timeRangeSelector.setStartTime(60);
                    return this.timeRangeSelector.setEndTime(end_time - 480);
                }
            }
        };

        EditBooking.prototype._disableButtons = function () {
            $("footer a").attr("disabled", "disabled");
            return $("footer #add-booking").text("Busy, please wait...");
        };

        EditBooking.prototype._composeViews = function () {
            var ref, ref1, ref2;
            this.initialClientOrProject = (ref = this.booking) != null ? ref.getBookingTarget().cid : void 0;
            if (this.booking) {
                if (this.booking.attributes.project) {
                    this.projects.push((ref1 = this.booking) != null ? ref1.getBookingTarget() : void 0);
                } else if (this.booking.attributes.client) {
                    this.clients.push((ref2 = this.booking) != null ? ref2.getBookingTarget() : void 0);
                }
            }
            EditBooking.__super__._composeViews.apply(this, arguments);
            this.$("header h3").text("Edit Booking");
            this.$("#add-booking").text("Update Booking");
            this.durationSelector.setDuration(this.booking.durations.models[0].getMinutes());
            if (this.booking.durations.models[0].get('startTime') || this.booking.durations.models[0].get('startTime') === 0) {
                this.setSelectingDuration(false);
                this.timeRangeSelector.setStartTime(this.booking.durations.models[0].get('startTime'));
                this.timeRangeSelector.setEndTime(this.booking.durations.models[0].get('endTime'));
            } else {
                this.timeRangeSelector.setStartTime('0');
                this.timeRangeSelector.setEndTime("" + (this.booking.durations.models[0].get('minutes')));
                this.setSelectingDuration(true);
            }
            this.clientProjectSelector.setSelectedValue(this.clientProjectSelector._originalValue);
            this.$("#booking-details").val(this.booking.get('notes'));
            this._sortProjectsAndClientsAlphabetically();
            this.bookerSelector.setSelectedValue(this.booking.get('booker').cid);
            return this.el.querySelector("#booking-billable").checked = this.booking.isBillable();
        };

        EditBooking.prototype._sortProjectsAndClientsAlphabetically = function () {
            this.clientProjectSelector.clients.sort();
            return this.clientProjectSelector.projects.sort();
        };

        EditBooking.prototype._setBookingTarget = function () {
            if (this.projectExists) {
                return this.booking.attributes.project.cid;
            } else if (this.clientExists) {
                return this.booking.attributes.client.cid;
            } else if (this.deletedProjectExists) {
                return this.deletedProjects.findWhere({
                    id: this.booking.attributes.project.attributes.id
                }).cid;
            } else if (this.deletedClientExists) {
                return this.deletedClients.findWhere({
                    id: this.booking.attributes.client.attributes.id
                }).cid;
            }
        };

        EditBooking.prototype.remove = function () {
            this.undelegateEvents();
            if (!this.projectExists && this.booking.attributes.project) {
                this.projects.remove(this.deletedProjects.findWhere({
                    id: this.booking.attributes.project.id
                }));
            }
            if (!this.clientExists && this.booking.attributes.client) {
                this.clients.remove(this.deletedClients.findWhere({
                    id: this.booking.attributes.client.id
                }));
            }
            if (!this.booker_exists) {
                this.bookers.remove(this.booking.attributes.booker);
            }
            return EditBooking.__super__.remove.apply(this, arguments);
        };

        EditBooking.prototype._saveBookingToApi = function (resource, booker, dateRange, targetClientOrProject, billable, details, bookingDuration) {
            var command, overlay;
            overlay = RG.Utils.spinnerOverlay($(this.el).closest('.js-edit-booking-popover')[0]);
            command = new RG.Commands.UpdateBookingCommand({
                resource: resource,
                booking: this.booking,
                booker: booker,
                startDate: dateRange.startDate,
                endDate: dateRange.endDate,
                target: targetClientOrProject,
                clearTarget: !targetClientOrProject,
                billable: billable,
                details: details,
                bookingDuration: bookingDuration,
                successCallback: (function (_this) {
                    return function (data) {
                        if (_this.booking && resource.id !== _this.booking.collection.resource.id) {
                            _this.booking.collection.remove(_this.booking);
                        }
                        RG.Utils.BookingMerger.merge(resource.bookings, [data]);
                        window.update();
                        overlay.close();
                        _this.trigger('close');
                        Q.delay(500).then(function () {
                            return RG.Popovers.popoverActive = false;
                        });
                        return resource.bookings.predictWaitingList();
                    };
                })(this),
                errorCallback: (function (_this) {
                    return function (e, xhr) {
                        overlay.close();
                        _this.$('.booking-save-error').show();
                        return window.Raven.captureException(e, {
                            extra: {
                                resource_id: resource.id,
                                booking_id: _this.booking.id,
                                booker_id: booker.id,
                                start_date: RG.Utils.DateFormatter.getISODate(dateRange.startDate),
                                end_date: RG.Utils.DateFormatter.getISODate(dateRange.endDate),
                                billable: billable,
                                duration: bookingDuration.duration,
                                start_time: bookingDuration.startTime,
                                target: targetClientOrProject && targetClientOrProject.constructor.name + ": " + targetClientOrProject.id,
                                xhr: {
                                    responseText: xhr.responseText,
                                    responseStatus: xhr.status
                                }
                            }
                        });
                    };
                })(this)
            });
            command.removedDatesCallback = (function (_this) {
                return function (removedDates) {
                    var placer, popover, ref, removedDatesDialog;
                    removedDatesDialog = new RG.Views.Dialogs.RemovedAvailabilityDates({
                        resource: resource,
                        removedAvailabilityDates: removedDates
                    });
                    placer = new RG.Utils.DatePopoverPlacer(resource, _this.originalDate, {
                        offsetTop: ((ref = $(".booking[data-booking-id=" + _this.booking.id + "]").offset()) != null ? ref.top : void 0) + 40
                    });
                    popover = new RG.Views.Dialogs.BookingClashPopover({
                        removeAttachTo: true,
                        attachTo: placer.createAnchor({
                            className: 'booking-clash-popover-anchor'
                        }),
                        body: removedDatesDialog,
                        className: 'edit-booking-dropdown'
                    });
                    return RG.Popovers.replace({
                        popoverView: popover,
                        removeCallback: function () { }
                    });
                };
            })(this);
            command.waitingCallback = (function (_this) {
                return function (waitingDates) {
                    var waitingConfirmation;
                    waitingConfirmation = new RG.Views.Dialogs.WaitingListConfirmation({
                        resource: resource,
                        waitingDates: waitingDates,
                        duration: command.bookingDuration.duration,
                        startTime: command.bookingDuration.startTime,
                        startDate: dateRange.startDate,
                        endDate: dateRange.endDate,
                        origin: _this,
                        callback: function () {
                            command.forceWaiting = true;
                            return command.execute();
                        }
                    });
                    overlay.close();
                    waitingConfirmation.on('addWaiting', function () {
                        waitingConfirmation.remove();
                        return overlay = RG.Utils.spinnerOverlay(_this.$el.closest('.js-edit-booking-popover')[0]);
                    });
                    return _this.trigger("changeOverlay", waitingConfirmation, {
                        className: 'overlay booking-waiting'
                    });
                };
            })(this);
            command.archivedCallback = (function (_this) {
                return function (data) {
                    new RG.Utils.ErrorHandler(_this.el, _this.backpackErrorsFields, data).handleErrors();
                    return overlay.close();
                };
            })(this);
            command.execute();
            return false;
        };

        return EditBooking;

    })(RG.Views.Dialogs.NewBooking);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.Dialogs.EditDowntime = (function (superClass) {
        extend(EditDowntime, superClass);

        function EditDowntime() {
            return EditDowntime.__super__.constructor.apply(this, arguments);
        }

        EditDowntime.prototype.initialize = function (options) {
            var selectedIds, selectedResources;
            this.downtime = options.downtime;
            this.currentUserId = options.currentUserId;
            this.resources = options.resources;
            this.resource = options.selectedResources[0];
            this.account = this.resource.account;
            this.selectedResources = options.selectedResources;
            this.selectedResourceIds = _.map(this.selectedResources, function (r) {
                return r.id;
            });
            this.originalResourceIds = _.clone(this.selectedResourceIds);
            this.bookers = options.bookers;
            this.selectedTimeZoneOption = this.downtime.getTimeZoneName();
            this.dateRange = this.downtime.getDateRange();
            this.timeRange = this.downtime.getRawTimeRange();
            this.downtimeTypes = options.downtimeTypes;
            this.timeZones = options.timeZones;
            this.currentUserTimeZone = options.currentUserTimeZone;
            this.renderHeader = true;
            selectedIds = _.map(this.selectedResources, function (r) {
                return r.id;
            });
            selectedResources = this.resources.filter(function (resource) {
                return selectedIds.includes(resource.get('id'));
            }, this);
            this.resourceSelector = new RG.Views.Downtimes.ResourceSelector({
                resources: this.resources,
                selected: selectedResources,
                itemClassName: 'multiselect-downtime-item',
                groupClassName: 'multiselect-downtime-group',
                onChange: this.toggleTimeZoneSelector
            });
            return this.resourceSelector.on('displaySpinner', (function (_this) {
                return function () {
                    return _this.resourceSelector.overlay = RG.Utils.spinnerOverlay($(_this.el).closest('.js-edit-downtime-popover')[0]);
                };
            })(this));
        };

        EditDowntime.prototype.createDowntime = function () {
            var overlay;
            overlay = RG.Utils.spinnerOverlay($(this.el).closest('.js-edit-downtime-popover')[0]);
            return Q.delay(20).then((function (_this) {
                return function () {
                    var command, dateTimeRange, originalAttributes, realDowntime;
                    dateTimeRange = _this.dateTimeRangeSelector.getValues();
                    if (_this.validate()) {
                        _this.rendererLock = new RG.Renderer.GlobalLock;
                        RG.renderer.lock(_this.rendererLock);
                        realDowntime = _this.account.downtimes.findWhere({
                            id: _this.downtime.id
                        });
                        originalAttributes = _.clone(realDowntime.attributes);
                        realDowntime.set({
                            saving: true
                        });
                        command = new RG.Commands.UpdateDowntimeCommand({
                            downtime: _this.downtime,
                            account: _this.resource.account,
                            resources: _this._getResources(),
                            booker: _this._getBooker(),
                            dateTimeRange: dateTimeRange,
                            details: _this._getDetails(),
                            timeZones: _this.timeZones,
                            timeZone: _this._getTimeZone(),
                            type: _this._getType(),
                            preExecuteCallback: function (downtime, durations, shouldDelete) {
                                return RG.renderer.unlock(_this.rendererLock);
                            },
                            successCallback: function (downtime) {
                                RG.renderer.unlock(_this.rendererLock);
                                realDowntime.set({
                                    saving: false
                                });
                                return window.update().then(function () {
                                    RG.Popovers.done();
                                    return Q.delay(500).then(function () {
                                        return RG.Popovers.popoverActive = false;
                                    });
                                });
                            },
                            errorCallback: function (data) {
                                RG.renderer.unlock(_this.rendererLock);
                                overlay.close();
                                realDowntime.set({
                                    saving: false
                                });
                                _this.optionView = new RG.Views.Dialogs.ErrorList({
                                    errors: data
                                });
                                return _this.trigger('changeOverlay', _this.optionView, {
                                    className: 'overlay availability-waiting'
                                });
                            },
                            saveErrorCallback: function (e, xhr) {
                                RG.renderer.unlock(_this.rendererLock);
                                overlay.close();
                                realDowntime.set({
                                    saving: false
                                });
                                _this.$('.downtime-save-error').show();
                                return window.Raven.captureException(e, {
                                    extra: {
                                        downtime_id: _this.downtime.id,
                                        account_id: _this.resource.account.id,
                                        resource_ids: _this.resourceSelector.getResourceIds(),
                                        booker_id: _this._getBooker().id,
                                        dateTimeRange: dateTimeRange,
                                        timeZones: _this.timeZones,
                                        timeZone: _this._getTimeZone(),
                                        type: _this._getType(),
                                        xhr: {
                                            responseText: xhr.responseText,
                                            responseStatus: xhr.status
                                        }
                                    }
                                });
                            }
                        });
                        return Q.delay(50).then(function () {
                            command.willTouchBookings({
                                success: function (bookingsCount) {
                                    var cancelCallback;
                                    cancelCallback = function () {
                                        RG.renderer.unlock(_this.rendererLock);
                                        RG.Popovers.removeCallback = null;
                                        realDowntime.set(originalAttributes);
                                        return realDowntime.set({
                                            saving: false
                                        });
                                    };
                                    _this.optionView = new RG.Views.Dialogs.BookingClashManagement({
                                        command: command,
                                        clashBookingsCount: bookingsCount,
                                        cancelCallback: cancelCallback,
                                        successCallback: function () {
                                            RG.renderer.unlock(_this.rendererLock);
                                            RG.Popovers.removeCallback = null;
                                            realDowntime.set({
                                                saving: false
                                            });
                                            return window.update();
                                        }
                                    });
                                    overlay.close();
                                    _this.trigger('changeOverlay', _this.optionView, {
                                        className: 'overlay availability-waiting'
                                    });
                                    return RG.Popovers.removeCallback = cancelCallback;
                                },
                                fail: function () {
                                    RG.renderer.unlock(_this.rendererLock);
                                    return command.execute();
                                }
                            });
                            return realDowntime.set(command.downtime.attributes);
                        });
                    } else {
                        return overlay.close();
                    }
                };
            })(this));
        };

        EditDowntime.prototype._fillValues = function () {
            EditDowntime.__super__._fillValues.apply(this, arguments);
            this.$(".js-downtime-icon").removeClass("rg-icon--vacation").addClass(this.downtime.getTypeIcon());
            this.$('.js-time-off-header-text').text("Edit " + (this.resource.getHeadingDowntimeText()));
            this.$('#downtime-details-value').val(this.downtime.get('details'));
            return this.$('#add-downtime').text("Update " + (this.resource.getHeadingDowntimeText()));
        };

        EditDowntime.prototype._composeDownTimeTypes = function () {
            this.downtimeTypeSelector = new RG.Views.Selectors.DowntimeTypeSelector({
                downtimeTypes: this.downtimeTypes,
                selectedOption: this.downtime.getDowntimeType()
            });
            this.downtimeTypeSelector.on("change", (function (_this) {
                return function (downtimeType) {
                    return _this._updateTypeIcon(downtimeType);
                };
            })(this));
            return this.$("#downtime-type-options").append(this.downtimeTypeSelector.render().el);
        };

        EditDowntime.prototype._updateTypeIcon = function (downtimeType) {
            return this.$(".js-downtime-icon").attr('class', "js-downtime-icon " + ((downtimeType != null ? downtimeType.typeIcon() : void 0) || 'rg-icon--vacation'));
        };

        EditDowntime.prototype._affectedResources = function () {
            var affectedResourceIds;
            this.selectedResourceIds = _.map(this.selectedResources, function (r) {
                return r.id;
            });
            affectedResourceIds = _.uniq(this.originalResourceIds.concat(this.selectedResourceIds));
            return this.resources.select(function (r) {
                return _.include(affectedResourceIds, r.id);
            });
        };

        EditDowntime.prototype._composeResourceSelector = function () {
            this.$('.js-resource-selector').html(this.resourceSelector.render().el);
            this.resourceSelector.setFilters([
                {
                    categoryName: 'Person',
                    options: [
                        {
                            matchType: 'any',
                            name: 'Name',
                            selectedOptions: this.selectedResourceIds
                        }
                    ]
                }
            ]);
            return this.resourceSelector.on('change:filter', (function (_this) {
                return function () {
                    return _this.trigger("updatePosition");
                };
            })(this));
        };

        return EditDowntime;

    })(RG.Views.Dialogs.NewDowntime);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.Dialogs.EditOvertimePopover = (function (superClass) {
        extend(EditOvertimePopover, superClass);

        function EditOvertimePopover() {
            return EditOvertimePopover.__super__.constructor.apply(this, arguments);
        }

        EditOvertimePopover.prototype.className = 'edit-overtime-dropdown';

        EditOvertimePopover.prototype.cssClass = 'js-edit-overtime-dropdown';

        EditOvertimePopover.prototype.events = {
            "click": "_stopPropagation"
        };

        EditOvertimePopover.prototype.initialize = function (options) {
            EditOvertimePopover.__super__.initialize.apply(this, arguments);
            this.availabilityConsistent = options.availabilityConsistent;
            this.availableMinutes = options.availableMinutes;
            return this.overtimeMinutes = options.overtimeMinutes;
        };

        EditOvertimePopover.prototype.render = function () {
            this.setupEvents();
            return EditOvertimePopover.__super__.render.apply(this, arguments);
        };

        EditOvertimePopover.prototype.remove = function () {
            this.triggerDone();
            return EditOvertimePopover.__super__.remove.apply(this, arguments);
        };

        EditOvertimePopover.prototype.setPosition = function () {
            var initialLeft, initialTop, overtimeEditLink;
            overtimeEditLink = this.attachTo.find(".js-text--edit-overtime");
            initialTop = overtimeEditLink.position().top;
            initialLeft = overtimeEditLink.position().left;
            this.$(".shadow-arrow").css({
                top: this.$(".f-dropdown").height() - 12,
                left: initialLeft - 32
            });
            return this.$el.css({
                position: 'absolute',
                top: initialTop - 194,
                left: initialLeft - 242
            });
        };

        EditOvertimePopover.prototype.setupEvents = function () {
            this.$el.on('click', '.js-cancel', (function (_this) {
                return function (e) {
                    e.preventDefault();
                    e.stopPropagation();
                    return _this.remove();
                };
            })(this));
            this.$el.on('click', '.js-update', (function (_this) {
                return function (e) {
                    e.preventDefault();
                    e.stopPropagation();
                    return _this.updateOvertime();
                };
            })(this));
            return this.$el.on('click', '.js-edit-overtime', (function (_this) {
                return function (e) {
                    e.preventDefault();
                    e.stopPropagation();
                    return _this.flagOvertime();
                };
            })(this));
        };

        EditOvertimePopover.prototype.triggerDone = function () {
            return this.trigger('editing:overtime:done');
        };

        EditOvertimePopover.prototype.popup = function () {
            if (this.overtimeMinutes === null) {
                this.setupEditOvertimeView();
            } else {
                this.setupFlagOvertimeView();
            }
            return EditOvertimePopover.__super__.popup.apply(this, arguments);
        };

        EditOvertimePopover.prototype.setupFlagOvertimeView = function () {
            var ref;
            if ((ref = this.bodyView) != null) {
                ref.remove();
            }
            return this.setBodyView(new RG.Views.CustomAvailability.FlagOvertimeForm({
                availabilityConsistent: this.availabilityConsistent,
                availableMinutes: this.availableMinutes,
                overtimeMinutes: this.overtimeMinutes
            }));
        };

        EditOvertimePopover.prototype.setupEditOvertimeView = function () {
            var ref;
            if ((ref = this.bodyView) != null) {
                ref.remove();
            }
            return this.setBodyView(new RG.Views.CustomAvailability.EditOvertimeForm);
        };

        EditOvertimePopover.prototype.flagOvertime = function () {
            this.setupFlagOvertimeView();
            return this.render();
        };

        EditOvertimePopover.prototype.updateOvertime = function () {
            this.trigger('change', this.bodyView.overtimeMinutes);
            return this.remove();
        };

        EditOvertimePopover.prototype._setOpenDirection = function () {
            EditOvertimePopover.__super__._setOpenDirection.apply(this, arguments);
            return this.$el.css({
                left: ""
            });
        };

        EditOvertimePopover.prototype._stopPropagation = function (e) {
            return e.stopPropagation();
        };

        return EditOvertimePopover;

    })(RG.Views.Dialogs.Popover);

    RG.Views.CustomAvailability.EditOvertimeForm = (function (superClass) {
        extend(EditOvertimeForm, superClass);

        function EditOvertimeForm() {
            return EditOvertimeForm.__super__.constructor.apply(this, arguments);
        }

        EditOvertimeForm.prototype.className = 'varying-overtime-dropdown';

        EditOvertimeForm.prototype.render = function () {
            this.$el.empty();
            this.$el.append($(document.createElement('p')).text('Overtime varies in this date range.\n Do you want to edit it?'));
            this.$el.append(this._renderFooter());
            return this;
        };

        EditOvertimeForm.prototype.remove = function () {
            this.off();
            this.$el.off();
            return EditOvertimeForm.__super__.remove.apply(this, arguments);
        };

        EditOvertimeForm.prototype._renderFooter = function () {
            this.footer = $(document.createElement("footer"));
            this.footer.append($(document.createElement("button")).addClass("btn btn-guru js-edit-overtime").text("Edit Overtime"));
            this.footer.append($(document.createElement("button")).addClass("btn js-cancel").text("Cancel"));
            return this.footer;
        };

        return EditOvertimeForm;

    })(RG.Views.BaseView);

    RG.Views.CustomAvailability.FlagOvertimeForm = (function (superClass) {
        extend(FlagOvertimeForm, superClass);

        function FlagOvertimeForm() {
            return FlagOvertimeForm.__super__.constructor.apply(this, arguments);
        }

        FlagOvertimeForm.prototype.className = 'overtime-slider';

        FlagOvertimeForm.prototype.initialize = function (options) {
            this.availabilityConsistent = options.availabilityConsistent;
            this.availableMinutes = options.availableMinutes;
            return this.overtimeMinutes = options.overtimeMinutes;
        };

        FlagOvertimeForm.prototype.remove = function () {
            var ref;
            if ((ref = this.overtimeTextEl) != null) {
                ref.off();
            }
            if (this.durationSelector) {
                this.durationSelector.validate = null;
                this.durationSelector.remove();
            }
            this.overtimeSlider.off();
            this._removeEventBindings();
            return FlagOvertimeForm.__super__.remove.apply(this, arguments);
        };

        FlagOvertimeForm.prototype.render = function () {
            var availabilityText, minutes, ref, startMinutes;
            this.$el.empty();
            if ((ref = this.durationSelector) != null) {
                ref.remove();
            }
            this.durationSelector = null;
            availabilityText = $(document.createElement("p")).text;
            this.$el.append(this._renderOvertimeSlider());
            minutes = +this.availableMinutes;
            startMinutes = minutes - +this.overtimeMinutes;
            this.overtimeSlider.noUiSlider({
                start: [startMinutes],
                range: {
                    min: 0,
                    max: minutes
                },
                step: 30
            }).on({
                change: (function (_this) {
                    return function () {
                        var ref1;
                        _this._updateOvertimeMinutes();
                        return (ref1 = _this.durationSelector) != null ? ref1.setDuration(_this.overtimeMinutes) : void 0;
                    };
                })(this),
                set: (function (_this) {
                    return function () {
                        return _this._updateOvertimeMinutes();
                    };
                })(this),
                slide: (function (_this) {
                    return function () {
                        return _this._updateOvertimeMinutes();
                    };
                })(this)
            });
            if (this.availabilityConsistent) {
                this.$el.append(this._renderAvailability());
            } else {
                this.overtimeSlider.hide();
            }
            this.$el.append(this._renderFooter());
            if (!this.availabilityConsistent) {
                this.toggleManualSet();
            }
            this._bindEvents();
            return this;
        };

        FlagOvertimeForm.prototype._bindEvents = function () {
            $(".availability-tabs__menu a.dropdown-toggle").on("click", function (e) {
                e.preventDefault();
                return e.stopPropagation();
            });
            return $(".js-edit, .js-add-timeblock").on("click", (function (_this) {
                return function (e) {
                    return _this.trigger('close');
                };
            })(this));
        };

        FlagOvertimeForm.prototype._removeEventBindings = function () {
            $(".availability-tabs__menu a.dropdown-toggle").off("click");
            return $(".js-edit").off("click");
        };

        FlagOvertimeForm.prototype.toggleManualSet = function (e) {
            var $element, div;
            if (e) {
                e.preventDefault();
                e.stopPropagation();
            }
            if (this.durationSelector) {
                this.overtimeSlider.noUiSlider({
                    step: 30
                }, true);
                this.durationSelector.remove();
                this.durationSelector = null;
                this.$el.find('.js-manual-set-controls').remove();
                return null;
            } else {
                this.overtimeSlider.noUiSlider({
                    step: 1
                }, true);
            }
            div = $(document.createElement('div')).addClass('overtime-fine-controls js-manual-set-controls');
            this.durationSelector = new RG.Views.Selectors.Duration({
                duration: this.overtimeMinutes,
                typeName: 'Overtime',
                inlineHelpText: 'Cannot assign more overtime than available time.'
            });
            this.durationSelector.validate = this.validate.bind(this);
            this.durationSelector.validate();
            $element = $(this.durationSelector.render().el);
            $element.find('.alt-toggle').remove();
            div.append($element);
            return this.footer.prepend(div);
        };

        FlagOvertimeForm.prototype.validate = function () {
            var error;
            error = false;
            this.overtimeSlider.val(this.availableMinutes - this.durationSelector.getDuration());
            this.overtimeMinutes = this.durationSelector.getDuration();
            if (this.overtimeMinutes > 0) {
                if (this.overtimeMinutes > this.availableMinutes) {
                    error = true;
                    this.$(".help-inline.error").text("Hours must fall within the available time");
                } else {
                    error = false;
                }
            }
            this.durationSelector.toggleError(error);
            this.$(".js-update").attr('disabled', error ? 'disabled' : null);
            return !error;
        };

        FlagOvertimeForm.prototype._renderOvertimeSlider = function () {
            this.overtimeSlider = $(document.createElement('div'));
            return this.overtimeSlider;
        };

        FlagOvertimeForm.prototype._renderAvailability = function () {
            if (this.overtimeTextEl == null) {
                this.overtimeTextEl = $(document.createElement("strong")).addClass("text--edit-overtime");
            }
            this.overtimeTextEl.on('click', this.toggleManualSet.bind(this));
            if (this.availabilityTextEl == null) {
                this.availabilityTextEl = $(document.createElement("span"));
            }
            if (this.availabilityEl == null) {
                this.availabilityEl = $(document.createElement("p"));
            }
            this.availabilityTextEl.text((RG.Utils.TimeFormatter.formatMinutes(this.availableMinutes)) + " availability, of which ");
            this._changeOverTimeText();
            this.availabilityEl.append(this.availabilityTextEl);
            return this.availabilityEl.append(this.overtimeTextEl);
        };

        FlagOvertimeForm.prototype._changeOverTimeText = function () {
            if (this.availabilityConsistent) {
                return this.overtimeTextEl.text(RG.Utils.TimeFormatter.formatMinutes(this.overtimeMinutes) + " is overtime");
            }
        };

        FlagOvertimeForm.prototype._updateOvertimeMinutes = function () {
            this.overtimeMinutes = +this.availableMinutes - +this.overtimeSlider.val();
            return this._changeOverTimeText();
        };

        FlagOvertimeForm.prototype._renderFooter = function () {
            this.footer = $(document.createElement("footer"));
            this.footer.append($(document.createElement("button")).addClass("btn btn-guru btn--small js-update").text("Flag Overtime"));
            this.footer.append("\n");
            this.footer.append($(document.createElement("button")).addClass("btn btn--small js-cancel").text("Cancel"));
            return this.footer;
        };

        return FlagOvertimeForm;

    })(RG.Views.BaseView);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.Dialogs.EditTimeBlockDropdown = (function (superClass) {
        extend(EditTimeBlockDropdown, superClass);

        function EditTimeBlockDropdown() {
            return EditTimeBlockDropdown.__super__.constructor.apply(this, arguments);
        }

        EditTimeBlockDropdown.prototype.cssClass = 'add-timeblock-dropdown';

        EditTimeBlockDropdown.prototype.events = {
            "click .js-cancel-button": "close",
            "click": "closeSelector"
        };

        EditTimeBlockDropdown.prototype.initialize = function (options) {
            this.newTimeBlockStartTime = options.newTimeBlockStartTime;
            this.newTimeBlockEndTime = options.newTimeBlockEndTime;
            return EditTimeBlockDropdown.__super__.initialize.apply(this, arguments);
        };

        EditTimeBlockDropdown.prototype.close = function () {
            return this.trigger("close");
        };

        EditTimeBlockDropdown.prototype.remove = function () {
            this.attachTo = null;
            return EditTimeBlockDropdown.__super__.remove.apply(this, arguments);
        };

        EditTimeBlockDropdown.prototype.setBodyView = function () {
            EditTimeBlockDropdown.__super__.setBodyView.apply(this, arguments);
            this.bodyView.on("add", (function (_this) {
                return function (ap) {
                    return _this.trigger("update", ap);
                };
            })(this));
            return this.bodyView.on("remove", (function (_this) {
                return function (ap) {
                    return _this.trigger("remove", ap);
                };
            })(this));
        };

        EditTimeBlockDropdown.prototype.closeSelector = function (e) {
            this.bodyView.closeSelector();
            if (e) {
                return e.stopPropagation();
            }
        };

        EditTimeBlockDropdown.prototype.popup = function () {
            this.setBodyView(new RG.Views.CustomAvailability.EditTimeBlock({
                newTimeBlockStartTime: this.newTimeBlockStartTime,
                newTimeBlockEndTime: this.newTimeBlockEndTime
            }));
            return EditTimeBlockDropdown.__super__.popup.apply(this, arguments);
        };

        return EditTimeBlockDropdown;

    })(RG.Views.Dialogs.Popover);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.Dialogs.ErrorList = (function (superClass) {
        extend(ErrorList, superClass);

        function ErrorList() {
            return ErrorList.__super__.constructor.apply(this, arguments);
        }

        ErrorList.prototype.template = templates.find('dialogs/error_list');

        ErrorList.prototype.initialize = function (options) {
            if (options == null) {
                options = {};
            }
            return this.errors = options.errors;
        };

        ErrorList.prototype.render = function () {
            this.$el.html(this.template());
            this._fillValues();
            this._bindEvents();
            return this;
        };

        ErrorList.prototype.cancel = function (e) {
            e.preventDefault();
            this.trigger("close");
            return e.stopPropagation();
        };

        ErrorList.prototype._fillValues = function () {
            var attribute, element, error, errors, i, len, ref, text;
            element = this.$('.js-alert-error');
            text = [];
            ref = this.errors;
            for (attribute in ref) {
                errors = ref[attribute];
                text.push("<p>" + attribute + ":</p>");
                text.push("<ul>");
                for (i = 0, len = errors.length; i < len; i++) {
                    error = errors[i];
                    text.push("<li>" + error + "</li>");
                }
                text.push("</ul>");
            }
            return this.$(".js-alert-error").html(text.join(""));
        };

        ErrorList.prototype._bindEvents = function () {
            return this.$el.on("click", ".js-ok", (function (_this) {
                return function () {
                    return _this.trigger('close');
                };
            })(this));
        };

        return ErrorList;

    })(RG.Views.BaseView);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.Dialogs.NewBookingDowntimePopover = (function (superClass) {
        extend(NewBookingDowntimePopover, superClass);

        function NewBookingDowntimePopover() {
            return NewBookingDowntimePopover.__super__.constructor.apply(this, arguments);
        }

        NewBookingDowntimePopover.prototype.template = templates.find('dialogs/new_booking_downtime_popover');

        NewBookingDowntimePopover.prototype.className = 'booking-dropdown js-booking-downtime-new';

        NewBookingDowntimePopover.prototype.events = {
            'click #new-booking': 'newBooking',
            'click #new-downtime': 'newDowntime'
        };

        NewBookingDowntimePopover.prototype.initialize = function (options) {
            this.newBookingOptions = options;
            this.cssClass = 'new-booking-time-off';
            this.permissions = options.permissions || RG.Utils.Permissions;
            return NewBookingDowntimePopover.__super__.initialize.apply(this, arguments);
        };

        NewBookingDowntimePopover.prototype.render = function () {
            this.$el.html(this.template());
            this.toggleActiveTab('booking');
            this._fillValues();
            this._applyPermissions();
            return this;
        };

        NewBookingDowntimePopover.prototype._fillValues = function () {
            var ref;
            NewBookingDowntimePopover.__super__._fillValues.apply(this, arguments);
            if (!((ref = this.newBookingOptions.resource) != null ? ref.isHuman() : void 0)) {
                return this.$(".js-time-off-text").text("New Downtime");
            }
        };

        NewBookingDowntimePopover.prototype._bindEvents = function () {
            return this.bodyView.on('change', (function (_this) {
                return function (dateRange) {
                    if (dateRange && dateRange.startDate && dateRange.endDate) {
                        _this.newBookingOptions.dateRange = dateRange;
                        return _this.newBookingOptions.changeCallback(dateRange);
                    }
                };
            })(this));
        };

        NewBookingDowntimePopover.prototype.remove = function () {
            var base;
            this.newBookingOptions.attachTo.remove();
            if (typeof (base = this.newBookingOptions).removeCallback === "function") {
                base.removeCallback();
            }
            return NewBookingDowntimePopover.__super__.remove.apply(this, arguments);
        };

        NewBookingDowntimePopover.prototype.popup = function () {
            this.bodyView = new RG.Views.Dialogs.NewBooking(this.newBookingOptions);
            return NewBookingDowntimePopover.__super__.popup.apply(this, arguments);
        };

        NewBookingDowntimePopover.prototype._getContentPanel = function () {
            return this.el.querySelector(".tabs-content");
        };

        NewBookingDowntimePopover.prototype.setBodyView = function (view, options) {
            if (options == null) {
                options = {
                    render: true
                };
            }
            NewBookingDowntimePopover.__super__.setBodyView.apply(this, arguments);
            return this._bindEvents();
        };

        NewBookingDowntimePopover.prototype.newBooking = function (e) {
            e.preventDefault();
            this.setBodyView(new RG.Views.Dialogs.NewBooking(this.newBookingOptions));
            return this.toggleActiveTab('booking');
        };

        NewBookingDowntimePopover.prototype.newDowntime = function (e) {
            var newDowntimeView, options, repositionFunc, resourceSelector;
            e.preventDefault();
            resourceSelector = new RG.Views.Factories.NameSearch(this.newBookingOptions.resources).create({
                showMenu: true,
                cssClass: 'js-downtime-resource-selector',
                resourceSelector: true
            });
            resourceSelector.on('displaySpinner', (function (_this) {
                return function () {
                    var spinner;
                    resourceSelector.overlay = new RG.Views.Dialogs.Overlay({
                        attachTo: _this.el,
                        className: "overlay",
                        template: function () {
                            return '';
                        }
                    });
                    resourceSelector.overlay.render();
                    return spinner = new Spinner(_this.spinnerOptions).spin(resourceSelector.overlay.el);
                };
            })(this));
            repositionFunc = (function (_this) {
                return function () {
                    return window.requestAnimationFrame(function () {
                        _this.setPosition();
                        return $(window).trigger('scroll');
                    });
                };
            })(this);
            resourceSelector.on('change:filter', repositionFunc);
            options = _.extend({
                resourceSelector: resourceSelector
            }, this.newBookingOptions);
            options.timeRange = new RG.Utils.TimeRange(0, 1440);
            newDowntimeView = new RG.Views.Dialogs.NewDowntime(options);
            newDowntimeView.on("validate", repositionFunc);
            this.setBodyView(newDowntimeView);
            return this.toggleActiveTab('downtime');
        };

        NewBookingDowntimePopover.prototype.toggleActiveTab = function (tab) {
            this.$('.tab-title').removeClass('active');
            this.$("." + tab + "-tab").addClass('active');
            return this.setPosition();
        };

        NewBookingDowntimePopover.prototype._applyPermissions = function () {
            if (!this.permissions.canAddDowntime()) {
                this.$(".downtime-tab").remove();
            }
            if (!this.permissions.canAddBooking()) {
                return window.requestAnimationFrame((function (_this) {
                    return function () {
                        _this.$(" #new-downtime").click();
                        return _this.$(".booking-tab").remove();
                    };
                })(this));
            }
        };

        return NewBookingDowntimePopover;

    })(RG.Views.Dialogs.Popover);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.Dialogs.NewClient = (function (superClass) {
        extend(NewClient, superClass);

        function NewClient() {
            return NewClient.__super__.constructor.apply(this, arguments);
        }

        NewClient.prototype.template = templates.find('dialogs/new_client');

        NewClient.prototype.events = {
            "submit form": "triggerAddClient",
            "click .add-client": "addClient",
            "click .cancel": "cancel"
        };

        NewClient.prototype.initialize = function (options) {
            if (options == null) {
                options = {};
            }
            return this.colorPicker = options.colorPicker || new RG.Views.Selectors.ColorPicker;
        };

        NewClient.prototype.render = function () {
            this.$el.html(this.template());
            this.$('dl').append(this.colorPicker.render().el);
            requestAnimationFrame((function (_this) {
                return function () {
                    return _this.$el.find('input.client-name').focus();
                };
            })(this));
            return this;
        };

        NewClient.prototype.addClient = function () {
            var data;
            if (this._validate()) {
                data = {
                    name: this.$("input.client-name").val().trim(),
                    color: this.$('.color').val()
                };
                this.disableButtons();
                return $.ajax(RG.getApiRoot() + "/clients", {
                    method: "POST",
                    data: data,
                     dataType: 'json',
                    headers: {
                        "X-CSRF-Token": $('meta[name="csrf-token"]').attr('content')
                    },
                    success: (function (_this) {
                        return function (responseData) {
                            var client;
                            client = new RG.Models.Client({
                                id: responseData.id,
                                color: responseData.color,
                                name: responseData.name,
                                archived: responseData.archived,
                                notes: responseData.notes
                            });
                            window.clients.add(client);
                            return _this.trigger('close', client);
                        };
                    })(this),
                    error: (function (_this) {
                        return function (xhr) {
                            var errorText;
                            errorText = JSON.parse(xhr.responseText);
                            _this.enableButtons();
                            _this.addErrorMessageByStatusCode(xhr.status, errorText.name);
                            return _this.$("input.client-name").focus();
                        };
                    })(this)
                });
            }
        };

        NewClient.prototype.addErrorMessageByStatusCode = function (statusCode, errorMsg) {
            if (parseInt(statusCode, 10) === 403) {
                return this.$(".help-inline").addClass("error").text("Sorry, you don't have permission to do that.").removeClass('hide');
            } else {
                return this.$(".help-inline").addClass("error").text("Sorry, name " + errorMsg).removeClass('hide');
            }
        };

        NewClient.prototype.cancel = function (e) {
            e.cancelBubble = true;
            e.stopPropagation();
            this.trigger('cancelled');
            return this.trigger('close');
        };

        NewClient.prototype.remove = function () {
            this.off();
            this.$el.off();
            return NewClient.__super__.remove.apply(this, arguments);
        };

        NewClient.prototype.disableButtons = function () {
            this.$("footer button").attr("disabled", "disabled");
            return this.$("footer .js-add-client").text("Busy, please wait...");
        };

        NewClient.prototype.enableButtons = function () {
            this.$("footer .js-add-client").text("Add Client");
            return this.$("footer button").attr("disabled", null);
        };

        NewClient.prototype.triggerAddClient = function () {
            this.addClient();
            return false;
        };

        NewClient.prototype._validate = function () {
            if (this.$("input.client-name").val().trim().length === 0) {
                this.$("span.help-inline").addClass("error").text("Please enter a name").removeClass("hide");
                this.$("input.client-name").addClass("error");
                return false;
            } else {
                this.$("span.help-inline").text("").addClass("hide");
                this.$("input.client-name").removeClass("error");
                return true;
            }
        };

        return NewClient;

    })(RG.Views.BaseView);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.Dialogs.NewProject = (function (superClass) {
        extend(NewProject, superClass);

        function NewProject() {
            return NewProject.__super__.constructor.apply(this, arguments);
        }

        NewProject.prototype.template = templates.find('dialogs/new_project');

        NewProject.prototype.events = {
            "submit form": "triggerAddProject",
            "click .add-project": "addProject",
            "click .cancel": "cancel",
            "click .chzn-single": "shrinkDropdown",
            "input input.project-name": "updateProjectCode"
        };

        NewProject.prototype.initialize = function (options) {
            if (options == null) {
                options = {};
            }
            this.clients = options.clients;
            this.projectCodes = options.projectCodes;
            this.listenTo(this.clients, 'add', this._createClientsSelect);
            this.listenTo(this.clients, 'remove', this._createClientsSelect);
            this.listenTo(this.clients, 'add', this._selectClient);
            this.selectedClient = options.selectedClient;
            this.colorPicker = options.colorPicker || new RG.Views.Selectors.ColorPicker;
            this.billableChecked = true;
            return this.backpackErrorsFields = [
                {
                    mountpoint: '.project-code-error',
                    label: 'project_code'
                }, {
                    mountpoint: '.name-error',
                    label: 'name'
                }
            ];
        };

        NewProject.prototype.render = function () {
            this.$el.html(this.template());
            this._createClientsSelect();
            if (this.selectedClient) {
                this._selectClient(this.selectedClient);
                this.selectedClient = null;
            }
            this.$('dl').append(this.colorPicker.render().el);
            this._createSwitchComponent(this.billableChecked);
            this._createProjectCodeUpdater();
            requestAnimationFrame((function (_this) {
                return function () {
                    return _this.$el.find('input.project-name').focus();
                };
            })(this));
            return this;
        };

        NewProject.prototype.addProject = function () {
            var client, data;
            if (this._validate()) {
                client = this.clients.find((function (_this) {
                    return function (c) {
                        return c.cid === _this.selectBox.val();
                    };
                })(this));
                data = {
                    name: this.$("input.project-name").val().trim(),
                    project_code: this.$("input[name='project_code']").val().trim(),
                    color: this.$('.color').val(),
                    client_id: client != null ? client.id : void 0,
                    default_billable: this.billableChecked
                };
                this.disableButtons();
                return $.ajax(RG.getApiRoot() + "/projects", {
                    method: "POST",
                    data: data,
                    dataType: 'json',
                    headers: {
                        "X-CSRF-Token": $('meta[name="csrf-token"]').attr('content')
                    },
                    success: (function (_this) {
                        return function (responseData) {
                            var project;
                            project = new RG.Models.Project({
                                id: responseData.id,
                                name: responseData.name,
                                project_code: responseData.project_code,
                                archived: responseData.archived,
                                notes: responseData.notes,
                                client: client,
                                default_billable: responseData.default_billable
                            });
                            if (responseData.color) {
                                project.set('color', "#" + responseData.color);
                            }
                            window.projects.add(project);
                            return _this.trigger('close');
                        };
                    })(this),
                    error: (function (_this) {
                        return function (xhr) {
                            var errorData;
                            errorData = {};
                            if (parseInt(xhr.status, 10) === 403) {
                                errorData = {
                                    'name': ["Sorry, you don't have permission to do that."]
                                };
                            } else {
                                errorData = JSON.parse(xhr.responseText);
                            }
                            _this.enableButtons();
                            new RG.Utils.ErrorHandler(_this.el, _this.backpackErrorsFields, errorData).handleErrors();
                            return _this.$("input.project-name").focus();
                        };
                    })(this)
                });
            }
        };

        NewProject.prototype.cancel = function (e) {
            e.cancelBubble = true;
            e.stopPropagation();
            this.trigger('cancelled');
            return this.trigger('close');
        };

        NewProject.prototype.clearClientOrProject = function () {
            return this.selectBox.val("").trigger("liszt:updated");
        };

        NewProject.prototype.disableButtons = function () {
            this.$("footer button").attr("disabled", "disabled");
            return this.$("footer .js-add-project").text("Busy, please wait...");
        };

        NewProject.prototype.enableButtons = function () {
            this.$("footer .js-add-project").text("Add Project");
            return this.$("footer button").attr("disabled", null);
        };

        NewProject.prototype.triggerAddProject = function () {
            this.addProject();
            return false;
        };

        NewProject.prototype.remove = function () {
            var ref;
            this.off();
            this.$el.off();
            if ((ref = this.modal) != null) {
                ref.remove();
            }
            return NewProject.__super__.remove.apply(this, arguments);
        };

        NewProject.prototype._createClientsSelect = function () {
            this.selectBox = $("<select data-optional=\"true\" data-placeholder=\"Please select (optional)\" style='width: 234px'><option></option></select>");
            this.selectBox.change((function (_this) {
                return function () {
                    return _this._clientChanged();
                };
            })(this));
            this._fillClientSelect();
            this.$(".client-select-field").html(this.selectBox);
            return this.selectBox.chosen({
                allow_single_deselect: true
            });
        };

        NewProject.prototype._fillClientSelect = function () {
            var c, i, len, ref;
            this.selectBox.html('<option></option><option value=\"new-client\">New client...</option>');
            ref = this.clients.models;
            for (i = 0, len = ref.length; i < len; i++) {
                c = ref[i];
                if (!c.get('archived')) {
                    this.selectBox.append("<option value=\"" + c.cid + "\">" + (c.getName()) + "</option>");
                }
            }
            return this.selectBox.trigger("liszt:updated");
        };

        NewProject.prototype._clientChanged = function () {
            if (this.selectBox.val() === "new-client") {
                window.rgStorage.set('newProject', JSON.stringify({
                    name: this.$(".project-name").val(),
                    color: this.$('.color').val(),
                    project_code: this.$("input[name='project_code']").val()
                }));
                this.modal = new RG.Views.Dialogs.NewClient;
                this.modal.on('close', (function (_this) {
                    return function (client) {
                        _this.trigger('changeOverlay', _this, {
                            className: 'overlay client',
                            client: client
                        });
                        return _this._fillInPreviousValues();
                    };
                })(this), this);
                return this.trigger('changeOverlay', this.modal, {
                    className: 'overlay client',
                    newClient: true
                });
            }
        };

        NewProject.prototype._fillInPreviousValues = function () {
            var newProject;
            newProject = window.rgStorage.get('newProject');
            if (newProject) {
                newProject = $.parseJSON(newProject);
                $(".project-name").val(newProject.name);
                $("input[name='project_code']").val(newProject.project_code);
                $(".color").val(newProject.color);
                $(".selected-color").css("background-color", "#" + newProject.color);
                return window.rgStorage["delete"]('newProject');
            }
        };

        NewProject.prototype._validate = function () {
            if (this.$("input.project-name").val().trim().length === 0) {
                this.$("span.help-inline").addClass("error").text("Please enter a name").removeClass("hide");
                this.$("input.project-name").addClass("error");
                return false;
            } else {
                this.$("span.help-inline").text("").addClass("hide");
                this.$("input.project-name").removeClass("error");
                return true;
            }
        };

        NewProject.prototype._selectClient = function (client) {
            return this.selectBox.val(client.cid).trigger("liszt:updated");
        };

        NewProject.prototype._createSwitchComponent = function (isChecked) {
            var selected;
            selected = isChecked ? 'Billable' : 'Non-billable';
            return window.RGComponents.createSwitch(this.$(".booking-billable-control")[0], {
                name: 'booking-billable',
                id: 'booking-billable',
                mode: 'a-b',
                labelLeft: 'Billable',
                labelRight: 'Non-billable',
                left: 'Billable',
                right: 'Non-billable',
                selected: isChecked ? 'Billable' : 'Non-billable',
                onChange: (function (_this) {
                    return function (checked) {
                        return _this.billableChecked = checked === 'Billable' ? true : false;
                    };
                })(this)
            });
        };

        NewProject.prototype._createProjectCodeUpdater = function () {
            this.setName = RGComponents.createProjectCodesFormControl(this.$(".project-code-control")[0], {
                existing: this.projectCodes
            });
            return this.setName("");
        };

        NewProject.prototype.updateProjectCode = function (ev) {
            return this.setName(ev.currentTarget.value);
        };

        return NewProject;

    })(RG.Views.BaseView);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.Dialogs.RemovedAvailabilityDates = (function (superClass) {
        extend(RemovedAvailabilityDates, superClass);

        function RemovedAvailabilityDates() {
            return RemovedAvailabilityDates.__super__.constructor.apply(this, arguments);
        }

        RemovedAvailabilityDates.prototype.template = templates.find('dialogs/removed_availability_dates');

        RemovedAvailabilityDates.prototype.initialize = function (options) {
            if (options == null) {
                options = {};
            }
            this.resource = options.resource;
            return this.removedAvailabilityDates = options.removedAvailabilityDates;
        };

        RemovedAvailabilityDates.prototype.render = function () {
            this.$el.html(this.template());
            this._fillValues();
            this._bindEvents();
            return this;
        };

        RemovedAvailabilityDates.prototype.close = function (e) {
            RG.Popovers.locked = false;
            return this.trigger('close');
        };

        RemovedAvailabilityDates.prototype._bindEvents = function () {
            return this.$el.on("click", ".js-ok", (function (_this) {
                return function () {
                    return _this.close();
                };
            })(this));
        };

        RemovedAvailabilityDates.prototype._fillValues = function () {
            var text;
            text = [];
            if (!this.resource.isHuman()) {
                this.$('.js-warning-title').text("Downtime " + (this._pluralizeDays()) + " Skipped");
            } else {
                this.$('.js-warning-title').text("Non-working " + (this._pluralizeDays()) + " Skipped");
            }
            text.push("<p>Just a heads up, ");
            text.push("<strong class='booking-clash-resource-name'>" + (this.resource.escape('name')) + "</strong> has " + (this._timeOffOrDowntime()) + " on " + (this._pluralizeDates()));
            text.push("</p>");
            if (this.removedAvailabilityDates.length > 5) {
                text.push("<p class='has-margin-left'>... and " + (this.removedAvailabilityDates.length - 5) + " " + (this._pluralizeOther()) + "</p>");
            } else {
                text.push("</p>");
            }
            return this.$(".js-booking-non-working-dates-details").html(text.join(""));
        };

        RemovedAvailabilityDates.prototype._pluralizeDays = function () {
            if (this.removedAvailabilityDates.length > 1) {
                return 'Days';
            } else {
                return 'Day';
            }
        };

        RemovedAvailabilityDates.prototype._pluralizeDates = function () {
            var date;
            date = RG.Utils.BookingDataParser.getDateFromStr(this.removedAvailabilityDates[0]);
            if (this.removedAvailabilityDates.length > 1) {
                return "the following dates so they were skipped: <ul>" + (this._getRemovedAvailabilityDatesListItems()) + "</ul>";
            } else {
                return (RG.Utils.DateFormatter.getLongDateWithYear(date)) + ".";
            }
        };

        RemovedAvailabilityDates.prototype._pluralizeOther = function () {
            if ((this.removedAvailabilityDates.length - 5) > 1) {
                return 'others';
            } else {
                return 'other';
            }
        };

        RemovedAvailabilityDates.prototype._timeOffOrDowntime = function () {
            if (this.resource.isHuman()) {
                return 'time off';
            } else {
                return 'downtime';
            }
        };

        RemovedAvailabilityDates.prototype._getRemovedAvailabilityDates = function () {
            return _.map(this.removedAvailabilityDates, function (wd) {
                return RG.Utils.DateFormatter.getLongDateWithYear(RG.Utils.BookingMerger.getDateFromStr(wd));
            });
        };

        RemovedAvailabilityDates.prototype._getRemovedAvailabilityDatesListItems = function () {
            var dates, formattedDates, visibleDates;
            formattedDates = this._getRemovedAvailabilityDates();
            visibleDates = _.first(formattedDates, 5);
            dates = _.map(visibleDates, function (d) {
                return "<li>" + d + "</li>";
            });
            return dates.join("");
        };

        return RemovedAvailabilityDates;

    })(RG.Views.BaseView);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.Dialogs.ResourceListPopover = (function (superClass) {
        extend(ResourceListPopover, superClass);

        function ResourceListPopover() {
            return ResourceListPopover.__super__.constructor.apply(this, arguments);
        }

        ResourceListPopover.prototype.className = 'resources-list-dropdown';

        ResourceListPopover.prototype._setOpenRight = function () {
            ResourceListPopover.__super__._setOpenRight.apply(this, arguments);
            return this.$el.css({
                left: 425
            });
        };

        ResourceListPopover.prototype._setOpenLeft = function () {
            ResourceListPopover.__super__._setOpenLeft.apply(this, arguments);
            return this.$el.css({
                left: 70
            });
        };

        ResourceListPopover.prototype._getOpenDirection = function () {
            var $window, offset, width, windowRight;
            $window = $(window);
            windowRight = $window.scrollLeft() + $window.width();
            offset = this.$el.offset();
            width = $(this.el.firstChild).outerWidth();
            if (this.openDirection === "left" || windowRight <= offset.left + width + 360) {
                return "left";
            } else {
                return "right";
            }
        };

        ResourceListPopover.prototype.setPosition = function () {
            var shadowArrow;
            ResourceListPopover.__super__.setPosition.apply(this, arguments);
            shadowArrow = this.$(".shadow-arrow");
            return shadowArrow.css({
                top: shadowArrow.position().top + 4
            });
        };

        return ResourceListPopover;

    })(RG.Views.Dialogs.Popover);

    RG.Views.Dialogs.ResourceList = (function (superClass) {
        extend(ResourceList, superClass);

        function ResourceList() {
            return ResourceList.__super__.constructor.apply(this, arguments);
        }

        ResourceList.prototype.tagName = 'main';

        ResourceList.prototype.render = function () {
            var i, len, ref, resource;
            while (this.el.firstChild) {
                this.el.removeChild(this.el.firstChild);
            }
            ref = this.collection.models;
            for (i = 0, len = ref.length; i < len; i++) {
                resource = ref[i];
                this._renderResource(resource);
            }
            return this;
        };

        ResourceList.prototype._renderResource = function (resource) {
            var div, resourceAvatar;
            resourceAvatar = new RG.Views.Resource.Avatar({
                resource: resource
            });
            div = $(document.createElement("div")).addClass("resources-list__resource");
            div.append(resourceAvatar.render().el);
            div.append($(document.createElement("span")).addClass("resources-list__resource-name").text(resource.getName()));
            return this.$el.append(div);
        };

        return ResourceList;

    })(RG.Views.BaseView);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.Dialogs.SingleBookingDetailsActions = (function (superClass) {
        extend(SingleBookingDetailsActions, superClass);

        function SingleBookingDetailsActions() {
            return SingleBookingDetailsActions.__super__.constructor.apply(this, arguments);
        }

        SingleBookingDetailsActions.prototype.tagName = 'ul';

        SingleBookingDetailsActions.prototype.className = 'booking-actions';

        SingleBookingDetailsActions.prototype.template = templates.find('dialogs/booking_details_single_actions');

        SingleBookingDetailsActions.prototype.initialize = function (options) {
            this.booking = options.booking;
            return this.bookingFormFactory = options.bookingFormFactory;
        };

        SingleBookingDetailsActions.prototype.deleteBooking = function () {
            RG.Popovers.clear();
            RG.Utils.BookingService.deleteBooking(this.booking, (function (_this) {
                return function () {
                    return _this.trigger('close');
                };
            })(this));
            return false;
        };

        SingleBookingDetailsActions.prototype.editBooking = function () {
            var view;
            view = this.bookingFormFactory.createEdit({
                booking: this.booking
            });
            this.trigger("changeView", view);
            return false;
        };

        SingleBookingDetailsActions.prototype.render = function () {
            this.$el.html(this.template());
            this._bindEvents();
            return this;
        };

        SingleBookingDetailsActions.prototype._bindEvents = function () {
            this.$el.on("click", "a#edit-booking", (function (_this) {
                return function () {
                    return _this.editBooking();
                };
            })(this));
            return this.$el.on("click", "a#delete-booking", (function (_this) {
                return function () {
                    return _this.deleteBooking();
                };
            })(this));
        };

        return SingleBookingDetailsActions;

    })(RG.Views.BaseView);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.Dialogs.SplitBooking = (function (superClass) {
        extend(SplitBooking, superClass);

        function SplitBooking() {
            return SplitBooking.__super__.constructor.apply(this, arguments);
        }

        SplitBooking.prototype.className = 'calendar-split';

        SplitBooking.prototype.template = templates.find('dialogs/split_booking');

        SplitBooking.prototype.events = {
            "click #split-booking": "splitBooking",
            "click #cancel": "cancel"
        };

        SplitBooking.prototype.initialize = function (options) {
            this.booking = options.booking;
            return this.splitDate = options.splitDate;
        };

        SplitBooking.prototype.cancel = function () {
            return this.trigger('close');
        };

        SplitBooking.prototype.render = function () {
            this.$el.html(this.template());
            this._fillValues();
            return this;
        };

        SplitBooking.prototype.popup = function () {
            this.render();
            return this.$el.modal();
        };

        SplitBooking.prototype.splitBooking = function () {
            var overlay;
            this._disableButtons();
            overlay = RG.Utils.spinnerOverlay($(this.el).closest('.js-edit-booking-popover')[0]);
            RG.Utils.BookingService.split(this.booking, this.splitDate);
            overlay.remove();
            this.trigger('close');
            return false;
        };

        SplitBooking.prototype._disableButtons = function () {
            $("footer button").attr("disabled", "disabled");
            return $("footer #split-booking").text("Busy, please wait...");
        };

        SplitBooking.prototype._fillValues = function () {
            var dr, firstBlock, firstEnd, secondBlock;
            dr = this.booking.getDateRange();
            firstEnd = new Date(this.splitDate.getFullYear(), this.splitDate.getMonth(), this.splitDate.getDate() - 1);
            firstBlock = new RG.Utils.DateRange(dr.startDate, firstEnd);
            secondBlock = new RG.Utils.DateRange(this.splitDate, dr.endDate);
            this.$(".split.block1").text(firstBlock.toString());
            return this.$(".split.block2").text(secondBlock.toString());
        };

        return SplitBooking;

    })(RG.Views.BaseView);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.Dialogs.SplitDowntime = (function (superClass) {
        extend(SplitDowntime, superClass);

        function SplitDowntime() {
            return SplitDowntime.__super__.constructor.apply(this, arguments);
        }

        SplitDowntime.prototype.className = 'calendar-split';

        SplitDowntime.prototype.template = templates.find('dialogs/split_downtime');

        SplitDowntime.prototype.events = {
            "click #split-downtime": "splitDowntime",
            "click #cancel": "cancel"
        };

        SplitDowntime.prototype.initialize = function (options) {
            this.account = options.account;
            this.resources = options.resources;
            this.downtime = options.downtime;
            return this.splitDate = options.splitDate;
        };

        SplitDowntime.prototype.cancel = function () {
            return this.trigger('close');
        };

        SplitDowntime.prototype.render = function () {
            this.$el.html(this.template());
            this._fillValues();
            return this;
        };

        SplitDowntime.prototype.popup = function () {
            this.render();
            return this.$el.modal();
        };

        SplitDowntime.prototype.splitDowntime = function () {
            var overlay;
            this._disableButtons();
            overlay = RG.Utils.spinnerOverlay($(this.el).closest('.js-edit-downtime-popover')[0]);
            RG.Utils.DowntimeService.split(this.downtime, this.splitDate);
            overlay.remove();
            this.trigger('close');
            return false;
        };

        SplitDowntime.prototype._disableButtons = function () {
            $("footer button").attr("disabled", "disabled");
            return $("footer #split-booking").text("Busy, please wait...");
        };

        SplitDowntime.prototype._fillValues = function () {
            var dr, firstBlock, firstEnd, secondBlock;
            dr = this.downtime.getDateRange();
            firstEnd = new Date(this.splitDate.getFullYear(), this.splitDate.getMonth(), this.splitDate.getDate() - 1);
            firstBlock = new RG.Utils.DateRange(dr.startDate, firstEnd);
            secondBlock = new RG.Utils.DateRange(this.splitDate, dr.endDate);
            this.$(".split.block1").text(firstBlock.toString());
            this.$(".split.block2").text(secondBlock.toString());
            if (this._hasHumanResources()) {
                this.$(".js-title-downtime-type").text("Split this series of events into two blocks?");
                return this.$(".js-button-downtime-type").text("Time Off");
            }
        };

        SplitDowntime.prototype._hasHumanResources = function () {
            return this.resources.some(function (r) {
                return r.isHuman();
            });
        };

        return SplitDowntime;

    })(RG.Views.BaseView);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.Dialogs.TagWrapper = (function (superClass) {
        extend(TagWrapper, superClass);

        function TagWrapper() {
            return TagWrapper.__super__.constructor.apply(this, arguments);
        }

        TagWrapper.prototype.initialize = function (options) {
            this.view = options.view;
            this.tagName = options.tagName;
            if (this.view) {
                this.view.on("all", (function (_this) {
                    return function () {
                        return _this.trigger.apply(_this, arguments);
                    };
                })(this));
                return this.el.appendChild(this.view.el);
            }
        };

        TagWrapper.prototype.render = function () {
            var ref;
            if ((ref = this.view) != null) {
                ref.render();
            }
            return this;
        };

        return TagWrapper;

    })(RG.Views.BaseView);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.Dialogs.WaitingListConfirmation = (function (superClass) {
        extend(WaitingListConfirmation, superClass);

        function WaitingListConfirmation() {
            return WaitingListConfirmation.__super__.constructor.apply(this, arguments);
        }

        WaitingListConfirmation.prototype.template = templates.find('dialogs/waiting_list_confirmation');

        WaitingListConfirmation.prototype.initialize = function (options) {
            if (options == null) {
                options = {};
            }
            this.resource = options.resource;
            this.waitingDates = options.waitingDates;
            this.bookingDuration = options.duration;
            this.bookingStartTime = options.startTime;
            this.bookingStartDate = options.startDate;
            this.bookingEndDate = options.endDate;
            this.callback = options.callback;
            return this.cancelCallback = options.cancelCallback;
        };

        WaitingListConfirmation.prototype.render = function () {
            this.$el.html(this.template());
            this._fillValues();
            this._bindEvents();
            return this;
        };

        WaitingListConfirmation.prototype.addWaiting = function () {
            RG.Popovers.locked = false;
            this.callback();
            this.cancelCallback = null;
            return this.trigger('addWaiting');
        };

        WaitingListConfirmation.prototype.cancel = function (e) {
            RG.Popovers.locked = false;
            if (this.cancelCallback) {
                this.cancelCallback();
            }
            return this.trigger('close');
        };

        WaitingListConfirmation.prototype._fillValues = function () {
            var text;
            text = [];
            text.push("<p>Sorry, ");
            text.push("<strong class='booking-clash-resource-name'>" + (this.resource.escape('name')) + "</strong> is not available for that amount of time on " + (this._pluralizeSelectedDates()) + ".");
            if (!RG.Utils.DateComparator.equalsYMD(this.bookingStartDate, this.bookingEndDate)) {
                text.push(" Clashes include:");
                text.push("</p>");
                text.push("<ul>" + (this._getWaitingDatesListItems()) + "</ul>");
                if (this.waitingDates.length > 5) {
                    text.push("<p class='has-margin-left'>... and " + (this.waitingDates.length - 5) + " " + (this._pluralizeOther()) + "</p>");
                }
                text.push(this._goAhead());
                $(".add-waiting").text("Add To Waiting List Where Time Unavailable");
            } else {
                text.push(this._goAhead());
                text.push("</p>");
            }
            return this.$(".js-booking-clash-details").html(text.join(""));
        };

        WaitingListConfirmation.prototype._pluralizeSelectedDates = function () {
            if (RG.Utils.DateComparator.equalsYMD(this.bookingStartDate, this.bookingEndDate)) {
                return "" + (RG.Utils.DateFormatter.getLongDateWithYear(this.bookingStartDate));
            } else {
                return 'all the dates selected';
            }
        };

        WaitingListConfirmation.prototype._pluralizeOther = function () {
            if (this._shouldPluralize()) {
                return 'others';
            } else {
                return 'other';
            }
        };

        WaitingListConfirmation.prototype._pluralizeClashes = function () {
            if (this.waitingDates.length > 1) {
                return 'any clashes';
            } else {
                return 'the clash';
            }
        };

        WaitingListConfirmation.prototype._shouldPluralize = function () {
            return (this.waitingDates.length - 5) > 1;
        };

        WaitingListConfirmation.prototype._goAhead = function () {
            return "<p class='has-margin-top'>You can still go ahead with your booking and add " + (this._pluralizeClashes()) + " to the waiting list.</p>";
        };

        WaitingListConfirmation.prototype._bindEvents = function () {
            this.$el.on("click", ".cancel", (function (_this) {
                return function () {
                    return _this.cancel();
                };
            })(this));
            return this.$el.on("click", ".add-waiting", (function (_this) {
                return function () {
                    return _this.addWaiting();
                };
            })(this));
        };

        WaitingListConfirmation.prototype._getBookingDateRange = function () {
            return (RG.Utils.DateFormatter.getLongDateWithYear(this.bookingStartDate)) + " and " + (RG.Utils.DateFormatter.getLongDateWithYear(this.bookingEndDate));
        };

        WaitingListConfirmation.prototype._getWaitingDates = function () {
            return _.map(this.waitingDates, function (wd) {
                return RG.Utils.DateFormatter.getLongDateWithYear(RG.Utils.BookingMerger.getDateFromStr(wd));
            });
        };

        WaitingListConfirmation.prototype._getWaitingDatesListItems = function () {
            var dates, formattedDates, visibleDates;
            formattedDates = this._getWaitingDates();
            visibleDates = _.first(formattedDates, 5);
            dates = _.map(visibleDates, function (d) {
                return "<li>" + d + "</li>";
            });
            return dates.join("");
        };

        return WaitingListConfirmation;

    })(RG.Views.BaseView);

}).call(this);
;
(function () {
    var bind = function (fn, me) { return function () { return fn.apply(me, arguments); }; },
        extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.Downtimes.ResourceSelector = (function (superClass) {
        extend(ResourceSelector, superClass);

        function ResourceSelector() {
            this._handleFilter = bind(this._handleFilter, this);
            this._handleSelected = bind(this._handleSelected, this);
            return ResourceSelector.__super__.constructor.apply(this, arguments);
        }

        ResourceSelector.prototype.tagName = "div";

        ResourceSelector.prototype.className = "downtime-resource-selector";

        ResourceSelector.prototype.initialize = function (options) {
            this.resources = options.resources;
            this.selected = options.selected || [];
            this.itemClassName = options.itemClassName;
            this.groupClassName = options.groupClassName;
            return this.onChange = options.onChange;
        };

        ResourceSelector.prototype.render = function () {
            this.clear();
            this.selector = window.RGComponents.createMultiselect(this.el, {
                onSelected: this._handleSelected,
                options: this.resources.toArray(),
                placeholder: '',
                selected: this.selected,
                mapper: function (resource) {
                    return resource.get('name');
                },
                groupBy: function (resource) {
                    return resource.get('resourceType').get('name');
                },
                groupBySorter: function (a, b) {
                    if (a === 'Person') {
                        return -1;
                    }
                    if (b === 'Person') {
                        return 1;
                    }
                    return a.localeCompare(b);
                },
                useAggressiveHandler: true,
                itemClassName: this.itemClassName,
                groupClassName: this.groupClassName
            });
            this.filter = window.RGComponents.createResourceFilter(this.el, {
                onSelected: this._handleFilter,
                className: 'multiselect-downtime-filter',
                useAggressiveHandler: true
            });
            return this;
        };

        ResourceSelector.prototype._handleSelected = function (selected) {
            this.selected = selected;
            return this.onChange(selected);
        };

        ResourceSelector.prototype._handleFilter = function (selected) {
            switch (selected) {
                case 'filtered':
                    this.selected = this.resources.filter(function (r) {
                        return r.visible && r.isBookable();
                    });
                    break;
                case 'people':
                    this.selected = this.resources.filter(function (r) {
                        return r.get('resourceType').get('name') === 'Person' && r.isBookable();
                    });
                    break;
                case 'all':
                    this.selected = this.resources.toArray();
                    break;
                case 'none':
                    this.selected = [];
            }
            this.onChange();
            return this.render();
        };

        ResourceSelector.prototype.getResourceIds = function () {
            return this.selected.map(function (resource) {
                return resource.id;
            });
        };

        ResourceSelector.prototype.setFilters = function () { };

        ResourceSelector.prototype.validate = function () {
            return true;
        };

        ResourceSelector.prototype.searchBlur = function () { };

        ResourceSelector.prototype.getSelectedOptions = ResourceSelector.getResourceIds;

        ResourceSelector.prototype.clear = function () {
            var ref, ref1;
            if ((ref = this.selector) != null) {
                ref.destroy();
            }
            return (ref1 = this.filter) != null ? ref1.destroy() : void 0;
        };

        ResourceSelector.prototype.remove = function () {
            return this.clear();
        };

        return ResourceSelector;

    })(RG.Views.BaseView);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.Downtimes.Resources = (function (superClass) {
        extend(Resources, superClass);

        function Resources() {
            return Resources.__super__.constructor.apply(this, arguments);
        }

        Resources.prototype.tagName = "span";

        Resources.prototype.className = "downtime-resource";

        Resources.prototype.events = {
            'click .js-expand-resources': 'expandTruncatedResources'
        };

        Resources.prototype.initialize = function (options) {
            this.resources = options.resources;
            return this.truncate = options.truncate === void 0 ? true : options.truncate;
        };

        Resources.prototype.render = function () {
            while (this.el.firstChild) {
                this.el.removeChild(this.el.firstChild);
            }
            this._renderResources();
            return this;
        };

        Resources.prototype.expandTruncatedResources = function (e) {
            if (this.resourcesPopover == null) {
                this.resourcesPopover = new RG.Views.Dialogs.ResourceListPopover({
                    attachTo: this.$(".js-expand-resources")
                });
            }
            this.resourcesPopover.setBodyView(new RG.Views.Dialogs.ResourceList({
                collection: new RG.Collections.ResourceInstances(this.resources)
            }));
            RG.Popovers.nest(this.resourcesPopover);
            this.resourcesPopover.popup();
            return e.stopPropagation();
        };

        Resources.prototype._renderResources = function () {
            var i, j, len, len1, ref, ref1, resource, resourceNameElement, results;
            if (this.resources.length > 8 && this.truncate) {
                ref = this.resources.slice(0, 9);
                for (i = 0, len = ref.length; i < len; i++) {
                    resource = ref[i];
                    this._renderResource(resource);
                }
                return this._renderTruncatedResourceText();
            } else if (this.resources.length === 1) {
                if (this.resources[0].hasAvatar()) {
                    this._renderResource(this.resources[0]);
                }
                resourceNameElement = $(document.createElement("span")).addClass("resource-name");
                return this.$el.append(resourceNameElement.text(this.resources[0].get('name')));
            } else {
                ref1 = this.resources;
                results = [];
                for (j = 0, len1 = ref1.length; j < len1; j++) {
                    resource = ref1[j];
                    results.push(this._renderResource(resource));
                }
                return results;
            }
        };

        Resources.prototype._renderResource = function (resource) {
            var resourceAvatar;
            resourceAvatar = new RG.Views.Resource.Avatar({
                resource: resource
            });
            return this.$el.append(resourceAvatar.render().el);
        };

        Resources.prototype._renderTruncatedResourceText = function () {
            if (this.resources.length > 9) {
                return this.$el.append("<a class=\"js-expand-resources expand-resources-link\">and " + (this.resources.length - 9) + " more</a>");
            }
        };

        return Resources;

    })(RG.Views.BaseView);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.Filters.Categories = (function (superClass) {
        extend(Categories, superClass);

        function Categories() {
            return Categories.__super__.constructor.apply(this, arguments);
        }

        Categories.prototype.className = "filter__categories";

        Categories.prototype.events = {
            "click .filter__category": "toggleCategory"
        };

        Categories.prototype.addItem = function (model) {
            var view;
            view = Categories.__super__.addItem.apply(this, arguments);
            return view.on("change:filter", (function (_this) {
                return function () {
                    return _this.trigger("change:filter", _this.getSelectedOptions());
                };
            })(this));
        };

        Categories.prototype.clearSelection = function () {
            var cid, ref, results, view;
            ref = this.collectionViews;
            results = [];
            for (cid in ref) {
                view = ref[cid];
                results.push(view.clearSelection());
            }
            return results;
        };

        Categories.prototype.createItemView = function (options) {
            return new RG.Views.Filters.Category({
                category: options.model
            });
        };

        Categories.prototype.getFilters = function () {
            return _.flatten(_.map(this.collectionViews, function (view) {
                return view.getFilters();
            }));
        };

        Categories.prototype.getSelectedOptions = function () {
            return _.flatten(_.map(this.collectionViews, function (v) {
                return v.getSelectedOptions();
            }));
        };

        Categories.prototype.resetFlyouts = function () {
            return this.$(".filter__category").removeClass("is-active");
        };

        Categories.prototype.setFilters = function (filters) {
            var cid, ref, results, view;
            this.clearSelection();
            ref = this.collectionViews;
            results = [];
            for (cid in ref) {
                view = ref[cid];
                results.push(view.setFilters(filters));
            }
            return results;
        };

        Categories.prototype.toggleCategory = function (e) {
            var $filterContainerEl, $filterEl, $originalTarget, $target, isOpen;
            RG.closeSelectedOptions();
            $target = this.$(e.currentTarget);
            $originalTarget = this.$(e.target);
            if ($originalTarget.closest(".filter__category__filters").length > 0) {
                return;
            }
            isOpen = $target.hasClass("is-active");
            this.resetFlyouts();
            $target.toggleClass("is-active", !isOpen);
            $filterEl = $target.find(".filter__category__filters");
            $filterEl.css({
                width: ""
            });
            $filterContainerEl = $filterEl.find("> div");
            $filterContainerEl.css({
                "overflow-y": "",
                "height": "",
                "width": ""
            });
            if ($(window).height() < $filterContainerEl.offset().top + $filterContainerEl.height() - $(window).scrollTop()) {
                $filterContainerEl.outerHeight($(window).height() - $filterContainerEl.offset().top - 25 + $(window).scrollTop()).css({
                    "overflow-y": "scroll"
                });
                $filterContainerEl.width($filterContainerEl.width() + 10);
                $filterEl.width($filterEl.width() + 10);
            }
            this.$(".filter__options-control .select2-search-field:first-child input.select2-input").width("295px");
            return false;
        };

        return Categories;

    })(RG.Support.CollectionView);

}).call(this);
;
(function () {
    var bind = function (fn, me) { return function () { return fn.apply(me, arguments); }; },
        extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.Filters.Category = (function (superClass) {
        extend(Category, superClass);

        function Category() {
            this._triggerChange = bind(this._triggerChange, this);
            return Category.__super__.constructor.apply(this, arguments);
        }

        Category.prototype.template = templates.find('filters/category');

        Category.prototype.className = "filter__category";

        Category.prototype.events = {
            "click .filter__clear": "clearSelection",
            "click .filter__category__filters": "clearInputs"
        };

        Category.prototype.clearSelection = function () {
            var ref, ref1;
            if ((ref = $(".match-type-select.select2-container-active")) != null) {
                if ((ref1 = ref.data('select2')) != null) {
                    ref1.close();
                }
            }
            this.filterCategoryOptionsView.off("change:filter", this._triggerChange);
            this.filterCategoryOptionsView.clearSelection();
            this.filterCategoryOptionsView.on("change:filter", this._triggerChange);
            this.trigger("change:filter");
            return false;
        };

        Category.prototype.clearInputs = function (e) {
            return RG.Utils.select2Close();
        };

        Category.prototype.getFilters = function () {
            return this.filterCategoryOptionsView.getFilters();
        };

        Category.prototype.getSelectedOptions = function () {
            var ref;
            return ((ref = this.filterCategoryOptionsView) != null ? ref.getSelectedOptions() : void 0) || [];
        };

        Category.prototype.initialize = function (options) {
            this.category = options.category;
            return this.on("change:filter", this.refreshSelectedOptionsView, this);
        };

        Category.prototype.refreshSelectedOptionsView = function () {
            var options;
            options = this.getSelectedOptions();
            this.selectedOptionsView.setSelectedOptions(options);
            return this.$(".filter__clear").toggle(options.length > 0);
        };

        Category.prototype.render = function () {
            this.$el.html(this.template());
            this._fillValues();
            return this;
        };

        Category.prototype.setFilters = function (filters) {
            return this.filterCategoryOptionsView.setFilters(filters);
        };

        Category.prototype.showOptionsFlyout = function () {
            return this.$el.addClass("is-active");
        };

        Category.prototype.hideOptionsFlyout = function () {
            return this.$el.removeClass("is-active");
        };

        Category.prototype._getFilterCategoryOptionsElement = function () {
            return this.$(".filter__category__filters");
        };

        Category.prototype._getSelectedOptionsElement = function () {
            return this.$(".filter__category--selected-options");
        };

        Category.prototype._fillValues = function () {
            this.$(".filter__category--name").text(this.category.get('name'));
            this.filterCategoryOptionsView = new RG.Views.Filters.CategoryOptions({
                category: this.category
            });
            this.filterCategoryOptionsView.on("change:filter", this._triggerChange);
            this.selectedOptionsView = new RG.Views.Filters.SelectedOptions();
            this._getSelectedOptionsElement().replaceWith(this.selectedOptionsView.render().el);
            this.refreshSelectedOptionsView();
            return this._getFilterCategoryOptionsElement().replaceWith(this.filterCategoryOptionsView.render().el);
        };

        Category.prototype._triggerChange = function () {
            return this.trigger("change:filter", this.getSelectedOptions());
        };

        return Category;

    })(RG.Views.BaseView);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.Filters.CategoryOptions = (function (superClass) {
        extend(CategoryOptions, superClass);

        function CategoryOptions() {
            return CategoryOptions.__super__.constructor.apply(this, arguments);
        }

        CategoryOptions.prototype.template = templates.find('filters/category_options');

        CategoryOptions.prototype.className = 'filter__category__filters';

        CategoryOptions.prototype.events = {
            "click .filter__options--all": "toggleSelectAll"
        };

        CategoryOptions.prototype.clearSelection = function () {
            this.filterOptionGroupsView.clearSelection();
            if (this._selectAllOption) {
                return this.toggleSelectAll();
            }
        };

        CategoryOptions.prototype.getFilters = function () {
            var options;
            options = _.map(this.filterOptionGroupsView.collectionViews, function (view) {
                return view.getOptions();
            });
            if (!this._selectAllOption) {
                return {
                    categoryName: this.category.getName(),
                    options: options
                };
            } else {
                return {
                    categoryName: this.category.getName(),
                    mode: "all",
                    options: options
                };
            }
        };

        CategoryOptions.prototype.getSelectedOptions = function () {
            var ref;
            if (!this._selectAllOption) {
                return (ref = this.filterOptionGroupsView) != null ? ref.getSelectedOptions() : void 0;
            } else {
                return [
                    {
                        matchType: "all",
                        resourceType: this.category.get('tag')
                    }
                ];
            }
        };

        CategoryOptions.prototype.initialize = function (options) {
            this._selectAllOption = false;
            return this.category = options.category;
        };

        CategoryOptions.prototype.render = function () {
            this.$el.html(this.template({
                tooltip: this._mustRenderTooltip()
            }));
            this._fillValues();
            this.$('.filter__info-tooltip').tooltip();
            return this;
        };

        CategoryOptions.prototype.setFilters = function (filters) {
            var cid, filter, i, len, results, view;
            results = [];
            for (i = 0, len = filters.length; i < len; i++) {
                filter = filters[i];
                if (this.category.get('name') === filter.categoryName) {
                    if (filter.mode === "all") {
                        this._selectAllOption = false;
                        results.push(this.toggleSelectAll());
                    } else {
                        if (this._selectAllOption) {
                            this.toggleSelectAll();
                        }
                        results.push((function () {
                            var ref, results1;
                            ref = this.filterOptionGroupsView.collectionViews;
                            results1 = [];
                            for (cid in ref) {
                                view = ref[cid];
                                results1.push(view.setFilters(filters));
                            }
                            return results1;
                        }).call(this));
                    }
                }
            }
            return results;
        };

        CategoryOptions.prototype.toggleSelectAll = function (e) {
            this._selectAllOption = !this._selectAllOption;
            this.filterOptionGroupsView.$el.toggle(!this._selectAllOption);
            this._getResetSpan().toggle(this._selectAllOption);
            this._getSelectAllSpan().toggle(!this._selectAllOption);
            this.$el.toggleClass("is-select-all", this._selectAllOption);
            return this.trigger("change:filter", this.getSelectedOptions());
        };

        CategoryOptions.prototype._fillValues = function () {
            this.$("h3").text(this.category.getName());
            this.filterOptionGroupsView = new RG.Views.Filters.OptionGroups({
                category_type: this.category.getName(),
                collection: this.category.optionGroups
            });
            this.filterOptionGroupsView.on("change:filter", (function (_this) {
                return function (e) {
                    return _this.trigger("change:filter", _this.getSelectedOptions());
                };
            })(this));
            this._getFilterOptionsElement().replaceWith(this.filterOptionGroupsView.render().el);
            return this.$(".filter__options--all").toggle(this._mustRenderAllToggle());
        };

        CategoryOptions.prototype._getFilterOptionsElement = function () {
            return this.$(".filter__options");
        };

        CategoryOptions.prototype._getResetSpan = function () {
            return this.$(".reset-select-all-filters");
        };

        CategoryOptions.prototype._getSelectAllSpan = function () {
            return this.$(".select-all-filters");
        };

        CategoryOptions.prototype._mustRenderAllToggle = function () {
            return ["Projects", "Clients"].indexOf(this.category.getName()) === -1;
        };

        CategoryOptions.prototype._mustRenderTooltip = function () {
            return ["Projects", "Clients"].indexOf(this.category.getName()) === -1;
        };

        return CategoryOptions;

    })(RG.Views.BaseView);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.Filters.OptionGroups = (function (superClass) {
        extend(OptionGroups, superClass);

        function OptionGroups(options) {
            OptionGroups.__super__.constructor.apply(this, arguments);
            this.category_type = options.category_type;
        }

        OptionGroups.prototype.createItemView = function (options) {
            return new RG.Views.Filters.OptionGroup({
                optionGroup: options.model
            });
        };

        OptionGroups.prototype.addItem = function (model) {
            var view;
            view = OptionGroups.__super__.addItem.apply(this, arguments);
            return view.on("change:filter", (function (_this) {
                return function (e) {
                    return _this.trigger("change:filter", _this.getSelectedOptions());
                };
            })(this));
        };

        OptionGroups.prototype.clearSelection = function () {
            var cid, ref, results, view;
            ref = this.collectionViews;
            results = [];
            for (cid in ref) {
                view = ref[cid];
                results.push(view.clearSelection());
            }
            return results;
        };

        OptionGroups.prototype.getSelectedOptions = function () {
            return _.compact(_.flatten(_.map(this.collectionViews, function (v) {
                return v.getSelectedOptions();
            })));
        };

        return OptionGroups;

    })(RG.Support.CollectionView);

}).call(this);
;
(function () {
    var bind = function (fn, me) { return function () { return fn.apply(me, arguments); }; },
        extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.Filters.SavedFilter = (function (superClass) {
        extend(SavedFilter, superClass);

        function SavedFilter() {
            this._handleInputKeyDown = bind(this._handleInputKeyDown, this);
            return SavedFilter.__super__.constructor.apply(this, arguments);
        }

        SavedFilter.prototype.template = templates.find('filters/saved_filter');

        SavedFilter.prototype.className = "filter__saved-filter";

        SavedFilter.prototype.events = {
            "click": "activateFilter",
            "click .delete-filter": "deleteFilter",
            "click .rename-filter": "enableRename",
            "click .save-rename-filter": "_saveRename",
            "blur .filter__saved-filter-input": "_saveRename",
            "keypress": "_handleInputKeyDown"
        };

        SavedFilter.prototype.initialize = function (options) {
            this.savedFilter = options.savedFilter;
            return this.listenTo(this.savedFilter, "change", this.render);
        };

        SavedFilter.prototype.activateFilter = function (e) {
            var ref, ref1;
            if ((ref = $(".match-type-select.select2-container-active")) != null) {
                if ((ref1 = ref.data('select2')) != null) {
                    ref1.close();
                }
            }
            this.trigger("activate:filter", this.savedFilter);
            return false;
        };

        SavedFilter.prototype.addActiveState = function () {
            return this.$el.addClass("is-active");
        };

        SavedFilter.prototype.deleteFilter = function (e) {
            var ref, ref1;
            if ((ref = $(".match-type-select.select2-container-active")) != null) {
                if ((ref1 = ref.data('select2')) != null) {
                    ref1.close();
                }
            }
            this.savedFilter.destroy();
            return false;
        };

        SavedFilter.prototype.disableRename = function () {
            setTimeout((function (_this) {
                return function () {
                    return $(document).off("keyup", _this._handleInputKeyDown);
                };
            })(this), 100);
            this.$(".filter__saved-filter-name").show();
            this.$(".filter__saved-filter-input").hide();
            this.$(".save-rename-filter").hide();
            this.$(".rename-filter").show();
            return this.$el.removeClass("is-editing");
        };

        SavedFilter.prototype.enableRename = function () {
            var ref, ref1;
            $(document).on("keyup", this._handleInputKeyDown);
            if ((ref = $(".match-type-select.select2-container-active")) != null) {
                if ((ref1 = ref.data('select2')) != null) {
                    ref1.close();
                }
            }
            this.$(".filter__saved-filter-input").show().focus().select();
            this.$(".filter__saved-filter-name").hide();
            this.$(".save-rename-filter").show();
            this.$(".rename-filter").hide();
            return this.$el.addClass("is-editing");
        };

        SavedFilter.prototype.render = function () {
            this.$el.html(this.template());
            this._fillValues();
            return this;
        };

        SavedFilter.prototype._fillValues = function () {
            this.$(".filter__saved-filter-name").text(this.savedFilter.get('name'));
            return this.$(".filter__saved-filter-input").val(this.savedFilter.get('name'));
        };

        SavedFilter.prototype._getName = function () {
            return this.$(".filter__saved-filter-input").val();
        };

        SavedFilter.prototype._handleInputKeyDown = function (e) {
            if (e.keyCode === 13) {
                return this._saveRename();
            } else if (e.keyCode === 27) {
                return this._cancelRename();
            }
        };

        SavedFilter.prototype._saveRename = function () {
            return setTimeout((function (_this) {
                return function () {
                    var isDuplicate;
                    isDuplicate = window.savedFilters.any(function (sf) {
                        var ref;
                        return ((ref = sf.get('name')) != null ? ref.toLowerCase() : void 0) === _this._getName().toLowerCase();
                    });
                    if (_this._getName().length > 0 && !isDuplicate) {
                        if (_this.savedFilter.get('name') !== _this._getName()) {
                            _this.savedFilter.set('name', _this._getName());
                            _this.savedFilter.save();
                        }
                        return _this.disableRename();
                    } else {
                        return _this._cancelRename();
                    }
                };
            })(this), 100);
        };

        SavedFilter.prototype._cancelRename = function () {
            this.$el.removeClass("is-editing");
            return this.render();
        };

        return SavedFilter;

    })(RG.Views.BaseView);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.Filters.SavedFilters = (function (superClass) {
        extend(SavedFilters, superClass);

        function SavedFilters() {
            return SavedFilters.__super__.constructor.apply(this, arguments);
        }

        SavedFilters.prototype.className = "filter__saved-filter-list";

        SavedFilters.prototype.initialize = function (options) {
            SavedFilters.__super__.initialize.apply(this, arguments);
            return this.listenTo(this.collection, "sort", (function (_this) {
                return function () {
                    return _this.render();
                };
            })(this));
        };

        SavedFilters.prototype.activateFilter = function (savedFilter) {
            return this.collectionViews[savedFilter.cid].activateFilter();
        };

        SavedFilters.prototype.createItemView = function (options) {
            var lastActiveFilterId, view;
            view = new RG.Views.Filters.SavedFilter({
                savedFilter: options.model
            });
            view.on("activate:filter", (function (_this) {
                return function (savedFilter) {
                    _this.trigger("activate:filter", savedFilter);
                    _this.removeActiveState();
                    return view.addActiveState();
                };
            })(this));
            lastActiveFilterId = window.rgStorage.get('lastActiveFilterId');
            if (lastActiveFilterId && parseInt(lastActiveFilterId, 10) === options.model.id) {
                view.addActiveState();
            }
            return view;
        };

        SavedFilters.prototype.removeActiveState = function () {
            return this.$(".is-active").removeClass("is-active");
        };

        return SavedFilters;

    })(RG.Support.SortedCollectionView);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.Filters.SelectedOptions = (function (superClass) {
        extend(SelectedOptions, superClass);

        function SelectedOptions() {
            return SelectedOptions.__super__.constructor.apply(this, arguments);
        }

        SelectedOptions.prototype.template = templates.find('filters/selected_options_summary');

        SelectedOptions.prototype.selectedAllTemplate = templates.find('filters/selected_options_summary_all');

        SelectedOptions.prototype.className = "filter__category--selected-options";

        SelectedOptions.prototype.initialize = function () {
            return this.ast = [];
        };

        SelectedOptions.prototype.render = function () {
            if (this._hasSelectedAll()) {
                this.$el.html(this.selectedAllTemplate());
            } else {
                this.$el.html(this.template({
                    collection: this._createViewModel()
                }));
            }
            return this;
        };

        SelectedOptions.prototype.setSelectedOptions = function (ast) {
            this.ast = ast;
            return this.render();
        };

        SelectedOptions.prototype._createViewModel = function () {
            return _.map(this.ast, function (group) {
                return {
                    name: group.optionGroup.get('name'),
                    matchType: group.matchType,
                    selectedOptions: _.map(group.selectedOptions, function (x) {
                        return x.get('name');
                    }).join("&nbsp;|&nbsp;")
                };
            });
        };

        SelectedOptions.prototype._hasSelectedAll = function () {
            return this.ast.length > 0 && this.ast[0].matchType === "all" && !this.ast[0].selectedOptions;
        };

        return SelectedOptions;

    })(RG.Views.BaseView);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.Resource.AvailableMinutes = (function (superClass) {
        extend(AvailableMinutes, superClass);

        function AvailableMinutes() {
            return AvailableMinutes.__super__.constructor.apply(this, arguments);
        }

        // AvailableMinutes.prototype.className = 'time-available';

        AvailableMinutes.prototype.initialize = function (options) {
            return this.availableMinutes = options.availableMinutes;
        };

        AvailableMinutes.prototype.render = function () {
            var availableFormatted;
            availableFormatted = RG.Utils.TimeFormatter.formatMinutes(this.availableMinutes);
            //this.el.innerHTML = availableFormatted + "<div class=\"time-available-linebreak\"></div>free";
            return this;
        };

        return AvailableMinutes;

    })(RG.Views.BaseView);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.Resource.Avatar = (function (superClass) {
        extend(Avatar, superClass);

        function Avatar() {
            return Avatar.__super__.constructor.apply(this, arguments);
        }

        Avatar.prototype.tagName = "span";

        Avatar.prototype.className = "booking-avatar";

        Avatar.prototype.initialize = function (options) {
            return this.resource = options.resource;
        };

        Avatar.prototype.render = function () {
            var avatarTag;
            avatarTag = this._avatarTag();
            avatarTag.attr('title', this.resource.get('name'));
            this.$el.append(avatarTag);
            return this;
        };

        Avatar.prototype._avatarTag = function () {
            if (this.resource.hasAvatar()) {
                return $(document.createElement('img')).attr('src', this.resource.get('imageUrl'));
            }
            return $(document.createElement('span')).addClass("resource-initials").text(this.resource.getInitials());
        };

        return Avatar;

    })(RG.Views.BaseView);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.Resource.Booking = (function (superClass) {
        extend(Booking, superClass);

        function Booking() {
            return Booking.__super__.constructor.apply(this, arguments);
        }

        Booking.prototype.className = 'booking';

        Booking.prototype.events = {
            'click': 'showDetailsPopup',
            'mousemove': 'showAvailability',
            'mouseenter': 'applyHover',
            'mouseleave': 'removeHover'
        };

        Booking.prototype.initialize = function (options) {
            var ref, ref1;
            this.availability = options.availability;
            this.unit = options.unit;
            this.waiting = options.waiting;
            this.bookingFormFactory = options.bookingFormFactory;
            this.currentUserId = this.bookingFormFactory.currentUserId;
            this.prevHoverDate = null;
            this._colorSource = options.colorSource;
            this._dateController = options.dateController;
            this.resource = (ref = this.model.realBooking) != null ? (ref1 = ref.collection) != null ? ref1.resource : void 0 : void 0;
        };

        Booking.prototype._ensureElement = function () {
            var el;
            if (!this.el) {
                el = document.createElement("div");
                el.className = this.className;
                this.el = el;
            }
            this.$el = $(this.el);
            return this.delegateEvents();
        };

        Booking.prototype.id = function () {
            if (this.model.id) {
                return this.model.cid;
            } else {
                return this.model.getDraggingId();
            }
        };

        Booking.prototype.applyHover = function (e) {
            this.prevHoverDate = null;
            $("#calendar .booking[data-booking-id=" + this.model.id + "]").addClass('hover');
            window.requestAnimationFrame((function (_this) {
                return function () {
                    return _this.el.classList.add('hover');
                };
            })(this));
            this._attachEvents();
        };

        Booking.prototype.hideAvailability = function (e) {
            this.timeUnitUnderlayElement.removeClass('hover');
        };

        Booking.prototype.showAvailability = function (e) {
            var duration, element;
            duration = this._getUnitDurationAtOffset(e.pageX - this.$el.offset().left);
            if (duration && this.prevHoverDate !== duration.get('date')) {
                this.prevHoverDate = duration.get('date');
                if (!this.model.collection || !this.model.collection.resource) {
                    return;
                }
                element = document.querySelector("#" + (RG.Utils.generateTimeUnitId(this.model.collection.resource.cid, duration.attributes.date)));
                RG.setHoverElement(element);
            }
        };

        Booking.prototype.removeHover = function () {
            $("#calendar .booking[data-booking-id=" + this.model.id + "]").removeClass('hover');
        };

        Booking.prototype.remove = function () {
            var ref;
            if ((ref = this.durationBlocksView) != null) {
                ref.remove();
            }
            Booking.__super__.remove.apply(this, arguments);
        };

        Booking.prototype.render = function () {
            this._fillValues();
            return this;
        };

        Booking.prototype.showDetailsPopup = function (e) {
            var bookingAnchor, factory, placer, selectedDuration;
            if (!this.model.id || this.isInInteraction) {
                return;
            }
            RG.Popovers.clear();
            placer = new RG.Utils.BookingPopoverPlacer(e);
            bookingAnchor = placer.createAnchor({
                className: 'booking-detail-anchor'
            });
            selectedDuration = this.getDurationAtOffset(e.pageX - $(this.el).offset().left);
            factory = new RG.Views.Dialogs.BookingPopoverFactory({
                bookingFormFactory: this.bookingFormFactory,
                popoverType: 'details',
                booking: this.model.realBooking,
                duration: selectedDuration,
                bookingAnchor: bookingAnchor
            });
            RG.Popovers.set(factory.popover());
        };

        Booking.prototype._attachEvents = function () {
            if (this.hasAttachedEvents) {
                return;
            }
            if (RG.Utils.Permissions.canManage(this.model)) {
                this._attachDragAndDrop();
            }
            if (RG.Utils.Permissions.canManage(this.model) && !this.waiting && !this.model.get('saving')) {
                this._attachResizable();
            }
            this.hasAttachedEvents = true;
        };

        Booking.prototype._detachEvents = function () {
            var ref, ref1;
            if ((ref = this.dragDrop) != null) {
                ref.detach();
            }
            if ((ref1 = this.resize) != null) {
                ref1.detach();
            }
            this.dragDrop = null;
            this.resize = null;
        };

        Booking.prototype._attachDragAndDrop = function () {
            if (!this.dragDrop) {
                this.dragDrop = new RG.Interactions.DragDropBooking(this);
                this.dragDrop.attach();
            }
        };

        Booking.prototype._attachResizable = function () {
            if (!this.resize) {
                this.resize = new RG.Interactions.ResizeBooking(this);
                this.resize.attach();
            }
        };

        Booking.prototype.getDurationAtOffset = function (offset) {
            var unitDuration;
            unitDuration = this._getUnitDurationAtOffset(offset);
            if (unitDuration) {
                return this.model.durations.find(function (d) {
                    return RG.Utils.DateComparator.equalsYMD(d.attributes.date, unitDuration.attributes.date);
                });
            } else {
                if (offset < 0) {
                    return (this._unitDurations.filter(function (d) {
                        return d.get("minutes") !== 0;
                    }))[0];
                }
                offset = offset - RG.getUnitWidth();
                return this.getDurationAtOffset(offset);
            }
        };

        Booking.prototype._getUnitDurationAtOffset = function (offset) {
            return this._unitDurations[Math.floor(offset / RG.getUnitWidth())];
        };

        Booking.prototype._fillValues = function () {
            this._setOwnerFlag();
            this._setDurations();
            this._setCaptions();
            this._setIdAttribute();
            this.resizeWidth();
            this._setStickyClass();
        };

        Booking.prototype._getLabelTopPosition = function () {
            var lineCount;
            lineCount = Math.ceil(this.model.getFirstNonZeroDuration().getMinutes() / this.unit.getMinutesPerUtilisationLine());
            return (lineCount * 6) + 2;
        };

        Booking.prototype._isTransientInvalidated = function () {
            return this.model.transient && this.model.getDateRange().startDate.valueOf() > this._dateController._startDate().valueOf();
        };

        Booking.prototype.rerenderIfOverExtends = function () {
            if (this._isTransientInvalidated()) {
                this.remove();
            }
            this.resizeWidth();
            this._setDurations();
        };

        Booking.prototype.resizeWidth = function () {
            var dateRange, getNumberOfDays, lastDate, width;
            dateRange = this.model.transient ? this.model.realBooking.getDateRange() : this.model.getDateRange();
            lastDate = this._dateController._endDate();
            if (dateRange.endDate.getTime() > lastDate.getTime()) {
                dateRange.endDate = lastDate;
                this.el.classList.add("no-end");
            } else {
                this.el.classList.remove("no-end");
            }
            if (this.model.transient) {
                dateRange.startDate = this._dateController._startDate();
                this.el.classList.add("no-begin");
            }
            getNumberOfDays = dateRange.getNumberOfDays();
            width = ((RG.getUnitWidth() * getNumberOfDays / this.unit.getDaysPerUnit()) + 1) + "px";
            this.el.style.width = width;
        };

        Booking.prototype._getCaptionElements = function () {
            var dailyLabel, detailedLabel, labelTop, refreshableImage, savingElement;
            refreshableImage = "";
            savingElement = "";
            if (this.model.get('refreshable')) {
                refreshableImage = '<img src="/assets/flag-detailed.png"></img>';
            }
            if (this.model.get('saving')) {
                savingElement = this._getSpinnerElement();
            }
            labelTop = this._getLabelTopPosition() + "px";
            dailyLabel = document.createElement("div");
            dailyLabel.className = "label daily";
            dailyLabel.style.top = labelTop;
            dailyLabel.innerHTML = [savingElement, refreshableImage, this.model.getCaption()].join("");
            detailedLabel = document.createElement("div");
            detailedLabel.className = "label detailed";
            detailedLabel.style.top = labelTop;
            detailedLabel.innerHTML = [savingElement, refreshableImage, this.model.getLongCaption()].join("");
            return [detailedLabel, dailyLabel];
        };

        Booking.prototype._getSpinnerElement = function () {
            return '<img src="/assets/calendar/ajax-loader.gif">';
        };

        Booking.prototype._getBookingResource = function () {
            return this.resource;
        };

        Booking.prototype._removeOldCaptions = function () {
            var i, label, len, ref, ref1;
            ref = this.el.querySelectorAll(".label");
            for (i = 0, len = ref.length; i < len; i++) {
                label = ref[i];
                if ((ref1 = label.parentElement) != null) {
                    ref1.removeChild(label);
                }
            }
        };

        Booking.prototype._setColor = function () {
            var color;
            color = this._colorSource.getColorForBooking(this.model);
            this._unitDurations.forEach(function (d) {
                return d.attributes.color = color;
            });
            this.$el.css("border-color", color.getBorderColor());
            this.$el.css("background-color", color.getBackgroundColor());
            this.$el.css("color", color.getTextColor());
        };

        Booking.prototype.resetColor = function () {
            this._setColor();
            return this._renderDurations();
        };

        Booking.prototype._setCaptions = function () {
            var element, i, len, ref;
            this._removeOldCaptions();
            this.el.setAttribute("title", _.unescape(this.model.getTitleCaption()));
            ref = this._getCaptionElements();
            for (i = 0, len = ref.length; i < len; i++) {
                element = ref[i];
                this.el.appendChild(element);
            }
        };

        Booking.prototype._setDurations = function () {
            var bookingDateRange, converter, durations, firstDate, lastDate;
            converter = new RG.Utils.UnitDurationConverter(this.unit.constructor);
            durations = this.model.durations.models;
            bookingDateRange = this.model.getDateRange();
            firstDate = bookingDateRange.startDate;
            lastDate = _.min([this._dateController._endDate(), bookingDateRange.endDate], function (d) {
                return d;
            });
            if (this.model.transient) {
                firstDate = this._dateController._startDate();
            }
            this._unitDurations = converter.convertArray(durations, firstDate, lastDate);
            this.resetColor();
        };

        Booking.prototype._renderDurations = function () {
            var blocksEl, ref;
            if ((ref = this.durationBlocksView) != null) {
                ref.remove();
            }
            blocksEl = document.createElement("div");
            blocksEl.className = "blocks";
            this.durationBlocksView = new RG.Views.Resource.UnitDurationBlocks({
                collection: this._unitDurations,
                unit: this.unit
            });
            this.durationBlocksView.el = blocksEl;
            this.durationBlocksView.render();
            if (blocksEl.parentNode !== this.el) {
                this.el.appendChild(blocksEl);
            }
        };

        Booking.prototype._setIdAttribute = function () {
            this.el.setAttribute('data-booking-id', this.model.id);
        };

        Booking.prototype._setOwnerFlag = function () {
            var ref;
            if (((ref = this.model.get('booker')) != null ? ref.id : void 0) === this.currentUserId) {
                this.el.classList.add("mine");
            }
        };

        Booking.prototype._setStickyClass = function () {
            if (!this.model.singleDayBooking()) {
                this.el.classList.add('sticky');
            }
        };

        Booking.prototype._stopPropagation = function (e) {
            if (typeof e.stopPropagation === "function") {
                e.stopPropagation();
            }
            e.cancelBubble = true;
        };

        return Booking;

    })(RG.Views.BaseView);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.Resource.TimeUnit = (function (superClass) {
        extend(TimeUnit, superClass);

        function TimeUnit() {
            return TimeUnit.__super__.constructor.apply(this, arguments);
        }

        TimeUnit.prototype.className = 'resources--cal-unit';

        TimeUnit.prototype.events = {
            "mouseenter": "showAvailability"
        };

        TimeUnit.prototype.baseUtilisationHeight = 14;

        TimeUnit.prototype.utilLineMultiplier = 11;

        TimeUnit.prototype._ensureElement = function () {
            var el;
            if (!this.el) {
                el = document.createElement("div");
                el.className = this.className;
                this.el = el;
            }
            this.$el = $(this.el);
            return this.delegateEvents();
        };

        TimeUnit.prototype.initialize = function (options) {
            this._waitingListViews = [];
            this.resource = options.resource;
            this._bookingFormDialogFactory = options.bookingFormDialogFactory;
            this._downtimeFormDialogFactory = options.downtimeFormDialogFactory;
            this.colorSource = options.colorSource;
            this.dateController = options.dateController;
            this.currentDate = options.currentDate || new RG.Models.CurrentDate(RG.Utils.getTodayISO());
            this.availabilityToggle = options.availabilityToggle;
            this.resourceLine = options.resourceLine;
            this.renderedBookings = {};
        };

        TimeUnit.prototype.resetColor = function () {
            if (this._bookingsView) {
                this._bookingsView.resetColor();
            }
            return this._waitingListViews.forEach(function (view) {
                return view.resetColor();
            });
        };

        TimeUnit.prototype.refreshInRange = function (range) {
            if (range.overlapsWith(this.model.getDateRange())) {
                return this.rerender();
            }
        };

        TimeUnit.prototype.bookingChanged = function (booking) {
            var originalBooking;
            if (!booking) {
                return;
            }
            if (this.model.getDateRange().overlapsWith(booking.getSavedDateRange()) || this.model.getDateRange().overlapsWith(new RG.Models.Booking(booking.previousAttributes()).getSavedDateRange())) {
                originalBooking = this.renderedBookings[booking.id];
                if (originalBooking && originalBooking.deepEqual(booking)) {
                    return;
                }
                return this.rerender();
            }
        };

        TimeUnit.prototype.resizeTimeAllocationWidths = function () {
            if (this._bookingsView) {
                this._bookingsView.resizeWidth();
            }
            return this._waitingListViews.forEach(function (view) {
                return view.resizeWidth();
            });
        };

        TimeUnit.prototype.rerenderIfTimeAllocationsOverextend = function () {
            if (this._bookingsView) {
                this._bookingsView.rerenderIfOverExtends();
            }
            return this._waitingListViews.forEach(function (view) {
                return view.rerenderIfOverExtends();
            });
        };

        TimeUnit.prototype.remove = function () {
            this.clearSubviews();
            this.undelegateEvents();
            this.stopListening();
            return TimeUnit.__super__.remove.apply(this, arguments);
        };

        TimeUnit.prototype.clearSubviews = function () {
            var ref, ref1;
            if ((ref = this._availableMinutesView) != null) {
                ref.remove();
            }
            if ((ref1 = this._utilisationView) != null) {
                ref1.remove();
            }
            this._removeExistingDowntimesView();
            this._removeExistingBookingsView();
            this._removeExistingWaitingListView();
        };

        TimeUnit.prototype.render = function () {
            RG.backburner.deferOnce('render', this, this._render);
            RG.backburner.debounce('renderCheck', RG.Utils.renderChecker, 500);
            return this;
        };

        TimeUnit.prototype.rerender = function () {
            this.render();
            return this.rerenderIfTimeAllocationsOverextend();
        };

        TimeUnit.prototype._getDate = function () {
            return RG.Utils.BookingDataParser.getDateFromStr(this.currentDate.date);
        };

        TimeUnit.prototype._render = function () {
            if (this.isRendered) {
                this.clearSubviews();
            }
            if (RG.Utils.DateComparator.equalsYMD(this.model.date, this._getDate())) {
                this.el.className = 'resources--cal-unit current';
            } else {
                this.el.className = 'resources--cal-unit';
            }
            this.bookingsEl = document.createElement("div");
            this.bookingsEl.className = "bookings";
            this.utilisationEl = document.createElement("div");
            this.utilisationEl.className = "utilisation";
            this.availableMinutesEl = document.createElement("div");
            this.availableMinutesEl.className = "time-available";
            this._setId();
            this._renderBookings();
            this.renderUtilisationAndAvailableMinutes();
            this._renderWaitingList();
            this._setAvailability();
            this._setDateAttribute();
            this.appendChildElements();
            RG.Utils.delayResizeCards();
            this.isRendered = true;
            return this;
        };

        TimeUnit.prototype.appendChildElements = function () {
            if (this.availabilityToggle.shouldRenderUtilisation()) {
                this.el.appendChild(this.utilisationEl);
                if (this.bookingsEl.firstChild) {
                    this.el.appendChild(this.bookingsEl);
                }
            } else {
                if (this.bookingsEl.firstChild) {
                    this.el.appendChild(this.bookingsEl);
                }
                this.el.appendChild(this.availableMinutesEl);
            }
        };

        TimeUnit.prototype.renderUtilisationAndAvailableMinutes = function () {
            if (this.availabilityToggle.shouldRenderUtilisation()) {
                this.renderUtilisation();
            } else {
                this.renderAvailableMinutes();
            }
        };

        TimeUnit.prototype._reRenderBookings = function () {
            if (this.model.containsDate(this.dateController._startDate())) {
                this.render();
            }
        };

        TimeUnit.prototype.showAvailability = function (e) {
            RG.setHoverElement(this.el);
        };

        TimeUnit.prototype._addAnchorDuration = function (booking, durations) {
            var duration;
            duration = new RG.Models.Duration({
                date: this.model.date,
                minutes: 0,
                waiting: false
            });
            duration.collection = booking.durations;
            durations.unshift(duration);
            return durations;
        };

        TimeUnit.prototype._calcDurationsForUnit = function () {
            var b, bookings, d, durations, i, j, len, len1, noDurationForDate, ref;
            bookings = this.resource.bookings.forDate(this.model.date);
            durations = [];
            for (i = 0, len = bookings.length; i < len; i++) {
                b = bookings[i];
                noDurationForDate = true;
                ref = b.durations.models;
                for (j = 0, len1 = ref.length; j < len1; j++) {
                    d = ref[j];
                    if (this.model.containsDate(d.attributes.date)) {
                        noDurationForDate = false;
                        durations.push(d);
                    }
                }
                if (noDurationForDate) {
                    this._addAnchorDuration(b, durations);
                }
            }
            return durations;
        };

        TimeUnit.prototype._getBookingDurationsForUnit = function () {
            if (this._durationsForUnit) {
                return this._durationsForUnit;
            }
            return this._durationsForUnit = this._calcDurationsForUnit();
        };

        TimeUnit.prototype._getEarlierStartedBookings = function () {
            var b, bookings, dateController, earlierBookings, eb, i, len, rangeDurations, startDate;
            dateController = this.dateController;
            earlierBookings = [];
            startDate = dateController._startDate();
            bookings = this.resource.bookings.overlapsDate(startDate);
            for (i = 0, len = bookings.length; i < len; i++) {
                b = bookings[i];
                rangeDurations = b.durations.betweenDates(startDate, dateController._endDate());
                if (rangeDurations.length) {
                    eb = b.clone();
                    eb.layer = b.layer;
                    eb.realBooking = b;
                    eb.transient = true;
                    eb.durations.reset(rangeDurations);
                    eb.collection = {
                        resource: this.resource,
                        remove: function () { }
                    };
                    earlierBookings.push(eb);
                }
            }
            return earlierBookings;
        };

        TimeUnit.prototype._getBookingsForUnit = function () {
            var bookings, earlierBookings;
            earlierBookings = [];
            if (this.model.containsDate(this.dateController._startDate())) {
                earlierBookings = this._getEarlierStartedBookings();
            }
            bookings = this.resource.bookings.startsOnDate(this.model.date);
            return new RG.Collections.Bookings([].concat(earlierBookings, bookings));
        };

        TimeUnit.prototype._getDowntimeDurationsForUnit = function () {
            return this.resource.downtimes.durationsForDateInTimeZone(this.model.date, this.resource.get('timeZone'));
        };

        TimeUnit.prototype._renderBookings = function () {
            var allDurations, bookingAnchorCount, bookingDurations, dayBookings, dayDowntimes, dayTimeAllocations, downtimeDurations;
            this._durationsForUnit = null;
            this._drawnBookings = dayBookings = this._getBookingsForUnit();
            bookingDurations = this._getBookingDurationsForUnit();
            downtimeDurations = this._getDowntimeDurationsForUnit();
            this._drawnDowntimes = dayDowntimes = this._getDowntimesForUnit();
            allDurations = [].concat(downtimeDurations, bookingDurations);
            bookingAnchorCount = this._getBookingAnchorCount(allDurations);
            dayTimeAllocations = [].concat(dayBookings.models, dayDowntimes.models);
            this.renderedBookings = {};
            dayTimeAllocations.forEach((function (_this) {
                return function (b) {
                    return _this.renderedBookings[b.id] = b.deepClone();
                };
            })(this));
            if (allDurations.length || dayBookings.length) {
                this._bookingsView = new RG.Views.Resource.TimeAllocations({
                    dateController: this.dateController,
                    bookingFormDialogFactory: this._bookingFormDialogFactory,
                    downtimeFormDialogFactory: this._downtimeFormDialogFactory,
                    bookingAnchorCount: bookingAnchorCount,
                    timeAllocations: dayTimeAllocations,
                    unit: this.model,
                    availability: this.resource.availability,
                    colorSource: this.colorSource,
                    el: this.bookingsEl
                });
                this._bookingsView.render();
            }
        };

        TimeUnit.prototype._getBookingAnchorCount = function (durations) {
            var anyConfirmedDurations, anyRenderedBooking, confirmedDrawnBookings, duration, earlierBookingCount, i, layer, len, maxLayer, minLayer, ref;
            maxLayer = 0;
            anyConfirmedDurations = false;
            anyRenderedBooking = false;
            earlierBookingCount = this._earlierStartedBookingCount();
            for (i = 0, len = durations.length; i < len; i++) {
                duration = durations[i];
                layer = duration.getLayer();
                if (layer > maxLayer) {
                    maxLayer = layer;
                }
                if (!anyConfirmedDurations) {
                    anyConfirmedDurations = duration.isConfirmed();
                }
                if (!anyRenderedBooking) {
                    anyRenderedBooking = !((ref = duration.collection) != null ? ref.booking.isExclusivelyOnWaitingList() : void 0);
                }
            }
            minLayer = anyRenderedBooking ? maxLayer : earlierBookingCount - 1;
            maxLayer = maxLayer > minLayer ? maxLayer : minLayer;
            confirmedDrawnBookings = this._drawnBookings.filter(function (b) {
                return b.durations.length && b.durations.models[0].isConfirmed();
            });
            if (confirmedDrawnBookings.length || anyConfirmedDurations || anyRenderedBooking) {
                return maxLayer + 1;
            } else {
                return minLayer;
            }
        };

        TimeUnit.prototype._getEarlierStartedDowntimes = function () {
            var dateController, downtimes;
            dateController = this.dateController;
            downtimes = this.resource.downtimes.overlapsDateInTimeZone(dateController._startDate(), this.resource.get('timeZone'));
            return this._cloneDowntimes(downtimes);
        };

        TimeUnit.prototype._earlierStartedBookingCount = function () {
            var bookings;
            bookings = this._getEarlierStartedBookings();
            return bookings.filter(function (booking) {
                return !booking.isExclusivelyOnWaitingList();
            }).length;
        };

        TimeUnit.prototype._cloneDowntimes = function (downtimes, transient) {
            var d, dTimes, ed, i, len;
            if (transient == null) {
                transient = true;
            }
            dTimes = [];
            for (i = 0, len = downtimes.length; i < len; i++) {
                d = downtimes[i];
                ed = d.inTimeZone(this.resource.get('timeZone'));
                ed.layer = d.layer;
                ed.realBooking = d;
                ed.transient = transient;
                ed.firstDate = this.dateController._startDate();
                ed.collection = {
                    resource: this.resource,
                    remove: function () { }
                };
                dTimes.push(ed);
            }
            return dTimes;
        };

        TimeUnit.prototype._getDowntimesForUnit = function () {
            var downtimes, earlierDowntimes;
            earlierDowntimes = [];
            if (this.model.containsDate(this.dateController._startDate())) {
                earlierDowntimes = this._getEarlierStartedDowntimes();
            }
            downtimes = this.resource.downtimes.startsOnDateInTimeZone(this.model.date, this.resource.get('timeZone'));
            this._downtimes = new RG.Collections.Downtimes;
            this._downtimes.models = earlierDowntimes.concat(this._cloneDowntimes(downtimes, false));
            this._downtimes.length = this._downtimes.models.length;
            this._downtimes.resource = this.resource;
            return this._downtimes;
        };

        TimeUnit.prototype.resetUtilisationHeight = function () {
            return RG.backburner.deferOnce('render', this, this._resetUtilisationHeight);
        };

        TimeUnit.prototype._resetUtilisationHeight = function () {
            var height, minsAvailable;
            if (this._utilisationView) {
                minsAvailable = this.resource.availability.getMaxMinutesInUnit(this._visibleDateRange());
                height = this._calculateUtilisationHeight(minsAvailable);
                return this._utilisationView.resetUtilisationHeight(height);
            }
        };

        TimeUnit.prototype.renderAvailableMinutes = function () {
            var minsAvailable, usedMinutes;
            usedMinutes = this._getUsedMinutes();
            minsAvailable = this.resource.availability.getMinutesAvailableForDate(this.model.date);
            this._availableMinutesView = new RG.Views.Resource.AvailableMinutes({
                availableMinutes: minsAvailable - usedMinutes,
                el: this.availableMinutesEl
            });
            this._availableMinutesView.render();
        };

        TimeUnit.prototype._calculateUtilisationHeight = function (minsAvailable) {
            return this.baseUtilisationHeight + (this._getNumberOfUtilisationLines(minsAvailable)) * this.utilLineMultiplier;
        };

        TimeUnit.prototype._getNumberOfUtilisationLines = function (minsAvailable) {
            return Math.ceil(minsAvailable / this.model.getMinutesPerUtilisationLine());
        };

        TimeUnit.prototype.renderUtilisation = function () {
            var availableMinutes, height, minsAvailable, overtimeMinutes, usedMinutes;
            usedMinutes = this._getUsedMinutes();
            minsAvailable = this.resource.availability.getMaxMinutesInUnit(this._visibleDateRange());
            availableMinutes = this.resource.availability.getMinutesAvailableForDate(this.model.date);
            overtimeMinutes = this.resource.availability.getOvertimeMinutesInDateRange(this.model.getDateRange());
            height = this._calculateUtilisationHeight(minsAvailable);
            this._utilisationView = new RG.Views.Resource.UtilisationBlock({
                usedMinutes: usedMinutes,
                availableMinutes: availableMinutes,
                overtimeMinutes: overtimeMinutes,
                minutesPerLine: this.model.getMinutesPerUtilisationLine(),
                height: height,
                el: this.utilisationEl
            });
            this._utilisationView.render();
        };

        TimeUnit.prototype._getUsedMinutes = function () {
            var converter, d, durations, i, len, ref;
            durations = [];
            ref = this._getBookingDurationsForUnit();
            for (i = 0, len = ref.length; i < len; i++) {
                d = ref[i];
                if (d.isConfirmed()) {
                    durations.push(d);
                }
            }
            converter = new RG.Utils.UnitDurationConverter(null, null);
            return converter.getDurationMinutesInUnit(durations, this.model);
        };

        TimeUnit.prototype._renderWaitingList = function () {
            var anchor, booking, d, fragment, i, j, len, len1, ref, view, waitingDuration, waitingDurations, waitingEl;
            waitingDurations = [];
            ref = this._getBookingDurationsForUnit();
            for (i = 0, len = ref.length; i < len; i++) {
                d = ref[i];
                if (d.isWaiting()) {
                    waitingDurations.push(d);
                }
            }
            if (waitingDurations.length > 0) {
                fragment = document.createDocumentFragment();
                waitingEl = document.createElement("div");
                waitingEl.className = "waitlist-anchor";
                waitingEl.innerHTML = '<div class="waitlist" title="Waiting List"><div class="blocks"><div class="unit"></div></div></div>';
                fragment.appendChild(waitingEl);
                waitingDurations.sort(function (a, b) {
                    return a.get('startTime') - b.get('startTime');
                });
                for (j = 0, len1 = waitingDurations.length; j < len1; j++) {
                    d = waitingDurations[j];
                    if (!(d.getMinutes() > 0)) {
                        continue;
                    }
                    anchor = document.createElement("div");
                    anchor.className = "booking-anchor waitlist";
                    booking = d.collection.booking.clone();
                    booking.realBooking = d.collection.booking;
                    booking.listenTo(booking.realBooking, "change", function () {
                        return booking.set(booking.realBooking.attributes);
                    });
                    waitingDuration = d.clone();
                    waitingDuration.set({
                        waiting: false
                    });
                    booking.durations.reset([waitingDuration]);
                    booking.collection = {
                        resource: this.resource,
                        remove: function () { }
                    };
                    view = new RG.Views.Resource.Booking({
                        dateController: this.dateController,
                        bookingFormFactory: this._bookingFormDialogFactory,
                        unit: this.model,
                        colorSource: this.colorSource,
                        model: booking,
                        waiting: true
                    });
                    anchor.appendChild(view.render().el);
                    fragment.appendChild(anchor);
                    this._waitingListViews.push(view);
                }
                this.bookingsEl.appendChild(fragment);
            }
        };

        TimeUnit.prototype._removeExistingBookingsView = function () {
            if (this._bookingsView) {
                this._bookingsView.remove();
            }
        };

        TimeUnit.prototype._removeExistingDowntimesView = function () {
            if (this._downtimesView) {
                this._downtimesView.remove();
            }
        };

        TimeUnit.prototype._removeExistingWaitingListView = function () {
            var i, len, ref, view;
            if (this._waitingListViews.length) {
                ref = this._waitingListViews;
                for (i = 0, len = ref.length; i < len; i++) {
                    view = ref[i];
                    view.remove();
                }
                this._waitingListViews.length = 0;
            }
        };

        TimeUnit.prototype._setAvailability = function () {
            var day;
            day = this.model.date.getDay();
            if (day === 0 || day === 6) {
                this.el.classList.add('unavailable');
            }
        };

        TimeUnit.prototype._setDateAttribute = function () {
            this.el.setAttribute('data-date', RG.Utils.DateFormatter.getISODate(this.model.date));
        };

        TimeUnit.prototype._setId = function () {
            this.el.setAttribute('id', RG.Utils.generateTimeUnitId(this.resource.cid, this.model.date));
        };

        TimeUnit.prototype._setBookingsContents = function (element) {
            this.el.insertBefore(element, this.bookingsEl);
            this.el.removeChild(this.bookingsEl);
            this.bookingsEl = element;
        };

        TimeUnit.prototype._visibleDateRange = function () {
            return new RG.Utils.DateRange(this.dateController._startDate(), this.dateController._endDate());
        };

        return TimeUnit;

    })(RG.Views.BaseView);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.Resource.Card = (function (superClass) {
        extend(Card, superClass);

        function Card() {
            return Card.__super__.constructor.apply(this, arguments);
        }

        Card.prototype.template = templates.find('resource/card');

        Card.prototype.className = 'resource';

        Card.prototype.initialize = function () {
            this.listenTo(this.model, 'change', this._fillValues);
        };

        Card.prototype.render = function () {
            window.requestAnimationFrame((function (_this) {
                return function () {
                    _this.el.innerHTML = _this.template();
                    _this.el.setAttribute('data-resource-id', _this.model.cid);
                    _this._fillValues();
                };
            })(this));
            return this;
        };

        Card.prototype._fillValues = function () {
            window.requestAnimationFrame((function (_this) {
                return function () {
                    var tz, userTimeZone;
                    _this.el.querySelector("h3").innerHTML = _this.model.escape('name');
                    _this.el.querySelector("h4").innerHTML = _this.model.escape('type');
                    userTimeZone = window.currentUserTimeZone.replace(/&amp;/g, '&');
                    tz = _this.model.getDisplayTimeZone();
                    if (tz.get('name') !== userTimeZone) {
                        _this.el.querySelector("p.timezone").innerHTML = tz.toString();
                    }
                    _this.el.querySelector("img").setAttribute("src", _this.model.get("imageUrl"));
                };
            })(this));
        };

        return Card;

    })(RG.Views.BaseView);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.Resource.Cards = (function (superClass) {
        extend(Cards, superClass);

        function Cards() {
            return Cards.__super__.constructor.apply(this, arguments);
        }

        Cards.prototype.tagName = 'aside';

        Cards.prototype.itemView = RG.Views.Resource.Card;

        Cards.prototype.render = function () {
            RG.backburner.deferOnce('render', this, this._render);
            return this;
        };

        Cards.prototype.createItemView = function (options) {
            var view;
            view = Cards.__super__.createItemView.apply(this, arguments);
            view.$el.toggleClass('hide', !options.model.visible);
            return view;
        };

        return Cards;

    })(RG.Support.CollectionView);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.Resource.Downtime = (function (superClass) {
        extend(Downtime, superClass);

        function Downtime() {
            return Downtime.__super__.constructor.apply(this, arguments);
        }

        Downtime.prototype.className = 'booking downtime';

        Downtime.prototype.initialize = function (options) {
            var ref;
            this.availability = options.availability;
            this.unit = options.unit;
            this.waiting = options.waiting;
            this.downtimeFormFactory = options.downtimeFormFactory;
            this.currentUserId = this.downtimeFormFactory.currentUserId;
            this.prevHoverDate = null;
            this._colorSource = options.colorSource;
            this._dateController = options.dateController;
            this.resource = (ref = this.model.collection) != null ? ref.resource : void 0;
        };

        Downtime.prototype.render = function () {
            this._fillValues();
            $(".sprite-spinner", this.el).each(function () {
                var s;
                s = {};
                if ($(this).closest(".detailed").length === 0) {
                    s = new SpriteSpinner(this, {
                        diameter: 12,
                        interval: 50
                    });
                } else {
                    s = new SpriteSpinner(this, {
                        diameter: 18,
                        interval: 50
                    });
                }
                return s.start();
            });
            this._ensureSpinnerStop();
            return this;
        };

        Downtime.prototype.resetColor = function () { };

        Downtime.prototype._ensureSpinnerStop = function () {
            return Q.delay(1000).then((function (_this) {
                return function () {
                    var realDowntime;
                    realDowntime = window.downtimes.findWhere({
                        id: _this.model.id
                    });
                    if (_this.model.get('saving')) {
                        if (!realDowntime.get('saving')) {
                            _this.model.set({
                                saving: false
                            });
                        } else {
                            _this._ensureSpinnerStop();
                        }
                    }
                };
            })(this));
        };

        Downtime.prototype.showDetailsPopup = function (e) {
            var date, downtime, downtimeAnchor, duration, factory, placer, selectedDuration, timeRange;
            if (this.model.id) {
                downtime = this.model.realBooking;
                this._stopPropagation(e);
                RG.Popovers.clear();
                placer = new RG.Utils.BookingPopoverPlacer(e);
                downtimeAnchor = placer.createAnchor({
                    className: 'downtime-detail-anchor'
                });
                selectedDuration = this.getDurationAtOffset(e.pageX - $(this.el).offset().left);
                date = selectedDuration.get('date');
                timeRange = downtime.getTimeRange(date);
                duration = this.model.realBooking.getDurations().filter(function (d) {
                    return RG.Utils.DateComparator.equalsYMD(d.getDate(), date);
                })[0];
                factory = new RG.Views.Dialogs.DowntimePopoverFactory({
                    downtimeFormFactory: this.downtimeFormFactory,
                    popoverType: 'details',
                    downtime: downtime,
                    duration: duration,
                    downtimeAnchor: downtimeAnchor
                });
                RG.Popovers.set(factory.popover());
            }
        };

        Downtime.prototype.getDurationAtOffset = function (offset) {
            var unitDuration;
            unitDuration = this._getUnitDurationAtOffset(offset);
            if (unitDuration) {
                return this._unitDurations.find(function (d) {
                    return RG.Utils.DateComparator.equalsYMD(d.attributes.date, unitDuration.attributes.date);
                });
            } else {
                if (offset < 0) {
                    return (this._unitDurations.filter(function (d) {
                        return d.get("minutes") !== 0;
                    }))[0];
                }
                offset = offset - RG.getUnitWidth();
                return this.getDurationAtOffset(offset);
            }
        };

        Downtime.prototype._setDurations = function () {
            var converter, durations, firstDate, lastDate;
            converter = new RG.Utils.UnitDurationConverter(this.unit.constructor);
            durations = this.model.getDurations();
            firstDate = this.model.getDateRange().startDate;
            lastDate = _.sortBy([this._dateController._endDate(), this.model.getDateRange().endDate], function (d) {
                return d;
            })[0];
            if (this.model.transient) {
                firstDate = this._dateController._startDate();
            }
            this._unitDurations = converter.convertArray(durations, firstDate, lastDate);
        };

        Downtime.prototype._setOwnerFlag = function () {
            if (this.model.attributes.creatorId === this.currentUserId) {
                this.el.classList.add('mine');
            }
        };

        Downtime.prototype._getCaptionElements = function () {
            var detailedLabel, details, labelTop, multipleResourceImage, nonDetailedLabel, refreshableImage, savingElement;
            refreshableImage = "";
            savingElement = "";
            multipleResourceImage = "";
            if (this.model.get('refreshable')) {
                refreshableImage = '<img src="/assets/flag-detailed.png"></img>';
            }
            if (this.model.get('saving')) {
                savingElement = this._getSpinnerElement();
            }
            if (this.model.get('resourceIds').length > 1) {
                multipleResourceImage = "<span class='rg-icon--contacts'></span>";
            }
            details = '';
            if (this.model.getType()) {
                details = ' | ';
            }
            if (this.model.get('details')) {
                details += (this.model.escape('details')) + " | ";
            }
            labelTop = this._getLabelTopPosition() + "px";
            detailedLabel = document.createElement("div");
            detailedLabel.className = "label daily";
            detailedLabel.style.top = labelTop;
            detailedLabel.innerHTML = [savingElement, '<div class="booking-icons">', this._getTypeIcon(), refreshableImage, multipleResourceImage, "</div>", this.model.getType(), details, this.model.getDateTimeString()].join("");
            nonDetailedLabel = document.createElement("div");
            nonDetailedLabel.className = "label detailed";
            nonDetailedLabel.style.top = labelTop;
            nonDetailedLabel.innerHTML = ['<div class="detailed-icons">', savingElement, this._getTypeIcon(), refreshableImage, multipleResourceImage, '</div>', '<div class="detailed-info">', this.model.getDateTimeString(), '<br />', this.model.getType(), '<br />', this.model.escape('details'), '</div>'].join("");
            return [nonDetailedLabel, detailedLabel];
        };

        Downtime.prototype._getSpinnerElement = function () {
            return templates.find('calendar/light_spinner')();
        };

        Downtime.prototype._getTypeIcon = function () {
            return "<span class='" + (this.model.getTypeIcon()) + "'></span>";
        };

        Downtime.prototype._attachDragAndDrop = function () {
            if (!this.dragDrop) {
                this.dragDrop = new RG.Interactions.DragDropDowntime(this);
                this.dragDrop.attach();
            }
        };

        Downtime.prototype._attachResizable = function () {
            if (!this.resize) {
                this.resize = new RG.Interactions.ResizeDowntime(this);
                this.resize.attach();
            }
        };

        Downtime.prototype._getBookingResource = function () {
            return this.resource;
        };

        Downtime.prototype._attachEvents = function () {
            if (!this.model.id) {
                return;
            }
            if (RG.Utils.Permissions.canManageDowntime(this.model)) {
                this._attachDragAndDrop();
            }
            if (RG.Utils.Permissions.canManageDowntime(this.model) && !this.waiting) {
                this._attachResizable();
            }
        };

        Downtime.prototype._isTransientInvalidated = function () {
            return this.model.transient && !RG.Utils.DateComparator.equalsYMD(this.model.firstDate, this._dateController._startDate());
        };

        return Downtime;

    })(RG.Views.Resource.Booking);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.Resource.UnitDurationBlocks = (function (superClass) {
        extend(UnitDurationBlocks, superClass);

        function UnitDurationBlocks() {
            return UnitDurationBlocks.__super__.constructor.apply(this, arguments);
        }

        UnitDurationBlocks.prototype.className = 'blocks';

        UnitDurationBlocks.prototype._ensureElement = function () {
            if (!this.el) {
                this.el = document.createElement("div");
                return this.el.className = this.className;
            }
        };

        UnitDurationBlocks.prototype.initialize = function (options) {
            this.unit = options.unit;
        };

        UnitDurationBlocks.prototype.createItemView = function (options) {
            return new RG.Views.Resource.UnitDurationLine({
                model: options.model,
                minutesPerLine: this.unit.getMinutesPerUtilisationLine()
            });
        };

        return UnitDurationBlocks;

    })(RG.Support.ArrayView);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.Resource.Line = (function (superClass) {
        extend(Line, superClass);

        function Line() {
            return Line.__super__.constructor.apply(this, arguments);
        }

        Line.prototype.className = 'resource-line';

        Line.prototype.itemView = RG.Views.Resource.TimeUnit;

        Line.prototype.initialize = function (options) {
            this._bookingFormDialogFactory = options.bookingFormDialogFactory;
            this._downtimeFormDialogFactory = options.downtimeFormDialogFactory;
            this.dateController = options.dateController;
            this.currentDate = options.currentDate || new RG.Models.CurrentDate(RG.Utils.getTodayISO());
            this.availabilityToggle = options.availabilityToggle;
            this._colorSource = options.colorSource;
            this.listenTo(this.currentDate, 'change', this._rerenderUnit);
            this.listenTo(this.dateController, 'append', this._appendFragment);
            this.listenTo(this.dateController, 'prepend', this._prependFragment);
            this.listenTo(this._colorSource, 'change:mode', this._resetColor);
            this.listenTo(this.model.availability, 'refresh', this._refreshAvailability);
            this.listenTo(this.model.availability, 'refreshUtilisation maxAvailabilityChanged', this._renderUtilisation);
            this.listenTo(this.model.bookings, 'add change remove', this._notifyBookingChanged);
            this.listenTo(this.collection, 'change', this._resizeTimeAllocationWidths);
        };

        Line.prototype.createItemView = function (options) {
            return new this.itemView({
                availabilityToggle: this.availabilityToggle,
                dateController: this.dateController,
                currentDate: this.currentDate,
                model: options.model,
                resource: this.model,
                colorSource: this._colorSource,
                bookingFormDialogFactory: this._bookingFormDialogFactory,
                downtimeFormDialogFactory: this._downtimeFormDialogFactory,
                resourceLine: this
            });
        };

        Line.prototype.render = function () {
            RG.backburner.deferOnce('render', this, this._render);
            return this;
        };

        Line.prototype._render = function () {
            var i, len, model, ref;
            this.close();
            ref = this.collection.models;
            for (i = 0, len = ref.length; i < len; i++) {
                model = ref[i];
                this.addItem(model);
            }
            this.$el.attr('data-resource-id', this.model.cid);
            this._attachDragToCreateInteraction();
            this._rendered = true;
            this._fragment = document.createDocumentFragment();
        };

        Line.prototype.remove = function () {
            this._detachInteractions();
            Line.__super__.remove.apply(this, arguments);
        };

        Line.prototype._detachInteractions = function () {
            this.dragInteraction.detach();
            this.dragCustomAvailabilityInteraction.detach();
        };

        Line.prototype._attachDragToCreateInteraction = function () {
            this.dragInteraction = new RG.Interactions.DragToCreate(this);
            this.dragInteraction.attach();
            this.dragCustomAvailabilityInteraction = new RG.Interactions.DragToCreateCustomAvailability(this);
            this.dragCustomAvailabilityInteraction.attach();
        };

        Line.prototype._insertView = function (view, model) {
            var element;
            if (!this._rendered) {
                return Line.__super__._insertView.apply(this, arguments);
            }
            element = view.render().el;
            if (model === this.collection.first()) {
                this._fragment.insertBefore(element, this._fragment.firstChild);
            } else {
                this._fragment.appendChild(element);
            }
        };

        Line.prototype._appendFragment = function () {
            var _, minUnit, ref, view;
            if (!this._rendered) {
                return;
            }
            this.el.appendChild(this._fragment);
            this._isListeningToGroup = false;
            this._fragment = document.createDocumentFragment();
            minUnit = this.collection.min(function (day) {
                return day.date.valueOf();
            });
            this.collectionViews[minUnit.cid].rerender();
            ref = this.collectionViews;
            for (_ in ref) {
                view = ref[_];
                view.rerenderIfTimeAllocationsOverextend();
                view.resetUtilisationHeight();
            }
        };

        Line.prototype._prependFragment = function () {
            var _, ref, view;
            if (!this._rendered) {
                return;
            }
            this.el.insertBefore(this._fragment, this.el.firstChild);
            this._isListeningToGroup = false;
            this._fragment = document.createDocumentFragment();
            ref = this.collectionViews;
            for (_ in ref) {
                view = ref[_];
                view.rerenderIfTimeAllocationsOverextend();
                view.resetUtilisationHeight();
            }
        };

        Line.prototype._resetColor = function () {
            return this.forEach(function (view) {
                return view.resetColor();
            });
        };

        Line.prototype._rerenderUnit = function () {
            return this.forEach(function (view) {
                return view.render();
            });
        };

        Line.prototype._refreshAvailability = function (range) {
            return this.forEach(function (view) {
                return view.refreshInRange(range);
            });
        };

        Line.prototype._renderUtilisation = function () {
            return this.forEach(function (view) {
                return view.renderUtilisationAndAvailableMinutes();
            });
        };

        Line.prototype._notifyBookingChanged = function (booking) {
            return this.forEach(function (view) {
                return view.bookingChanged(booking);
            });
        };

        Line.prototype._resizeTimeAllocationWidths = function () {
            return this.forEach(function (view) {
                return view.resizeTimeAllocationWidths();
            });
        };

        return Line;

    })(RG.Support.CollectionView);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.Resource.Lines = (function (superClass) {
        extend(Lines, superClass);

        function Lines() {
            return Lines.__super__.constructor.apply(this, arguments);
        }

        Lines.prototype.itemView = RG.Views.Resource.Line;

        Lines.prototype.id = 'resources';

        Lines.prototype.initialize = function (options) {
            var availabilityToggle;
            this.listenTo(this.collection, 'change:visible', this._setVisibility);
            this.dateController = options.dateController;
            this.timeUnits = options.timeUnits;
            this._colorSource = options.colorSource;
            this._bookingFormDialogFactory = options.bookingFormDialogFactory;
            this._downtimeFormDialogFactory = options.downtimeFormDialogFactory;
            this._customAvailabilityDialogFactory = options.customAvailabilityDialogFactory;
            availabilityToggle = window.rgStorage.get('availabilityToggle');
            this.availabilityToggle = new RG.Utils.AvailabilityToggle(this, availabilityToggle === "true");
            this.currentDate = options.currentDate || new RG.Models.CurrentDate(RG.Utils.getTodayISO());
            this.listenTo(this.timeUnits, 'append prepend', this.clearInvisibleViews);
        };

        Lines.prototype.createItemView = function (options) {
            var view;
            view = new this.itemView({
                availabilityToggle: this.availabilityToggle,
                dateController: this.dateController,
                collection: this.timeUnits,
                model: options.model,
                currentDate: this.currentDate,
                colorSource: this._colorSource,
                bookingFormDialogFactory: this._bookingFormDialogFactory,
                downtimeFormDialogFactory: this._downtimeFormDialogFactory,
                customAvailabilityDialogFactory: this._customAvailabilityDialogFactory
            });
            return view;
        };

        Lines.prototype._setVisibility = function () {
            var invisibleElements, visibleElements;
            visibleElements = [];
            invisibleElements = [];
            this.collection.models.forEach((function (_this) {
                return function (ri) {
                    var view;
                    view = _this.collectionViews[ri.cid];
                    if (ri.visible) {
                        visibleElements.push(view.el);
                    } else {
                        invisibleElements.push(view.el);
                    }
                };
            })(this));
            invisibleElements.forEach(function (el) {
                return el.style.display = "none";
            });
            visibleElements.forEach(function (el) {
                return el.style.display = "";
            });
            this.availabilityToggle._refreshCalendar();
        };

        return Lines;

    })(RG.Support.CachedCollectionView);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.Resource.TimeAllocations = (function (superClass) {
        extend(TimeAllocations, superClass);

        function TimeAllocations() {
            return TimeAllocations.__super__.constructor.apply(this, arguments);
        }

        TimeAllocations.prototype.className = 'bookings';

        TimeAllocations.prototype.initialize = function (options) {
            this.availability = options.availability;
            this.dateController = options.dateController;
            this.bookingAnchorCount = options.bookingAnchorCount;
            this.timeAllocations = options.timeAllocations;
            this.bookingAnchors = [];
            this.colorSource = options.colorSource;
            this.unit = options.unit;
            this._bookingFormDialogFactory = options.bookingFormDialogFactory;
            this._downtimeFormDialogFactory = options.downtimeFormDialogFactory;
            this.rendered = false;
            this.collectionViews = {};
        };

        TimeAllocations.prototype.addBooking = function (model) {
            var child, target, view;
            if (target = this.bookingAnchors[model.layer]) {
                view = this.createItemView(model);
                while ((child = target.firstChild)) {
                    target.removeChild(child);
                }
                target.appendChild(view.render().el);
                this.collectionViews[model.cid] = view;
            }
        };

        TimeAllocations.prototype.createItemView = function (model) {
            if (model.constructor === RG.Models.Booking) {
                return new RG.Views.Resource.Booking({
                    dateController: this.dateController,
                    bookingFormFactory: this._bookingFormDialogFactory,
                    model: model,
                    unit: this.unit,
                    availability: this.availability,
                    colorSource: this.colorSource
                });
            } else {
                return new RG.Views.Resource.Downtime({
                    model: model,
                    unit: this.unit,
                    availability: this.availability,
                    colorSource: this.colorSource,
                    downtimeFormFactory: this._downtimeFormDialogFactory,
                    dateController: this.dateController
                });
            }
        };

        TimeAllocations.prototype.remove = function () {
            var cid, ref, view;
            TimeAllocations.__super__.remove.apply(this, arguments);
            ref = this.collectionViews;
            for (cid in ref) {
                view = ref[cid];
                view.remove();
            }
        };

        TimeAllocations.prototype.render = function () {
            var cid, j, len, model, ref, ref1, view;
            this._fragment = document.createDocumentFragment();
            this._setBookingAnchors();
            ref = this.collectionViews;
            for (cid in ref) {
                view = ref[cid];
                view.remove();
            }
            ref1 = this.timeAllocations;
            for (j = 0, len = ref1.length; j < len; j++) {
                model = ref1[j];
                this.addBooking(model);
            }
            this.el.appendChild(this._fragment);
            return this;
        };

        TimeAllocations.prototype._setBookingAnchors = function () {
            var child, elem, i, j, ref;
            this.bookingAnchors = [];
            while ((child = this.el.firstChild)) {
                this.el.removeChild(child);
            }
            if (this.bookingAnchorCount > 0) {
                for (i = j = 1, ref = this.bookingAnchorCount; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {
                    elem = document.createElement("div");
                    elem.className = "booking-anchor";
                    this._fragment.appendChild(elem);
                    this.bookingAnchors.push(elem);
                }
            }
        };

        TimeAllocations.prototype.resetColor = function () {
            var _, ref, view;
            ref = this.collectionViews;
            for (_ in ref) {
                view = ref[_];
                view.resetColor();
            }
        };

        TimeAllocations.prototype.resizeWidth = function () {
            var _, ref, view;
            ref = this.collectionViews;
            for (_ in ref) {
                view = ref[_];
                view.resizeWidth();
            }
        };

        TimeAllocations.prototype.rerenderIfOverExtends = function () {
            var _, ref, view;
            ref = this.collectionViews;
            for (_ in ref) {
                view = ref[_];
                view.rerenderIfOverExtends();
            }
        };

        return TimeAllocations;

    })(RG.Views.BaseView);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.Resource.UnitDurationLine = (function (superClass) {
        extend(UnitDurationLine, superClass);

        UnitDurationLine.prototype.className = 'unit';

        UnitDurationLine.prototype._ensureElement = function () {
            if (!this.el) {
                this.el = document.createElement("div");
                return this.el.className = this.className;
            }
        };

        UnitDurationLine.prototype._removeElement = function () {
            if (this.el.parentNode) {
                return this.el.parentNode.removeChild(this.el);
            }
        };

        function UnitDurationLine(options) {
            UnitDurationLine.__super__.constructor.apply(this, arguments);
            this.minutesPerLine = options.minutesPerLine;
            this.listenTo(this.model, 'change', this.render);
        }

        UnitDurationLine.prototype.render = function () {
            var color, fragment, minutes;
            minutes = this.model.attributes.minutes;
            color = this.model.attributes.color;
            fragment = document.createDocumentFragment();
            while (minutes / this.minutesPerLine > 1) {
                minutes -= this.minutesPerLine;
                fragment.appendChild(this._createFullLine(color.toString()));
            }
            if (minutes > 0) {
                fragment.appendChild(this._createLine(minutes / this.minutesPerLine, color.toString()));
            }
            if (this.model.get('waiting')) {
                this.el.classList.add("waiting-list");
            }
            this.el.appendChild(fragment);
            return this;
        };

        UnitDurationLine.prototype._createFullLine = function (color) {
            var el;
            el = document.createElement("span");
            el.style["background-color"] = color;
            return el;
        };

        UnitDurationLine.prototype._createLine = function (ratio, color) {
            var el;
            el = document.createElement("span");
            el.style["background-color"] = color;
            el.style.width = (ratio * 100) + "%";
            return el;
        };

        return UnitDurationLine;

    })(RG.Views.BaseView);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty,
        slice = [].slice;

    RG.Views.Resource.UtilisationBlock = (function (superClass) {
        extend(UtilisationBlock, superClass);

        function UtilisationBlock() {
            return UtilisationBlock.__super__.constructor.apply(this, arguments);
        }

        UtilisationBlock.prototype.className = 'utilisation';

        UtilisationBlock.prototype.initialize = function (options) {
            this.usedMinutes = options.usedMinutes;
            this.availableMinutes = options.availableMinutes;
            this.overtimeMinutes = options.overtimeMinutes || 0;
            this.minutesPerLine = options.minutesPerLine;
            this.height = options.height;
        };

        UtilisationBlock.prototype.resetUtilisationHeight = function (height) {
            if (height === this.height) {
                return;
            }
            this.height = height;
            return this._setHeight();
        };

        UtilisationBlock.prototype.render = function () {
            var availableFormatted, availableMinutes, lineAvailable, lines, overtimeMinutes, ratio, ref, remainingMinutesInLine, renderableNormalMinutes, renderableUnusedNormalMinutes, renderableUnusedOvertimeMinutes, renderableUsedOvertimeMinutes, unit, unusedNormalMinutes, unusedOvertimeMinutes, usedMinutes, usedNormalMinutes, usedOvertimeMinutes, width;
            availableFormatted = RG.Utils.TimeFormatter.formatMinutes(this.availableMinutes - this.usedMinutes);
            // this.el.innerHTML = "<div class=\"time-available\">" + availableFormatted + "<div class=\"time-available-linebreak\"></div>free</div>";
            availableMinutes = this.availableMinutes;
            usedMinutes = this.usedMinutes;
            overtimeMinutes = this.overtimeMinutes > this.availableMinutes ? this.availableMinutes : this.overtimeMinutes;
            lines = [];
            usedNormalMinutes = usedMinutes > availableMinutes - overtimeMinutes ? availableMinutes - overtimeMinutes : usedMinutes;
            unusedNormalMinutes = usedMinutes < availableMinutes - overtimeMinutes ? availableMinutes - overtimeMinutes - usedMinutes : 0;
            usedOvertimeMinutes = usedMinutes > availableMinutes - overtimeMinutes ? -(availableMinutes - usedMinutes - overtimeMinutes) : 0;
            unusedOvertimeMinutes = overtimeMinutes - usedOvertimeMinutes;
            while (availableMinutes > 0) {
                width = availableMinutes / this.minutesPerLine;
                if (width > 1) {
                    width = 1;
                }
                lineAvailable = availableMinutes < this.minutesPerLine ? availableMinutes : this.minutesPerLine;
                lines = [];
                remainingMinutesInLine = lineAvailable;
                if (remainingMinutesInLine > 0 && usedNormalMinutes > 0) {
                    renderableNormalMinutes = usedNormalMinutes > remainingMinutesInLine ? remainingMinutesInLine : usedNormalMinutes;
                    ratio = renderableNormalMinutes / lineAvailable;
                    lines.push({
                        width: ratio,
                        color: "#9F9F9F",
                        className: "unit--used-normal"
                    });
                    remainingMinutesInLine -= renderableNormalMinutes;
                    availableMinutes -= renderableNormalMinutes;
                    usedNormalMinutes -= renderableNormalMinutes;
                }
                if (remainingMinutesInLine > 0 && unusedNormalMinutes > 0) {
                    renderableUnusedNormalMinutes = unusedNormalMinutes > remainingMinutesInLine ? remainingMinutesInLine : unusedNormalMinutes;
                    ratio = renderableUnusedNormalMinutes / lineAvailable;
                    lines.push({
                        width: ratio,
                        color: "#fff",
                        className: "unit--unused-normal"
                    });
                    remainingMinutesInLine -= renderableUnusedNormalMinutes;
                    availableMinutes -= renderableUnusedNormalMinutes;
                    unusedNormalMinutes -= renderableUnusedNormalMinutes;
                }
                if (remainingMinutesInLine > 0 && usedOvertimeMinutes > 0) {
                    renderableUsedOvertimeMinutes = usedOvertimeMinutes > remainingMinutesInLine ? remainingMinutesInLine : usedOvertimeMinutes;
                    ratio = renderableUsedOvertimeMinutes / lineAvailable;
                    lines.push({
                        width: ratio,
                        color: "#B47972",
                        className: "unit--used-overtime"
                    });
                    remainingMinutesInLine -= renderableUsedOvertimeMinutes;
                    availableMinutes -= renderableUsedOvertimeMinutes;
                    usedOvertimeMinutes -= renderableUsedOvertimeMinutes;
                }
                if (remainingMinutesInLine > 0 && unusedOvertimeMinutes > 0) {
                    renderableUnusedOvertimeMinutes = unusedOvertimeMinutes > remainingMinutesInLine ? remainingMinutesInLine : unusedOvertimeMinutes;
                    ratio = renderableUnusedOvertimeMinutes / lineAvailable;
                    lines.push({
                        width: ratio,
                        color: "#F7BCB5",
                        className: "unit--unused-overtime"
                    });
                    remainingMinutesInLine -= renderableUnusedOvertimeMinutes;
                    availableMinutes -= renderableUnusedOvertimeMinutes;
                    unusedOvertimeMinutes -= renderableUnusedOvertimeMinutes;
                }
                unit = (ref = RG.Views.Calendar.UtilisationBarFactory).create.apply(ref, [width, "unit"].concat(slice.call(lines)));
                this.el.appendChild(unit);
            }
            this._setHeight();
            return this;
        };

        UtilisationBlock.prototype._setHeight = function () {
            if (this.height != null) {
                return this.el.style.height = this.height.toString() + "px";
            }
        };

        return UtilisationBlock;

    })(RG.Views.BaseView);

}).call(this);
;
(function () {
    var bind = function (fn, me) { return function () { return fn.apply(me, arguments); }; },
        extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.Selectors.ClientProject = (function (superClass) {
        extend(ClientProject, superClass);

        function ClientProject() {
            this._setNewValue = bind(this._setNewValue, this);
            this._selectedProjectClientChanged = bind(this._selectedProjectClientChanged, this);
            return ClientProject.__super__.constructor.apply(this, arguments);
        }

        ClientProject.prototype.initialize = function (options) {
            if (options == null) {
                options = {};
            }
            this.clients = options.clients || new RG.Collections.Clients;
            this.projects = options.projects || new RG.Collections.Projects;
            this.resource = options.resource || null;
            this.container = options.container;
            this._selectedValue = options.selectedValue;
            this._originalValue = options.selectedValue;
            this.listenTo(this.clients, 'add', this.render);
            this.listenTo(this.clients, 'remove', this.render);
            this.listenTo(this.projects, 'add', this.render);
            this.listenTo(this.projects, 'remove', this.render);
            this.listenTo(this.clients, 'add', this._setNewValue);
            return this.listenTo(this.projects, 'add', this._setNewValue);
        };

        ClientProject.prototype._getSelectorOptions = function (selected) {
            var archiveFilter, commands, elements, groups;
            if (selected == null) {
                selected = null;
            }
            archiveFilter = (function (_this) {
                return function (obj) {
                    return !obj.get('archived') || (_this._originalValue && _this._originalValue === obj.cid);
                };
            })(this);
            groups = this.clients.filter(archiveFilter).map(function (c) {
                return c.toJSON();
            });
            elements = this.projects.filter(archiveFilter).map(function (p) {
                var project, ref;
                project = p.toJSON();
                project.client_id = ((ref = p.get('client')) != null ? ref.get('id') : void 0) || null;
                return project;
            });
            commands = [];
            if (RG.Utils.Permissions.canAddProject(this.resource)) {
                commands.push({
                    text: 'New project ...',
                    onSelect: (function (_this) {
                        return function () {
                            _this.modal = new RG.Views.Dialogs.NewProject({
                                clients: _this.clients,
                                projectCodes: _this.getAllProjectCodes()
                            });
                            _this._bindProjectEvents(_this.modal);
                            return _this.trigger('changeOverlay', _this.modal, {
                                className: 'overlay project'
                            });
                        };
                    })(this)
                });
            }
            if (RG.Utils.Permissions.canAddClient(this.resource)) {
                commands.push({
                    text: 'New client ...',
                    onSelect: (function (_this) {
                        return function () {
                            _this.modal = new RG.Views.Dialogs.NewClient;
                            _this.modal.on('cancelled', function () {
                                return _this.trigger('cancelled');
                            }, _this);
                            return _this.trigger('changeOverlay', _this.modal, {
                                className: 'overlay client'
                            });
                        };
                    })(this)
                });
            }
            return {
                groups: groups,
                elements: elements,
                selected: selected,
                groupId: function (group) {
                    return group.id;
                },
                elementId: function (element) {
                    return element.id;
                },
                groupIdFromElement: function (element) {
                    return element.client_id;
                },
                groupDisplay: function (group) {
                    return group.name;
                },
                groupSearch: function (group) {
                    return group.name;
                },
                elementSearch: function (element) {
                    return element.name + ' ' + element.project_code;
                },
                elementDisplay: function (element) {
                    var name;
                    name = element.name;
                    if (element.project_code) {
                        name += ' (' + element.project_code + ')';
                    }
                    return name;
                },
                onChange: this._selectedProjectClientChanged,
                commands: commands,
                style: {
                    zIndex: 1
                },
                ungroupedText: 'PROJECTS WITHOUT ASSIGNED CLIENTS',
                emptyText: '',
                clearSelectionText: 'Clear selection',
                useAggressiveHandler: true
            };
        };

        ClientProject.prototype.render = function () {
            var ref;
            if ((ref = this._selector) != null) {
                ref.destroy();
            }
            this._selector = RGComponents.createGroupedSelector(this.el, this._getSelectorOptions());
            return this;
        };

        ClientProject.prototype._selectedProjectClientChanged = function (selection) {
            if (!selection) {
                this._selectedValue = null;
            } else if (selection.type === 'element') {
                this._selectedValue = this.projects.findWhere({
                    id: selection.id
                });
            } else {
                this._selectedValue = this.clients.findWhere({
                    id: selection.id
                });
            }
            return this.trigger('change', this._selectedValue);
        };

        ClientProject.prototype._setNewValue = function (newItem) {
            return this.setSelectedValue(newItem.cid);
        };

        ClientProject.prototype.getSelectedOption = function (suppress) {
            return this._selectedValue;
        };

        ClientProject.prototype.setSelectedValue = function (cid) {
            var models, selected, target;
            models = _.flatten([this.projects.models, this.clients.models]);
            target = models.find(function (m) {
                return m.cid === cid;
            });
            this._selectedValue = target;
            selected = null;
            if (target) {
                selected = {
                    type: target instanceof RG.Models.Project ? 'element' : 'group',
                    id: target.get('id')
                };
            }
            RGComponents.createGroupedSelector(this.el, this._getSelectorOptions(selected));
            return this.trigger('change', target);
        };

        ClientProject.prototype._bindProjectEvents = function (projectView) {
            projectView.on('cancelled', (function (_this) {
                return function () {
                    return _this.trigger('cancelled');
                };
            })(this), this);
            return projectView.on('changeOverlay', (function (_this) {
                return function (view, options) {
                    if (!options.newClient) {
                        _this.modal = new RG.Views.Dialogs.NewProject({
                            clients: _this.clients,
                            projectCodes: _this.getAllProjectCodes(),
                            selectedClient: options.client
                        });
                        _this._bindProjectEvents(_this.modal);
                        view = _this.modal;
                    }
                    return _this.trigger('changeOverlay', view, options);
                };
            })(this));
        };

        ClientProject.prototype.getAllProjectCodes = function () {
            var dirty_project_codes;
            dirty_project_codes = this.projects.models.map(function (p) {
                return p.get('project_code');
            });
            return dirty_project_codes.filter(function (p) {
                return !!p;
            });
        };

        ClientProject.prototype.remove = function () {
            var ref, ref1, ref2, ref3;
            if ((ref = this.modal) != null) {
                ref.remove();
            }
            if ((ref1 = this.clients) != null) {
                ref1.remove();
            }
            if ((ref2 = this.projects) != null) {
                ref2.remove();
            }
            if ((ref3 = this._selector) != null) {
                ref3.destroy();
            }
            return ClientProject.__super__.remove.apply(this, arguments);
        };

        return ClientProject;

    })(RG.Views.BaseView);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.Selectors.ColorPicker = (function (superClass) {
        extend(ColorPicker, superClass);

        function ColorPicker() {
            return ColorPicker.__super__.constructor.apply(this, arguments);
        }

        ColorPicker.prototype.template = templates.find('selectors/color_picker');

        ColorPicker.prototype.defaultColors = ["d5ded9", "bfbfbf", "ece5ce", "f1d4af", "e8cb05", "c68c00", "e08e79", "ffb400", "ff9f80", "ff6600", "ef247f", "ea1414", "b70655", "bb4b01", "850505", "80056d", "d818bb", "a675ff", "683db8", "16287f", "0264b0", "2654ea", "59b2f6", "18cfd6", "09ca7a", "b9d020", "719004", "0e6c6f", "007f4b", "9c8803"];

        ColorPicker.prototype.events = {
            'click .dropdown-toggle, .dropdown-menu a': 'toggleColorbox',
            'click ul.dropdown-menu.color-palette a': 'colorPalette'
        };

        ColorPicker.prototype.initialize = function (options) {
            if (options == null) {
                options = {};
            }
            return this.colors = options.colors || this.defaultColors;
        };

        ColorPicker.prototype.render = function () {
            this.$el.html(this.template());
            this._fillValues();
            return this;
        };

        ColorPicker.prototype.colorPalette = function (e) {
            var color, elem, parentColorPicker, parentSelect, selectedColorBlock;
            e.preventDefault();
            e.stopPropagation();
            elem = $(e.currentTarget);
            color = elem.attr('data-color');
            parentColorPicker = elem.closest('.color-picker');
            parentSelect = parentColorPicker.parent().find('.color-picker-select');
            selectedColorBlock = parentColorPicker.find('.selected-color');
            parentSelect.val(color);
            return selectedColorBlock.css('background-color', '#' + color);
        };

        ColorPicker.prototype.toggleColorbox = function (e) {
            e.preventDefault();
            e.stopPropagation();
            return this.$('.color-picker').toggleClass('open');
        };

        ColorPicker.prototype._fillValues = function () {
            var a, color, i, len, li, ref, results;
            ref = this.colors;
            results = [];
            for (i = 0, len = ref.length; i < len; i++) {
                color = ref[i];
                this.$('.js-select').append($(document.createElement('option')).attr('value', color).text(color));
                li = $(document.createElement('li'));
                a = $(document.createElement('a')).css('background-color', "#" + color).attr('data-color', color);
                results.push(this.$('.js-displayed-colors').append(li.append(a)));
            }
            return results;
        };

        return ColorPicker;

    })(RG.Views.BaseView);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.Selectors.Duration = (function (superClass) {
        extend(Duration, superClass);

        function Duration() {
            return Duration.__super__.constructor.apply(this, arguments);
        }

        Duration.prototype.template = templates.find('selectors/duration');

        Duration.prototype.className = "hours-per-day";

        Duration.prototype.events = {
            "change input": "triggerValidate",
            "keyup input": "triggerValidate"
        };

        Duration.prototype.initialize = function (options) {
            this.duration = options.duration;
            this.storageTypeName = options.typeName;
            return this.inlineHelpText = options.inlineHelpText || 'Please fill in a booking duration.';
        };

        Duration.prototype.getBookingDurationDTO = function () {
            return new RG.DTO.BookingDuration({
                duration: this.getDuration()
            });
        };

        Duration.prototype.getDuration = function () {
            var hours, minutes;
            hours = parseInt(this._getHoursFieldEl().val(), 10);
            minutes = parseInt(this._getMinutesFieldEl().val(), 10);
            if (isNaN(hours)) {
                hours = 0;
            }
            if (isNaN(minutes)) {
                minutes = 0;
            }
            return (hours * 60) + minutes;
        };

        Duration.prototype.render = function () {
            this.$el.html(this.template());
            this._fillValues();
            return this;
        };

        Duration.prototype.setDuration = function (duration) {
            this.duration = duration;
            return this._fillValues();
        };

        Duration.prototype.toggleError = function (error) {
            return this.$(".help-inline").toggle(error);
        };

        Duration.prototype.triggerValidate = function () {
            if (this.getDuration() !== 0) {
                window.rgStorage.set("Duration:" + this.storageTypeName, this.getDuration());
            }
            this.validate(true);
            return true;
        };

        Duration.prototype.validate = function (trigger) {
            var duration, error;
            error = false;
            duration = this.getDuration();
            if (duration > 0) {
                if (duration > (24 * 60)) {
                    error = true;
                    this.$(".help-inline.error").text("Must be less than 24 hours.");
                } else {
                    error = false;
                }
            } else {
                error = true;
                this.$(".help-inline.error").text("Please fill in a booking duration.");
            }
            this.toggleError(error);
            if (trigger) {
                this.trigger('validate');
            }
            return !error;
        };

        Duration.prototype._fillValues = function () {
            var hours, minutes;
            hours = Math.floor(this.duration / 60);
            minutes = this.duration % 60;
            this.$(".help-inline").text(this.inlineHelpText);
            this._getHoursFieldEl().val(hours);
            this._getMinutesFieldEl().val(minutes);
            return this.validate();
        };

        Duration.prototype._getHoursFieldEl = function () {
            return this.$("#booking-hour-time");
        };

        Duration.prototype._getMinutesFieldEl = function () {
            return this.$("#booking-minute-time");
        };

        return Duration;

    })(RG.Views.BaseView);

}).call(this);
;
(function () {
    var extend = function (child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        hasProp = {}.hasOwnProperty;

    RG.Views.Selectors.Resource = (function (superClass) {
        extend(Resource, superClass);

        function Resource() {
            return Resource.__super__.constructor.apply(this, arguments);
        }

        Resource.prototype.template = templates.find('selectors/resource');

        Resource.prototype.events = {
            'change .selector select': '_updateSelectedResource',
            'click .alt-toggle a': '_showSelectBox'
        };

        Resource.prototype.initialize = function (options) {
            this.resources = options.resources;
            return this.selected = options.selected;
        };

        Resource.prototype.getSelectedResource = function () {
            return this.selected;
        };

        Resource.prototype.render = function () {
            this.$el.html(this.template());
            this._populateSelectBox();
            if (this.selected) {
                this._selectResourceByCid(this.selected.cid);
            }
            return this;
        };

        Resource.prototype._populateSelectBox = function () {
            var bookableResources, i, len, optionsHtml, ref, resource, selector;
            bookableResources = [];
            selector = this.el.querySelector(".selector select");
            optionsHtml = [];
            ref = this.resources.models;
            for (i = 0, len = ref.length; i < len; i++) {
                resource = ref[i];
                if (resource.isBookable()) {
                    optionsHtml.push("<option value=\"" + resource.cid + "\">" + (resource.getName()) + "</option>");
                }
            }
            return $(selector).html(optionsHtml.join(""));
        };

        Resource.prototype._selectResourceByCid = function (cid) {
            return this.$(".selector select").val(cid).trigger('change');
        };

        Resource.prototype._showSelectBox = function (e) {
            e.preventDefault();
            e.stopPropagation();
            this.$(".current, .alt-toggle").hide();
            return this.$(".selector").show();
        };

        Resource.prototype._updateSelectedResource = function () {
            var resourceAvatar;
            this.selected = this.resources.find((function (_this) {
                return function (ri) {
                    return ri.cid === _this.$(".selector select").val();
                };
            })(this));
            this.$(".current span.resource-name").text(this.selected.get('name'));
            if (this.selected.hasAvatar()) {
                resourceAvatar = new RG.Views.Resource.Avatar({
                    resource: this.selected
                });
                this.$(".current").prepend(resourceAvatar.render().el);
            }
            this.trigger('change', this.selected);
            return false;
        };

        return Resource;

    })(RG.Views.BaseView);

}).call(this);
;
(function () {
    window.RG.Popovers = new RG.Utils.PopoverManager;

    window.RG.renderer = new RG.Renderer.Renderer;

}).call(this);
;
(function () {
    if (!window.RGComponents || !window.RGComponents.createGiftDropdown) return;

    var CSRFToken = null;

    function getCSRFToken() {
        if (!CSRFToken)
            CSRFToken = $('meta[name="csrf-token"]').attr('content');
        return CSRFToken;
    }

    var $giftIcon = $('<li><div/></li>').css({
        position: 'relative',
        width: '60px',
        height: '40px',
        marginRight: '10px'
    });

    $giftIcon.children().css({
        position: 'absolute',
        width: '100%',
        height: '100%'
    });

    $('nav .right-menu').prepend($giftIcon);

    function fetchItems() {
        return new Promise(function (resolve, reject) {
            window.addEventListener('load', function listen() {
                window.removeEventListener('load', listen);
                $.ajax(
                    'http://localhost/EMRMAPI/product_updates/heartbeats',
                    {
                        method: 'GET',
                        dataType: 'json'
                    }
                ).fail(reject).done(resolve);
            })
        });
    }

    function updateLastReadAt() {
        return new Promise(function (resolve, reject) {
            $.ajax(
                '/v1/update_last_product_update_read_at',
                {
                    method: 'PUT',
                    headers: { 'X-CSRF-Token': getCSRFToken() }
                }
            ).fail(reject).done(resolve);
        });
    }

    function trackOpen() {
        window.analytics && window.analytics.track('Schedule Gift popover opened');
    }

    function trackClose() {
        window.analytics && window.analytics.track('Schedule Gift popover closed');
    }

    RGComponents.createGiftDropdown(
        $giftIcon.children().get(0),
        {
            fetchItems: fetchItems,
            updateLastReadAt: updateLastReadAt,
            lastReadAt: window.RGComponents.productUpdates.lastReadAt,
            message: window.RGComponents.productUpdates.giftMessage,
            basePath: '/assets/backpack/',
            blogLink: RGComponents.blogLink,
            animationTarget: RGComponents.animationTarget,
            trackOpen: trackOpen,
            trackClose: trackClose
        }
    );
})();
;
(function () {

    function warnBeforeNavigation(ev) {
        ev.preventDefault();
        // This is for older browsers; modern browsers do not allow customisation of the beforeunload dialog
        ev.returnValue = 'There are still changes that are being sent to the server.\n\nAre you sure you want to navigate away from this page?';
        return ev.returnValue;
    }

    var $doc = $(document);
    var $win = $(window);

    // preload the spinner image
    new Image().src = '/assets/calendar/spinner.gif';

    var tooltip = [
        'data-toggle="tooltip"',
        'data-html="true"',
        'data-placement="left"',
        'data-original-title="Syncing"'
    ].join(' ');

    var $spinner = $(
        '<li style="margin: 8px; padding: 0 16px;" ' + tooltip + '>' +
        '<img src="/assets/calendar/spinner.gif" style="width:24px;height:24px"/>' +
        '</li>'
    );

    $spinner.tooltip();

    $('#header .main .right-menu').prepend($spinner.hide());

    var timer = null;
    var FEEDBACK_DELAY = 1500;

    $doc.ajaxStart(function () {
        timer = setTimeout(function () {
            $spinner.show();
        }, FEEDBACK_DELAY);
        $win.on('beforeunload', warnBeforeNavigation);
    });

    $doc.ajaxStop(function () {
        clearTimeout(timer);
        timer = null;
        $spinner.hide();
        $win.off('beforeunload', warnBeforeNavigation);
    });

})();
;
(function () {
    $(function () {
        var $doc, $window, bookingScroller, host, nextVisible, previousVisible, ref, subdomain;
        window.clients = new RG.Collections.Clients;
        window.deletedClients = new RG.Collections.Clients;
        window.projects = new RG.Collections.Projects;
        window.deletedProjects = new RG.Collections.Projects;
        if (window.resources == null) {
            window.resources = new RG.Collections.ResourceInstances;
        }
        window.resourceTypes = new RG.Collections.ResourceTypes;
        window.bookers = new RG.Collections.Bookers;
        window.deletedBookers = new RG.Collections.Bookers;
        window.savedFilters = new RG.Collections.SavedFilters;
        window.downtimeTypes = new RG.Collections.DowntimeTypes;
        window.downtimes = new RG.Collections.Downtimes;
        window.currentUserDate = new RG.Models.CurrentDate(RG.Utils.getTodayISO());
        window.downtimes.on("change", function (model) {
            var addedResources, i, j, len, len1, newIds, previousIds, removedResources, results, rid;
            previousIds = model.previousAttributes().resourceIds;
            newIds = model.get('resourceIds') || [];
            if (previousIds && !_.isEqual(previousIds, newIds)) {
                removedResources = previousIds.filter(function (id) {
                    return newIds.indexOf(id) === -1;
                });
                for (i = 0, len = removedResources.length; i < len; i++) {
                    rid = removedResources[i];
                    window.downtimes.trigger("remove:resource_id:" + rid, model);
                }
                addedResources = newIds.filter(function (id) {
                    return previousIds.indexOf(id) === -1;
                });
                results = [];
                for (j = 0, len1 = addedResources.length; j < len1; j++) {
                    rid = addedResources[j];
                    results.push(window.downtimes.trigger("add:resource_id:" + rid, model));
                }
                return results;
            }
        });
        subdomain = window.location.host.substr(0, window.location.host.indexOf("."));
        RG.getApiRoot = function () {
            //return "/v1/" + subdomain;
            return "http://localhost:55959/v1/";
        };
        window.resources.reset([]);
        host = window.location.host.substr(0, window.location.host.indexOf("."));
        setTimeout(function () {
            return RG.Utils.BookingDataParser.boot(host);
        }, 50);
        window.update = function () {
            return Q.promise(function (resolve) {
                return setTimeout(function () {
                    RG.Utils.BookingDataParser.poll();
                    return resolve();
                }, 0);
            });
        };
        setInterval(window.update, 300000);
        $window = $(window);
        $doc = $(document);
        previousVisible = false;
        nextVisible = false;
        bookingScroller = function () {
            var booking, docHeight, docWidth, i, j, label, labels, len, len1, nextControl, padding, paddingStr, previousControl, rect, ref, shouldShowNext, shouldShowPrevious, windowHeight, windowLeft, windowTop, windowWidth;
            windowWidth = window.innerWidth;
            windowHeight = window.innerHeight;
            windowLeft = $window.scrollLeft();
            windowTop = $window.scrollTop();
            docWidth = $doc.width();
            docHeight = $doc.height();
            ref = $('.booking.sticky:visible');
            for (i = 0, len = ref.length; i < len; i++) {
                booking = ref[i];
                rect = booking.getBoundingClientRect();
                if (rect.left < windowWidth && rect.right > 250 && rect.top < windowHeight && rect.top > 110) {
                    padding = Math.max(0, 250 - rect.left);
                    paddingStr = padding + "px";
                    labels = booking.getElementsByClassName("label");
                    for (j = 0, len1 = labels.length; j < len1; j++) {
                        label = labels[j];
                        if (label.style.paddingLeft !== paddingStr) {
                            label.style.paddingLeft = paddingStr;
                        }
                    }
                }
            }
            shouldShowPrevious = windowLeft < 50;
            shouldShowNext = windowLeft > docWidth - windowWidth - 50;
            previousControl = $('.large-controls .previous-timeperiods');
            nextControl = $('.large-controls .next-timeperiods');
            if (shouldShowPrevious && !previousVisible) {
                previousVisible = true;
                previousControl.fadeIn();
            } else if (!shouldShowPrevious && previousVisible) {
                previousVisible = false;
                previousControl.fadeOut();
            }
            if (shouldShowNext && !nextVisible) {
                nextVisible = true;
                return nextControl.fadeIn();
            } else if (!shouldShowNext && nextVisible) {
                nextVisible = false;
                return nextControl.fadeOut();
            }
        };
        $window.scroll(bookingScroller);
        $window.on('touchmove', bookingScroller);
        return (ref = window.analytics) != null ? ref.track('Viewed Schedule') : void 0;
    });

    $(window).load(function () {
        var leftPos;
        leftPos = $(window).scrollLeft();
        $(window).scrollLeft(leftPos);
        return requestAnimationFrame(function () {
            return $(window).scrollLeft(leftPos);
        });
    });

}).call(this);